//#define DEBUG_MCU
//------------------------------------------------------------------------------
// netfinder.c
//------------------------------------------------------------------------------
// Copyright 2006 Silicon Laboratories, Inc.
//
// Description:
//    This file contains the routines which implement the netfinder protocol.
//
// Generated by TCP/IP Library Builder Version 3.23

#include "mn_userconst.h"                      // TCP/IP Library Constants
#include "mn_stackconst.h"                     // TCP/IP Library Constants
#include "mn_errs.h"                           // Library Error Codes
#include "mn_defs.h"                           // Library Type definitions
#include "mn_funcs.h"                          // Library Function Prototyes
#include "netfinder.h"                         // Netfinder User Options 
#include <string.h>
#include <stdio.h>                         	   // SPRINTF

#include "ublox_prot.h"
#include "telnet.h"
#include "uart_0.h"
#include "main.h"
//------------------------------------------------------------------------------
// Constants and Type Definitions
//------------------------------------------------------------------------------
#define INVALID_BUFFER_ADDRESS  -1
#define REQUEST_NOT_BROADCAST   -2
#define MAC_MISMATCH            -3
#define UNRECOGNIZED_PACKET     -4
/*
typedef struct EVENT_DATA_S {
   unsigned int days;
   unsigned char hours;
   unsigned char minutes;
   unsigned char seconds;
} EVENT_DATA;
*/

//------------------------------------------------------------------------------
// Global Variables
//------------------------------------------------------------------------------
int netfinder_socketno = -1;				// Define a variable for the netfinder
											// socket number to be assigned by 
											// the mn_open() routine. 

char code STRINGA[] = STRING_A;
char code STRINGB[] = STRING_B;
char code STRINGC[] = STRING_C;
char code STRINGD[] = STRING_D;

#define NETFINDER_BUFF_SIZE	128//32+sizeof(STRINGA)+sizeof(STRINGB)+sizeof(STRINGC)+sizeof(STRINGD)
unsigned char netfinder_buff[NETFINDER_BUFF_SIZE];

//EVENT_DATA event1;
//EVENT_DATA event2;

bit netfinder_need_reset_socket = 0;
bit ethernet_reconfigure;					// Being used to restart the MCU after IP change.
bit	b_reset_password			= 0;		// Reset Username and password.

unsigned char DHCP_Enable			= 0x01;
unsigned char TELNET_Enable			= 0x01;

unsigned int rand = 0;						// Random Number 
unsigned char netfinder_reset_socket_delay = 0x00;
//------------------------------------------------------------------------------
// Function Prototypes
//------------------------------------------------------------------------------
int netfinder_start(void);				// Starts the netfinder service
int netfinder_process_packet(void);
//void netfinder_update_RTC(void);
//void netfinder_reset_event1(void);
//void netfinder_reset_event2(void);
void ETHFlashReset(void);				// Write default settings to CP2200.
unsigned char chk_packet(void);
unsigned char chk_pass(void);
//------------------------------------------------------------------------------
// netfinder_start
//------------------------------------------------------------------------------
//
// This routine opens a UDP socket at the NETFINDER port. If application layer
// services such as HTTP or FTP are enabled, then packets addressed to the 
// netfinder port will be placed in netfinder_buff and the callback function
// callback_app_server_process_packet() should be handled.
//
// If HTTP or FTP are not enabled, then mn_receive() should be periodically
// called on the open socket to check if any packets have arrived.
//
int netfinder_start(void)
{
   int status;

   // Open a new UDP socket.
   status = mn_open(  null_addr,           // Destination IP
                      NETFINDER_PORT,      // Source Port
                      0,                   // Destination Port
                      NO_OPEN,             // Do not wait for connection
                      PROTO_UDP,           // UDP Socket
                      STD_TYPE,            // Reqired constant
                      netfinder_buff,      // Address of receive buffer
                      NETFINDER_BUFF_SIZE  // Receive buffer size
                    );

   // Check the value returned from mn_open()
   // Possible Return Codes:
   //    0 - 126:            A valid socket number.
   //    NOT_SUPPORTED:      Unsupported Protocol
   //    NOT_ENOUGH_SOCKETS: Too many open sockets
   
   if(status < 0){
      
      // Error: Return Error Code
      return status;

   } else {
      
      // Valid socket number
      netfinder_socketno = status;
      return 1;
   }
   
}

//------------------------------------------------------------------------------
// netfinder_process_packet
//------------------------------------------------------------------------------
//
// This routine processes a netfinder packet after it has been received.
// 
// Note: This routine only processes packets received on the netfinder socket
// with the number <netfinder_socketno>.
//
// Note: This routine assumes that only a single packet has been received. It
// should be called immediately after calling mn_recv(), or directly from the 
// callback function that provided notification that a UDP packet was received.
//
// Note: The Netfinder socket must be reset after each Netfinder transaction. A
// Netfinder transaction is defined as a received packet that does not generate 
// a response, or a response to a valid packet. When an invalid packet is recieved,
// the socket is immediately reset. After a response to a valid packet is sent, this
// routine sets the <need_reset_socket> flag to trigger a socket reset from the 
// netfinder_update_RTC() routine. This is required because after any packet is sent
// or received, the Netfinder socket is bound to the address of the sender and can 
// only send or receive packets from that address until the socket is reset.
//
int netfinder_process_packet()
{
   PSOCKET_INFO socket_ptr;
   unsigned char *buffer_start = netfinder_buff;
   unsigned char	j;
   unsigned int		i;
//   bit mac_ok;

   //static unsigned int rand = 0;                     // Random Number 

   // Obtain socket pointer
   socket_ptr = MK_SOCKET_PTR(netfinder_socketno);   

   //-----------------------------------
   // Verify and Handle Received Packet
   //-----------------------------------
   
   // Check for data placed in incorrect buffer
   if(socket_ptr->recv_ptr != buffer_start){
     
      // Reset Socket and Return
      mn_close(netfinder_socketno);
      netfinder_start();  
      return INVALID_BUFFER_ADDRESS;      
   
   } else 
   
   // Check if the packet is a Broadcast Identity Request
   if((socket_ptr->recv_len == 4) && (netfinder_buff[0] == 0x00)){
      
      //----------------------
      // Check Random Number
      //----------------------      
      // If random number matches the random number of the last
      // received request, then ignore this packet. This prevents
      // the generation of duplicate traffic. The Netfinder app
      // typically sends 3 - 8 broadcast requests using the same
      // random number for each search.
      
      if((netfinder_buff[2] == ((rand>>8) & 0xFF)) && (netfinder_buff[3] == (rand & 0xFF)) ){
               
         // Reset Socket
         mn_close(netfinder_socketno);
         netfinder_start();
         
         // Return
         return 1;

      } else {
         rand = (int) netfinder_buff[2] << 8;
         rand |=  netfinder_buff[3];
      }

	#ifdef DEBUG_MCU		
		sprintf(DebugString, "Netfinder Identity Request.\n\r");
		str2COM0(&DebugString, 0x00);	
	#endif

      //----------------------
      // Build Identity Reply
      //----------------------

      // Set Netfinder packet type
      netfinder_buff[0] = 0x01;

      // Set the Alert Level (static = yellow(1), dhcp = green(0))
      if(dhcp_lease.infinite_lease == 1){
         netfinder_buff[1] = 0x01;
      } else {
         netfinder_buff[1] = 0x00;
      }

      // Leave the Random Sequence in the buffer ([2] & [3])

      // Set Event1 Days Hours Minutes
      netfinder_buff[4] = 0x00;//(event1.days >> 8);
      netfinder_buff[5] = 0x00;//(event1.days & 0xFF); 
      netfinder_buff[6] = 0x00;//(event1.hours);
      netfinder_buff[7] = 0x00;//(event1.minutes); 
       
      // Set Event2 Days Hours Minutes
      netfinder_buff[8] = 0x00;//(event2.days >> 8);
      netfinder_buff[9] = 0x00;//(event2.days & 0xFF); 
      netfinder_buff[10] = 0x00;//(event2.hours);
      netfinder_buff[11] = 0x00;//(event2.minutes); 
      
      // Set Event1 + Event2 seconds
      netfinder_buff[12] = 0x00;//(event1.seconds);
      netfinder_buff[13] = 0x00;//(event2.seconds);
      
      // Set MAC Address
      netfinder_buff[14] = eth_src_hw_addr[0]; 
      netfinder_buff[15] = eth_src_hw_addr[1];
      netfinder_buff[16] = eth_src_hw_addr[2];
      netfinder_buff[17] = eth_src_hw_addr[3];
      netfinder_buff[18] = eth_src_hw_addr[4];
      netfinder_buff[19] = eth_src_hw_addr[5];

      // Set IP Address
      netfinder_buff[20] = ip_src_addr[0]; 
      netfinder_buff[21] = ip_src_addr[1];
      netfinder_buff[22] = ip_src_addr[2];
      netfinder_buff[23] = ip_src_addr[3];
      
      // Set Subnet Mask
      netfinder_buff[24] = subnet_mask[0]; 
      netfinder_buff[25] = subnet_mask[1];
      netfinder_buff[26] = subnet_mask[2];
      netfinder_buff[27] = subnet_mask[3];
      
      // Set Default Gateway
      netfinder_buff[28] = gateway_ip_addr[0]; 
      netfinder_buff[29] = gateway_ip_addr[1];
      netfinder_buff[30] = gateway_ip_addr[2];
      netfinder_buff[31] = gateway_ip_addr[3];

      // Set Telnet State
      netfinder_buff[32] = telnet_socketstate;
     
	  // Mainboard Serial Number	
	  netfinder_buff[33] = 0x00;//i2c_readEEbyte(I2C_MBSerial);			// Serial Number from Mainboard Byte 1.
	  netfinder_buff[34] = 0x00;//i2c_readEEbyte(I2C_MBSerial + 1);		// Serial Number from Mainboard Byte 2.

	  // IO/Module Run Version
	  netfinder_buff[35] = 0x00;//read_flash_addr(FLASH_RUNInfo_ADDR);		// Run code Version Major
	  netfinder_buff[36] = 0x00;//read_flash_addr(FLASH_RUNInfo_ADDR + 1);	// Run code Version Minor

   	  i = CP2201_Flash_DHCP;
	  netfinder_buff[37] = CPFLASH_ByteRead(i); 	// DHCP Status.

   	  i = CP2201_Flash_TelnetPort;
	  netfinder_buff[38] = CPFLASH_ByteRead(i);						// Telnet Port High Byte.
	  netfinder_buff[39] = CPFLASH_ByteRead(i + 1);					// Telnet Port Low Byte.
	  netfinder_buff[40] = 0x00; 									// Unused
	  netfinder_buff[41] = 0x00; 									// Unused
	  netfinder_buff[42] = 0x00; 									// Unused
	  netfinder_buff[43] = 0x00; 									// Unused
	  netfinder_buff[44] = 0x00; 									// Unused

	  // Set String A (Name/Type Field)
      strcpy(&netfinder_buff[45], STRINGA);
      
      // Set String B (Description)
      strcpy(&netfinder_buff[45+sizeof(STRINGA)], STRINGB);       
      
	  i = CP2201_Flash_Name;
      for(j = 0; j < 32; j++)
	  {
		  netfinder_buff[45 + sizeof(STRINGA) + sizeof(STRINGB) + j] = CPFLASH_ByteRead(i);
		  i++;
	  }

		//--------------------------------
		// Send Identity Reply
		//--------------------------------
      
      // Place transmit data in the socket.
      // This will automatically be transmitted by the stack after this
      // routine exits.

      socket_ptr->send_ptr = netfinder_buff;
      socket_ptr->send_len = 128;
                       
      netfinder_need_reset_socket = 1;      

   } else 

   // Check if the packet is a Identity Assignment
   if((socket_ptr->recv_len == 121) && (netfinder_buff[0] == 0x30)){
		
		if (chk_packet() == 1)
		{
			
		 	if( (telnet_socketstate == CONNECTED) || (telnet_socketstate == LOGIN_Name) || (telnet_socketstate == LOGIN) || (telnet_socketstate == COMMAND) || (telnet_socketstate == DATA) )
			{
				netfinder_buff[10] = 0x03;// Telnet is active...
			}
			else if (chk_pass() == 1)
			{ 
			 	if (netfinder_buff[74] == 0x00)  // Do not change password, load it from flash before erase.
				{
			     	for(j = 0; j < 16; j++)
				 	{
						i = j + CP2201_Flash_User;
						netfinder_buff[j + 74] = CPFLASH_ByteRead(i); // Last byte in the packet is CRC and is not used at this point.
					}
				}

			 	if (netfinder_buff[90] == 0x00)  // Do not change password, load it from flash before erase.
				{
			     	for(j = 0; j < 16; j++)
				 	{
						i = j + CP2201_Flash_Pass;
						netfinder_buff[j + 90] = CPFLASH_ByteRead(i); // Last byte in the packet is CRC and is not used at this point.
					}
				}
				else if (netfinder_buff[90] == 0x01) // Disable the use of password...
				{									 // It is assumed that the rest of the passwordbuffer
					netfinder_buff[90] = 0x00;		 // is set to 0x00 by the host software...
				}
				
				i = CP2201_Flash_Prog;
				CPFLASH_PageErase(i);
				while (flash_busy == 1);
	
			 	// Write data and MAC Address.
				i = CP2201_Flash_Name;
			 	for(j = 0; j < 79; j++) //socket_ptr->recv_len + 6; j++)
			 	{
					CPFLASH_ByteWrite(i, netfinder_buff[j + 42]);
					while (flash_busy == 1);
					i++;
				}
				
				i = CP2201_Flash_TelnetEnable;
				CPFLASH_ByteWrite(i, TELNET_Enable);
				while (flash_busy == 1);	

				i = CP2201_Flash_Prog;
				CPFLASH_ByteWrite(i, 0x02);
				while (flash_busy == 1);	

				netfinder_buff[10] = 0x01; //Set the response code.
				ethernet_reconfigure = 1;
		  	}			
			else
			{
				netfinder_buff[10] = 0x02;// Incorrect Password...
			}
		}
		else {netfinder_buff[10] = 0x00;} // Rejected...

	      
	    //------------------------------------------
	    // Build Identity Assignment Acknowlegement
	    //------------------------------------------
	     
	    // Set Netfinder response packet type.
      	netfinder_buff[0] = 0x31;

      	//------------------------------------------
	    // Send Identity Assignment Acknowlegement
      	//------------------------------------------
		#ifdef DEBUG_MCU		
			sprintf(DebugString, "Netfinder Identity Assigned.\n\r");
			str2COM0(&DebugString, 0x00);	
		#endif
      
      	// Place transmit data in the socket.
      	// This will automatically be transmitted by the stack after this routine exits.
      	socket_ptr->send_ptr = netfinder_buff;
      	socket_ptr->send_len = 11;
      
//      	need_reset_socket = 1;

   } else {
      
      // Reset Socket and Return
      mn_close(netfinder_socketno);
      netfinder_start(); 
      return UNRECOGNIZED_PACKET; 

   }

   return 1;
 
}

//------------------------------------------------------------------------------
// netfinder_update_RTC
//------------------------------------------------------------------------------
//
// This routine should be called once per second to update the RTC
//
// If the Netfinder socket needs to be reset, this routine waits for a one second
// to pass then resets the socket.
//
/*
void netfinder_update_RTC(void)
{
//	static bit reset_socket_delay = 0;
   
	// Update Event 1 RTC
	event1.seconds++;
	if(event1.seconds >= 60){
		event1.seconds = 0;
		event1.minutes ++;
		if(event1.minutes >= 60){
			event1.minutes = 0;
			event1.hours++;
			if(event1.hours >= 24){
				event1.hours = 0;
				event1.days++;
			}
		}
	}

	// Update Event 2 RTC
	event2.days = 0;
	event2.hours = UTC_time_buffer.hour;
	event2.minutes = UTC_time_buffer.min;
	event2.seconds = UTC_time_buffer.sec;

//	event2.seconds++;
//	if(event2.seconds >= 60){
//		event2.seconds = 0;
//		event2.minutes ++;
//		if(event2.minutes >= 60){
//			event2.minutes = 0;
//			event2.hours++;
//			if(event2.hours >= 24){
//			event2.hours = 0;
//			event2.days++;
//			}
//		}
//	}

	// Check if the Netfinder socket needs to be reset.
//	if(reset_socket_delay){
// 		reset_socket_delay = 0;
//
//		// Reset Socket
//		mn_close(netfinder_socketno);
//		netfinder_start();
//	}
//   
//	// Check if the netfinder module has flagged that a socket reset is required.
//	// If so, then start the socket reset delay.
//	if(need_reset_socket){
//		need_reset_socket = 0;
//		reset_socket_delay = 1;
//	}

}
*/

//------------------------------------------------------------------------------
// netfinder_reset_event1
//------------------------------------------------------------------------------
//
// This routine resets event 1 time to zero seconds
//
/*
void netfinder_reset_event1(void)
{
	event1.days = 0;
	event1.hours = 0;
	event1.minutes = 0;
	event1.seconds = 0;

}
*/

//------------------------------------------------------------------------------
// netfinder_reset_event2
//------------------------------------------------------------------------------
//
// This routine resets event 2 time to zero seconds
//
/*
void netfinder_reset_event2(void)
{
	event2.days = 0;
	event2.hours = 0;
	event2.minutes = 0;
	event2.seconds = 0;
}
*/
void ETHFlashReset(void)
{
	unsigned char i;
	unsigned int j;
//	char xdata *p;

	/* Clear netfinder buffer. */
	for(i = 0; i < 121; i++)
	{
		netfinder_buff[i] = 0x00; 
	}

	/* Fill netfinder buffer with default settings. */
	netfinder_buff[0] = 'U'; 	// Instrument Name. Instrument name is 32 characters.
	netfinder_buff[1] = 'n'; 	// Instrument Name.
	netfinder_buff[2] = 'n'; 	// Instrument Name.
	netfinder_buff[3] = 'a'; 	// Instrument Name.
	netfinder_buff[4] = 'm'; 	// Instrument Name.
	netfinder_buff[5] = 'e'; 	// Instrument Name.
	netfinder_buff[6] = 'd'; 	// Instrument Name.
	netfinder_buff[7] = '.'; 	// Instrument Name.
	
	netfinder_buff[32] = 'A'; 	// Username. Username is 16 char long.
	netfinder_buff[33] = 'd'; 	// Username. 
	netfinder_buff[34] = 'm'; 	// Username.
	netfinder_buff[35] = 'i'; 	// Username.
	netfinder_buff[36] = 'n'; 	// Username.
	netfinder_buff[37] = 0x00; 	// Username.

	netfinder_buff[48] = '2'; 	// Password. Password is DK-Technologies Zip Code.
	netfinder_buff[49] = '7'; 	// Password. Password length is 16 characters.
	netfinder_buff[50] = '3'; 	// Password.
	netfinder_buff[51] = '0'; 	// Password.

	netfinder_buff[64] = 0x01;	// Enable DHCP. (0x00 = Disabled)
	netfinder_buff[65] = 0xFF;	// IP.
	netfinder_buff[66] = 0xFF;	// IP.
	netfinder_buff[67] = 0xFF;	// IP.
	netfinder_buff[68] = 0xFF;	// IP.
	netfinder_buff[69] = 0xFF;	// SubNet.
	netfinder_buff[70] = 0xFF;	// SubNet.
	netfinder_buff[71] = 0xFF;	// SubNet.
	netfinder_buff[72] = 0xFF;	// SubNet.
	netfinder_buff[73] = 0xFF;	// Gateway.
	netfinder_buff[74] = 0xFF;	// Gateway.
	netfinder_buff[75] = 0xFF;	// Gateway.
	netfinder_buff[76] = 0xFF;	// Gateway.
	netfinder_buff[77] = 0x00;	// Telnet port 23.
	netfinder_buff[78] = 0x17;	// Telnet port 23.
	netfinder_buff[79] = 0x01;	// Telnet Enabled.

	j = CP2201_Flash_Prog;
	CPFLASH_PageErase(j);
	while (flash_busy == 1);
			
	// Write data.
	j = CP2201_Flash_Name;
	for(i = 0; i < 80; i++)
 	{
		CPFLASH_ByteWrite(j, netfinder_buff[i]);
		while (flash_busy == 1);
		j++;
	}

	j = CP2201_Flash_Prog;
	CPFLASH_ByteWrite(j, 0x02);
	while (flash_busy == 1);

}

unsigned char chk_packet()
{
	unsigned char i;
	unsigned char mac_ok = 0x01;

	// Check Random Number
    //----------------------      
    // If random number matches the random number of the last
    // received request, then ignore this packet. This prevents
    // the generation of duplicate traffic. The Netfinder app
    // typically sends 3 - 8 broadcast requests using the same
    // random number for each search.
      
	if((netfinder_buff[2] == ((rand>>8) & 0xFF)) && (netfinder_buff[3] == (rand & 0xFF)) )
	{             
		// Reset Socket
		mn_close(netfinder_socketno);
		netfinder_start();      
		// Return
		return 0;
	} 
	else
	{
		//--------------------------------
		// Verify MAC Address
		//--------------------------------
		for(i = 0; i < ETH_ADDR_LEN; i++)
		{
			if(eth_src_hw_addr[i] != netfinder_buff[i+4]){mac_ok = 0;}
		}
	  
		return(mac_ok); 
	}
}

unsigned char chk_pass()
{
	unsigned int i;
	unsigned char j;
	unsigned char mac_ok = 0x01;

	// Check Random Number
    //----------------------      
    // If random number matches the random number of the last
    // received request, then ignore this packet. This prevents
    // the generation of duplicate traffic. The Netfinder app
    // typically sends 3 - 8 broadcast requests using the same
    // random number for each search.
      
	if((netfinder_buff[2] == ((rand>>8) & 0xFF)) && (netfinder_buff[3] == (rand & 0xFF)) )
	{             
		// Reset Socket
		mn_close(netfinder_socketno);
		netfinder_start();      
		// Return
		return 0;
	} 
	else
	{
		i = CP2201_Flash_User;
		for(j = 0; j < 32; j++)
		{
			if(netfinder_buff[10+j] != CPFLASH_ByteRead(i + j)){mac_ok = 0;}
		}
	  
		return(mac_ok); 
	}
}

void write_network_settings(void)
{

	unsigned char i;
	unsigned int j;
	for(i = 0; i < 127; i++)
	{
		j = CP2201_Flash_Name;
		netfinder_buff[i] = CPFLASH_ByteRead(j + i);
	}

	// Fill netfinder buffer with default settings. 

	if (b_reset_password == 1)
	{
		b_reset_password = 0;
		netfinder_buff[32] = 'A'; 				// Username. Username is 16 char long.
		netfinder_buff[33] = 'd'; 				// Password. 
		netfinder_buff[34] = 'm'; 				// Password.
		netfinder_buff[35] = 'i'; 				// Password.
		netfinder_buff[36] = 'n'; 				// Password.
		netfinder_buff[37] = 0x00; 				// Password.
	
		netfinder_buff[48] = '2'; 				// Password. Password is DK-Technologies Zip Code.
		netfinder_buff[49] = '7'; 				// Password. Password length is 16 characters.
		netfinder_buff[50] = '3'; 				// Password.
		netfinder_buff[51] = '0'; 				// Password.
		netfinder_buff[52] = 0x00; 				// Password.
	}

	netfinder_buff[64] = DHCP_Enable;			// Enable DHCP. (0x00 = Disabled)
	netfinder_buff[65] = ip_src_addr[0];		// IP.
	netfinder_buff[66] = ip_src_addr[1];		// IP.
	netfinder_buff[67] = ip_src_addr[2];		// IP.
	netfinder_buff[68] = ip_src_addr[3];		// IP.
	netfinder_buff[69] = subnet_mask[0];		// SubNet.
	netfinder_buff[70] = subnet_mask[1];		// SubNet.
	netfinder_buff[71] = subnet_mask[2];		// SubNet.
	netfinder_buff[72] = subnet_mask[3];		// SubNet.
	netfinder_buff[73] = gateway_ip_addr[0];	// Gateway.
	netfinder_buff[74] = gateway_ip_addr[1];	// Gateway.
	netfinder_buff[75] = gateway_ip_addr[2];	// Gateway.
	netfinder_buff[76] = gateway_ip_addr[3];	// Gateway.
	netfinder_buff[77] = TELNET_PORT >> 8;	
	netfinder_buff[78] = TELNET_PORT;
	netfinder_buff[79] = TELNET_Enable;			// Telnet Enable. 1 = Enabled, 0 = Disabled.

	while (flash_busy == 1);

	j = CP2201_Flash_Prog;
	CPFLASH_PageErase(j);
	while (flash_busy == 1);
			
	// Write data.
	j = CP2201_Flash_Name;
	for(i = 0; i < 80; i++)
 	{
		CPFLASH_ByteWrite(j, netfinder_buff[i]);
		while (flash_busy == 1);
		j++;
	}

	j = CP2201_Flash_Prog;
	CPFLASH_ByteWrite(j, 0x02);
	while (flash_busy == 1);

}

/*
void erase_network_settings(void)
{
	unsigned int j;

	j = CP2201_Flash_Prog;
	CPFLASH_PageErase(j);
	while (flash_busy == 1);
}
*/                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  