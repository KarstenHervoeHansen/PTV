// Subs-Densité06.txt.
//
// Création : 2011-10-05 par Robert Tremblay.
// Modification : 2012-01-17 par Luc Czitkovics.
// Modification : 2012-02-09 par Robert Tremblay.
// Modification : 2012-10-17 par Robert Tremblay.
// Modification : 2013-01-14 par Robert Tremblay.
// Copyright © 2011-2012 - Miranda Technologies inc., tous droits réservés.
// 
// Test de fonctionnalité en QA/R&D.
// Module de sous-routines de communication avec les cartes densité.
// Version gérant les réponses NACK.
// Version enrichie de DENClean, DENReceiveRawDataStreamed, DENReceiveRespEx1A.
// Version avec délai de réception dans DENReceiveResp, DENReceiveRespEx1,DENSendMsgReceiveResp
//   et DENInitOpenSendMsgReceiveRespClose applicable une seule fois, donc en dehors de la boucle,
//   si ayant une valeur négative.
// Version enrichie de DENSendMoreMsgEx1 qui permet de tenter de poursuivre la transmission en reprenant le dernier paquet malgré un NACK.
// Version enrichie de DENInitOpenSendMsgReceiveRespDealWithNackClose (Par JB).
// Version utilisant le protocol Densité étendu (Jusqu'à 1032 (1024+) octets pour les messages normaux) par les fonction 'Ex1' (Sauf pour le RAW Data).
// Version dans laquelle les DenClose sont tous remplacés par des DenClean.
// Version ou la communication seriel via un port COM est maintenant disponible seulement pour les message de base.
// 2012-10-17 (RT) : Ajout d'une variable globale lDENNumRxLoops pour le retour du nombre de boucles qui ont été requises en réception.

// ---------------------------------------------------------------------------------------------------- //
//                                                                                                      //
// Sous-routines de communication avec les cartes densité                                               //
//                                                                                                      //
// Préfixe réservé : DEN                                                                                //
//                                                                                                      //
// Sous-routines d'usage publique :                                                                     //
//                                                                                                      //
//   DENInit                                                                                            //
//   DENOpen                                                                                            //
//   DENClose                                                                                           //
//   DENClean                                                                                           //
//                                                                                                      //
//   DENSendMsg                                                                                         //
//   DENReceiveResp                                                                                     //
//   DENReceiveRespX                                                                                    //
//   DENReceiveRespComplet                                                                              //
//   DENReceiveRespComplet2                                                                             //
//   DENReceiveRespEx1                                                                                  //
//   DENReceiveRespEx1A                                                                                 //
//   DENSendMsgReceiveResp                                                                              //
//   DENSendMsgReceiveRespX                                                                             //
//   DENInitOpenSendMsgReceiveRespClose                                                                 //
//   DENInitOpenSendMsgReceiveRespCloseX
//   DENInitOpenSendMsgReceiveRespDealWithNackClose                                                     //
//                                                                                                      //
//   DENSendMoreMsg                                                                                     //
//   DENSendMoreMsgEx1                                                                                  //
//   DENReceiveMoreResp                                                                                 //
//                                                                                                      //
//   DENSendRawData                                                                                     //
//   DENReceiveRawData                                                                                  //
//   DENReceiveRawDataStreamed                                                                          //
//   
//   DENGetThumbnail                                                                                    //
//   DENGetVideoLine                                                                                    //
//                                                                                                      //
//   DENGetRespLength
//                                                                                                      //
// Sous-routines d'usage privé :                                                                        //
//                                                                                                      //
// Modules requis :                                                                                     //
//                                                                                                      //
//   Subs-MiscTools01.txt                                                                               //
//                                                                                                      //
// Variables externes utilisées :                                                                       //
//                                                                                                      //
// ---------------------------------------------------------------------------------------------------- //


/* Log des erreurs de communication en résumé

sDENErrorCode	;	strDENErrorDetails 						/ 			strDENErrorDesc
-----------------------------------------------------------------------------------------------------------
0				;   Aucune erreur
-1				; 											/			Temps alloué de réception écoulé
-2				;	STX absent
-3				;	Mauvaise source
-4				;	Mauvaise destination
-5				;	Mauvaise longueur, Mauvais octet #4 ou 6
-6				;	Mauvais octet #5 ou  7
-7				;	Mauvais octet #x
-10				;	NACK #

*/


// ---------------------------------------------------------------------------------------------------- //


// Constantes opérationnelles globales.
Longs(klDENRawArraySize=32768)
Longs(DENProtocolDensitéBase=0 )
Longs(DENProtocolDensitéExtented1=1) ; Axino


// Variables globales d'usage publique.
Strings(strDENErrorDesc,strDENErrorSource,strDENErrorDetails,strDENRespString)
Bytes(bDENMsgByteArray[1032],bDENRespByteArray[1032],bDENRawDataByteArray[klDENRawArraySize])
Bytes(bDENThumbnailDataArray[klDENRawArraySize],bDENVideoLineDataArray[klDENRawArraySize])
Shorts(sDENErrorCode,sDENRespType,sDENVideoFormat,sDENLineNumber)
Shorts(sDENVideoLineRawDataArray[8250],sDENVideoLineActiveDataArray[3840])
Longs(lDENMoreArraySize,lDENThumbnailDataSize,lDENVideoLineDataSize,lDENVideoLineRawDataSize,lDENVideoLineActiveDataSize,lDENNumRxLoops)
Floats(fDENVideoLineRealDataArray[3840])


// Variables globales d'usage privé.
Strings(strDENErrorMsg,strDENLeadingSpaces,strDENIPAddr,strDENMessage,strDENFullMessage,strDENErrorDescBU,strDENErrorSourceBU,strDENErrorDetailsBU)
Shorts(sDENChannel,sDENSource,sDENDest,sDENMonFlag,sDENEndOrAbortIfFailed)
Shorts(sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENFilterByte6,sDENFilterByte7,sDENFilterByte8,sDENFilterType,sDENErrorCodeBU)
Longs(lDENIPPort,lDENMsgLength,lDENRespLength,lDENRawDataLength,lDENInitialReadDelay,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops)

Strings(strDEN_IPOrSerialCOM[16]) // Mettre l'adresse IP dans la Channel utiliser / Utile principalement pour le close du COM
Longs(lDENBufferReceiveIndex)


// ---------------------------------------------------------------------------------------------------- //


/////////////
// DENInit //
/////////////

BeginSub(DENInit)
// Initialisation de la communication TCP/IP avec un châssis Densité.
// Usage : GoSubArg(DENInit,sChannel,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 - Entrées dans le moniteur.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenInitIP" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenInitIP (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenInitIP ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
// Exemple : GoSubArg(DENInit,sDenChannel1,sDenMonFlag,"    ",sDenAbortIfFailed).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.

  // Lecture des arguments d'entrée et de retour.
  GetSubArgs(sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)

  // Initialisation de la communication IP.
  CommTools(DenInitIP,sDENChannel,sDENErrorCode,strDENErrorDesc)

  // Traitement d'une erreur.
  If(sDENErrorCode=0)
    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Initialisation de la communication IP sur le canal <",sDENChannel,">...Succès - %s/%s"):::EndIf()
    Assign("",strDENErrorSource,"",strDENErrorDesc,"",strDENErrorDetails)
  Else()
    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Initialisation de la communication IP sur le canal <",sDENChannel,">...Échec - %s/%s"):::EndIf()
    Assign("CommTools - DenInitIP",strDENErrorSource)
    IfMC("OR",sDENEndOrAbortIfFailed=1,sDENEndOrAbortIfFailed=2,sDENEndOrAbortIfFailed=3)
      Addn("ATTENTION !",kstrCRLF,kstrCRLF,/+
           "Erreur lors de l'initialisation d'une communication avec les cartes Densité",kstrCRLF,kstrCRLF,/+
           "  Source de l'erreur : <",strDENErrorSource,">",kstrCRLF,/+
           "  Code d'erreur : <",sDENErrorCode,">",kstrCRLF,/+
           "  Description de l'erreur : <",strDENErrorDesc,">",strDENErrorMsg)
      Assign("",strDENErrorDetails)
      MsgBoxOK(strDENErrorMsg,kstrAttnDlgTitle,800,250,14)
      If(sDENEndOrAbortIfFailed=1):::GoSub(MTComplete):::ElseIf(sDENEndOrAbortIfFailed=2):::GoSub(MTEnd):::ElseIf(sDENEndOrAbortIfFailed=3):::GoSub(MTAbort):::EndIf()
    EndIf()
  EndIf()

  // Écriture dans les arguments de retour.

EndSub(DENInit)


// ---------------------------------------------------------------------------------------------------- //


/////////////
// DENOpen //
/////////////

BeginSub(DENOpen)
// Ouverture de la communication TCP/IP avec un châssis Densité.
// Usage : GoSubArg(DENOpen,sChannel,strIPAddr,lIPPort,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         strIPAddr (V/L) : Adresse TCP/IP (Format 0.0.0.0 ou @Descripteur).
//         lIPPort (V/L) : Port Ethernet (5100).
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 - Entrées dans le moniteur.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenInitIP" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenOpenIP (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenInitIP ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
// Exemple : GoSubArg(DENOpen,sDenChannel1,strDenIPAddr,lDenIPPort,sDenMonFlag,"    ",sDenAbortIfFailed).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.
  LStrings(lstrCOMDetect)

  // Lecture des arguments d'entrée et de retour.
  GetSubArgs(sDENChannel,strDENIPAddr,lDENIPPort,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
  
	SubString(strDENIPAddr,Left,0,3,lstrCOMDetect)

    Assign(strDENIPAddr, strDEN_IPOrSerialCOM[sDENChannel])
	If(lstrCOMDetect="COM")
	  // Initialisation du COM
      SerialComm(SetParameters,sDENChannel,strDENIPAddr,115200,8,"NOPARITY","ONESTOPBIT",CTSFlowOFF,DSRFlowOFF,DTRDISABLE,RTSDISABLE,NoReportErrorNoAbort)
      //NoReportErrorNoAbort, NoReportErrorAbort, ReportErrorNoAbort, ReportErrorAbort.
	  SerialComm(SetTimeOuts,sDENChannel,10,10,1000,0,0)

	  // Ouverture de la communication Serial.
      SerialComm(Open,sDENChannel,sDENErrorCode)
	  
	  //Inversion du resultat lorsque nous utilisons SerialComm
	  If(sDENErrorCode=1)
	  	Assign(0,sDENErrorCode)
	  Else()
	  	Assign(1,sDENErrorCode)
	  EndIf()
	
	  // Traitement d'une erreur.
	  If(sDENErrorCode=0)
	    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Ouverture de la communication Serial sur le canal <",sDENChannel,">, <",strDENIPAddr,">...Succès - %s/%s"):::EndIf()
	    Assign("",strDENErrorSource,"",strDENErrorDesc,"",strDENErrorDetails)
	  Else()
	    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Ouverture de la communication Serial sur le canal <",sDENChannel,">, <",strDENIPAddr,">...Échec - %s/%s"):::EndIf()
	    Assign("Subs-DensitéXX - DENOpen",strDENErrorSource)
	    IfMC("OR",sDENEndOrAbortIfFailed=1,sDENEndOrAbortIfFailed=2,sDENEndOrAbortIfFailed=3)
	      Addn("ATTENTION !",kstrCRLF,kstrCRLF,/+
	           "Erreur lors de l'ouverture d'une communication avec les cartes Densité",kstrCRLF,kstrCRLF,/+
	           "  Source de l'erreur : <",strDENErrorSource,">",kstrCRLF,/+
	           "  Code d'erreur : <",sDENErrorCode,">",kstrCRLF,/+
	           "  Description de l'erreur : <",strDENErrorDesc,">",strDENErrorMsg)
	      Assign("",strDENErrorDetails)
	      MsgBoxOK(strDENErrorMsg,kstrAttnDlgTitle,800,250,14)
	      If(sDENEndOrAbortIfFailed=1):::GoSub(MTComplete):::ElseIf(sDENEndOrAbortIfFailed=2):::GoSub(MTEnd):::ElseIf(sDENEndOrAbortIfFailed=3):::GoSub(MTAbort):::EndIf()
	    EndIf()
	  EndIf()

	Else()

	  // Ouverture de la communication IP.
	  CommTools(DenOpenIP,sDENChannel,strDENIPAddr,lDENIPPort,sDENErrorCode,strDENErrorDesc)
	
	  // Traitement d'une erreur.
	  If(sDENErrorCode=0)
	    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Ouverture de la communication IP sur le canal <",sDENChannel,">, Adresse <",strDENIPAddr,">, Port <",lDENIPPort,">...Succès - %s/%s"):::EndIf()
	    Assign("",strDENErrorSource,"",strDENErrorDesc,"",strDENErrorDetails)
	  Else()
	    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Ouverture de la communication IP sur le canal <",sDENChannel,">, Adresse <",strDENIPAddr,">, Port <",lDENIPPort,">...Échec - %s/%s"):::EndIf()
	    Assign("CommTools - DenOpenIP",strDENErrorSource)
	    IfMC("OR",sDENEndOrAbortIfFailed=1,sDENEndOrAbortIfFailed=2,sDENEndOrAbortIfFailed=3)
	      Addn("ATTENTION !",kstrCRLF,kstrCRLF,/+
	           "Erreur lors de l'ouverture d'une communication avec les cartes Densité",kstrCRLF,kstrCRLF,/+
	           "  Source de l'erreur : <",strDENErrorSource,">",kstrCRLF,/+
	           "  Code d'erreur : <",sDENErrorCode,">",kstrCRLF,/+
	           "  Description de l'erreur : <",strDENErrorDesc,">",strDENErrorMsg)
	      Assign("",strDENErrorDetails)
	      MsgBoxOK(strDENErrorMsg,kstrAttnDlgTitle,800,250,14)
	      If(sDENEndOrAbortIfFailed=1):::GoSub(MTComplete):::ElseIf(sDENEndOrAbortIfFailed=2):::GoSub(MTEnd):::ElseIf(sDENEndOrAbortIfFailed=3):::GoSub(MTAbort):::EndIf()
	    EndIf()
	  EndIf()

  EndIf()

  // Écriture dans les arguments de retour.

EndSub(DENOpen)

// ---------------------------------------------------------------------------------------------------- //


//////////////
// DENClose //
//////////////

BeginSub(DENClose)
// Fermeture de la communication IP.
// Usage : GoSubArg(DENClose,sChannel,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 - Entrées dans le moniteur.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenCloseIP" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenCloseIP (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenInitIP ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
// Exemple : GoSubArg(DENClose,sDenChannel1,sDenMonFlag,"    ",sDenAbortIfFailed).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.
  LStrings(lstrCOMDetect)

  // Lecture des arguments d'entrée et de retour.
  GetSubArgs(sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)

  SubString(strDEN_IPOrSerialCOM[sDENChannel],Left,0,3,lstrCOMDetect)

  If(lstrCOMDetect="COM")
	  // Fermeture de la communication Serial.
	  SerialComm(Close,sDENChannel,sDENErrorCode)
	
	  //Inversion du resultat lorsque nous utilisons SerialComm
	  If(sDENErrorCode=1)
	  	Assign(0,sDENErrorCode)
	  Else()
	  	Assign(1,sDENErrorCode)
	  EndIf()
	
	  // Traitement d'une erreur.
	  If(sDENErrorCode=0)
	    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Fermeture de la communication Serial sur le canal <",sDENChannel,">...Succès - %s/%s"):::EndIf()
	    Assign("",strDENErrorSource,"",strDENErrorDesc,"",strDENErrorDetails)
	  Else()
	    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Fermeture de la communication Serial sur le canal <",sDENChannel,">...Échec - %s/%s"):::EndIf()
	    Assign("Subs-DensitéXX - DenCloseSerial",strDENErrorSource)
	    IfMC("OR",sDENEndOrAbortIfFailed=1,sDENEndOrAbortIfFailed=2,sDENEndOrAbortIfFailed=3)
	      Addn("ATTENTION !",kstrCRLF,kstrCRLF,/+
	           "Erreur lors de la fermeture d'une communication avec les cartes Densité",kstrCRLF,kstrCRLF,/+
	           "  Source de l'erreur : <",strDENErrorSource,">",kstrCRLF,/+
	           "  Code d'erreur : <",sDENErrorCode,">",kstrCRLF,/+
	           "  Description de l'erreur : <",strDENErrorDesc,">",strDENErrorMsg)
	      Assign("",strDENErrorDetails)
	      MsgBoxOK(strDENErrorMsg,kstrAttnDlgTitle,800,250,14)
	      If(sDENEndOrAbortIfFailed=1):::GoSub(MTComplete):::ElseIf(sDENEndOrAbortIfFailed=2):::GoSub(MTEnd):::ElseIf(sDENEndOrAbortIfFailed=3):::GoSub(MTAbort):::EndIf()
	    EndIf()
	  EndIf()

  Else()
	  
	  // Fermeture de la communication IP.

	  ; CommTools(DenCloseIP,sDENChannel,sDENErrorCode,strDENErrorDesc)
	  CommTools(DenCleanIP,sDENChannel,sDENErrorCode,strDENErrorDesc)
	
	  // Traitement d'une erreur.
	  If(sDENErrorCode=0)
	    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Fermeture de la communication IP sur le canal <",sDENChannel,">...Succès - %s/%s"):::EndIf()
	    Assign("",strDENErrorSource,"",strDENErrorDesc,"",strDENErrorDetails)
	  Else()
	    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Fermeture de la communication IP sur le canal <",sDENChannel,">...Échec - %s/%s"):::EndIf()
	    Assign("CommTools - DenCloseIP",strDENErrorSource)
	    IfMC("OR",sDENEndOrAbortIfFailed=1,sDENEndOrAbortIfFailed=2,sDENEndOrAbortIfFailed=3)
	      Addn("ATTENTION !",kstrCRLF,kstrCRLF,/+
	           "Erreur lors de la fermeture d'une communication avec les cartes Densité",kstrCRLF,kstrCRLF,/+
	           "  Source de l'erreur : <",strDENErrorSource,">",kstrCRLF,/+
	           "  Code d'erreur : <",sDENErrorCode,">",kstrCRLF,/+
	           "  Description de l'erreur : <",strDENErrorDesc,">",strDENErrorMsg)
	      Assign("",strDENErrorDetails)
	      MsgBoxOK(strDENErrorMsg,kstrAttnDlgTitle,800,250,14)
	      If(sDENEndOrAbortIfFailed=1):::GoSub(MTComplete):::ElseIf(sDENEndOrAbortIfFailed=2):::GoSub(MTEnd):::ElseIf(sDENEndOrAbortIfFailed=3):::GoSub(MTAbort):::EndIf()
	    EndIf()
	  EndIf()

	EndIf()

  // Écriture dans les arguments de retour.

EndSub(DENClose)


// ---------------------------------------------------------------------------------------------------- //


//////////////
// DENClean //
//////////////

BeginSub(DENClean)
// Fermeture inconditionnelle de la communication IP.
// Usage : GoSubArg(DENClean,sChannel,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 - Entrées dans le moniteur.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenCleanIP" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenCleanIP (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenCleanIP ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
// Exemple : GoSubArg(DENClean,sDenChannel1,sDenMonFlag,"    ",sDenAbortIfFailed).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.

  // Lecture des arguments d'entrée et de retour.
  GetSubArgs(sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)

  // Fermeture inconditionnelle de la communication IP.
  CommTools(DenCleanIP,sDENChannel,sDENErrorCode,strDENErrorDesc)

  // Traitement d'une erreur.
  If(sDENErrorCode=0)
    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Fermeture inconditionnelle de la communication IP sur le canal <",sDENChannel,">...Succès - %s/%s"):::EndIf()
    Assign("",strDENErrorSource,"",strDENErrorDesc,"",strDENErrorDetails)
  Else()
    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Fermeture inconditionnelle de la communication IP sur le canal <",sDENChannel,">...Échec - %s/%s"):::EndIf()
    Assign("CommTools - DenCleanIP",strDENErrorSource)
    IfMC("OR",sDENEndOrAbortIfFailed=1,sDENEndOrAbortIfFailed=2,sDENEndOrAbortIfFailed=3)
      Addn("ATTENTION !",kstrCRLF,kstrCRLF,/+
           "Erreur lors de la fermeture inconditionnelle d'une communication avec les cartes Densité",kstrCRLF,kstrCRLF,/+
           "  Source de l'erreur : <",strDENErrorSource,">",kstrCRLF,/+
           "  Code d'erreur : <",sDENErrorCode,">",kstrCRLF,/+
           "  Description de l'erreur : <",strDENErrorDesc,">",strDENErrorMsg)
      Assign("",strDENErrorDetails)
      MsgBoxOK(strDENErrorMsg,kstrAttnDlgTitle,800,250,14)
      If(sDENEndOrAbortIfFailed=1):::GoSub(MTComplete):::ElseIf(sDENEndOrAbortIfFailed=2):::GoSub(MTEnd):::ElseIf(sDENEndOrAbortIfFailed=3):::GoSub(MTAbort):::EndIf()
    EndIf()
  EndIf()

  // Écriture dans les arguments de retour.

EndSub(DENClean)


// ---------------------------------------------------------------------------------------------------- //


////////////////
// DENSendMsg //
////////////////

BeginSub(DENSendMsg)
// Envoi d'un message à une carte densité selon le protocol normal ou étendu #1 au choix.
// Usage : GoSubArg(DENSendMsg,sChannel,sSource,sDest,strMessage,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed[,sExtProtocolID]).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         sSource (V/L) : Source de communication (25).
//         sDest (V/L) : Fente de la carte (1-21).
//         strMessage (V/L) : Message Densité à envoyer.
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 - Entrées dans le moniteur.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
//         sExtProtocolID (V/L) (Optionnel) : 0 - Protocol normal.
//                                            1 - Protocol étendu #1 (Axino).
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenSendIP(Ex1)" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenSendIP(Ex1) (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenSendIP(Ex1) ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
// Exemple : GoSubArg(DENSendMsg,sDenChannel1,sDenSource,sDenDestination,"0012",sDenMonFlag,"    ",sDenAbortIfFailed[,0/1]).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.
  LShorts(lsNumSubArgs,lsExtProtocolID)
  LStrings(lstrCOMDetect)
  // Lecture des arguments d'entrée et de retour.
  GetSubNumArgs(lsNumSubArgs)
  If(lsNumSubArgs=7)
    GetSubArgs(sDENChannel,sDENSource,sDENDest,strDENMessage,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
    Assign(0,lsExtProtocolID)
  ElseIf(lsNumSubArgs=8)
    GetSubArgs(sDENChannel,sDENSource,sDENDest,strDENMessage,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed,lsExtProtocolID)
  Else()
    Assign(100,sDENErrorCode,"DENSendMsg",strDENErrorSource,"Nombre d'arguments incorrect",strDENErrorDesc,"Nombre d'arguments différent de 8 et 9",strDENErrorDetails)
    ExitSub(DENSendMsg)
  EndIf()

  // Envoi d'un message à une carte densité.
  If(lsExtProtocolID=0)  // Protocol normal.
    CommTools(DenBuildCmdArrayAndString,sDENSource,sDENDest,strDENMessage,bDENMsgByteArray,0,lDENMsgLength,strDENFullMessage)
	SubString(strDENIPAddr,Left,0,3,lstrCOMDetect)
	If(lstrCOMDetect="COM")
//	  AddnMonitorText(strDENMessage,";",bDENMsgByteArray[4],";", bDENMsgByteArray[5],";",lDENMsgLength)
	  SerialComm(Send,sDENChannel,bDENMsgByteArray,lDENMsgLength,1,0,sDENErrorCode)
//	  AddnMonitorText("Message complet à transmettre : ", strDENFullMessage, " : ", sDENErrorCode, " : sDENMonFlag ", sDENMonFlag)
	  //Inversion du resultat lorsque nous utilisons SerialComm
	  If(sDENErrorCode=1)
	  	Assign(0,sDENErrorCode)
	  Else()
	  	Assign(1,sDENErrorCode)
	  EndIf()
    Else()
	    CommTools(DenSendIP,sDENChannel,bDENMsgByteArray,lDENMsgLength,sDENErrorCode,strDENErrorDesc)
	EndIf()
  ElseIf(lsExtProtocolID=1) // Protocol étendu #1 (Axino).
    CommTools(DenBuildCmdArrayAndStringEx1,sDENSource,sDENDest,strDENMessage,bDENMsgByteArray,0,lDENMsgLength,strDENFullMessage,2)
    CommTools(DenSendIPEx1,sDENChannel,bDENMsgByteArray,lDENMsgLength,sDENErrorCode,strDENErrorDesc)
  Else()
    Assign(101,sDENErrorCode,"DENSendMsg",strDENErrorSource,"Argument #7 invalide",strDENErrorDesc,"Le protocole Densité doit être 0 ou 1",strDENErrorDetails)
    ExitSub(DENSendMsg)
  EndIf()

  // Traitement d'une erreur.
  If(sDENErrorCode=0)
    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Envoi d'un message à une carte densité sur le canal <",sDENChannel,">, Source <",sDENSource,">, Destination <",sDENDest,">, Message <",strDENMessage,">, Séquence <",strDENFullMessage,">...Succès - %s/%s"):::EndIf()
    Assign("",strDENErrorSource,"",strDENErrorDesc,"",strDENErrorDetails)
  Else()
    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Envoi d'un message à une carte densité sur le canal <",sDENChannel,">, Source <",sDENSource,">, Destination <",sDENDest,">, Message <",strDENMessage,">, Séquence <",strDENFullMessage,">...Échec - %s/%s"):::EndIf()
    If(lsExtProtocolID=0):::Assign("CommTools - DenSendIP",strDENErrorSource)
    ElseIf(lsExtProtocolID=1):::Assign("CommTools - DenSendIPEx1",strDENErrorSource)
    EndIf()
    IfMC("OR",sDENEndOrAbortIfFailed=1,sDENEndOrAbortIfFailed=2,sDENEndOrAbortIfFailed=3)
      Addn("ATTENTION !",kstrCRLF,kstrCRLF,/+
           "Erreur lors de l'envoi d'un message à une cartes Densité",kstrCRLF,kstrCRLF,/+
           "  Source de l'erreur : <",strDENErrorSource,">",kstrCRLF,/+
           "  Code d'erreur : <",sDENErrorCode,">",kstrCRLF,/+
           "  Description de l'erreur : <",strDENErrorDesc,">",strDENErrorMsg)
      Assign("",strDENErrorDetails)
      MsgBoxOK(strDENErrorMsg,kstrAttnDlgTitle,800,250,14)
      If(sDENEndOrAbortIfFailed=1):::GoSub(MTComplete):::ElseIf(sDENEndOrAbortIfFailed=2):::GoSub(MTEnd):::ElseIf(sDENEndOrAbortIfFailed=3):::GoSub(MTAbort):::EndIf()
    EndIf()
  EndIf()

  // Écriture dans les arguments de retour.

EndSub(DENSendMsg)


// ---------------------------------------------------------------------------------------------------- //


////////////////////
// DENReceiveResp //
////////////////////

BeginSub(DENReceiveResp)
// Réception d'une réponse suite à l'envoi d'un message à une carte densité selon le protocol normal ou étendu #1 de manière automatique.
// Usage : GoSubArg(DENReceiveResp,sChannel,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         lDenReadDelay (V/L) : Délai avant chaque lecture (msec). Si négatif, ne s'applique qu'avant la première lecture.
//         lDenReadTimeOutDelay (V/L) : Délai de timeout (msec).
//         lDenNumReadLoops (V/L) : Nombre de boucles de lecture si en timeout.
//         sDenFilterSource (V/L) : Filtrage de la source (-1 si pas de filtrage ou numéro de la fente désirée).
//         sDenFilterDest (V/L) : Filtrage de la destination (-1 si pas de filtrage ou destination désirée).
//         sDenFilterLength (V/L) : Filtrage de la longueur du message (-1 si pas de filtrage ou longueur désirée).
//         sDenFilterByte4(6), sDenFilterByte5(7) (V/L) : Filtrage de la réponse (-1 si pas de filtrage ou octets de réponse désirés).
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 - Entrées dans le moniteur.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenReceiveIP(Ex1)" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenReceiveIP(Ex1) ou par la sous-routine (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenReceiveIP(Ex1) ou par la sous-routine ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
//         bDENRespByteArray : Champ d'octets de la réponse de la carte.
//         strDENRespString : Texte de la réponse de la carte.
// Exemple : GoSubArg(DENReceiveResp,sDenChannel1,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sDenMonFlag,"    ",sDenAbortIfFailed).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.
  LShorts(lsOKFlag)
  LLongs(llLoopIndex,lReadDelayAbs,llRxLengthEx)
  LStrings(lstrCOMDetect)

  // Lecture des arguments d'entrée et de retour.
  GetSubArgs(sDENChannel,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)

  // Réception d'une réponse suite à l'envoi d'un message à une carte densité.
  Abs(lDENReadDelay,lReadDelayAbs)
  If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Réception d'une réponse sur le canal <",sDENChannel,">...Début - %s/%s"):::EndIf()
  Assign(0,llLoopIndex)
  Assign(0,lDENBufferReceiveIndex)
  If(lDENReadDelay<0):::msecSleep(lReadDelayAbs,1):::EndIf()
  BeginLoop()
    If(lDENReadDelay>0):::msecSleep(lDENReadDelay,1):::EndIf()
	SubString(strDENIPAddr,Left,0,3,lstrCOMDetect)
	If(lstrCOMDetect="COM")
		GoSubArg(DENReceiveRespComplet,sDENChannel)
//	  Assign(7,lDENRespLength,0,sDENErrorCode)
//	  SerialComm(Receive,sDENChannel,bDENRespByteArray,lDENRespLength,1,0,sDENErrorCode)
////	  ShowArrayData(bDENRespByteArray,0,lDENRespLength)
	  //AddnMonitorText("Channel : ",sDENChannel," ; len :",lDENRespLength," ; ErrCode : ",sDENErrorCode)

	  //Inversion du resultat lorsque nous utilisons SerialComm
	  If(sDENErrorCode=1)
	  	Assign(0,sDENErrorCode)
	  Else()
	  	Assign(1,sDENErrorCode)
	  EndIf()
    Else()
	    CommTools(DenReceiveIPEx1,sDENChannel,lDENReadTimeOutDelay,bDENRespByteArray,lDENRespLength,sDENErrorCode,strDENErrorDesc)
	EndIf()
    If(sDENErrorCode=0)
      Assign("",strDENErrorSource,"",strDENErrorDesc,"",strDENErrorDetails)
      CommTools(ByteArrayToHexString,bDENRespByteArray,0,lDENRespLength,strDENRespString)
      If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"  Données reçues : <",strDENRespString,"> (",llLoopIndex," boucle(s))"," - %s/%s"):::EndIf()
      Assign(1,lsOKFlag)
      If(bDENRespByteArray[0]!=2)
        Assign(0,lsOKFlag,-2,sDENErrorCode)
        Addn("STX absent (",bDENRespByteArray[0],"/2)",strDENErrorDetails)
      Else()
        IfMC("AND",lsOKFlag=1,sDENFilterSource!=-1,sDENFilterSource!=bDENRespByteArray[2])
          Assign(0,lsOKFlag,-3,sDENErrorCode)
          Addn("Mauvaise source (",bDENRespByteArray[2],"/",sDENFilterSource,")",strDENErrorDetails)
        Else()
          IfMC("AND",lsOKFlag=1,sDENFilterDest!=-1,sDENFilterDest!=bDENRespByteArray[1])
            Assign(0,lsOKFlag,-4,sDENErrorCode)
            Addn("Mauvaise destination (",bDENRespByteArray[1],"/",sDENFilterDest,")",strDENErrorDetails)
          Else()
            If(bDENRespByteArray[3]!=128)
              IfMC("AND",lsOKFlag=1,sDENFilterLength!=-1,sDENFilterLength!=bDENRespByteArray[3])
                Assign(0,lsOKFlag,-5,sDENErrorCode)
                Addn("Mauvaise longueur (",bDENRespByteArray[3],"/",sDENFilterLength,")",strDENErrorDetails)
              Else()
                IfMC("AND",bDENRespByteArray[3]=3,bDENRespByteArray[4]=0,bDENRespByteArray[5]=1) // NACK : retour immédiat avec code d'erreur -10.
                  Assign(0,lsOKFlag,-10,sDENErrorCode)
                  Addn("NACK #",bDENRespByteArray[6]," reçu",strDENErrorDetails)
                  ExitLoop()
                EndIf()
                IfMC("AND",lsOKFlag=1,sDENFilterByte4!=-1,sDENFilterByte4!=bDENRespByteArray[4])
                  Assign(0,lsOKFlag,-5,sDENErrorCode)
                  Addn("Mauvais octet #4 (",bDENRespByteArray[4],"/",sDENFilterByte4,")",strDENErrorDetails)
                Else()
                  IfMC("AND",lsOKFlag=1,sDENFilterByte5!=-1,sDENFilterByte5!=bDENRespByteArray[5])
                    Assign(0,lsOKFlag,-6,sDENErrorCode)
                    Addn("Mauvais octet #5 (",bDENRespByteArray[5],"/",sDENFilterByte5,")",strDENErrorDetails)
                  EndIf()
                EndIf()
              EndIf()
            Else()
              RPN(bDENRespByteArray[4],256,*,bDENRespByteArray[5],+,llRxLengthEx)
              IfMC("AND",lsOKFlag=1,sDENFilterLength!=-1,sDENFilterLength!=llRxLengthEx)
                Assign(0,lsOKFlag,-5,sDENErrorCode)
                Addn("Mauvaise longueur (",llRxLengthEx,"/",sDENFilterLength,")",strDENErrorDetails)
              Else()
                IfMC("AND",lsOKFlag=1,sDENFilterByte4!=-1,sDENFilterByte4!=bDENRespByteArray[6])
                  Assign(0,lsOKFlag,-5,sDENErrorCode)
                  Addn("Mauvais octet #6 (",bDENRespByteArray[6],"/",sDENFilterByte4,")",strDENErrorDetails)
                Else()
                  IfMC("AND",lsOKFlag=1,sDENFilterByte5!=-1,sDENFilterByte5!=bDENRespByteArray[7])
                    Assign(0,lsOKFlag,-6,sDENErrorCode)
                    Addn("Mauvais octet #7 (",bDENRespByteArray[7],"/",sDENFilterByte5,")",strDENErrorDetails)
                  EndIf()
                EndIf()
              EndIf()
            EndIf()
          EndIf()
        EndIf()
      EndIf()
      ExitLoopIf(lsOKFlag=1)
    ElseIf(sDENErrorCode!=-1)
      Assign(-1,llLoopIndex)
      ExitLoop()
    EndIf()
    Add(llLoopIndex,1,llLoopIndex)
    ExitLoopIf(llLoopIndex>=lDENNumReadLoops)
  EndLoop()
  Assign(llLoopIndex,lDENNumRxLoops)
  IfMC("OR",llLoopIndex=-1,llLoopIndex>=lDENNumReadLoops)
    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"  >>> Réception d'une réponse sur le canal <",sDENChannel,">...Échec - %s/%s"):::EndIf()
    Assign("CommTools - DenReceiveIP(Ex1)",strDENErrorSource)
    If(llLoopIndex>=lDENNumReadLoops)
      Assign(-1,sDENErrorCode,"Temps alloué de réception écoulé",strDENErrorDesc)
    EndIf()
    IfMC("OR",sDENEndOrAbortIfFailed=1,sDENEndOrAbortIfFailed=2,sDENEndOrAbortIfFailed=3)
      Addn("ATTENTION !",kstrCRLF,kstrCRLF,/+
           "Erreur lors de la réception d'une réponse d'une carte Densité",kstrCRLF,kstrCRLF,/+
           "  Source de l'erreur : <",strDENErrorSource,">",kstrCRLF,/+
           "  Code d'erreur : <",sDENErrorCode,">",kstrCRLF,/+
           "  Description de l'erreur : <",strDENErrorDesc,">",strDENErrorMsg)
      MsgBoxOK(strDENErrorMsg,kstrAttnDlgTitle,800,250,14)
      If(sDENEndOrAbortIfFailed=1):::GoSub(MTComplete):::ElseIf(sDENEndOrAbortIfFailed=2):::GoSub(MTEnd):::ElseIf(sDENEndOrAbortIfFailed=3):::GoSub(MTAbort):::EndIf()
    EndIf()
  EndIf()
  If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Réception d'une réponse sur le canal <",sDENChannel,">...Fin - %s/%s"):::EndIf()

  // Écriture dans les arguments de retour.

EndSub(DENReceiveResp)

// ---------------------------------------------------------------------------------------------------- //


////////////////////
// DENReceiveRespX //
////////////////////

BeginSub(DENReceiveRespX)
// Réception d'une réponse suite à l'envoi d'un message à une carte densité.
// Usage : GoSubArg(DENReceiveResp,sChannel,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         lDenReadDelay (V/L) : Délai avant chaque lecture (msec).
//         lDenReadTimeOutDelay (V/L) : Délai de timeout (msec).
//         lDenNumReadLoops (V/L) : Nombre de boucles de lecture si en timeout.
//         sDenFilterSource (V/L) : Filtrage de la source (-1 si pas de filtrage ou numéro de la fente désirée).
//         sDenFilterDest (V/L) : Filtrage de la destination (-1 si pas de filtrage ou destination désirée).
//         sDenFilterLength (V/L) : Filtrage de la longueur du message (-1 si pas de filtrage ou longueur désirée).
//         sDenFilterByte4, sDenFilterByte5, sDenFilterByte6, sDenFilterByte7, sDenFilterByte8 (V/L) : Filtrage de la réponse (-1 si pas de filtrage ou octets de réponse désirés).
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 - Entrées dans le moniteur.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenReceiveIP" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenReceiveIP ou par la sous-routine (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenReceiveIP ou par la sous-routine ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
//         bDENRespByteArray : Champ d'octets de la réponse de la carte.
//         strDENRespString : Texte de la réponse de la carte.
// Exemple : GoSubArg(DENReceiveResp,sDenChannel1,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sDenMonFlag,"    ",sDenAbortIfFailed).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.
  LShorts(lsOKFlag)
  LLongs(llLoopIndex,lReadDelayAbs,llRxLengthEx)
  LStrings(lstrCOMDetect)

  // Lecture des arguments d'entrée et de retour.
  GetSubArgs(sDENChannel,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENFilterByte6,sDENFilterByte7,sDENFilterByte8,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)

  // Réception d'une réponse suite à l'envoi d'un message à une carte densité.
  Abs(lDENReadDelay,lReadDelayAbs)
  If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Réception d'une réponse sur le canal <",sDENChannel,">...Début - %s/%s"):::EndIf()
  Assign(0,llLoopIndex)
  Assign(0,lDENBufferReceiveIndex)
  If(lDENReadDelay<0):::msecSleep(lReadDelayAbs,1):::EndIf()
  BeginLoop()
    If(lDENReadDelay>0):::msecSleep(lDENReadDelay,1):::EndIf()
	SubString(strDENIPAddr,Left,0,3,lstrCOMDetect)
	If(lstrCOMDetect="COM")
		GoSubArg(DENReceiveRespComplet,sDENChannel)
//	  Assign(7,lDENRespLength,0,sDENErrorCode)
//	  SerialComm(Receive,sDENChannel,bDENRespByteArray,lDENRespLength,1,0,sDENErrorCode)
////	  ShowArrayData(bDENRespByteArray,0,lDENRespLength)
	  //AddnMonitorText("Channel : ",sDENChannel," ; len :",lDENRespLength," ; ErrCode : ",sDENErrorCode)

	  //Inversion du resultat lorsque nous utilisons SerialComm
	  If(sDENErrorCode=1)
	  	Assign(0,sDENErrorCode)
	  Else()
	  	Assign(1,sDENErrorCode)
	  EndIf()
    Else()
	    CommTools(DenReceiveIPEx1,sDENChannel,lDENReadTimeOutDelay,bDENRespByteArray,lDENRespLength,sDENErrorCode,strDENErrorDesc)
	EndIf()
    If(sDENErrorCode=0)
      Assign("",strDENErrorSource,"",strDENErrorDesc,"",strDENErrorDetails)
      CommTools(ByteArrayToHexString,bDENRespByteArray,0,lDENRespLength,strDENRespString)
      If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"  Données reçues : <",strDENRespString,"> (",llLoopIndex," boucle(s))"," - %s/%s"):::EndIf()
      Assign(1,lsOKFlag)
      If(bDENRespByteArray[0]!=2)
        Assign(0,lsOKFlag,-2,sDENErrorCode)
        Addn("STX absent (",bDENRespByteArray[0],"/2)",strDENErrorDetails)
      Else()
        IfMC("AND",lsOKFlag=1,sDENFilterSource!=-1,sDENFilterSource!=bDENRespByteArray[2])
          Assign(0,lsOKFlag,-3,sDENErrorCode)
          Addn("Mauvaise source (",bDENRespByteArray[2],"/",sDENFilterSource,")",strDENErrorDetails)
        Else()
          IfMC("AND",lsOKFlag=1,sDENFilterDest!=-1,sDENFilterDest!=bDENRespByteArray[1])
            Assign(0,lsOKFlag,-4,sDENErrorCode)
            Addn("Mauvaise destination (",bDENRespByteArray[1],"/",sDENFilterDest,")",strDENErrorDetails)
          Else()
            If(bDENRespByteArray[3]!=128)
              IfMC("AND",lsOKFlag=1,sDENFilterLength!=-1,sDENFilterLength!=bDENRespByteArray[3])
                Assign(0,lsOKFlag,-5,sDENErrorCode)
                Addn("Mauvaise longueur (",bDENRespByteArray[3],"/",sDENFilterLength,")",strDENErrorDetails)
              Else()
                IfMC("AND",bDENRespByteArray[3]=3,bDENRespByteArray[4]=0,bDENRespByteArray[5]=1) // NACK : retour immédiat avec code d'erreur -10.
                  Assign(0,lsOKFlag,-10,sDENErrorCode)
                  Addn("NACK #",bDENRespByteArray[6]," reçu",strDENErrorDetails)
                  ExitLoop()
                EndIf()
                IfMC("AND",lsOKFlag=1,sDENFilterByte4!=-1,sDENFilterByte4!=bDENRespByteArray[4])
                  Assign(0,lsOKFlag,-5,sDENErrorCode)
                  Addn("Mauvais octet #4 (",bDENRespByteArray[4],"/",sDENFilterByte4,")",strDENErrorDetails)
                Else()
                  IfMC("AND",lsOKFlag=1,sDENFilterByte5!=-1,sDENFilterByte5!=bDENRespByteArray[5])
                    Assign(0,lsOKFlag,-6,sDENErrorCode)
                    Addn("Mauvais octet #5 (",bDENRespByteArray[5],"/",sDENFilterByte5,")",strDENErrorDetails)
		          ElseIfMC("AND",lsOKFlag=1,sDENFilterByte6!=-1,sDENFilterByte6!=bDENRespByteArray[6])
		            Assign(0,lsOKFlag,-6,sDENErrorCode)
		            Addn("Mauvais octet #6 (",bDENRespByteArray[6],"/",sDENFilterByte6,")",strDENErrorDetails)
			      ElseIfMC("AND",lsOKFlag=1,sDENFilterByte7!=-1,sDENFilterByte7!=bDENRespByteArray[7])
			        Assign(0,lsOKFlag,-6,sDENErrorCode)
			        Addn("Mauvais octet #7 (",bDENRespByteArray[7],"/",sDENFilterByte7,")",strDENErrorDetails)
				  ElseIfMC("AND",lsOKFlag=1,sDENFilterByte8!=-1,sDENFilterByte8!=bDENRespByteArray[8])
				    Assign(0,lsOKFlag,-6,sDENErrorCode)
				    Addn("Mauvais octet #8 (",bDENRespByteArray[8],"/",sDENFilterByte8,")",strDENErrorDetails)
                  EndIf()
                EndIf()
              EndIf()
            Else()
              RPN(bDENRespByteArray[4],256,*,bDENRespByteArray[5],+,llRxLengthEx)
              IfMC("AND",lsOKFlag=1,sDENFilterLength!=-1,sDENFilterLength!=llRxLengthEx)
                Assign(0,lsOKFlag,-5,sDENErrorCode)
                Addn("Mauvaise longueur (",llRxLengthEx,"/",sDENFilterLength,")",strDENErrorDetails)
              Else()
                IfMC("AND",lsOKFlag=1,sDENFilterByte4!=-1,sDENFilterByte4!=bDENRespByteArray[6])
                  Assign(0,lsOKFlag,-5,sDENErrorCode)
                  Addn("Mauvais octet #6 (",bDENRespByteArray[6],"/",sDENFilterByte4,")",strDENErrorDetails)
                Else()
                  IfMC("AND",lsOKFlag=1,sDENFilterByte5!=-1,sDENFilterByte5!=bDENRespByteArray[7])
                    Assign(0,lsOKFlag,-6,sDENErrorCode)
                    Addn("Mauvais octet #7 (",bDENRespByteArray[7],"/",sDENFilterByte5,")",strDENErrorDetails)
                  EndIf()
                EndIf()
              EndIf()
            EndIf()
          EndIf()
        EndIf()
      EndIf()
      ExitLoopIf(lsOKFlag=1)
    ElseIf(sDENErrorCode!=-1)
      Assign(-1,llLoopIndex)
      ExitLoop()
    EndIf()
    Add(llLoopIndex,1,llLoopIndex)
    ExitLoopIf(llLoopIndex>=lDENNumReadLoops)
  EndLoop()
  Assign(llLoopIndex,lDENNumRxLoops)
  IfMC("OR",llLoopIndex=-1,llLoopIndex>=lDENNumReadLoops)
    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"  >>> Réception d'une réponse sur le canal <",sDENChannel,">...Échec - %s/%s"):::EndIf()
    Assign("CommTools - DenReceiveIP(Ex1)",strDENErrorSource)
    If(llLoopIndex>=lDENNumReadLoops)
      Assign(-1,sDENErrorCode,"Temps alloué de réception écoulé",strDENErrorDesc)
    EndIf()
    IfMC("OR",sDENEndOrAbortIfFailed=1,sDENEndOrAbortIfFailed=2,sDENEndOrAbortIfFailed=3)
      Addn("ATTENTION !",kstrCRLF,kstrCRLF,/+
           "Erreur lors de la réception d'une réponse d'une carte Densité",kstrCRLF,kstrCRLF,/+
           "  Source de l'erreur : <",strDENErrorSource,">",kstrCRLF,/+
           "  Code d'erreur : <",sDENErrorCode,">",kstrCRLF,/+
           "  Description de l'erreur : <",strDENErrorDesc,">",strDENErrorMsg)
      MsgBoxOK(strDENErrorMsg,kstrAttnDlgTitle,800,250,14)
      If(sDENEndOrAbortIfFailed=1):::GoSub(MTComplete):::ElseIf(sDENEndOrAbortIfFailed=2):::GoSub(MTEnd):::ElseIf(sDENEndOrAbortIfFailed=3):::GoSub(MTAbort):::EndIf()
    EndIf()
  EndIf()
  If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Réception d'une réponse sur le canal <",sDENChannel,">...Fin - %s/%s"):::EndIf()

  // Écriture dans les arguments de retour.


EndSub(DENReceiveRespX)


// ---------------------------------------------------------------------------------------------------- //


///////////////////////////
// DENReceiveRespComplet //
///////////////////////////

BeginSub(DENReceiveRespComplet)
	LShorts(lsDENChannel)
	GetSubArgs(lsDENChannel)
	
	LBytes(lbBkpArray[1024])
;	LBytes(lbBkpResteArray[1024])
	LLongs(llMsgLenTotal,llMsgLen, llMsgLenExtra, llByteTotalReceive, llMsgIndex, llMsgQtyRecu, llMsgQtyARcvr)
	LLongs(llRetry, llRetryMax)
	Assign(4,llMsgLenExtra,0,sDENErrorCode)
	Assign(0,lDENRespLength)
	FillArray(0x55, bDENRespByteArray, 0, 1032)
    Assign(0,llRetry,2,llRetryMax)
    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"  Entrée fonction DENReceiveRespComplet - %s/%s"):::EndIf()
	
	FillArray(0,lbBkpArray,0,80)
;	Assign(1,llByteTotalReceive, 1, llMsgLenExtra)
	Assign(1,llByteTotalReceive, 4, llMsgLenExtra)
	Assign(0,llMsgQtyRecu, 0, llMsgIndex, 4, llMsgQtyARcvr)
	BeginLoop()
		//Lecture STX-SRC-DES-LEN seulement
		SerialComm(ReceiveEx1,lsDENChannel,lbBkpArray,0,llMsgLenExtra,llByteTotalReceive,1,0,sDENErrorCode)
		
		If(llByteTotalReceive>0)
		    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"    Nombre de Byte Attendu / reçu (",llMsgLenExtra," / ", llByteTotalReceive , ")- Statut de reception 1 OK - ",sDENErrorCode ," - %s/%s"):::EndIf()
			//svv(llByteTotalReceive, sDENErrorCode)
			CopyArray(lbBkpArray,0, bDENRespByteArray,llMsgIndex,llMsgLenExtra)
			RPN(llMsgIndex,llByteTotalReceive,+,llMsgIndex) 
			;Assign(1, llMsgLenExtra)
			RPN(llMsgQtyARcvr,llByteTotalReceive, -, llMsgLenExtra)
		Else()
			Assign(0,sDENErrorCode)
			Assign(0,lDENRespLength)
			If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"    Aucune données reçues Retry - (", llRetry, ") - %s/%s"):::EndIf()
			RPN(llRetry,++,llRetry)
			ExitLoopIf(llRetry>llRetryMax)
		EndIf()
		
		ExitLoopIf(llMsgIndex=4)
	EndLoop()	

	If(llMsgIndex=4)	
		Assign(bDENRespByteArray[3],llMsgLen)
		;AddnMonitorText("Len extra +1 : ", llMsgLen)
		RPN(llMsgLen,++,llMsgLenExtra)
		RPN(4, llMsgLenExtra, +,llMsgLenTotal)
;		Assign(1,llMsgLenExtra)
		Assign(llMsgLenExtra,llMsgQtyARcvr)
		
		//Lecture du reste du message
		BeginLoop()
			//Lecture Len-DATA[]-CRC
			SerialComm(ReceiveEx1,lsDENChannel,lbBkpArray,0,llMsgLenExtra,llByteTotalReceive,1,0,sDENErrorCode)
			
			If(llByteTotalReceive>0)
			    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"    Nombre de Byte Attendu / reçu (",llMsgLenExtra," / ", llByteTotalReceive , ")- Statut de reception 1 OK - ",sDENErrorCode ," - %s/%s"):::EndIf()
				//svv(llByteTotalReceive, sDENErrorCode)
				CopyArray(lbBkpArray,0, bDENRespByteArray,llMsgIndex,llMsgLenExtra)
				RPN(llMsgIndex,llByteTotalReceive,+,llMsgIndex) 
				;Assign(1, llMsgLenExtra)
				RPN(llMsgQtyARcvr,llByteTotalReceive, -, llMsgLenExtra)
				
			Else()
				Assign(0,sDENErrorCode)
				Assign(0,lDENRespLength)
				If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"    Aucune données reçues Retry - (", llRetry, ") - %s/%s"):::EndIf()
				RPN(llRetry,++,llRetry)
				ExitLoopIf(llRetry>llRetryMax)
			EndIf()
			
			ExitLoopIf(llMsgIndex=llMsgLenTotal)
		EndLoop()	

	EndIf()
	//Conclusion du message recu
	If(llMsgIndex=llMsgLenTotal)
		Assign(1,sDENErrorCode)
		Assign(llMsgIndex,lDENRespLength)
		CommTools(ByteArrayToHexString,bDENRespByteArray,0,lDENRespLength,strDENRespString)
		If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"    Données reçues  <",strDENRespString,"> (",lDENRespLength," Len)"," - %s/%s"):::EndIf()
	Else()
		If(llMsgIndex>0)
			Assign(1,sDENErrorCode)
			Assign(llMsgIndex,lDENRespLength)
			CommTools(ByteArrayToHexString,bDENRespByteArray,0,lDENRespLength,strDENRespString)
			If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"    Données reçues incomplet <",strDENRespString,"> (",lDENRespLength," Len)"," - %s/%s"):::EndIf()
		Else()
			Assign(0,sDENErrorCode)
			Assign(0,lDENRespLength)
			If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"    Aucune données reçues - %s/%s"):::EndIf()
		EndIf()
	EndIf()
    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"  Sortie fonction DENReceiveRespComplet - %s/%s"):::EndIf()
    
EndSub(DENReceiveRespComplet)



BeginSub(DENReceiveRespComplet2)
	LShorts(lsDENChannel)
	GetSubArgs(lsDENChannel)
	
	LBytes(lbBkpArray[1024])
	LBytes(lbBkpResteArray[1024])
	LLongs(llMsgLenTotal,llMsgLen, llMsgLenExtra, llByteTotalReceive)
	Assign(4,llMsgLenExtra,0,sDENErrorCode)
	Assign(0,lDENRespLength)
	FillArray(0x55, bDENRespByteArray, 0, 1032)
    
    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"  Entrée fonction DENReceiveRespComplet - %s/%s"):::EndIf()
	
	FillArray(0,lbBkpResteArray,0,4)
	SerialComm(ReceiveEx1,lsDENChannel,lbBkpArray,0,llMsgLenExtra,llByteTotalReceive,1,0,sDENErrorCode)
	If(llByteTotalReceive>0)
	    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"    Nombre de Byte Attendu / reçu (",llMsgLenExtra," / ", llByteTotalReceive , ")- Statut de reception 1 OK - ",sDENErrorCode ," - %s/%s"):::EndIf()
		//svv(llByteTotalReceive, sDENErrorCode)
		If(llByteTotalReceive!=0)
			Assign(llMsgLenExtra,llMsgLenTotal)
						
			//AddnMonitorText("DENReceiveRespComplet 1 : Channel : ", lsDENChannel," ; len :",llMsgLenExtra," ; ErrCode : ",sDENErrorCode)
			CopyArray(lbBkpArray,0, bDENRespByteArray,0,llMsgLenExtra)
			Assign(bDENRespByteArray[3],llMsgLen)
			;AddnMonitorText("Len extra +1 : ", llMsgLen)
			RPN(llMsgLen,++,llMsgLenExtra)
	
			FillArray(0,lbBkpResteArray,0,4)
		    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"    Nombre de Byte recu ",llMsgLenExtra,"  et ", llByteTotalReceive , " - %s/%s"):::EndIf()
			SerialComm(Receive,lsDENChannel,lbBkpArray,llMsgLenExtra,1,0,sDENErrorCode)
			;SerialComm(ReceiveEx1,lsDENChannel,lbBkpArray,0,llMsgLenExtra,llByteTotalReceive,1,0,sDENErrorCode)
			//SerialComm(ReceiveEx1,lsDENChannel,lbBkpArray,0,llMsgLenExtra,llByteTotalReceive,1,0,sDENErrorCode)
			
			If(llMsgLenExtra>0)
			    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"    Nombre de Byte copier ",llMsgLenExtra,"  et ", llByteTotalReceive , " - %s/%s"):::EndIf()
				//AddnMonitorText("DENReceiveRespComplet 2:  Channel : ",lsDENChannel," ; len :",llMsgLenExtra," ; ErrCode : ",sDENErrorCode)
	//			ShowArrayData(lbBkpResteArray,0,10)
	//			ShowArrayData(bDENRespByteArray,0,10)
				CopyArray(lbBkpArray,0, bDENRespByteArray,4,llMsgLenExtra)
				RPN(llMsgLenTotal,llMsgLenExtra,+,llMsgLenTotal)
			EndIf()
			;ShowArrayData(bDENRespByteArray,0,llMsgLenTotal)
		EndIf()
		If(llMsgLenTotal>0)
			Assign(1,sDENErrorCode)
			Assign(llMsgLenTotal,lDENRespLength)
		Else()
			Assign(0,sDENErrorCode)
			Assign(0,lDENRespLength)
		EndIf()
		CommTools(ByteArrayToHexString,bDENRespByteArray,0,lDENRespLength,strDENRespString)
		If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"    Données reçues  <",strDENRespString,"> (",lDENRespLength," Len)"," - %s/%s"):::EndIf()

	Else()
		Assign(0,sDENErrorCode)
		Assign(0,lDENRespLength)
		If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"    Aucune données reçues - %s/%s"):::EndIf()
	EndIf()	
    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"  Sortie fonction DENReceiveRespComplet - %s/%s"):::EndIf()
EndSub(DENReceiveRespComplet2)


// ---------------------------------------------------------------------------------------------------- //


///////////////////////
// DENReceiveRespEx1 //
///////////////////////

BeginSub(DENReceiveRespEx1)
// Réception d'une réponse suite à l'envoi d'un message à une carte densité selon le protocol normal ou étendu #1 de manière automatique.
// Choix complet, i.e. individuel, des sources (fentes) à filtrer.
// Usage : GoSubArg(DENReceiveRespEx1,sChannel,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSourceFlagsArray,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         lDenReadDelay (V/L) : Délai avant chaque lecture (msec). Si négatif, ne s'applique qu'avant la première lecture.
//         lDenReadTimeOutDelay (V/L) : Délai de timeout (msec).
//         lDenNumReadLoops (V/L) : Nombre de boucles de lecture si en timeout.
//         sDenFilterSourceFlagsArray (V) : Champs de 21 valeurs de type Shorts contenant le flag de filtrage pour chaque source (fente) possible (0: Inactif; 1: Actif).
//                                          Index 0 : CPU.
//                                          Indexes 1 à 20 : Fentes du châssis Densité.
//         sDenFilterDest (V/L) : Filtrage de la destination (-1 si pas de filtrage ou destination désirée).
//         sDenFilterLength (V/L) : Filtrage de la longueur du message (-1 si pas de filtrage ou longueur désirée).
//         sDenFilterByte4, sDenFilterByte5 (V/L) : Filtrage de la réponse (-1 si pas de filtrage ou octets de réponse désirés).
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 - Entrées dans le moniteur.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenReceiveIP(Ex1)" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenReceiveIP(Ex1) ou par la sous-routine (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenReceiveIP(Ex1) ou par la sous-routine ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
//         bDENRespByteArray : Champ d'octets de la réponse de la carte.
//         strDENRespString : Texte de la réponse de la carte.
// Exemple : GoSubArg(DENReceiveRespEx1,sDenChannel1,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSourceFlagsArray,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sDenMonFlag,"    ",sDenAbortIfFailed).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.
  LShorts(lsOKFlag,lsSourceFlags[1])
  LLongs(llLoopIndex,lReadDelayAbs,llRxLengthEx)
  LStrings(lstrCOMDetect)
  // Lecture des arguments d'entrée et de retour.
  GetSubArgs(sDENChannel,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,lsSourceFlags,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)

  // Réception d'une réponse suite à l'envoi d'un message à une carte densité.
  Abs(lDENReadDelay,lReadDelayAbs)
  If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Réception d'une réponse sur le canal <",sDENChannel,">...Début - %s/%s"):::EndIf()
  Assign(0,llLoopIndex)
  Assign(0,lDENBufferReceiveIndex)
  If(lDENReadDelay<0):::msecSleep(lReadDelayAbs,1):::EndIf()
  BeginLoop()
    If(lDENReadDelay>0):::msecSleep(lDENReadDelay,1):::EndIf()
    
	SubString(strDENIPAddr,Left,0,3,lstrCOMDetect)
	If(lstrCOMDetect="COM")
		GoSubArg(DENReceiveRespComplet,sDENChannel)
		//SerialComm(Receive,sDENChannel,bDENRespByteArray,lDENRespLength,1,0,sDENErrorCode)
	
	  //Inversion du resultat lorsque nous utilisons SerialComm
	  If(sDENErrorCode=1)
	  	Assign(0,sDENErrorCode)
	  Else()
	  	Assign(1,sDENErrorCode)
	  EndIf()
    Else()
	    CommTools(DenReceiveIPEx1,sDENChannel,lDENReadTimeOutDelay,bDENRespByteArray,lDENRespLength,sDENErrorCode,strDENErrorDesc)
	EndIf()
    If(sDENErrorCode=0)
      Assign("",strDENErrorSource,"",strDENErrorDesc,"",strDENErrorDetails)
      CommTools(ByteArrayToHexString,bDENRespByteArray,0,lDENRespLength,strDENRespString)
      If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"  Données reçues Ex1: <",strDENRespString,"> (",llLoopIndex," boucle(s))"," - %s/%s"):::EndIf()
      Assign(1,lsOKFlag)
      If(bDENRespByteArray[0]!=2)
        Assign(0,lsOKFlag,-2,sDENErrorCode)
        Addn("STX absent (",bDENRespByteArray[0],"/2)",strDENErrorDetails)
      Else()
        Assign(0,sDENFilterSource)
        IfMC("AND",lsSourceFlags[0]=1,bDENRespByteArray[2]=21):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[1]=1,bDENRespByteArray[2]=1):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[2]=1,bDENRespByteArray[2]=2):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[3]=1,bDENRespByteArray[2]=3):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[4]=1,bDENRespByteArray[2]=4):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[5]=1,bDENRespByteArray[2]=5):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[6]=1,bDENRespByteArray[2]=6):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[7]=1,bDENRespByteArray[2]=7):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[8]=1,bDENRespByteArray[2]=8):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[9]=1,bDENRespByteArray[2]=9):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[10]=1,bDENRespByteArray[2]=10):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[11]=1,bDENRespByteArray[2]=11):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[12]=1,bDENRespByteArray[2]=12):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[13]=1,bDENRespByteArray[2]=13):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[14]=1,bDENRespByteArray[2]=14):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[15]=1,bDENRespByteArray[2]=15):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[16]=1,bDENRespByteArray[2]=16):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[17]=1,bDENRespByteArray[2]=17):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[18]=1,bDENRespByteArray[2]=18):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[19]=1,bDENRespByteArray[2]=19):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[20]=1,bDENRespByteArray[2]=20):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsOKFlag=1,sDENFilterSource=0)
          Assign(0,lsOKFlag,-3,sDENErrorCode)
          Addn("Mauvaise source (",bDENRespByteArray[2],"/",sDENFilterSource,")",strDENErrorDetails)
        Else()
          IfMC("AND",lsOKFlag=1,sDENFilterDest!=-1,sDENFilterDest!=bDENRespByteArray[1])
            Assign(0,lsOKFlag,-4,sDENErrorCode)
            Addn("Mauvaise destination (",bDENRespByteArray[1],"/",sDENFilterDest,")",strDENErrorDetails)
          Else()
            If(bDENRespByteArray[3]!=128)
              IfMC("AND",lsOKFlag=1,sDENFilterLength!=-1,sDENFilterLength!=bDENRespByteArray[3])
                Assign(0,lsOKFlag,-5,sDENErrorCode)
                Addn("Mauvaise longueur (",bDENRespByteArray[3],"/",sDENFilterLength,")",strDENErrorDetails)
              Else()
                IfMC("AND",bDENRespByteArray[3]=3,bDENRespByteArray[4]=0,bDENRespByteArray[5]=1) // NACK : retour immédiat avec code d'erreur -10.
                  Assign(0,lsOKFlag,-10,sDENErrorCode)
                  Addn("NACK #",bDENRespByteArray[6]," reçu",strDENErrorDetails)
                  ExitLoop()
                EndIf()
                IfMC("AND",lsOKFlag=1,sDENFilterByte4!=-1,sDENFilterByte4!=bDENRespByteArray[4])
                  Assign(0,lsOKFlag,-5,sDENErrorCode)
                  Addn("Mauvais octet #4 (",bDENRespByteArray[4],"/",sDENFilterByte4,")",strDENErrorDetails)
                Else()
                  IfMC("AND",lsOKFlag=1,sDENFilterByte5!=-1,sDENFilterByte5!=bDENRespByteArray[5])
                    Assign(0,lsOKFlag,-6,sDENErrorCode)
                    Addn("Mauvais octet #5 (",bDENRespByteArray[5],"/",sDENFilterByte5,")",strDENErrorDetails)
                  EndIf()
                EndIf()
              EndIf()
            Else()
              RPN(bDENRespByteArray[4],256,*,bDENRespByteArray[5],+,llRxLengthEx)
              IfMC("AND",lsOKFlag=1,sDENFilterLength!=-1,sDENFilterLength!=llRxLengthEx)
                Assign(0,lsOKFlag,-5,sDENErrorCode)
                Addn("Mauvaise longueur (",llRxLengthEx,"/",sDENFilterLength,")",strDENErrorDetails)
              Else()
                IfMC("AND",lsOKFlag=1,sDENFilterByte4!=-1,sDENFilterByte4!=bDENRespByteArray[6])
                  Assign(0,lsOKFlag,-5,sDENErrorCode)
                  Addn("Mauvais octet #6 (",bDENRespByteArray[6],"/",sDENFilterByte4,")",strDENErrorDetails)
                Else()
                  IfMC("AND",lsOKFlag=1,sDENFilterByte5!=-1,sDENFilterByte5!=bDENRespByteArray[7])
                    Assign(0,lsOKFlag,-6,sDENErrorCode)
                    Addn("Mauvais octet #7 (",bDENRespByteArray[7],"/",sDENFilterByte5,")",strDENErrorDetails)
                  EndIf()
                EndIf()
              EndIf()
            EndIf()
          EndIf()
        EndIf()
      EndIf()
      ExitLoopIf(lsOKFlag=1)
    ElseIf(sDENErrorCode!=-1)
      Assign(-1,llLoopIndex)
      ExitLoop()
    EndIf()
    Add(llLoopIndex,1,llLoopIndex)
    ExitLoopIf(llLoopIndex>=lDENNumReadLoops)
  EndLoop()
  Assign(llLoopIndex,lDENNumRxLoops)
  IfMC("OR",llLoopIndex=-1,llLoopIndex>=lDENNumReadLoops)
    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"  >>> Réception d'une réponse sur le canal <",sDENChannel,">...Échec - %s/%s"):::EndIf()
    Assign("CommTools - DenReceiveIP(Ex1)",strDENErrorSource)
    If(llLoopIndex>=lDENNumReadLoops)
      Assign(-1,sDENErrorCode,"Temps alloué de réception écoulé",strDENErrorDesc)
    EndIf()
    IfMC("OR",sDENEndOrAbortIfFailed=1,sDENEndOrAbortIfFailed=2,sDENEndOrAbortIfFailed=3)
      Addn("ATTENTION !",kstrCRLF,kstrCRLF,/+
           "Erreur lors de la réception d'une réponse d'une carte Densité",kstrCRLF,kstrCRLF,/+
           "  Source de l'erreur : <",strDENErrorSource,">",kstrCRLF,/+
           "  Code d'erreur : <",sDENErrorCode,">",kstrCRLF,/+
           "  Description de l'erreur : <",strDENErrorDesc,">",strDENErrorMsg)
      MsgBoxOK(strDENErrorMsg,kstrAttnDlgTitle,800,250,14)
      If(sDENEndOrAbortIfFailed=1):::GoSub(MTComplete):::ElseIf(sDENEndOrAbortIfFailed=2):::GoSub(MTEnd):::ElseIf(sDENEndOrAbortIfFailed=3):::GoSub(MTAbort):::EndIf()
    EndIf()
  EndIf()
  If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Réception d'une réponse sur le canal <",sDENChannel,">...Fin - %s/%s"):::EndIf()

  // Écriture dans les arguments de retour.

EndSub(DENReceiveRespEx1)


// ---------------------------------------------------------------------------------------------------- //


////////////////////////
// DENReceiveRespEx1A //
////////////////////////

BeginSub(DENReceiveRespEx1A)
// Réception d'une réponse suite à l'envoi d'un message à une carte densité selon le protocol normal ou étendu #1 de manière automatique.
// Délai initial avant la première lecture spécifié séparément du délai à chaque boucle.
// Choix complet, i.e. individuel, des sources (fentes) à filtrer.
// Choix complet, i.e. individuel, des octets de réponse à filtrer.
// Usage : GoSubArg(DENReceiveRespEx1,sChannel,lDenInitialReadDelay,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSourceFlagsArray,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sDenFilterBytes6To63Array,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         lDenInitialReadDelay (V/L) : Délai initial avant lecture (msec).
//         lDenReadDelay (V/L) : Délai avant chaque lecture (msec).
//         lDenReadTimeOutDelay (V/L) : Délai de timeout (msec).
//         lDenNumReadLoops (V/L) : Nombre de boucles de lecture si en timeout.
//         sDenFilterSourceFlagsArray (V) : Champs de 21 valeurs de type Shorts contenant le flag de filtrage pour chaque source (fente) possible (0: Inactif; 1: Actif).
//                                          Index 0 : CPU.
//                                          Indexes 1 à 20 : Fentes du châssis Densité.
//         sDenFilterDest (V/L) : Filtrage de la destination (-1 si pas de filtrage ou destination désirée).
//         sDenFilterLength (V/L) : Filtrage de la longueur du message (-1 si pas de filtrage ou longueur désirée).
//         sDenFilterByte4, sDenFilterByte5 (V/L) : Filtrage de la réponse (-1 si pas de filtrage ou octets de réponse désirés).
//         sDenFilterBytes6To63Array (V/L) :  Filtrage de la réponse, octets 6 à 63 (-1 si pas de filtrage ou octets de réponse désirés).
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 - Entrées dans le moniteur.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenReceiveIP(Ex1)" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenReceiveIP(Ex1) ou par la sous-routine (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenReceiveIP(Ex1) ou par la sous-routine ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
//         bDENRespByteArray : Champ d'octets de la réponse de la carte.
//         strDENRespString : Texte de la réponse de la carte.
// Exemple : GoSubArg(DENReceiveRespEx1,sDenChannel1,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSourceFlagsArray,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sDenMonFlag,"    ",sDenAbortIfFailed).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.
  LShorts(lsOKFlag,lsSourceFlags[1],lsBytesFlags[1],lsRespBytesArrayIndex)
  LLongs(llLoopIndex,llDelay1A,llDelay1B,llDelay2A,llDelay2B,llRxLengthEx)

  // Lecture des arguments d'entrée et de retour.
  GetSubArgs(sDENChannel,lDENInitialReadDelay,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,lsSourceFlags,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,lsBytesFlags,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)

  // Réception d'une réponse suite à l'envoi d'un message à une carte densité.
  If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Réception d'une réponse sur le canal <",sDENChannel,">...Début - %s/%s"):::EndIf()
  If(lDENInitialReadDelay<100):::Assign(lDENInitialReadDelay,llDelay1A,1,llDelay1B):::Else():::Assign(100,llDelay1A):::Div(lDENInitialReadDelay,100,llDelay1B):::EndIf()
  If(lDENReadDelay<100):::Assign(lDENReadDelay,llDelay2A,1,llDelay2B):::Else():::Assign(100,llDelay2A):::Div(lDENReadDelay,100,llDelay2B):::EndIf()
  msecSleep(llDelay1A,llDelay1B)
  Assign(0,llLoopIndex)
  BeginLoop()
    msecSleep(llDelay2A,llDelay2B)
    CommTools(DenReceiveIPEx1,sDENChannel,lDENReadTimeOutDelay,bDENRespByteArray,lDENRespLength,sDENErrorCode,strDENErrorDesc)
    If(sDENErrorCode=0)
      Assign("",strDENErrorSource,"",strDENErrorDesc,"",strDENErrorDetails)
      CommTools(ByteArrayToHexString,bDENRespByteArray,0,lDENRespLength,strDENRespString)
      If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"  Données reçues Ex1A: <",strDENRespString,"> (",llLoopIndex," boucle(s))"," - %s/%s"):::EndIf()
      Assign(1,lsOKFlag)
      If(bDENRespByteArray[0]!=2)
        Assign(0,lsOKFlag,-2,sDENErrorCode)
        Addn("STX absent (",bDENRespByteArray[0],"/2)",strDENErrorDetails)
      Else()
        Assign(0,sDENFilterSource)
        IfMC("AND",lsSourceFlags[0]=1,bDENRespByteArray[2]=21):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[1]=1,bDENRespByteArray[2]=1):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[2]=1,bDENRespByteArray[2]=2):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[3]=1,bDENRespByteArray[2]=3):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[4]=1,bDENRespByteArray[2]=4):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[5]=1,bDENRespByteArray[2]=5):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[6]=1,bDENRespByteArray[2]=6):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[7]=1,bDENRespByteArray[2]=7):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[8]=1,bDENRespByteArray[2]=8):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[9]=1,bDENRespByteArray[2]=9):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[10]=1,bDENRespByteArray[2]=10):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[11]=1,bDENRespByteArray[2]=11):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[12]=1,bDENRespByteArray[2]=12):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[13]=1,bDENRespByteArray[2]=13):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[14]=1,bDENRespByteArray[2]=14):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[15]=1,bDENRespByteArray[2]=15):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[16]=1,bDENRespByteArray[2]=16):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[17]=1,bDENRespByteArray[2]=17):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[18]=1,bDENRespByteArray[2]=18):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[19]=1,bDENRespByteArray[2]=19):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsSourceFlags[20]=1,bDENRespByteArray[2]=20):::Assign(1,sDENFilterSource):::EndIf()
        IfMC("AND",lsOKFlag=1,sDENFilterSource=0)
          Assign(0,lsOKFlag,-3,sDENErrorCode)
          Addn("Mauvaise source (",bDENRespByteArray[2],"/",sDENFilterSource,")",strDENErrorDetails)
        Else()
          IfMC("AND",lsOKFlag=1,sDENFilterDest!=-1,sDENFilterDest!=bDENRespByteArray[1])
            Assign(0,lsOKFlag,-4,sDENErrorCode)
            Addn("Mauvaise destination (",bDENRespByteArray[1],"/",sDENFilterDest,")",strDENErrorDetails)
          Else()
            If(bDENRespByteArray[3]!=128)
              IfMC("AND",lsOKFlag=1,sDENFilterLength!=-1,sDENFilterLength!=bDENRespByteArray[3])
                Assign(0,lsOKFlag,-5,sDENErrorCode)
                Addn("Mauvaise longueur (",bDENRespByteArray[3],"/",sDENFilterLength,")",strDENErrorDetails)
              Else()
                IfMC("AND",bDENRespByteArray[3]=3,bDENRespByteArray[4]=0,bDENRespByteArray[5]=1) // NACK : retour immédiat avec code d'erreur -10.
                  Assign(0,lsOKFlag,-10,sDENErrorCode)
                  Addn("NACK #",bDENRespByteArray[6]," reçu",strDENErrorDetails)
                  ExitLoop()
                EndIf()
                IfMC("AND",lsOKFlag=1,sDENFilterByte4!=-1,sDENFilterByte4!=bDENRespByteArray[4])
                  Assign(0,lsOKFlag,-5,sDENErrorCode)
                  Addn("Mauvais octet #4 (",bDENRespByteArray[4],"/",sDENFilterByte4,")",strDENErrorDetails)
                Else()
                  IfMC("AND",lsOKFlag=1,sDENFilterByte5!=-1,sDENFilterByte5!=bDENRespByteArray[5])
                    Assign(0,lsOKFlag,-6,sDENErrorCode)
                    Addn("Mauvais octet #5 (",bDENRespByteArray[5],"/",sDENFilterByte5,")",strDENErrorDetails)
                  Else()
                    Assign(0,lsRespBytesArrayIndex)
                    BeginLoop()
                      IfMC("AND",lsOKFlag=1,lsBytesFlags[lsRespBytesArrayIndex]!=-1,lsBytesFlags[lsRespBytesArrayIndex]!=bDENRespByteArray[lsRespBytesArrayIndex])
                        Assign(0,lsOKFlag,-7,sDENErrorCode)
                        Addn("Mauvais octet #",lsRespBytesArrayIndex," (",bDENRespByteArray[lsRespBytesArrayIndex],"/",lsBytesFlags[lsRespBytesArrayIndex],")",strDENErrorDetails)
                      EndIf()
                      Add(lsRespBytesArrayIndex,1,lsRespBytesArrayIndex)
                      ExitLoopIf(lsRespBytesArrayIndex>=64)
                    EndLoop()
                  EndIf()
                EndIf()
              EndIf()
            Else()
              RPN(bDENRespByteArray[4],256,*,bDENRespByteArray[5],+,llRxLengthEx)
              IfMC("AND",lsOKFlag=1,sDENFilterLength!=-1,sDENFilterLength!=llRxLengthEx)
                Assign(0,lsOKFlag,-5,sDENErrorCode)
                Addn("Mauvaise longueur (",llRxLengthEx,"/",sDENFilterLength,")",strDENErrorDetails)
              Else()
                IfMC("AND",lsOKFlag=1,sDENFilterByte4!=-1,sDENFilterByte4!=bDENRespByteArray[6])
                  Assign(0,lsOKFlag,-5,sDENErrorCode)
                  Addn("Mauvais octet #6 (",bDENRespByteArray[6],"/",sDENFilterByte4,")",strDENErrorDetails)
                Else()
                  IfMC("AND",lsOKFlag=1,sDENFilterByte5!=-1,sDENFilterByte5!=bDENRespByteArray[7])
                    Assign(0,lsOKFlag,-6,sDENErrorCode)
                    Addn("Mauvais octet #7 (",bDENRespByteArray[7],"/",sDENFilterByte5,")",strDENErrorDetails)
                  Else()
                    Assign(0,lsRespBytesArrayIndex)
                    BeginLoop()
                      IfMC("AND",lsOKFlag=1,lsBytesFlags[lsRespBytesArrayIndex]!=-1,lsBytesFlags[lsRespBytesArrayIndex]!=bDENRespByteArray[lsRespBytesArrayIndex])
                        Assign(0,lsOKFlag,-7,sDENErrorCode)
                        Addn("Mauvais octet #",lsRespBytesArrayIndex," (",bDENRespByteArray[lsRespBytesArrayIndex],"/",lsBytesFlags[lsRespBytesArrayIndex],")",strDENErrorDetails)
                      EndIf()
                      Add(lsRespBytesArrayIndex,1,lsRespBytesArrayIndex)
                      ExitLoopIf(lsRespBytesArrayIndex>=1032)
                    EndLoop()
                  EndIf()
                EndIf()
              EndIf()
            EndIf()
          EndIf()
        EndIf()
      EndIf()
      ExitLoopIf(lsOKFlag=1)
    ElseIf(sDENErrorCode!=-1)
      Assign(-1,llLoopIndex)
      ExitLoop()
    EndIf()
    Add(llLoopIndex,1,llLoopIndex)
    ExitLoopIf(llLoopIndex>=lDENNumReadLoops)
  EndLoop()
  Assign(llLoopIndex,lDENNumRxLoops)
  IfMC("OR",llLoopIndex=-1,llLoopIndex>=lDENNumReadLoops)
    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"  >>> Réception d'une réponse sur le canal <",sDENChannel,">...Échec - %s/%s"):::EndIf()
    Assign("CommTools - DenReceiveIP(Ex1)",strDENErrorSource)
    If(llLoopIndex>=lDENNumReadLoops)
      Assign(-1,sDENErrorCode,"Temps alloué de réception écoulé",strDENErrorDesc)
    EndIf()
    IfMC("OR",sDENEndOrAbortIfFailed=1,sDENEndOrAbortIfFailed=2,sDENEndOrAbortIfFailed=3)
      Addn("ATTENTION !",kstrCRLF,kstrCRLF,/+
           "Erreur lors de la réception d'une réponse d'une carte Densité",kstrCRLF,kstrCRLF,/+
           "  Source de l'erreur : <",strDENErrorSource,">",kstrCRLF,/+
           "  Code d'erreur : <",sDENErrorCode,">",kstrCRLF,/+
           "  Description de l'erreur : <",strDENErrorDesc,">",strDENErrorMsg)
      MsgBoxOK(strDENErrorMsg,kstrAttnDlgTitle,800,250,14)
      If(sDENEndOrAbortIfFailed=1):::GoSub(MTComplete):::ElseIf(sDENEndOrAbortIfFailed=2):::GoSub(MTEnd):::ElseIf(sDENEndOrAbortIfFailed=3):::GoSub(MTAbort):::EndIf()
    EndIf()
  EndIf()
  If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Réception d'une réponse sur le canal <",sDENChannel,">...Fin - %s/%s"):::EndIf()

  // Écriture dans les arguments de retour.

EndSub(DENReceiveRespEx1A)


// ---------------------------------------------------------------------------------------------------- //


///////////////////////////
// DENSendMsgReceiveResp //
///////////////////////////

BeginSub(DENSendMsgReceiveResp)
// Envoi d'un message à une carte densité selon le protocol normal ou étendu #1 au choix et réception d'une réponse selon le protocol normal ou étendu #1 de manière automatique.
// Combine les fonctionnalités de DENSendMsg et DENReceiveResp.
// Usage : GoSubArg(DENSendMsgReceiveResp,sChannel,sSource,sDest,strMessage,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed[,sExtProtocolID]).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         sSource (V/L) : Source de communication (25).
//         sDest (V/L) : Fente de la carte (1-21).
//         strMessage (V/L) : Message Densité à envoyer.
//         lDenReadDelay (V/L) : Délai avant lecture (msec). Si négatif, ne s'applique qu'avant la première lecture.
//         lDenReadTimeOutDelay (V/L) : Délai de timeout (msec).
//         lDenNumReadLoops (V/L) : Nombre de boucles de lecture si en timeout.
//         sDenFilterSource (V/L) : Filtrage de la source (-1 si pas de filtrage ou numéro de la fente désirée).
//         sDenFilterDest (V/L) : Filtrage de la destination (-1 si pas de filtrage ou destination désirée).
//         sDenFilterLength (V/L) : Filtrage de la longueur du message (-1 si pas de filtrage ou longueur désirée).
//         sDenFilterByte4, sDenFilterByte5 (V/L) : Filtrage de la réponse (-1 si pas de filtrage ou octets de réponse désirés).
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 - Entrées dans le moniteur.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
//         sExtProtocolID (V/L) (Optionnel) : 0 - Protocol normal.
//                                            1 - Protocol étendu #1 (Axino).
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenSendIP/DenReceiveIP(Ex1)" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenSendIP/DenReceiveIP(Ex1) ou par la sous-routine (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenSendIP/DenReceiveIP(Ex1) ou par la sous-routine ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
//         bDENRespByteArray : Champ d'octets de la réponse de la carte.
//         strDENRespString : Texte de la réponse de la carte.
// Exemple : GoSubArg(DENSendMsgReceiveResp,sDenChannel1,sDenSource,sDenDestination,"0012",lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sDenMonFlag,"    ",sDenAbortIfFailed[,0/1]).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.
  LShorts(lsNumSubArgs,lsExtProtocolID)
  LLongs(llLoopIndex)

  // Lecture des arguments d'entrée et de retour.
  GetSubNumArgs(lsNumSubArgs)
  If(lsNumSubArgs=15)
    GetSubArgs(sDENChannel,sDENSource,sDENDest,strDENMessage,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
    Assign(0,lsExtProtocolID)
  ElseIf(lsNumSubArgs=16)
    GetSubArgs(sDENChannel,sDENSource,sDENDest,strDENMessage,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed,lsExtProtocolID)
  Else()
    Assign(100,sDENErrorCode,"DENSendMsgReceiveResp",strDENErrorSource,"Nombre d'arguments incorrect",strDENErrorDesc,"Nombre d'arguments différent de 15 et 16",strDENErrorDetails)
    ExitSub(DENSendMsgReceiveResp)
  EndIf()

  // Envoi et réception.
  Assign(0,llLoopIndex)
  BeginLoop()
    GoSubArg(DENSendMsg,sDENChannel,sDENSource,sDENDest,strDENMessage,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed,lsExtProtocolID)
    If(sDENErrorCode=0)
      GoSubArg(DENReceiveResp,sDENChannel,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
    EndIf()
    ExitLoopIf(sDENErrorCode!=-10)
    Add(llLoopIndex,1,llLoopIndex)
    ExitLoopIf(llLoopIndex>=lDENNumReadLoops)
    msecSleep(lDENReadTimeOutDelay,1)
  EndLoop()

  // Écriture dans les arguments de retour.

EndSub(DENSendMsgReceiveResp)


// ---------------------------------------------------------------------------------------------------- //


///////////////////////////
// DENSendMsgReceiveRespX //
///////////////////////////

BeginSub(DENSendMsgReceiveRespX)
// Envoi d'un message à une carte densité et réception d'une réponse.
// Combine les fonctionnalités de DENSendMsg et DENReceiveResp.
// Usage : GoSubArg(DENSendMsgReceiveResp,sChannel,sSource,sDest,strMessage,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         sSource (V/L) : Source de communication (25).
//         sDest (V/L) : Fente de la carte (1-21).
//         strMessage (V/L) : Message Densité à envoyer.
//         lDenReadDelay (V/L) : Délai avant lecture (msec).
//         lDenReadTimeOutDelay (V/L) : Délai de timeout (msec).
//         lDenNumReadLoops (V/L) : Nombre de boucles de lecture si en timeout.
//         sDenFilterSource (V/L) : Filtrage de la source (-1 si pas de filtrage ou numéro de la fente désirée).
//         sDenFilterDest (V/L) : Filtrage de la destination (-1 si pas de filtrage ou destination désirée).
//         sDenFilterLength (V/L) : Filtrage de la longueur du message (-1 si pas de filtrage ou longueur désirée).
//         sDenFilterByte4, sDenFilterByte5,sDENFilterByte6,sDENFilterByte7,sDENFilterByte8 (V/L) : Filtrage de la réponse (-1 si pas de filtrage ou octets de réponse désirés).
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 - Entrées dans le moniteur.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenSendIP/DenReceiveIP" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenSendIP/DenReceiveIP ou par la sous-routine (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenSendIP/DenReceiveIP ou par la sous-routine ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
//         bDENRespByteArray : Champ d'octets de la réponse de la carte.
//         strDENRespString : Texte de la réponse de la carte.
// Exemple : GoSubArgX(DENSendMsgReceiveResp,sDenChannel1,sDenSource,sDenDestination,"0012",lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sDenMonFlag,"    ",sDenAbortIfFailed).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.
  LShorts(lsNumSubArgs,lsExtProtocolID)
  LLongs(llLoopIndex)

  // Lecture des arguments d'entrée et de retour.
  GetSubNumArgs(lsNumSubArgs)
  If(lsNumSubArgs=18)
    GetSubArgs(sDENChannel,sDENSource,sDENDest,strDENMessage,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENFilterByte6,sDENFilterByte7,sDENFilterByte8,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
    Assign(0,lsExtProtocolID)
  ElseIf(lsNumSubArgs=19)
    GetSubArgs(sDENChannel,sDENSource,sDENDest,strDENMessage,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENFilterByte6,sDENFilterByte7,sDENFilterByte8,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed,lsExtProtocolID)
  Else()
    Assign(100,sDENErrorCode,"DENSendMsgReceiveResp",strDENErrorSource,"Nombre d'arguments incorrect",strDENErrorDesc,"Nombre d'arguments différent de 15 et 16",strDENErrorDetails)
    ExitSub(DENSendMsgReceiveRespX)
  EndIf()

  // Envoi et réception.
  Assign(0,llLoopIndex)
  BeginLoop()
    GoSubArg(DENSendMsg,sDENChannel,sDENSource,sDENDest,strDENMessage,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed,lsExtProtocolID)
    If(sDENErrorCode=0)
      GoSubArg(DENReceiveRespX,sDENChannel,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENFilterByte6,sDENFilterByte7,sDENFilterByte8,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
    EndIf()
    ExitLoopIf(sDENErrorCode!=-10)
    Add(llLoopIndex,1,llLoopIndex)
    ExitLoopIf(llLoopIndex>=lDENNumReadLoops)
    msecSleep(lDENReadTimeOutDelay,1)
  EndLoop()

  // Écriture dans les arguments de retour.

EndSub(DENSendMsgReceiveRespX)


// ---------------------------------------------------------------------------------------------------- //


////////////////////////////////////////
// DENInitOpenSendMsgReceiveRespClose //
////////////////////////////////////////

BeginSub(DENInitOpenSendMsgReceiveRespClose)
// Initialisation et ouverture de la communication IP, envoi d'un message à une carte densité selon le protocol normal ou étendu #1 au choix, réception d'une réponse selon le protocol normal ou étendu #1
// de manière automatique puis fermeture de la communication IP.
// Toutes les opérations pour une communication complète sont ici réunies ensemble.
// Usage : GoSubArg(DENInitOpenSendMsgReceiveRespClose,sChannel,strIPAddr,lIPPort,sSource,sDest,strMessage,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed[,sExtProtocolID]).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         strIPAddr (V/L) : Adresse TCP/IP (Format 0.0.0.0 ou @Descripteur).
//         lIPPort (V/L) : Port Ethernet (5100).
//         sSource (V/L) : Source de communication (25).
//         sDest (V/L) : Fente de la carte (1-21).
//         strMessage (V/L) : Message Densité à envoyer.
//         lDenReadDelay (V/L) : Délai avant lecture (msec). Si négatif, ne s'applique qu'avant la première lecture.
//         lDenReadTimeOutDelay (V/L) : Délai de timeout (msec).
//         lDenNumReadLoops (V/L) : Nombre de boucles de lecture si en timeout.
//         sDenFilterSource (V/L) : Filtrage de la source (-1 si pas de filtrage ou numéro de la fente désirée).
//         sDenFilterDest (V/L) : Filtrage de la destination (-1 si pas de filtrage ou destination désirée).
//         sDenFilterLength (V/L) : Filtrage de la longueur du message (-1 si pas de filtrage ou longueur désirée).
//         sDenFilterByte4, sDenFilterByte5 (V/L) : Filtrage de la réponse (-1 si pas de filtrage ou octets de réponse désirés).
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 - Entrées dans le moniteur.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
//         sExtProtocolID (V/L) (Optionnel) : 0 - Protocol normal.
//                                            1 - Protocol étendu #1 (Axino).
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenInitIP/DenOpenIP/DenSendIP(Ex1)/DenReceiveIP(Ex1)/DenCloseIP" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenInitIP/DenOpenIP/DenSendIP(Ex1)/DenReceiveIP(Ex1)/DenCloseIP ou par la sous-routine (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenInitIP/DenOpenIP/DenSendIP/DenReceiveIP/DenCloseIP ou par la sous-routine ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
//         bDENRespByteArray : Champ d'octets de la réponse de la carte.
//         strDENRespString : Texte de la réponse de la carte.
// Exemple : GoSubArg(DENInitOpenSendMsgReceiveRespClose,sDenChannel1,strDenIPAddr,lDenIPPort,sDenSource,sDenDestination,"0012",lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sDenMonFlag,"    ",sDenAbortIfFailed[,0/1]).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.
  LShorts(lsNumSubArgs,lsExtProtocolID)
  LStrings(lstrCOMDetect)
    
  // Lecture des arguments d'entrée et de retour.
  GetSubNumArgs(lsNumSubArgs)
  If(lsNumSubArgs=17)
    GetSubArgs(sDENChannel,strDENIPAddr,lDENIPPort,sDENSource,sDENDest,strDENMessage,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
    Assign(0,lsExtProtocolID)
  ElseIf(lsNumSubArgs=18)
    GetSubArgs(sDENChannel,strDENIPAddr,lDENIPPort,sDENSource,sDENDest,strDENMessage,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed,lsExtProtocolID)
  Else()
    Assign(100,sDENErrorCode,"DENInitOpenSendMsgReceiveRespClose",strDENErrorSource,"Nombre d'arguments incorrect",strDENErrorDesc,"Nombre d'arguments différent de 17 et 18",strDENErrorDetails)
    ExitSub(DENInitOpenSendMsgReceiveRespClose)
  EndIf()

  // Opérations.
	SubString(strDENIPAddr,Left,0,3,lstrCOMDetect)
	If(lstrCOMDetect="COM")
	  Assign(0,sDENErrorCode)
	Else()
	  GoSubArg(DENInit,sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
	EndIf()

  If(sDENErrorCode=0)
    GoSubArg(DENOpen,sDENChannel,strDENIPAddr,lDENIPPort,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
    If(sDENErrorCode=0)
      GoSubArg(DENSendMsgReceiveResp,sDENChannel,sDENSource,sDENDest,strDENMessage,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed,lsExtProtocolID)
      If(sDENErrorCode=0)
        GoSubArg(DENClose,sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
      Else()
        Assign(sDENErrorCode,sDENErrorCodeBU,strDENErrorDesc,strDENErrorDescBU,strDENErrorSource,strDENErrorSourceBU,strDENErrorDetails,strDENErrorDetailsBU)
        GoSubArg(DENClose,sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
        Assign(sDENErrorCodeBU,sDENErrorCode,strDENErrorDescBU,strDENErrorDesc,strDENErrorSourceBU,strDENErrorSource,strDENErrorDetailsBU,strDENErrorDetails)
      EndIf()
    Else()
      Assign(sDENErrorCode,sDENErrorCodeBU,strDENErrorDesc,strDENErrorDescBU,strDENErrorSource,strDENErrorSourceBU,strDENErrorDetails,strDENErrorDetailsBU)
      GoSubArg(DENClose,sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
      Assign(sDENErrorCodeBU,sDENErrorCode,strDENErrorDescBU,strDENErrorDesc,strDENErrorSourceBU,strDENErrorSource,strDENErrorDetailsBU,strDENErrorDetails)
    EndIf()
  EndIf()

  // Écriture dans les arguments de retour.

EndSub(DENInitOpenSendMsgReceiveRespClose)


// ---------------------------------------------------------------------------------------------------- //

////////////////////////////////////////
// DENInitOpenSendMsgReceiveRespCloseX //
////////////////////////////////////////

BeginSub(DENInitOpenSendMsgReceiveRespCloseX)
//comme DENInitOpenSendMsgReceiveRespCloseX mais avec ajout de 3 bytes supplementaires de flitrage 6,7 et 8
// Initialisation et ouverture de la communication IP, envoi d'un message à une carte densité, réception d'une réponse puis fermeture de la communication IP.
// Toutes les opérations pour une communication complète sont ici réunies ensemble.
// Usage : GoSubArg(DENInitOpenSendMsgReceiveRespClose,sChannel,strIPAddr,lIPPort,sSource,sDest,strMessage,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sDENFilterByte6,sDENFilterByte7,sDENFilterByte8,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         strIPAddr (V/L) : Adresse TCP/IP (Format 0.0.0.0 ou @Descripteur).
//         lIPPort (V/L) : Port Ethernet (5100).
//         sSource (V/L) : Source de communication (25).
//         sDest (V/L) : Fente de la carte (1-21).
//         strMessage (V/L) : Message Densité à envoyer.
//         lDenReadDelay (V/L) : Délai avant lecture (msec).
//         lDenReadTimeOutDelay (V/L) : Délai de timeout (msec).
//         lDenNumReadLoops (V/L) : Nombre de boucles de lecture si en timeout.
//         sDenFilterSource (V/L) : Filtrage de la source (-1 si pas de filtrage ou numéro de la fente désirée).
//         sDenFilterDest (V/L) : Filtrage de la destination (-1 si pas de filtrage ou destination désirée).
//         sDenFilterLength (V/L) : Filtrage de la longueur du message (-1 si pas de filtrage ou longueur désirée).
//         sDenFilterByte4, sDenFilterByte5,sDENFilterByte6,sDENFilterByte7,sDENFilterByte8 (V/L) : Filtrage de la réponse (-1 si pas de filtrage ou octets de réponse désirés).
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 - Entrées dans le moniteur.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenInitIP/DenOpenIP/DenSendIP/DenReceiveIP/DenCloseIP" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenInitIP/DenOpenIP/DenSendIP/DenReceiveIP/DenCloseIP ou par la sous-routine (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenInitIP/DenOpenIP/DenSendIP/DenReceiveIP/DenCloseIP ou par la sous-routine ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
//         bDENRespByteArray : Champ d'octets de la réponse de la carte.
//         strDENRespString : Texte de la réponse de la carte.
// Exemple : GoSubArgX(DENInitOpenSendMsgReceiveRespClose,sDenChannel1,strDenIPAddr,lDenIPPort,sDenSource,sDenDestination,"0012",lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sDenMonFlag,"    ",sDenAbortIfFailed).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.
  LShorts(lsNumSubArgs,lsExtProtocolID)
  LStrings(lstrCOMDetect)
    
  // Lecture des arguments d'entrée et de retour.
  GetSubNumArgs(lsNumSubArgs)
  If(lsNumSubArgs=20)
    GetSubArgs(sDENChannel,strDENIPAddr,lDENIPPort,sDENSource,sDENDest,strDENMessage,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENFilterByte6,sDENFilterByte7,sDENFilterByte8,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
    Assign(0,lsExtProtocolID)
  ElseIf(lsNumSubArgs=21)
    GetSubArgs(sDENChannel,strDENIPAddr,lDENIPPort,sDENSource,sDENDest,strDENMessage,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENFilterByte6,sDENFilterByte7,sDENFilterByte8,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed,lsExtProtocolID)
  Else()
    Assign(100,sDENErrorCode,"DENInitOpenSendMsgReceiveRespClose",strDENErrorSource,"Nombre d'arguments incorrect",strDENErrorDesc,"Nombre d'arguments différent de 17 et 18",strDENErrorDetails)
    ExitSub(DENInitOpenSendMsgReceiveRespCloseX)
  EndIf()

  // Opérations.
  SubString(strDENIPAddr,Left,0,3,lstrCOMDetect)
  If(lstrCOMDetect="COM")
    Assign(0,sDENErrorCode)
  Else()
    GoSubArg(DENInit,sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
  EndIf()

  If(sDENErrorCode=0)
    GoSubArg(DENOpen,sDENChannel,strDENIPAddr,lDENIPPort,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
    If(sDENErrorCode=0)
      GoSubArg(DENSendMsgReceiveRespX,sDENChannel,sDENSource,sDENDest,strDENMessage,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENFilterByte6,sDENFilterByte7,sDENFilterByte8,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed,lsExtProtocolID)
      If(sDENErrorCode=0)
        GoSubArg(DENClose,sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
      Else()
        Assign(sDENErrorCode,sDENErrorCodeBU,strDENErrorDesc,strDENErrorDescBU,strDENErrorSource,strDENErrorSourceBU,strDENErrorDetails,strDENErrorDetailsBU)
        GoSubArg(DENClose,sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
        Assign(sDENErrorCodeBU,sDENErrorCode,strDENErrorDescBU,strDENErrorDesc,strDENErrorSourceBU,strDENErrorSource,strDENErrorDetailsBU,strDENErrorDetails)
      EndIf()
    Else()
      Assign(sDENErrorCode,sDENErrorCodeBU,strDENErrorDesc,strDENErrorDescBU,strDENErrorSource,strDENErrorSourceBU,strDENErrorDetails,strDENErrorDetailsBU)
      GoSubArg(DENClose,sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
      Assign(sDENErrorCodeBU,sDENErrorCode,strDENErrorDescBU,strDENErrorDesc,strDENErrorSourceBU,strDENErrorSource,strDENErrorDetailsBU,strDENErrorDetails)
    EndIf()
  EndIf()

  // Écriture dans les arguments de retour.

EndSub(DENInitOpenSendMsgReceiveRespCloseX)

// ---------------------------------------------------------------------------------------------------- //

////////////////////////////////////////////////////
// DENInitOpenSendMsgReceiveRespDealWithNackClose //
////////////////////////////////////////////////////

BeginSub(DENInitOpenSendMsgReceiveRespDealWithNackClose)
// Initialisation et ouverture de la communication IP, envoi d'un message à une carte densité selon le protocol normal ou étendu #1 au choix, réception d'une réponse selon le protocol normal ou étendu #1
// de manière automatique puis fermeture de la communication IP.
// Toutes les opérations pour une communication complète sont ici réunies ensemble.
// Usage : GoSubArg(DENInitOpenSendMsgReceiveRespDealWithNackClose,sChannel,strIPAddr,lIPPort,sSource,sDest,strMessage,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed[,sExtProtocolID]).
//         sDENChannel (V/L) : 				Canal de communication Ethernet (0-15).
//         strDENIPAddr (V/L) : 			Adresse TCP/IP (Format 0.0.0.0 ou @Descripteur).
//         lDENIPPort (V/L) : 				Port Ethernet (5100).
//         sDENSource (V/L) : 				Source de communication (25).
//         sDENDest (V/L) : 				Fente de la carte (1-21).
//         strDENMessage (V/L) : 			Message Densité à envoyer.
//         lDENReadDelay (V/L) : 			Délai avant lecture (msec). Si négatif, ne s'applique qu'avant la première lecture.
//         lDenReadTimeOutDelay (V/L) : 	Délai de timeout (msec).
//         lDenNumReadLoops (V/L) : 		Nombre de boucles de lecture si en timeout.
//         sDenFilterSource (V/L) : 		Filtrage de la source (-1 si pas de filtrage ou numéro de la fente désirée).
//         sDenFilterDest (V/L) : 			Filtrage de la destination (-1 si pas de filtrage ou destination désirée).
//         sDenFilterLength (V/L) : 		Filtrage de la longueur du message (-1 si pas de filtrage ou longueur désirée).
//         sDenFilterByte4, 
//		   sDenFilterByte5 (V/L) : 			Filtrage de la réponse (-1 si pas de filtrage ou octets de réponse désirés).
//         sDENMonFlag (V/L) : 				0 - Pas d'entrée dans le moniteur, 1 - Entrées dans le moniteur.
//         strDENLeadingSpaces (V/L) : 		Espaces en début de lignes dans le moniteur.
//         sDENEndOrAbortIfFailed (V/L) : 	0 - Erreur non traitée,
//                                     		1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     		2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     		3 - Erreur traitée avec avortement de l'exécution.
//         lsExtProtocolID (V/L) (Optionnel) : 0 - Protocol normal.
//                                            1 - Protocol étendu #1 (Axino).
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenInitIP/DenOpenIP/DenSendIP(Ex1)/DenReceiveIP(Ex1)/DenCloseIP" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenInitIP/DenOpenIP/DenSendIP(Ex1)/DenReceiveIP(Ex1)/DenCloseIP ou par la sous-routine (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenInitIP/DenOpenIP/DenSendIP(Ex1)/DenReceiveIP(Ex1)/DenCloseIP ou par la sous-routine ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
//         bDENRespByteArray : Champ d'octets de la réponse de la carte.
//         strDENRespString : Texte de la réponse de la carte.
// Exemple : GoSubArg(DENInitOpenSendMsgReceiveRespDealWithNackClose,sDenChannel,strDenIPAddr,lDenIPPort,sDenSource,sDenDestination,"0012",lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sDenMonFlag,"    ",sDenAbortIfFailed[,0/1]).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.
  LShorts(lsNumSubArgs,lsExtProtocolID)
  LLongs(llLoopIndex)
  LStrings(lstrCOMDetect)
  
  // Lecture des arguments d'entrée et de retour.
  GetSubNumArgs(lsNumSubArgs)
  If(lsNumSubArgs=17)
    GetSubArgs(sDENChannel,strDENIPAddr,lDENIPPort,sDENSource,sDENDest,strDENMessage,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
    Assign(0,lsExtProtocolID)
  ElseIf(lsNumSubArgs=18)
    GetSubArgs(sDENChannel,strDENIPAddr,lDENIPPort,sDENSource,sDENDest,strDENMessage,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed,lsExtProtocolID)
  Else()
    Assign(100,sDENErrorCode,"DENInitOpenSendMsgReceiveRespDealWithNackClose",strDENErrorSource,"Nombre d'arguments incorrect",strDENErrorDesc,"Nombre d'arguments différent de 17 et 18",strDENErrorDetails)
    ExitSub(DENInitOpenSendMsgReceiveRespDealWithNackClose)
  EndIf()

  // Opérations.
  SubString(strDENIPAddr,Left,0,3,lstrCOMDetect)
  If(lstrCOMDetect="COM")
    Assign(1,sDENErrorCode)
  Else()
    GoSubArg(DENInit,sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
  EndIf()
  
  If(sDENErrorCode=0)
    GoSubArg(DENOpen,sDENChannel,strDENIPAddr,lDENIPPort,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
    If(sDENErrorCode=0)
      // Envoi et réception.
      Assign(0,llLoopIndex)
      BeginLoop()
        GoSubArg(DENSendMsg,sDENChannel,sDENSource,sDENDest,strDENMessage,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed,lsExtProtocolID)
        If(sDENErrorCode=0)
          GoSubArg(DENReceiveResp,sDENChannel,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
        EndIf()
        ExitLoopIf(sDENErrorCode!=-10)
        If( sDENErrorCode=-10 )  
          If(bDENRespByteArray[6] = 02)
            ; amt( "Busy" )
          Else()
            Assign( bDENRespByteArray[6], sDENErrorCode)
            Assign(sDENErrorCode,sDENErrorCodeBU,strDENErrorDesc,strDENErrorDescBU,strDENErrorSource,strDENErrorSourceBU,strDENErrorDetails,strDENErrorDetailsBU)
            Addn( "Un NACK autre que BUSY a été recu : ", sDENErrorCode ,strDENErrorDesc)
            ExitLoop()
          EndIf()
        EndIf()
        
        Add(llLoopIndex,1,llLoopIndex)
        ExitLoopIf(llLoopIndex>=lDENNumReadLoops)
        msecSleep(lDENReadTimeOutDelay,1)
      EndLoop()
      If(sDENErrorCode=0)
        GoSubArg(DENClose,sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
      Else()
        Assign(sDENErrorCode,sDENErrorCodeBU,strDENErrorDesc,strDENErrorDescBU,strDENErrorSource,strDENErrorSourceBU,strDENErrorDetails,strDENErrorDetailsBU)
        GoSubArg(DENClose,sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
        Assign(sDENErrorCodeBU,sDENErrorCode,strDENErrorDescBU,strDENErrorDesc,strDENErrorSourceBU,strDENErrorSource,strDENErrorDetailsBU,strDENErrorDetails)
      EndIf()
    Else()
      Assign(sDENErrorCode,sDENErrorCodeBU,strDENErrorDesc,strDENErrorDescBU,strDENErrorSource,strDENErrorSourceBU,strDENErrorDetails,strDENErrorDetailsBU)
      GoSubArg(DENClose,sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
      Assign(sDENErrorCodeBU,sDENErrorCode,strDENErrorDescBU,strDENErrorDesc,strDENErrorSourceBU,strDENErrorSource,strDENErrorDetailsBU,strDENErrorDetails)
    EndIf()
  EndIf()

  // Écriture dans les arguments de retour.

EndSub(DENInitOpenSendMsgReceiveRespDealWithNackClose)


// ---------------------------------------------------------------------------------------------------- //


////////////////////
// DENSendMoreMsg //
////////////////////

BeginSub(DENSendMoreMsg)
// Envoi d'un message en plusieurs parties (avec utilisation du BitMore) à une carte densité.
// ATTENTION : Les données numériques à envoyer avec le message doivent se trouver dans la variable globale bDENRawDataByteArray
//             et la longueur dans l'argument lDataLength.
// Usage : GoSubArg(DENSendMoreMsg,sChannel,sSource,sDest,strMessage,strMessageInitExt,lDataLength,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         sSource (V/L) : Source de communication (25).
//         sDest (V/L) : Fente de la carte (1-21).
//         strMessage (V/L) : Message Densité à envoyer (de type More. Ex.: '0016' pour le MemBlock d'une XVP-3901).
//         strMessageInitExt (V/L) : Extension au message initial à envoyer (Ajouté au message Densité sur le premier envoi seulement. Ex.: '0043' pour le MemBlock d'une XVP-3901).
//         lDataLength (V/L) : Longueur du champ de données (Données contenues dans bDENRawDataByteArray).
//         lDenReadDelay (V/L) : Délai avant lecture (msec).
//         lDenReadTimeOutDelay (V/L) : Délai de timeout (msec).
//         lDenNumReadLoops (V/L) : Nombre de boucles de lecture si en timeout.
//         sDenFilterSource (V/L) : Filtrage de la source (-1 si pas de filtrage ou numéro de la fente désirée).
//         sDenFilterDest (V/L) : Filtrage de la destination (-1 si pas de filtrage ou destination désirée).
//         sDenFilterLength (V/L) : Filtrage de la longueur du message (-1 si pas de filtrage ou longueur désirée).
//         sDenFilterByte4, sDenFilterByte5 (V/L) : Filtrage de la réponse (-1 si pas de filtrage ou octets de réponse désirés).
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 - Entrées dans le moniteur.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenSendIP/DenReceiveIP" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenSendIP/DenReceiveIP (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenSendIP/DenReceiveIP ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
// Exemple : GoSubArg(DENSendMoreMsg,sDenChannel1,sDenSource,sDenDestination,"0016","0043",lDataLength,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sDenMonFlag,"    ",sDenAbortIfFailed).

  // Constantes opérationnelles locales.

  // Arguments.
  LStrings(lstrMessageInitExt)

  // Variables locales.
  LStrings(lstrDataString,lstrSubCmdString,lstrFullCmdString)
  LBytes(bDenBitMoreFlag)
  LLongs(llDataArrayPointer,llDataArrayLength,llDataArraySubLength,llMessageInitExtLength,llMessageInitLength,llMessageChunkLength)

  // Lecture des arguments d'entrée et de retour.
  GetSubArgs(sDENChannel,sDENSource,sDENDest,strDENMessage,lstrMessageInitExt,lDENMoreArraySize,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)

  // Envoi du message en plusieurs parties (Bit More) à une carte densité.
  Assign(0,llDataArrayPointer,lDENMoreArraySize,llDataArrayLength)
  If(lstrMessageInitExt="")
    Assign(0,llMessageInitExtLength,57,llMessageInitLength)
  Else()
    StringLength(lstrMessageInitExt,llMessageInitExtLength)
    Div(llMessageInitExtLength,2,llMessageInitExtLength)
    Assign(55,llMessageInitLength)
  EndIf()
  BeginLoop()
    If(llDataArrayPointer=0):::Assign(llMessageInitLength,llMessageChunkLength):::Else():::Assign(57,llMessageChunkLength):::EndIf()
    If(llDataArrayLength>llMessageChunkLength):::Assign(llMessageChunkLength,llDataArraySubLength,1,bDenBitMoreFlag):::Else():::Assign(llDataArrayLength,llDataArraySubLength,0,bDenBitMoreFlag):::EndIf()
    CommTools(ByteArrayToHexString,bDENRawDataByteArray,llDataArrayPointer,llDataArraySubLength,lstrDataString)
    If(llDataArrayPointer=0):::Addn(strDENMessage,lstrMessageInitExt,lstrDataString,lstrSubCmdString):::Else():::Add(strDENMessage,lstrDataString,lstrSubCmdString):::EndIf()
    CommTools(DenBuildCmdArrayAndString,sDENSource,sDENDest,lstrSubCmdString,bDENMsgByteArray,0,lDENMsgLength,strDENFullMessage,bDenBitMoreFlag)
    CommTools(DenSendIP,sDENChannel,bDENMsgByteArray,lDENMsgLength,sDENErrorCode,strDENErrorDesc)
    If(sDENErrorCode=0)
      If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Envoi d'un message en plusieurs parties (Bit More/Offset : ",llDataArrayPointer,") à une carte densité sur le canal <",sDENChannel,">, Source <",sDENSource,">, Destination <",sDENDest,">, Message <",strDENMessage,">, Séquence <",strDENFullMessage,">...Succès - %s/%s"):::EndIf()
      Assign("",strDENErrorSource,"",strDENErrorDesc,"",strDENErrorDetails)
      GoSubArg(DENReceiveResp,sDENChannel,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
    Else()
      If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Envoi d'un message en plusieurs parties (Bit More) à une carte densité sur le canal <",sDENChannel,">, Source <",sDENSource,">, Destination <",sDENDest,">, Message <",strDENMessage,">, Séquence <",strDENFullMessage,">...Échec - %s/%s"):::EndIf()
      Assign("CommTools - DenSendIP",strDENErrorSource)
      IfMC("OR",sDENEndOrAbortIfFailed=1,sDENEndOrAbortIfFailed=2,sDENEndOrAbortIfFailed=3)
        Addn("ATTENTION !",kstrCRLF,kstrCRLF,/+
             "Erreur lors de l'envoi d'un message à une cartes Densité",kstrCRLF,kstrCRLF,/+
             "  Source de l'erreur : <",strDENErrorSource,">",kstrCRLF,/+
             "  Code d'erreur : <",sDENErrorCode,">",kstrCRLF,/+
             "  Description de l'erreur : <",strDENErrorDesc,">",strDENErrorMsg)
        Assign("",strDENErrorDetails)
        MsgBoxOK(strDENErrorMsg,kstrAttnDlgTitle,800,250,14)
        If(sDENEndOrAbortIfFailed=1):::GoSub(MTComplete):::ElseIf(sDENEndOrAbortIfFailed=2):::GoSub(MTEnd):::ElseIf(sDENEndOrAbortIfFailed=3):::GoSub(MTAbort):::EndIf()
      EndIf()
    EndIf()
    ExitLoopIf(sDENErrorCode!=0)
    Sub(llDataArrayLength,llDataArraySubLength,llDataArrayLength)
    ExitLoopIf(llDataArrayLength<=0)
    Add(llDataArrayPointer,llDataArraySubLength,llDataArrayPointer)
  EndLoop()

  // Écriture dans les arguments de retour.

EndSub(DENSendMoreMsg)


// ---------------------------------------------------------------------------------------------------- //


///////////////////////
// DENSendMoreMsgEx1 //
///////////////////////

BeginSub(DENSendMoreMsgEx1)
// Envoi d'un message en plusieurs parties (avec utilisation du BitMore) à une carte densité.
// ATTENTION : Les données numériques à envoyer avec le message doivent se trouver dans la variable globale bDENRawDataByteArray
//             et la longueur dans l'argument lDataLength.
// Usage : GoSubArg(DENSendMoreMsgEx1,sChannel,sSource,sDest,strMessage,strMessageInitExt,lDataLength,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,lDenMaxNumNACK,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         sSource (V/L) : Source de communication (25).
//         sDest (V/L) : Fente de la carte (1-21).
//         strMessage (V/L) : Message Densité à envoyer (de type More. Ex.: '0016' pour le MemBlock d'une XVP-3901).
//         strMessageInitExt (V/L) : Extension au message initial à envoyer (Ajouté au message Densité sur le premier envoi seulement. Ex.: '0043' pour le MemBlock d'une XVP-3901).
//         lDataLength (V/L) : Longueur du champ de données (Données contenues dans bDENRawDataByteArray).
//         lDenReadDelay (V/L) : Délai avant lecture (msec).
//         lDenReadTimeOutDelay (V/L) : Délai de timeout (msec).
//         lDenNumReadLoops (V/L) : Nombre de boucles de lecture si en timeout.
//         lDenMaxNumNACK (V/L) : Nombre maximum permis de NACK reçus de la carte après une tranmission.
//                                Note : Après chaque NACK, les données sont renvoyées encore une fois, jusqu'à concurrence de lDenMaxNumNACK fois.
//         sDenFilterSource (V/L) : Filtrage de la source (-1 si pas de filtrage ou numéro de la fente désirée).
//         sDenFilterDest (V/L) : Filtrage de la destination (-1 si pas de filtrage ou destination désirée).
//         sDenFilterLength (V/L) : Filtrage de la longueur du message (-1 si pas de filtrage ou longueur désirée).
//         sDenFilterByte4, sDenFilterByte5 (V/L) : Filtrage de la réponse (-1 si pas de filtrage ou octets de réponse désirés).
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 - Entrées dans le moniteur.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenSendIP/DenReceiveIP" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenSendIP/DenReceiveIP (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenSendIP/DenReceiveIP ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
// Exemple : GoSubArg(DENSendMoreMsg,sDenChannel1,sDenSource,sDenDestination,"0016","0043",lDataLength,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sDenMonFlag,"    ",sDenAbortIfFailed).

  // Constantes opérationnelles locales.

  // Arguments.
  LStrings(lstrMessageInitExt)

  // Variables locales.
  LStrings(lstrDataString,lstrSubCmdString,lstrFullCmdString)
  LBytes(bDenBitMoreFlag)
  LLongs(llDataArrayPointer,llDataArrayLength,llDataArraySubLength,llMessageInitExtLength,llMessageInitLength,llMessageChunkLength,llDenMaxNumNACK,llNACKCount)

  // Lecture des arguments d'entrée et de retour.
  GetSubArgs(sDENChannel,sDENSource,sDENDest,strDENMessage,lstrMessageInitExt,lDENMoreArraySize,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,llDenMaxNumNACK,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)

  // Envoi du message en plusieurs parties (Bit More) à une carte densité.
  Assign(0,llDataArrayPointer,lDENMoreArraySize,llDataArrayLength)
  If(lstrMessageInitExt="")
    Assign(0,llMessageInitExtLength,57,llMessageInitLength)
  Else()
    StringLength(lstrMessageInitExt,llMessageInitExtLength)
    Div(llMessageInitExtLength,2,llMessageInitExtLength)
    Assign(55,llMessageInitLength)
  EndIf()
  Assign(0,llNACKCount)
  BeginLoop()
    If(llDataArrayPointer=0):::Assign(llMessageInitLength,llMessageChunkLength):::Else():::Assign(57,llMessageChunkLength):::EndIf()
    If(llDataArrayLength>llMessageChunkLength):::Assign(llMessageChunkLength,llDataArraySubLength,1,bDenBitMoreFlag):::Else():::Assign(llDataArrayLength,llDataArraySubLength,0,bDenBitMoreFlag):::EndIf()
    CommTools(ByteArrayToHexString,bDENRawDataByteArray,llDataArrayPointer,llDataArraySubLength,lstrDataString)
    If(llDataArrayPointer=0):::Addn(strDENMessage,lstrMessageInitExt,lstrDataString,lstrSubCmdString):::Else():::Add(strDENMessage,lstrDataString,lstrSubCmdString):::EndIf()
    CommTools(DenBuildCmdArrayAndString,sDENSource,sDENDest,lstrSubCmdString,bDENMsgByteArray,0,lDENMsgLength,strDENFullMessage,bDenBitMoreFlag)
    CommTools(DenSendIP,sDENChannel,bDENMsgByteArray,lDENMsgLength,sDENErrorCode,strDENErrorDesc)
    If(sDENErrorCode=0)
      If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Envoi d'un message en plusieurs parties (Bit More/Offset : ",llDataArrayPointer,") à une carte densité sur le canal <",sDENChannel,">, Source <",sDENSource,">, Destination <",sDENDest,">, Message <",strDENMessage,">, Séquence <",strDENFullMessage,">...Succès - %s/%s"):::EndIf()
      Assign("",strDENErrorSource,"",strDENErrorDesc,"",strDENErrorDetails)
      GoSubArg(DENReceiveResp,sDENChannel,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
      Ifn(sDENErrorCode!=0,bDENRespByteArray[4]=0,AND,bDENRespByteArray[5]=1,AND):::Assign(-100,sDENErrorCode):::Incr(llNACKCount):::EndIf()
    Else()
      If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Envoi d'un message en plusieurs parties (Bit More) à une carte densité sur le canal <",sDENChannel,">, Source <",sDENSource,">, Destination <",sDENDest,">, Message <",strDENMessage,">, Séquence <",strDENFullMessage,">...Échec - %s/%s"):::EndIf()
      Assign("CommTools - DenSendIP",strDENErrorSource)
      IfMC("OR",sDENEndOrAbortIfFailed=1,sDENEndOrAbortIfFailed=2,sDENEndOrAbortIfFailed=3)
        Addn("ATTENTION !",kstrCRLF,kstrCRLF,/+
             "Erreur lors de l'envoi d'un message à une cartes Densité",kstrCRLF,kstrCRLF,/+
             "  Source de l'erreur : <",strDENErrorSource,">",kstrCRLF,/+
             "  Code d'erreur : <",sDENErrorCode,">",kstrCRLF,/+
             "  Description de l'erreur : <",strDENErrorDesc,">",strDENErrorMsg)
        Assign("",strDENErrorDetails)
        MsgBoxOK(strDENErrorMsg,kstrAttnDlgTitle,800,250,14)
        If(sDENEndOrAbortIfFailed=1):::GoSub(MTComplete):::ElseIf(sDENEndOrAbortIfFailed=2):::GoSub(MTEnd):::ElseIf(sDENEndOrAbortIfFailed=3):::GoSub(MTAbort):::EndIf()
      EndIf()
    EndIf()
    If(sDENErrorCode!=-100)
      ExitLoopIf(sDENErrorCode!=0)
      Sub(llDataArrayLength,llDataArraySubLength,llDataArrayLength)
      ExitLoopIf(llDataArrayLength<=0)
      Add(llDataArrayPointer,llDataArraySubLength,llDataArrayPointer)
      Assign(0,llNACKCount)
    Else()
      ExitLoopIf(llNACKCount>=llDenMaxNumNACK)
    EndIf()
  EndLoop()

  // Écriture dans les arguments de retour.

EndSub(DENSendMoreMsgEx1)


// ---------------------------------------------------------------------------------------------------- //


////////////////////////
// DENReceiveMoreResp //
////////////////////////

BeginSub(DENReceiveMoreResp)
// Réception d'une réponse en plusieurs parties (Bit More) suite à l'envoi d'un message à une carte densité. le protocol étendu #1 est pris en charge automatiquement si nécessaire
// La réponse complète est retourné dans bDENRawDataByteArray et la longueur dans lDENMoreArraySize.
// Usage : GoSubArg(DENReceiveMoreResp,sChannel,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         lDenReadDelay (V/L) : Délai avant lecture (msec). Si négatif, ne s'applique qu'avant la première lecture.
//         lDenReadTimeOutDelay (V/L) : Délai de timeout (msec).
//         lDenNumReadLoops (V/L) : Nombre de boucles de lecture si en timeout.
//         sDenFilterSource (V/L) : Filtrage de la source (-1 si pas de filtrage ou numéro de la fente désirée).
//         sDenFilterDest (V/L) : Filtrage de la destination (-1 si pas de filtrage ou destination désirée).
//         sDenFilterLength (V/L) : Filtrage de la longueur du message (-1 si pas de filtrage ou longueur désirée).
//         sDenFilterByte4, sDenFilterByte5 (V/L) : Filtrage de la réponse (-1 si pas de filtrage ou octets de réponse désirés).
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 - Entrées dans le moniteur.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenReceiveIP" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenReceiveIP ou par la sous-routine (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenReceiveIP ou par la sous-routine ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
//         bDENRespByteArray : Champ d'octets de la dernière partie de réponse reçue de la carte.
//         strDENRespString : Texte de la dernière partie de réponse reçue de la carte.
//         bDENRawDataByteArray : Données d'intérêt reçues de la carte.
//         lDENMoreArraySize : Nombre d'octets de données d'intérêt reçues de la carte.
// Exemple : GoSubArg(DENReceiveMoreResp,sDenChannel1,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sDenMonFlag,"    ",sDenAbortIfFailed).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.
  LBytes(lbBitMore)
  LLongs(llRespDataArrayLength,llRespDataArrayPointer)

  // Lecture des arguments d'entrée et de retour.
  GetSubArgs(sDENChannel,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)

  // Réception d'une réponse suite à l'envoi d'un message à une carte densité.
  Assign(0,llRespDataArrayPointer)
  BeginLoop()
    GoSubArg(DENReceiveResp,sDENChannel,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
    If(sDENErrorCode=0)
      BWAnd(bDENRespByteArray[3],63,llRespDataArrayLength)
      Sub(llRespDataArrayLength,2,llRespDataArrayLength)
      CopyArray(bDENRespByteArray,6,bDENRawDataByteArray,llRespDataArrayPointer,llRespDataArrayLength)
      Add(llRespDataArrayPointer,llRespDataArrayLength,llRespDataArrayPointer)
      BWAnd(bDENRespByteArray[3],64,lbBitMore)
    EndIf()
    Assign(llRespDataArrayPointer,lDENMoreArraySize)
    ExitLoopIf(sDENErrorCode!=0)
    ExitLoopIf(lbBitMore=0)
  EndLoop()

  // Écriture dans les arguments de retour.

EndSub(DENReceiveMoreResp)


// ---------------------------------------------------------------------------------------------------- //


////////////////////
// DENSendRawData //
////////////////////

BeginSub(DENSendRawData)
// Envoi de données RAW à une carte densité.
// Les données doivent être formattées au complet préalablement et placées dans bDENRawDataByteArray.
// Format : 2, Destination, Source, 4, 0, 2, 43, Length (MSB), Length (LSB), --- Data ---, Type, Sequence.
// Usage : GoSubArg(DENSendRawData,sChannel,lRawDataLength,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         lRawDataLength (V/L) : Nombre d'octets (formattés) à envoyer.
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 - Entrées dans le moniteur.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
// Retours : strDENErrorSource, sDENErrorCode, strDENErrorDesc.
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenSendRawIP" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenSendRawIP (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenSendRawIP ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
// Exemple : GoSubArg(DENSendRawData,sDenChannel1,550,sDenMonFlag,"    ",sDenAbortIfFailed).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.

  // Lecture des arguments d'entrée et de retour.
  GetSubArgs(sDENChannel,lDENRawDataLength,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)

  // Envoi des données à une carte densité.
  CommTools(DenSendRawIP,sDENChannel,bDENRawDataByteArray,lDENRawDataLength,sDENErrorCode,strDENErrorDesc)

  // Traitement d'une erreur.
  If(sDENErrorCode=0)
    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Envoi de données RAW à une carte densité sur le canal <",sDENChannel,">...Succès - %s/%s"):::EndIf()
    Assign("",strDENErrorSource,"",strDENErrorDesc,"",strDENErrorDetails)
  Else()
    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Envoi de données RAW à une carte densité sur le canal <",sDENChannel,">...Échec - %s/%s"):::EndIf()
    Assign("CommTools - DenSendRawIP",strDENErrorSource)
    IfMC("OR",sDENEndOrAbortIfFailed=1,sDENEndOrAbortIfFailed=2,sDENEndOrAbortIfFailed=3)
      Addn("ATTENTION !",kstrCRLF,kstrCRLF,/+
           "Erreur lors de l'envoi de données RAW à une cartes Densité",kstrCRLF,kstrCRLF,/+
           "  Source de l'erreur : <",strDENErrorSource,">",kstrCRLF,/+
           "  Code d'erreur : <",sDENErrorCode,">",kstrCRLF,/+
           "  Description de l'erreur : <",strDENErrorDesc,">",strDENErrorMsg)
      Assign("",strDENErrorDetails)
      MsgBoxOK(strDENErrorMsg,kstrAttnDlgTitle,800,250,14)
      If(sDENEndOrAbortIfFailed=1):::GoSub(MTComplete):::ElseIf(sDENEndOrAbortIfFailed=2):::GoSub(MTEnd):::ElseIf(sDENEndOrAbortIfFailed=3):::GoSub(MTAbort):::EndIf()
    EndIf()
  EndIf()

  // Écriture dans les arguments de retour.

EndSub(DENSendRawData)


// ---------------------------------------------------------------------------------------------------- //


///////////////////////
// DENReceiveRawData //
///////////////////////

BeginSub(DENReceiveRawData)
// Réception de données de message standard ou RAW suite à l'envoi d'un message à une carte densité.
// Usage : GoSubArg(DENReceiveRawData,sChannel,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sDenFilterType,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         lDenReadDelay (V/L) : Délai avant lecture (msec). Si négatif, ne s'applique qu'avant la première lecture.
//         lDenReadTimeOutDelay (V/L) : Délai de timeout (msec).
//         lDenNumReadLoops (V/L) : Nombre de boucles de lecture si en timeout.
//         sDenFilterSource (V/L) : Filtrage de la source (-1 si pas de filtrage ou numéro de la fente désirée).
//         sDenFilterDest (V/L) : Filtrage de la destination (-1 si pas de filtrage ou destination désirée).
//         sDenFilterLength (V/L) : Filtrage de la longueur du message (-1 si pas de filtrage ou longueur désirée).
//         sDenFilterByte4, sDenFilterByte5 (V/L) : Filtrage de la réponse (-1 si pas de filtrage ou octets de réponse désirés).
//         sDenFilterType (V/L) : Filtrage du type de réponse (-1 si pas de filtrage, 1 (Normale), 2 (RAW)).
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 ou 2 - Entrées dans le moniteur.
//                          Note : 1 pour les données d'entête reçues seulement, 2 pour toutes les données RAW reçues.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenReceiveRawIP" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenReceiveRawIP ou par la sous-routine (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenReceiveRawIP ou par la sous-routine ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
//         bDENRespByteArray : Champ d'octets de la réponse de la carte (Standard ou RAW).
//         strDENRespString : Texte de la réponse de la carte.
//         lDENRawDataLength : Nombre d'octets de données standard ou RAW reçues de la carte.
// Exemple : GoSubArg(DENReceiveRawData,sDenChannel1,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sDenFilterType,sDenMonFlag,"    ",sDenAbortIfFailed).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.
  LShorts(lsOKFlag)
  LLongs(llLoopIndex,lReadDelayAbs)

  // Lecture des arguments d'entrée et de retour.
  GetSubArgs(sDENChannel,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENFilterType,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)

  // Réception de données RAW suite à l'envoi d'un message à une carte densité.
  Abs(lDENReadDelay,lReadDelayAbs)
  If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Réception de données RAW sur le canal <",sDENChannel,">...Début - %s/%s"):::EndIf()
  Assign(0,llLoopIndex,0,lsOKFlag)
  If(lDENReadDelay<0):::msecSleep(lReadDelayAbs,1):::EndIf()
  BeginLoop()
    If(lDENReadDelay>0):::msecSleep(lDENReadDelay,1):::EndIf()
    CommTools(DenReceiveRawIP,sDENChannel,lDENReadTimeOutDelay,bDENRawDataByteArray,lDENRawDataLength,sDENErrorCode,strDENErrorDesc,sDENRespType)
    If(sDENErrorCode=0)
      Assign("",strDENErrorSource,"",strDENErrorDesc,"",strDENErrorDetails)
      Ifn(sDENRespType=1,sDENFilterType=1,"AND",sDENRespType=1,sDENFilterType=0,"AND","OR")
        CommTools(ByteArrayToHexString,bDENRawDataByteArray,0,lDENRawDataLength,strDENRespString)
        If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"  Données reçues : <",strDENRespString,"> (",llLoopIndex," boucle(s))"," - %s/%s"):::EndIf()
        Assign(1,lsOKFlag)
        If(bDENRawDataByteArray[0]!=2)
          Assign(0,lsOKFlag,-2,sDENErrorCode)
          Addn("STX absent (",bDENRawDataByteArray[0],"/2)",strDENErrorDetails)
        Else()
          IfMC("AND",lsOKFlag=1,sDENFilterSource!=-1,sDENFilterSource!=bDENRawDataByteArray[2])
            Assign(0,lsOKFlag,-3,sDENErrorCode)
            Addn("Mauvaise source (",bDENRawDataByteArray[2],"/",sDENFilterSource,")",strDENErrorDetails)
          Else()
            IfMC("AND",lsOKFlag=1,sDENFilterDest!=-1,sDENFilterDest!=bDENRawDataByteArray[1])
              Assign(0,lsOKFlag,-4,sDENErrorCode)
              Addn("Mauvaise destination (",bDENRawDataByteArray[1],"/",sDENFilterDest,")",strDENErrorDetails)
            Else()
              IfMC("AND",lsOKFlag=1,sDENFilterLength!=-1,sDENFilterLength!=bDENRawDataByteArray[3])
                Assign(0,lsOKFlag,-5,sDENErrorCode)
                Addn("Mauvaise longueur (",bDENRawDataByteArray[3],"/",sDENFilterLength,")",strDENErrorDetails)
              Else()
                IfMC("AND",lsOKFlag=1,sDENFilterByte4!=-1,sDENFilterByte4!=bDENRawDataByteArray[4])
                  Assign(0,lsOKFlag,-5,sDENErrorCode)
                  Addn("Mauvais octet #4 (",bDENRawDataByteArray[4],"/",sDENFilterByte4,")",strDENErrorDetails)
                Else()
                  IfMC("AND",lsOKFlag=1,sDENFilterByte5!=-1,sDENFilterByte5!=bDENRawDataByteArray[5])
                    Assign(0,lsOKFlag,-6,sDENErrorCode)
                    Addn("Mauvais octet #5 (",bDENRawDataByteArray[5],"/",sDENFilterByte5,")",strDENErrorDetails)
                  EndIf()
                EndIf()
              EndIf()
            EndIf()
          EndIf()
        EndIf()
      ElseIfn(sDENRespType=2,sDENFilterType=2,"AND",sDENRespType=2,sDENFilterType=0,"AND","OR")
        If(sDENMonFlag=1)
          CommTools(ByteArrayToHexString,bDENRawDataByteArray,0,8,strDENRespString)
          AddnMonitorDateTime(strDENLeadingSpaces,"  Données d'entête RAW reçues : <",strDENRespString,"> (",llLoopIndex," boucle(s))"," - %s/%s")
        ElseIf(sDENMonFlag=2)
          CommTools(ByteArrayToHexString,bDENRawDataByteArray,0,lDENRawDataLength,strDENRespString)
          AddnMonitorDateTime(strDENLeadingSpaces,"  Données RAW reçues : <",strDENRespString,"> (",llLoopIndex," boucle(s))"," - %s/%s")
        EndIf()
        Assign(1,lsOKFlag)
        If(bDENRawDataByteArray[0]!=2)
          Assign(0,lsOKFlag,-2,sDENErrorCode)
          Addn("STX absent (",bDENRawDataByteArray[0],"/2)",strDENErrorDetails)
        Else()
          IfMC("AND",lsOKFlag=1,sDENFilterSource!=-1,sDENFilterSource!=bDENRawDataByteArray[2])
            Assign(0,lsOKFlag,-3,sDENErrorCode)
            Addn("Mauvaise source (",bDENRawDataByteArray[2],"/",sDENFilterSource,")",strDENErrorDetails)
          Else()
            IfMC("AND",lsOKFlag=1,sDENFilterDest!=-1,sDENFilterDest!=bDENRawDataByteArray[1])
              Assign(0,lsOKFlag,-4,sDENErrorCode)
              Addn("Mauvaise destination (",bDENRawDataByteArray[1],"/",sDENFilterDest,")",strDENErrorDetails)
            Else()
              IfMC("AND",lsOKFlag=1,sDENFilterLength!=-1,sDENFilterLength!=bDENRawDataByteArray[3])
                Assign(0,lsOKFlag,-5,sDENErrorCode)
                Addn("Mauvaise longueur (",bDENRawDataByteArray[3],"/",sDENFilterLength,")",strDENErrorDetails)
              Else()
                IfMC("AND",lsOKFlag=1,sDENFilterByte4!=-1,sDENFilterByte4!=bDENRawDataByteArray[4])
                  Assign(0,lsOKFlag,-5,sDENErrorCode)
                  Addn("Mauvais octet #4 (",bDENRawDataByteArray[4],"/",sDENFilterByte4,")",strDENErrorDetails)
                Else()
                  IfMC("AND",lsOKFlag=1,sDENFilterByte5!=-1,sDENFilterByte5!=bDENRawDataByteArray[5])
                    Assign(0,lsOKFlag,-6,sDENErrorCode)
                    Addn("Mauvais octet #5 (",bDENRawDataByteArray[5],"/",sDENFilterByte5,")",strDENErrorDetails)
                  EndIf()
                EndIf()
              EndIf()
            EndIf()
          EndIf()
        EndIf()
      Else()
        CommTools(ByteArrayToHexString,bDENRawDataByteArray,0,lDENRawDataLength,strDENRespString)
        If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"  Données reçues (Non conformes) : <",strDENRespString,"> (",llLoopIndex," boucle(s))"," - %s/%s"):::EndIf()
      EndIf()
      ExitLoopIf(lsOKFlag=1)
    ElseIf(sDENErrorCode!=-1)
      Assign(-1,llLoopIndex)
      ExitLoop()
    EndIf()
    Add(llLoopIndex,1,llLoopIndex)
    ExitLoopIf(llLoopIndex>=lDENNumReadLoops)
  EndLoop()
  IfMC("OR",llLoopIndex=-1,llLoopIndex>=lDENNumReadLoops)
    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"  >>> Réception de données RAW sur le canal <",sDENChannel,">...Échec - %s/%s"):::EndIf()
    Assign("CommTools - DenReceiveRawIP",strDENErrorSource)
    If(llLoopIndex>=lDENNumReadLoops)
      Assign(-1,sDENErrorCode,"Temps alloué de réception écoulé",strDENErrorDesc)
    EndIf()
    IfMC("OR",sDENEndOrAbortIfFailed=1,sDENEndOrAbortIfFailed=2,sDENEndOrAbortIfFailed=3)
      Addn("ATTENTION !",kstrCRLF,kstrCRLF,/+
           "Erreur lors de la réception de données RAW d'une carte Densité",kstrCRLF,kstrCRLF,/+
           "  Source de l'erreur : <",strDENErrorSource,">",kstrCRLF,/+
           "  Code d'erreur : <",sDENErrorCode,">",kstrCRLF,/+
           "  Description de l'erreur : <",strDENErrorDesc,">",strDENErrorMsg)
      MsgBoxOK(strDENErrorMsg,kstrAttnDlgTitle,800,250,14)
      If(sDENEndOrAbortIfFailed=1):::GoSub(MTComplete):::ElseIf(sDENEndOrAbortIfFailed=2):::GoSub(MTEnd):::ElseIf(sDENEndOrAbortIfFailed=3):::GoSub(MTAbort):::EndIf()
    EndIf()
  EndIf()
  If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Réception de données RAW sur le canal <",sDENChannel,">...Fin - %s/%s"):::EndIf()

  // Écriture dans les arguments de retour.

EndSub(DENReceiveRawData)


// ---------------------------------------------------------------------------------------------------- //


///////////////////////////////
// DENReceiveRawDataStreamed //
///////////////////////////////

BeginSub(DENReceiveRawDataStreamed)
// Réception de données de message standard ou RAW suite à l'envoi d'un message à une carte densité.
// Contrairement à DENReceiveRawData, DENReceiveRawDataStreamed peut recevoir des données partielles.
// Contrairement à DENReceiveRawData, DENReceiveRawDataStreamed ne retire pas l'octet #8 de la réponse.
// Usage : GoSubArg(DENReceiveRawDataStreamed,sChannel,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sDenFilterType,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         lDenReadDelay (V/L) : Délai avant lecture (msec). Si négatif, ne s'applique qu'avant la première lecture.
//         lDenReadTimeOutDelay (V/L) : Délai de timeout (msec).
//         lDenNumReadLoops (V/L) : Nombre de boucles de lecture si en timeout.
//         sDenFilterSource (V/L) : Filtrage de la source (-1 si pas de filtrage ou numéro de la fente désirée).
//         sDenFilterDest (V/L) : Filtrage de la destination (-1 si pas de filtrage ou destination désirée).
//         sDenFilterLength (V/L) : Filtrage de la longueur du message (-1 si pas de filtrage ou longueur désirée).
//         sDenFilterByte4, sDenFilterByte5 (V/L) : Filtrage de la réponse (-1 si pas de filtrage ou octets de réponse désirés).
//         sDenFilterType (V/L) : Filtrage du type de réponse (-1 si pas de filtrage, 1 (Normale), 2 (RAW)).
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 ou 2 - Entrées dans le moniteur.
//                          Note : 1 pour les données d'entête reçues seulement, 2 pour toutes les données RAW reçues.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur,"CommTools - DenReceiveRawIPStreamed" si erreur présente).
//         sDENErrorCode : Code d'erreur retourné par CommTools-DenReceiveRawIPStreamed ou par la sous-routine (0 si pas d'erreur).
//         strDENErrorDesc: Description de l'erreur retournée par CommTools-DenReceiveRawIPStreamed ou par la sous-routine ("" si pas d'erreur).
//         strDENErrorDetails: Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
//         bDENRespByteArray : Champ d'octets de la réponse de la carte (Standard ou RAW).
//         strDENRespString : Texte de la réponse de la carte.
//         lDENRawDataLength : Nombre d'octets de données standard ou RAW reçues de la carte.
// Exemple : GoSubArg(DENReceiveRawDataStreamed,sDenChannel1,lDenReadDelay,lDenReadTimeOutDelay,lDenNumReadLoops,sDenFilterSource,sDenFilterDest,sDenFilterLength,sDenFilterByte4,sDenFilterByte5,sDenFilterType,sDenMonFlag,"    ",sDenAbortIfFailed).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.
  LShorts(lsOKFlag)
  LLongs(llLoopIndex,lReadDelayAbs)

  // Lecture des arguments d'entrée et de retour.
  GetSubArgs(sDENChannel,lDENReadDelay,lDENReadTimeOutDelay,lDENNumReadLoops,sDENFilterSource,sDENFilterDest,sDENFilterLength,sDENFilterByte4,sDENFilterByte5,sDENFilterType,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)

  // Réception de données RAW suite à l'envoi d'un message à une carte densité.
  Abs(lDENReadDelay,lReadDelayAbs)
  If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Réception de données RAW sur le canal <",sDENChannel,">...Début - %s/%s"):::EndIf()
  Assign(0,llLoopIndex,0,lsOKFlag)
  If(lDENReadDelay<0):::msecSleep(lReadDelayAbs,1):::EndIf()
  BeginLoop()
    If(lDENReadDelay>0):::msecSleep(lDENReadDelay,1):::EndIf()
    CommTools(DenReceiveRawIPStreamed,sDENChannel,lDENReadTimeOutDelay,bDENRawDataByteArray,lDENRawDataLength,sDENErrorCode,strDENErrorDesc,sDENRespType)
    If(sDENErrorCode=0)
      Assign("",strDENErrorSource,"",strDENErrorDesc,"",strDENErrorDetails)
      Ifn(sDENRespType=1,sDENFilterType=1,"AND",sDENRespType=1,sDENFilterType=0,"AND","OR")
        CommTools(ByteArrayToHexString,bDENRawDataByteArray,0,lDENRawDataLength,strDENRespString)
        If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"  Données reçues : <",strDENRespString,"> (",llLoopIndex," boucle(s))"," - %s/%s"):::EndIf()
        Assign(1,lsOKFlag)
        If(bDENRawDataByteArray[0]!=2)
          Assign(0,lsOKFlag,-2,sDENErrorCode)
          Addn("STX absent (",bDENRawDataByteArray[0],"/2)",strDENErrorDetails)
        Else()
          IfMC("AND",lsOKFlag=1,sDENFilterSource!=-1,sDENFilterSource!=bDENRawDataByteArray[2])
            Assign(0,lsOKFlag,-3,sDENErrorCode)
            Addn("Mauvaise source (",bDENRawDataByteArray[2],"/",sDENFilterSource,")",strDENErrorDetails)
          Else()
            IfMC("AND",lsOKFlag=1,sDENFilterDest!=-1,sDENFilterDest!=bDENRawDataByteArray[1])
              Assign(0,lsOKFlag,-4,sDENErrorCode)
              Addn("Mauvaise destination (",bDENRawDataByteArray[1],"/",sDENFilterDest,")",strDENErrorDetails)
            Else()
              IfMC("AND",lsOKFlag=1,sDENFilterLength!=-1,sDENFilterLength!=bDENRawDataByteArray[3])
                Assign(0,lsOKFlag,-5,sDENErrorCode)
                Addn("Mauvaise longueur (",bDENRawDataByteArray[3],"/",sDENFilterLength,")",strDENErrorDetails)
              Else()
                IfMC("AND",lsOKFlag=1,sDENFilterByte4!=-1,sDENFilterByte4!=bDENRawDataByteArray[4])
                  Assign(0,lsOKFlag,-5,sDENErrorCode)
                  Addn("Mauvais octet #4 (",bDENRawDataByteArray[4],"/",sDENFilterByte4,")",strDENErrorDetails)
                Else()
                  IfMC("AND",lsOKFlag=1,sDENFilterByte5!=-1,sDENFilterByte5!=bDENRawDataByteArray[5])
                    Assign(0,lsOKFlag,-6,sDENErrorCode)
                    Addn("Mauvais octet #5 (",bDENRawDataByteArray[5],"/",sDENFilterByte5,")",strDENErrorDetails)
                  EndIf()
                EndIf()
              EndIf()
            EndIf()
          EndIf()
        EndIf()
      ElseIfn(sDENRespType=2,sDENFilterType=2,"AND",sDENRespType=2,sDENFilterType=0,"AND","OR")
        If(sDENMonFlag=1)
          CommTools(ByteArrayToHexString,bDENRawDataByteArray,0,8,strDENRespString)
          AddnMonitorDateTime(strDENLeadingSpaces,"  Données d'entête RAW reçues : <",strDENRespString,"> (",llLoopIndex," boucle(s))"," - %s/%s")
        ElseIf(sDENMonFlag=2)
          CommTools(ByteArrayToHexString,bDENRawDataByteArray,0,lDENRawDataLength,strDENRespString)
          AddnMonitorDateTime(strDENLeadingSpaces,"  Données RAW reçues : <",strDENRespString,"> (",llLoopIndex," boucle(s))"," - %s/%s")
        EndIf()
        Assign(1,lsOKFlag)
        If(bDENRawDataByteArray[0]!=2)
          Assign(0,lsOKFlag,-2,sDENErrorCode)
          Addn("STX absent (",bDENRawDataByteArray[0],"/2)",strDENErrorDetails)
        Else()
          IfMC("AND",lsOKFlag=1,sDENFilterSource!=-1,sDENFilterSource!=bDENRawDataByteArray[2])
            Assign(0,lsOKFlag,-3,sDENErrorCode)
            Addn("Mauvaise source (",bDENRawDataByteArray[2],"/",sDENFilterSource,")",strDENErrorDetails)
          Else()
            IfMC("AND",lsOKFlag=1,sDENFilterDest!=-1,sDENFilterDest!=bDENRawDataByteArray[1])
              Assign(0,lsOKFlag,-4,sDENErrorCode)
              Addn("Mauvaise destination (",bDENRawDataByteArray[1],"/",sDENFilterDest,")",strDENErrorDetails)
            Else()
              IfMC("AND",lsOKFlag=1,sDENFilterLength!=-1,sDENFilterLength!=bDENRawDataByteArray[3])
                Assign(0,lsOKFlag,-5,sDENErrorCode)
                Addn("Mauvaise longueur (",bDENRawDataByteArray[3],"/",sDENFilterLength,")",strDENErrorDetails)
              Else()
                IfMC("AND",lsOKFlag=1,sDENFilterByte4!=-1,sDENFilterByte4!=bDENRawDataByteArray[4])
                  Assign(0,lsOKFlag,-5,sDENErrorCode)
                  Addn("Mauvais octet #4 (",bDENRawDataByteArray[4],"/",sDENFilterByte4,")",strDENErrorDetails)
                Else()
                  IfMC("AND",lsOKFlag=1,sDENFilterByte5!=-1,sDENFilterByte5!=bDENRawDataByteArray[5])
                    Assign(0,lsOKFlag,-6,sDENErrorCode)
                    Addn("Mauvais octet #5 (",bDENRawDataByteArray[5],"/",sDENFilterByte5,")",strDENErrorDetails)
                  EndIf()
                EndIf()
              EndIf()
            EndIf()
          EndIf()
        EndIf()
      Else()
        CommTools(ByteArrayToHexString,bDENRawDataByteArray,0,lDENRawDataLength,strDENRespString)
        If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"  Données reçues (Non conformes) : <",strDENRespString,"> (",llLoopIndex," boucle(s))"," - %s/%s"):::EndIf()
      EndIf()
      ExitLoopIf(lsOKFlag=1)
    ElseIf(sDENErrorCode!=-1)
      Assign(-1,llLoopIndex)
      ExitLoop()
    EndIf()
    Add(llLoopIndex,1,llLoopIndex)
    ExitLoopIf(llLoopIndex>=lDENNumReadLoops)
  EndLoop()
  IfMC("OR",llLoopIndex=-1,llLoopIndex>=lDENNumReadLoops)
    If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"  >>> Réception de données RAW sur le canal <",sDENChannel,">...Échec - %s/%s"):::EndIf()
    Assign("CommTools - DenReceiveRawIPStreamed",strDENErrorSource)
    If(llLoopIndex>=lDENNumReadLoops)
      Assign(-1,sDENErrorCode,"Temps alloué de réception écoulé",strDENErrorDesc)
    EndIf()
    IfMC("OR",sDENEndOrAbortIfFailed=1,sDENEndOrAbortIfFailed=2,sDENEndOrAbortIfFailed=3)
      Addn("ATTENTION !",kstrCRLF,kstrCRLF,/+
           "Erreur lors de la réception de données RAW d'une carte Densité",kstrCRLF,kstrCRLF,/+
           "  Source de l'erreur : <",strDENErrorSource,">",kstrCRLF,/+
           "  Code d'erreur : <",sDENErrorCode,">",kstrCRLF,/+
           "  Description de l'erreur : <",strDENErrorDesc,">",strDENErrorMsg)
      MsgBoxOK(strDENErrorMsg,kstrAttnDlgTitle,800,250,14)
      If(sDENEndOrAbortIfFailed=1):::GoSub(MTComplete):::ElseIf(sDENEndOrAbortIfFailed=2):::GoSub(MTEnd):::ElseIf(sDENEndOrAbortIfFailed=3):::GoSub(MTAbort):::EndIf()
    EndIf()
  EndIf()
  If(sDENMonFlag!=0):::AddnMonitorDateTime(strDENLeadingSpaces,"Réception de données RAW sur le canal <",sDENChannel,">...Fin - %s/%s"):::EndIf()

  // Écriture dans les arguments de retour.

EndSub(DENReceiveRawDataStreamed)


// ---------------------------------------------------------------------------------------------------- //


/////////////////////
// DENGetThumbnail //
/////////////////////

BeginSub(DENGetThumbnail)
// Obtention d'un Thumbnail d'une carte Densité.
// Le Thumbnail est retourné dans le champ bDENThumbnailDataArray et aussi directement dans le registre de Thumbnail 'Meas'.
// Usage : GoSubArg(DENGetThumbnail,sChannel,strIPAddr,lIPPort,sSource,sDest,sThumbnailFormat,sThumbnailQuality,strHeaderExt,strCmdExt,lOptions,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         strIPAddr (V/L) : Adresse TCP/IP (Format 0.0.0.0 ou @Descripteur).
//         lIPPort (V/L) : Port Ethernet (5100).
//         sSource (V/L) : Source de communication (25).
//         sDest (V/L) : Fente de la carte (1-21).
//         sThumbnailFormat (V/L) : 0 (Small), 1 (Medium), 2 (Large).
//         sThumbnailQuality (V/L) : 0 (Poor), 1 (Medium), 2 (High).
//         strHeaderExt (V/L) : Caractères de demande de Header étendue (Ex. : Source ("01", "02" pour XVP-3901)).
//                              Exemples :
//                                FRS-1801 : "".
//                                HCO-1821 : "01", "02".
//                                HCP-1801 : "".
//                                HMP-1801 : Anciennement : "01", "02". Maintenant : "".
//                                SCP-1121 : ""
//                                XVP-3901 : "01", "02".
//         strCmdExt (V/L) : Caractères de commande étendue (Ex. : TimeStamp ("00" ou "01") pour la SCP-1121. Source ("01", "02" pour XVP-3901)).
//                           Exemples :
//                             FRS-1801 : "".
//                             HCO-1821 : "01", "02".
//                             HCP-1801 : "".
//                             HMP-1801 : Anciennement : "01", "02". Maintenant : "".
//                             SCP-1121 : "00", "01".
//                             XVP-3901 : "01", "02".
//         lOptions (V) : Variable contenant une série de bits d'options. Une option est active si le bit correspondant est à 1.
//                        Bit 0 (1) : Ne pas attendre le ACK de la commande de configuration du Thumbnail (Ex. : Bogue sur la XVP-3901 et la HCO-1821 originale).
//                        Bit 1 (2) : Header de 634 octets au lieu de 633.
//                        Bit 2 (4) : Header & Body Type Byte à 11 et 12 au lieu de 0 et 1.
//                        Bit 3 (8) : Données sous forme segmentée.
//                        Bit 4 (16) : Message GET_BODY requis.
//                        Bit 5 (32) : Ignorer le filtrage du canal de communication de la CPU (Destination en réception, normalement 25).
//                        Exemples :
//                          FRS-1801 : 0.
//                          HCO-1821 : 22 ou 23 (00010110 ou 00010111).
//                          HCP-1801 : 0.
//                          HMP-1801 : 0.
//                          SCP-1121 : 8 (00001000).
//                          XVP-3901 : 7 (00000111).
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 ou 2 - Entrées dans le moniteur.
//                          Note : 1 pour les données d'entête reçues seulement, 2 pour toutes les données RAW reçues.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur, fonction responsable de l'erreur si présente).
//         sDENErrorCode : Code d'erreur retourné par la fonction responsable de l'erreur (0 si pas d'erreur).
//         strDENErrorDesc : Description de l'erreur retournée par la fonction responsable de l'erreur ("" si pas d'erreur).
//         strDENErrorDetails : Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
//         bDENThumbnailDataArray : Données de Thumbnail reçues.
//         lDENThumbnailDataSize : Nombre d'octets de données de Thumbnail reçues (0 si erreur ou pas de données valides reçues).
// Exemple : GoSubArg(DENGetThumbnail,0,"192.168.100.3",5100,25,19,2,2,"01","01",7,2,"    ",0).

  // Constantes opérationnelles locales.
  LLongs(lklReadWaitDelayResp=10,lklReadTimeOutDelayResp=10,lklNumReadLoopsResp=10)
  LLongs(lklReadWaitDelayRaw=100,lklReadTimeOutDelayRaw=100,lklNumReadLoopsRaw=25)

  // Arguments.
  LStrings(lstrHeaderExt,lstrCmdExt)
  LShorts(lsThumbnailFormat,lsThumbnailQuality)
  LLongs(llOptions)

  // Variables locales.
  LStrings(lstrGetHeaderMsg,lstrGetBodyMsg,lstrThumbnailFormat,lstrThumbnailQuality,lstrThumbnailConfigMsg)
  LBytes(lbHeaderTypeByte,lbBodyTypeByte)
  LShorts(lsOptions[32])
  LLongs(llTNDataLen,llTNDataMark,llIndex1,llIndex2)
  LLongs(llHeaderLength,llHeaderSubLength)
  LLongs(llPacketLength,llPacketDataLength,llPacketTypeMarker,llPacketSeqMarker)
  LLongs(llSubPacketMSBLengthMarker,llSubPacketLSBLengthMarker,llSubPacketStart,llSubPacketDataStart,llSubPacketLength,llSubPacketDataLength)
  LLongs(llSubPacketTypeMarker,llSubPacketSeqMarker)

  // Lecture des arguments d'entrée et de retour.
  GetSubArgs(sDENChannel,strDENIPAddr,lDENIPPort,sDENSource,sDENDest,lsThumbnailFormat,lsThumbnailQuality,lstrHeaderExt,lstrCmdExt,llOptions,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)

  // Extraction des options.
  BWAnd(llOptions,1,lsOptions[0])
  BWAnd(llOptions,2,lsOptions[1])
  BWAnd(llOptions,4,lsOptions[2])
  BWAnd(llOptions,8,lsOptions[3])
  BWAnd(llOptions,16,lsOptions[4])
  BWAnd(llOptions,32,lsOptions[5])

  // Chooix du filtrage du canal de communication.
  If(lsOptions[5]=32):::Assign(-1,sDENFilterDest):::Else():::Assign(sDENSource,sDENFilterDest):::EndIf()

  // Initialisation.
  GoSubArg(DENInit,sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)

  // Ouverture.
  If(sDENErrorCode=0)
    GoSubArg(DENOpen,sDENChannel,strDENIPAddr,lDENIPPort,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
  EndIf()

  // Demande du 'Thumbnail Header'.
  If(sDENErrorCode=0)
    Add("1003",lstrHeaderExt,lstrGetHeaderMsg)
    GoSubArg(DENSendMsg,sDENChannel,sDENSource,sDENDest,lstrGetHeaderMsg,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
  EndIf()

  // Réception du ACK.
  If(sDENErrorCode=0)
    GoSubArg(DENReceiveResp,sDENChannel,lklReadWaitDelayResp,lklReadTimeOutDelayResp,lklNumReadLoopsResp,sDENDest,sDENFilterDest,2,0,0,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
  EndIf()

  // Configuration du Thumbnail.
  If(sDENErrorCode=0)
    If(lsThumbnailFormat=0):::Assign("00",lstrThumbnailFormat):::ElseIf(lsThumbnailFormat=1):::Assign("01",lstrThumbnailFormat):::ElseIf(lsThumbnailFormat=2):::Assign("02",lstrThumbnailFormat):::Else():::Assign("02",lstrThumbnailFormat):::EndIf()
    If(lsThumbnailQuality=0):::Assign("00",lstrThumbnailQuality):::ElseIf(lsThumbnailQuality=1):::Assign("01",lstrThumbnailQuality):::ElseIf(lsThumbnailQuality=2):::Assign("02",lstrThumbnailQuality):::Else():::Assign("02",lstrThumbnailQuality):::EndIf()
    Addn("100201",lstrThumbnailFormat,lstrThumbnailQuality,"80",lstrCmdExt,lstrThumbnailConfigMsg)
    GoSubArg(DENSendMsg,sDENChannel,sDENSource,sDENDest,lstrThumbnailConfigMsg,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
  EndIf()

  // Réception du ACK.
  IfMC("AND",sDENErrorCode=0,lsOptions[0]=0)
    GoSubArg(DENReceiveResp,sDENChannel,lklReadWaitDelayResp,lklReadTimeOutDelayResp,lklNumReadLoopsResp,sDENDest,sDENFilterDest,2,0,0,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
  EndIf()

  // Demande du 'Thumbnail Body'.
  IfMC("AND",sDENErrorCode=0,lsOptions[4]=16)
    Add("0127",lstrHeaderExt,lstrGetBodyMsg)
    GoSubArg(DENSendMsg,sDENChannel,sDENSource,sDENDest,lstrGetBodyMsg,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
  EndIf()

  // Réception du ACK.
  IfMC("AND",sDENErrorCode=0,lsOptions[4]=16)
    GoSubArg(DENReceiveResp,sDENChannel,lklReadWaitDelayResp,lklReadTimeOutDelayResp,lklNumReadLoopsResp,sDENDest,sDENFilterDest,2,0,0,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
  EndIf()

  // Données sous forme non-segmentée.
  IfMC("AND",sDENErrorCode=0,lsOptions[3]=0)
  
    // Réception du header.
    If(lsOptions[1]=0):::Assign(633,llHeaderLength,10,llHeaderSubLength)
    ElseIf(lsOptions[1]=2):::Assign(634,llHeaderLength,11,llHeaderSubLength)
    EndIf()
    If(sDENErrorCode=0)
      GoSubArg(DENReceiveRawData,sDENChannel,lklReadWaitDelayRaw,lklReadTimeOutDelayRaw,lklNumReadLoopsRaw,sDENDest,sDENFilterDest,4,0,43,2,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
    EndIf()
    IfMC("AND",sDENErrorCode=0,lDENRawDataLength=llHeaderLength)
      Sub(lDENRawDataLength,llHeaderSubLength,llTNDataLen)
      CopyArray(bDENRawDataByteArray,8,bDENThumbnailDataArray,0,llTNDataLen)
      Assign(llTNDataLen,llTNDataMark)
    Else()
      AddnMonitorDateTime(strDENLeadingSpaces,">>> Les données reçues ne correspondent pas au Header ! - %s/%s")
      Assign(-1,sDENErrorCode)
    EndIf()
  
    // Réception du reste des données.
    If(lsOptions[2]=0):::Assign(0,lbHeaderTypeByte,1,lbBodyTypeByte)
    ElseIf(lsOptions[2]=4):::Assign(11,lbHeaderTypeByte,12,lbBodyTypeByte)
    EndIf()
    If(sDENErrorCode=0)
      Sub(lDENRawDataLength,1,llIndex1)
      Sub(lDENRawDataLength,2,llIndex2)
      IfMC("AND",bDENRawDataByteArray[llIndex2]=lbHeaderTypeByte,bDENRawDataByteArray[llIndex1]=255)
        BeginLoop()
          GoSubArg(DENReceiveRawData,sDENChannel,lklReadWaitDelayRaw,lklReadTimeOutDelayRaw,lklNumReadLoopsRaw,sDENDest,sDENFilterDest,4,0,43,2,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
          ExitLoopIf(sDENErrorCode!=0)
          Sub(lDENRawDataLength,2,llTNDataLen)
          If(bDENRawDataByteArray[llTNDataLen]=lbBodyTypeByte)
            Sub(lDENRawDataLength,10,llTNDataLen)
            CopyArray(bDENRawDataByteArray,8,bDENThumbnailDataArray,llTNDataMark,llTNDataLen)
            Add(llTNDataMark,llTNDataLen,llTNDataMark)
            Sub(lDENRawDataLength,1,llIndex1)
            Sub(lDENRawDataLength,2,llIndex2)
            IfMC("AND",bDENRawDataByteArray[llIndex2]=lbBodyTypeByte,bDENRawDataByteArray[llIndex1]=255)
              ExitLoop()
            EndIf()
          EndIf()
        EndLoop()
      EndIf()
    EndIf()

  // Données sous forme segmentée.
  ElseIfMC("AND",sDENErrorCode=0,lsOptions[3]=8)

    If(lsOptions[2]=0):::Assign(0,lbHeaderTypeByte,1,lbBodyTypeByte)
    ElseIf(lsOptions[2]=4):::Assign(11,lbHeaderTypeByte,12,lbBodyTypeByte)
    EndIf()

    Assign(0,llTNDataMark,0,llTNDataLen)

    BeginLoop()

      GoSubArg(DENReceiveRawData,sDENChannel,lklReadWaitDelayRaw,lklReadTimeOutDelayRaw,lklNumReadLoopsRaw,sDENDest,sDENFilterDest,4,0,43,2,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
      ExitLoopIf(sDENErrorCode!=0)

      Assign(lDENRawDataLength,llPacketLength)
      RPN(bDENRawDataByteArray[6],256,*,bDENRawDataByteArray[7],+,llPacketDataLength)
      Sub(llPacketLength,2,llPacketTypeMarker)
      Sub(llPacketLength,1,llPacketSeqMarker)

      IfMC("OR",bDENRawDataByteArray[llPacketTypeMarker]!=10,bDENRawDataByteArray[llPacketSeqMarker]!=255)
        Assign(-1,sDENErrorCode)
        ExitLoop()
      EndIf()

      Assign(8,llSubPacketMSBLengthMarker,9,llSubPacketLSBLengthMarker,8,llSubPacketStart,10,llSubPacketDataStart)

      BeginLoop()

        RPN(bDENRawDataByteArray[llSubPacketMSBLengthMarker],256,*,bDENRawDataByteArray[llSubPacketLSBLengthMarker],+,llSubPacketLength)
        Sub(llSubPacketLength,2,llSubPacketDataLength)
        Addn(llSubPacketDataStart,llSubPacketDataLength,0,llSubPacketTypeMarker)
        Addn(llSubPacketDataStart,llSubPacketDataLength,1,llSubPacketSeqMarker)
        IfMC("OR",bDENRawDataByteArray[llSubPacketTypeMarker]=0,bDENRawDataByteArray[llSubPacketTypeMarker]=1)
          CopyArray(bDENRawDataByteArray,llSubPacketDataStart,bDENThumbnailDataArray,llTNDataMark,llSubPacketDataLength)
          Add(llTNDataLen,llSubPacketDataLength,llTNDataLen)
          Add(llTNDataMark,llSubPacketDataLength,llTNDataMark)
        ElseIfMC("OR",bDENRawDataByteArray[llSubPacketTypeMarker]=0,bDENRawDataByteArray[llSubPacketTypeMarker]=2)
          Sub(llSubPacketDataLength,8,llSubPacketDataLength)
          CopyArray(bDENRawDataByteArray,llSubPacketDataStart,bDENThumbnailDataArray,llTNDataMark,llSubPacketDataLength)
          Add(llTNDataLen,llSubPacketDataLength,llTNDataLen)
          Add(llTNDataMark,llSubPacketDataLength,llTNDataMark)
        EndIf()
        Ifn(bDENRawDataByteArray[llSubPacketTypeMarker]=1,bDENRawDataByteArray[llSubPacketSeqMarker]=255,"AND",bDENRawDataByteArray[llSubPacketTypeMarker]=2,bDENRawDataByteArray[llSubPacketSeqMarker]=255,"AND","OR")
          ExitLoop()
        EndIf()

        Addn(llSubPacketMSBLengthMarker,llSubPacketLength,2,llSubPacketMSBLengthMarker)
        Add(llSubPacketMSBLengthMarker,1,llSubPacketLSBLengthMarker)
        Assign(llSubPacketMSBLengthMarker,llSubPacketStart)
        Add(llSubPacketStart,2,llSubPacketDataStart)
        ExitLoopIf(llSubPacketDataStart>=llPacketTypeMarker)

      EndLoop()

      ExitLoopIf(bDENRawDataByteArray[llSubPacketSeqMarker]=255)

    EndLoop()

  EndIf()

  // Fermeture et transport dans un registre de Thumbnail.
  If(sDENErrorCode=0)
    GoSubArg(DENClose,sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
    Assign(llTNDataMark,lDENThumbnailDataSize)
    CommTools(DenRawArrayToThumbnail,bDENThumbnailDataArray,lDENThumbnailDataSize)
  Else()
    Assign(sDENErrorCode,sDENErrorCodeBU,strDENErrorDesc,strDENErrorDescBU,strDENErrorSource,strDENErrorSourceBU,strDENErrorDetails,strDENErrorDetailsBU)
    GoSubArg(DENClose,sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
    Assign(sDENErrorCodeBU,sDENErrorCode,strDENErrorDescBU,strDENErrorDesc,strDENErrorSourceBU,strDENErrorSource,strDENErrorDetailsBU,strDENErrorDetails)
    Assign(0,lDENThumbnailDataSize)
  EndIf()

  // Écriture dans les arguments de retour.

EndSub(DENGetThumbnail)


// ---------------------------------------------------------------------------------------------------- //


/////////////////////
// DENGetVideoLine //
/////////////////////

BeginSub(DENGetVideoLine)
// Obtention d'une ligne vidéo d'une carte Densité (LineScope/LineGrabber).
// Les données sont retournées dans les variables et champs globaux décrits ci-bas.
// Usage : GoSubArg(DENGetVideoLine,sChannel,strIPAddr,lIPPort,sSource,sDest,sVideoLine,strVideoFormat,lOptions,sMonFlag,strLeadingSpaces,sEndOrAbortIfFailed).
//         sChannel (V/L) : Canal de communication Ethernet (0-15).
//         strIPAddr (V/L) : Adresse TCP/IP (Format 0.0.0.0 ou @Descripteur).
//         lIPPort (V/L) : Port Ethernet (5100).
//         sSource (V/L) : Source de communication (25).
//         sDest (V/L) : Fente de la carte (1-21).
//         sVideoLine (V/L) : Numéro de ligne vidéo (Doit être un numéro valide pour le format).
//         strVideoFormat (V/L) : Format vidéo du signal (525, 625, 1080i59.94, 1080i50, 720p59.94, 720p50).
//         lOptions (V) : Variable contenant une série de bits d'options. Une option est active si le bit correspondant est à 1.
//                        Bit 0 (1) : Ne pas attendre le ACK de la commande de configuration du LineScope.
//                        Bit 1 (2) : Données sous forme segmentée.
//                        Bit 2 (4) : Ignorer le filtrage du canal de communication de la CPU (Destination en réception, normalement 25).
//                        Exemples :
//                          HCP-1801LS : 0.
//                          SCP-1121 : 2.
//         sMonFlag (V/L) : 0 - Pas d'entrée dans le moniteur, 1 ou 2 - Entrées dans le moniteur.
//                          Note : 1 pour les données d'entête reçues seulement, 2 pour toutes les données RAW reçues.
//         strLeadingSpaces (V/L) : Espaces en début de lignes dans le moniteur.
//         sEndOrAbortIfFailed (V/L) : 0 - Erreur non traitée,
//                                     1 - Erreur traitée avec fin gracieuse de l'exécution,
//                                     2 - Erreur traitée avec fin immédiate de l'exécution,
//                                     3 - Erreur traitée avec avortement de l'exécution.
// Retours dans les variables globales :
//         strDENErrorSource : Sources de l'erreur ("" si pas d'erreur, fonction responsable de l'erreur si présente).
//         sDENErrorCode : Code d'erreur retourné par la fonction responsable de l'erreur (0 si pas d'erreur).
//         strDENErrorDesc : Description de l'erreur retournée par la fonction responsable de l'erreur ("" si pas d'erreur).
//         strDENErrorDetails : Détails de l'erreur spécifique à cette sous-routine, si applicable ("" si pas d'erreur).
//         sDENVideoLineRawDataArray : Champ de variables de type Short contenant les données complètes d'une ligne vidéo sous forme Cb Y1 Cr Y2 ...,
//                                     comprenant d'abord les données de type Ancillary, puis les données actives.
//         lDENVideoLineRawDataSize : Nombres d'octets de données valides dans sDENVideoLineRawDataArray.
//         sDENVideoFormat : Code de format du signal vidéo reçu.
//         sDENLineNumber : Numéro de la ligne vidéo reçue.
//         sDENVideoLineActiveDataArray : Champ de variables de type Short contenant les données vidéo actives seulement, sous forme Y0,...,YN,Cb0,...,CbN/2,Cr0,...,CrN/2.
//         fDENVideoLineRealDataArray : Champ de variables de type Float contenant les données vidéo actives seulement, sous forme Y0,...,YN,Cb0,...,CbN/2,Cr0,...,CrN/2.
//         lDENVideoLineActiveDataSize : Nombres d'octets de données valides dans sDENVideoLineActiveDataArray et fDENVideoLineRealDataArray.
// Exemple : GoSubArg(DENGetVideoLine,0,"192.168.100.2",5100,25,3,100,"525",2,2,"    ",0).

  // Constantes opérationnelles locales.
  LLongs(lklReadWaitDelayResp=10,lklReadTimeOutDelayResp=10,lklNumReadLoopsResp=10)
  LLongs(lklReadWaitDelayRaw=100,lklReadTimeOutDelayRaw=100,lklNumReadLoopsRaw=25)

  // Arguments.
  LStrings(lstrVideoFormat)
  LShorts(lsVideoLine)
  LLongs(llOptions)

  // Variables locales.
  LStrings(lstrVideoLine,lstrVideoLineConfigMsg)
  LBytes(lbVideoLineBytes[2],lbBodyTypeByte)
  LShorts(lsOptions[32])
  LLongs(llLSDataLen,llLSDataMark,llIndex1,llIndex2)
  LLongs(llPacketLength,llPacketDataLength,llPacketTypeMarker,llPacketSeqMarker)
  LLongs(llSubPacketMSBLengthMarker,llSubPacketLSBLengthMarker,llSubPacketStart,llSubPacketDataStart)
  LLongs(llSubPacketLength,llSubPacketDataLength,llSubPacketTypeMarker,llSubPacketSeqMarker)

  // Lecture des arguments d'entrée et de retour.
  GetSubArgs(sDENChannel,strDENIPAddr,lDENIPPort,sDENSource,sDENDest,lsVideoLine,lstrVideoFormat,llOptions,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)

  // Extraction des options.
  BWAnd(llOptions,1,lsOptions[0])
  BWAnd(llOptions,2,lsOptions[1])
  BWAnd(llOptions,4,lsOptions[2])

  // Chooix du filtrage du canal de communication.
  If(lsOptions[5]=32):::Assign(-1,sDENFilterDest):::Else():::Assign(sDENSource,sDENFilterDest):::EndIf()

  // Initialisation.
  GoSubArg(DENInit,sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)

  // Ouverture.
  If(sDENErrorCode=0)
    GoSubArg(DENOpen,sDENChannel,strDENIPAddr,lDENIPPort,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
  EndIf()

  // Configuration du LineScope.
  If(sDENErrorCode=0)
    MathTools(IntegerToByteArray,lsVideoLine,lbVideoLineBytes,0,-2)
    CommTools(ByteArrayToHexString,lbVideoLineBytes,0,2,lstrVideoLine)
    Addn("1006",lstrVideoLine,"80",lstrVideoLineConfigMsg)
    GoSubArg(DENSendMsg,sDENChannel,sDENSource,sDENDest,lstrVideoLineConfigMsg,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
  EndIf()

  // Réception du ACK.
  IfMC("AND",sDENErrorCode=0,lsOptions[0]=0)
    GoSubArg(DENReceiveResp,sDENChannel,lklReadWaitDelayResp,lklReadTimeOutDelayResp,lklNumReadLoopsResp,sDENDest,sDENFilterDest,2,0,0,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
  EndIf()

  // Données sous forme non-segmentée.
  IfMC("AND",sDENErrorCode=0,lsOptions[1]=0)
  
    Assign(6,lbBodyTypeByte,0,llLSDataMark,0,llLSDataLen)

    BeginLoop()
      GoSubArg(DENReceiveRawData,sDENChannel,lklReadWaitDelayRaw,lklReadTimeOutDelayRaw,lklNumReadLoopsRaw,sDENDest,sDENFilterDest,4,0,43,2,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
      ExitLoopIf(sDENErrorCode!=0)
      Sub(lDENRawDataLength,2,llLSDataLen)
      If(bDENRawDataByteArray[llLSDataLen]=lbBodyTypeByte)
        Sub(lDENRawDataLength,10,llLSDataLen)
        CopyArray(bDENRawDataByteArray,8,bDENVideoLineDataArray,llLSDataMark,llLSDataLen)
        Add(llLSDataMark,llLSDataLen,llLSDataMark)
        Sub(lDENRawDataLength,1,llIndex1)
        Sub(lDENRawDataLength,2,llIndex2)
        IfMC("AND",bDENRawDataByteArray[llIndex2]=lbBodyTypeByte,bDENRawDataByteArray[llIndex1]=255)
          ExitLoop()
        EndIf()
      EndIf()
    EndLoop()

  // Données sous forme segmentée.
  ElseIfMC("AND",sDENErrorCode=0,lsOptions[1]=2)

    Assign(6,lbBodyTypeByte,0,llLSDataMark,0,llLSDataLen)

    BeginLoop()

      GoSubArg(DENReceiveRawData,sDENChannel,lklReadWaitDelayRaw,lklReadTimeOutDelayRaw,lklNumReadLoopsRaw,sDENDest,sDENFilterDest,4,0,43,2,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
      ExitLoopIf(sDENErrorCode!=0)

      Assign(lDENRawDataLength,llPacketLength)
      RPN(bDENRawDataByteArray[6],256,*,bDENRawDataByteArray[7],+,llPacketDataLength)
      Sub(llPacketLength,2,llPacketTypeMarker)
      Sub(llPacketLength,1,llPacketSeqMarker)

      IfMC("OR",bDENRawDataByteArray[llPacketTypeMarker]!=10,bDENRawDataByteArray[llPacketSeqMarker]!=255)
        Assign(-1,sDENErrorCode)
        ExitLoop()
      EndIf()

      Assign(8,llSubPacketMSBLengthMarker,9,llSubPacketLSBLengthMarker,8,llSubPacketStart,10,llSubPacketDataStart)

      BeginLoop()

        RPN(bDENRawDataByteArray[llSubPacketMSBLengthMarker],256,*,bDENRawDataByteArray[llSubPacketLSBLengthMarker],+,llSubPacketLength)
        Sub(llSubPacketLength,2,llSubPacketDataLength)
        Addn(llSubPacketDataStart,llSubPacketDataLength,0,llSubPacketTypeMarker)
        Addn(llSubPacketDataStart,llSubPacketDataLength,1,llSubPacketSeqMarker)
        If(bDENRawDataByteArray[llSubPacketTypeMarker]=lbBodyTypeByte)
          CopyArray(bDENRawDataByteArray,llSubPacketDataStart,bDENVideoLineDataArray,llLSDataMark,llSubPacketDataLength)
          Add(llLSDataLen,llSubPacketDataLength,llLSDataLen)
          Add(llLSDataMark,llSubPacketDataLength,llLSDataMark)
        EndIf()
        Ifn(bDENRawDataByteArray[llSubPacketTypeMarker]=lbBodyTypeByte,bDENRawDataByteArray[llSubPacketSeqMarker]=255,"AND")
          ExitLoop()
        EndIf()

        Addn(llSubPacketMSBLengthMarker,llSubPacketLength,2,llSubPacketMSBLengthMarker)
        Add(llSubPacketMSBLengthMarker,1,llSubPacketLSBLengthMarker)
        Assign(llSubPacketMSBLengthMarker,llSubPacketStart)
        Add(llSubPacketStart,2,llSubPacketDataStart)
        ExitLoopIf(llSubPacketDataStart>=llPacketTypeMarker)

      EndLoop()

      ExitLoopIf(bDENRawDataByteArray[llSubPacketSeqMarker]=255)

    EndLoop()

  EndIf()

  // Fermeture et transport dans un registre de signal.
  If(sDENErrorCode=0)
    GoSubArg(DENClose,sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
    Assign(llLSDataMark,lDENVideoLineDataSize)
    CommTools(DenRawArrayToRawVideoLine,bDENVideoLineDataArray,lDENVideoLineDataSize,sDENVideoLineRawDataArray,lDENVideoLineRawDataSize,sDENVideoFormat,sDENLineNumber)
    CommTools(DenRawVideoLineToActiveVideoLine,lstrVideoFormat,sDENVideoLineRawDataArray,lDENVideoLineRawDataSize,sDENVideoLineActiveDataArray,lDENVideoLineActiveDataSize)
    CommTools(DenActiveVideoLineToRealVideoLine,sDENVideoLineActiveDataArray,lDENVideoLineActiveDataSize,fDENVideoLineRealDataArray)
  Else()
    Assign(sDENErrorCode,sDENErrorCodeBU,strDENErrorDesc,strDENErrorDescBU,strDENErrorSource,strDENErrorSourceBU,strDENErrorDetails,strDENErrorDetailsBU)
    GoSubArg(DENClose,sDENChannel,sDENMonFlag,strDENLeadingSpaces,sDENEndOrAbortIfFailed)
    Assign(sDENErrorCodeBU,sDENErrorCode,strDENErrorDescBU,strDENErrorDesc,strDENErrorSourceBU,strDENErrorSource,strDENErrorDetailsBU,strDENErrorDetails)
    Assign(0,lDENVideoLineDataSize)
  EndIf()

  // Écriture dans les arguments de retour.

EndSub(DENGetVideoLine)


// ---------------------------------------------------------------------------------------------------- //


////////////
// DENNew //
////////////

BeginSub(DENNew)
// Description....
// Usage : GoSubArg(DENNew,...).
//         ... : ....
//         ... : ....
//         ... : ....
// Exemple : ....
// Utilisée par ....

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.

  // Lecture des arguments d'entrée et de retour.
  GetSubArgs(...)

  // ....
  ; ...

  // Écriture dans les arguments de retour.
  SetSubArgs(...)

EndSub(DENNew)


//////////////////////
// DENGetRespLength //
//////////////////////

BeginSub(DENGetRespLength)
//         lsExtProtocolID (V/L) : 0 - Protocol normal.
//                                 1 - Protocol étendu #1 (Axino).  
//         llLength : Longueur de la réponse de la communication Densité
LLongs( llLength, llTemp ):::LShorts(lsExtProtocolID)

GetSubArgs( lsExtProtocolID, llLength )

  If( lsExtProtocolID=DENProtocolDensitéExtented1 )
    If( Fct@DENGetExtendedBit(llTemp) = 1 )
      ;amt( "Mode ext will large message" )
      RPN( bDENRespByteArray[4], 0x100, *, bDENRespByteArray[5], +, llLength)
    Else()
      ;amt( "Mode ext but simple densité message" )
      RPN( bDENRespByteArray[3], 0x3F, BWAnd, llLength )
    EndIf()
  ElseIf(lsExtProtocolID=DENProtocolDensitéBase)
    RPN( bDENRespByteArray[3], 0x3F, BWAnd, llLength )
  EndIf()
Return( llLength )
SetSubArgs( -, llLength )
EndSub(DENGetRespLength)

  ///////////////////
 //  DENGeMoreBit //
///////////////////
BeginSub(DENGeMoreBit)
  LBytes( DENGeMoreBit )
  RPN( bDENRespByteArray[3], 6 , >>, 1, BWAnd , DENGeMoreBit )
  Return( DENGeMoreBit )
  SetSubArgs( DENGeMoreBit )
EndSub(DENGeMoreBit)

///////////////////////
// DENGetExtendedBit //
///////////////////////
BeginSub(DENGetExtendedBit)
  LBytes( lbxtendedBit )
  RPN( bDENRespByteArray[3], 7 , >> , lbxtendedBit )
  Return( lbxtendedBit )
  SetSubArgs( lbxtendedBit )
EndSub(DENGetExtendedBit)



//////////////////////////////section pour la SerialComm avec Densité


/*
/////////////////////

BeginSub(DensiteBuilRespText)
// Construction du texte de la ou des réponses.
// Usage : GoSub(SCWBuilRespText).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.
  LShorts(lsLoopDoneFlag)
  LLongs(llResIndex,llIndexes[8],llBaseIndex,llAbsIndex,llRelIndex,llDiffIndex,llRemIndex)
	LStrings(lstrMsgResp)
	LStrings(lstrSCWHexString1,lstrSCWHexString2,lstrSCWResp)
  // Lecture des arguments d'entrée et de retour.

  // Affichage.
  {
  	Addn("Nombre d'octets reçus : ",lDENRespLength,lstrSCWResp)
    AddnMonitorText(lstrSCWResp)
  
  
      If(lDENRespLength>0)
  
        Assign(0,llAbsIndex)

        BeginLoop()
    
          Assign(0,lsLoopDoneFlag,llAbsIndex,llBaseIndex)

          // Indexes.
          Add(llBaseIndex,0,llIndexes[0])
          Add(llBaseIndex,1,llIndexes[1])
          Add(llBaseIndex,2,llIndexes[2])
          Add(llBaseIndex,3,llIndexes[3])
          Add(llBaseIndex,4,llIndexes[4])
          Add(llBaseIndex,5,llIndexes[5])
          Add(llBaseIndex,6,llIndexes[6])
          Add(llBaseIndex,7,llIndexes[7])

          // Vérifications de validité.
          Sub(lDENRespLength,llBaseIndex,llDiffIndex)
          Sub(llDiffIndex,5,llRemIndex)
          If(llDiffIndex<7) // Quantité d'octets restant insuffisants.
          	Addn("Données reçues invalides..."," Quantité d'octets restant insuffisants !", lstrSCWResp)
          	AddnMonitorText(lstrSCWResp)
          EndIf()
          If(bDENRespByteArray[llIndexes[0]]!=2) // Absence du STX.
          	Addn("Données reçues invalides..."," Absence du STX !", lstrSCWResp)
          	AddnMonitorText(lstrSCWResp)
          EndIf()
          If(bDENRespByteArray[llIndexes[3]]>llRemIndex) // Longueur du message indiqué trop grande.
          	Addn("Données reçues invalides..."," Longueur du message indiqué trop grande !", lstrSCWResp)
          	AddnMonitorText(lstrSCWResp)
          EndIf()
          IfMC("OR",llDiffIndex<7,bDENRespByteArray[llIndexes[0]]!=2,bDENRespByteArray[llIndexes[3]]>llRemIndex)
          	Assign("",lstrMsgResp)
            AddnMonitorText("Données brutes reçues :")
            Assign(0,llRelIndex)
            Add(llRelIndex,llBaseIndex,llAbsIndex)
            BeginLoop()
              FormatStringBSL(bDENRespByteArray[llAbsIndex],"0x%.2X",lstrSCWHexString1)
              //FormatStringBSL(bDENRespByteArray[llAbsIndex],"%1c",strSCWASCIIChar)
              IfMC("OR",bDENRespByteArray[llAbsIndex]<32,bDENRespByteArray[llAbsIndex]>126)
                Addn(lstrMsgResp,lstrSCWHexString1,lstrMsgResp)
              EndIf()
              IfMC("AND",bDENRespByteArray[llAbsIndex]>=32,bDENRespByteArray[llAbsIndex]<=126)
                Addn(lstrMsgResp,lstrSCWHexString1,lstrMsgResp)
//                Addn("AddTextLine=","Byte ",llRelIndex," : ",bDENRespByteArray[llAbsIndex]," (",lstrSCWHexString1,") (",strSCWASCIIChar,")",lstrSCWResp)
              EndIf()
              
              //UFConfigControl(sSCWFormID1,strSCWMemoMon,iSCWTagMemoMon,lstrSCWResp)
              Add(llRelIndex,1,llRelIndex)
              Add(llRelIndex,llBaseIndex,llAbsIndex)
              ExitLoopIf(llAbsIndex>=lDENRespLength)
            EndLoop()
            ExitLoop()
          EndIf()
          AddnMonitorText(lstrMsgResp)

          // Entête.
          FormatStringBSL(bDENRespByteArray[llIndexes[0]],"0x%.2X",lstrSCWHexString1)
          	Addn("Byte 0 (STX) : ",lstrSCWHexString1, lstrSCWResp)
          	AddnMonitorText(lstrSCWResp)
//            Addn("AddTextLine=","Byte 0 (STX) : ",bDENRespByteArray[llIndexes[0]]," (",lstrSCWHexString1,")",lstrSCWResp)
//            UFConfigControl(sSCWFormID1,strSCWMemoMon,iSCWTagMemoMon,lstrSCWResp)
          FormatStringBSL(bDENRespByteArray[llIndexes[1]],"0x%.2X",lstrSCWHexString1)
          	Addn("Byte 1 (Destination) : ",lstrSCWHexString1, lstrSCWResp)
          	AddnMonitorText(lstrSCWResp)
//            Addn("AddTextLine=","Byte 1 (Destination) : ",bDENRespByteArray[llIndexes[1]]," (",lstrSCWHexString1,")",lstrSCWResp)
//            UFConfigControl(sSCWFormID1,strSCWMemoMon,iSCWTagMemoMon,lstrSCWResp)
          FormatStringBSL(bDENRespByteArray[llIndexes[2]],"0x%.2X",lstrSCWHexString1)
          	Addn("Byte 2 (Source) : ",lstrSCWHexString1, lstrSCWResp)
          	AddnMonitorText(lstrSCWResp)
//            Addn("AddTextLine=","Byte 2 (Source) : ",bDENRespByteArray[llIndexes[2]]," (",lstrSCWHexString1,")",lstrSCWResp)
//            UFConfigControl(sSCWFormID1,strSCWMemoMon,iSCWTagMemoMon,lstrSCWResp)
          FormatStringBSL(bDENRespByteArray[llIndexes[3]],"0x%.2X",lstrSCWHexString1)
          	Addn("Byte 3 (Longueur) : ",lstrSCWHexString1, lstrSCWResp)
          	AddnMonitorText(lstrSCWResp)
//            Addn("AddTextLine=","Byte 3 (Longueur) : ",bDENRespByteArray[llIndexes[3]]," (",lstrSCWHexString1,")",lstrSCWResp)
//            UFConfigControl(sSCWFormID1,strSCWMemoMon,iSCWTagMemoMon,lstrSCWResp)
          Add(llAbsIndex,4,llAbsIndex)

          // Commande.
          If(bDENRespByteArray[llIndexes[3]]>=2)
            FormatStringBSL(bDENRespByteArray[llIndexes[4]],"0x%.2X",lstrSCWHexString1)
            FormatStringBSL(bDENRespByteArray[llIndexes[5]],"0x%.2X",lstrSCWHexString2)
          	Addn("Byte 4&5 (Message) : ",lstrSCWHexString1,lstrSCWHexString2 ,lstrSCWResp)
          	AddnMonitorText(lstrSCWResp)

//            Addn("AddTextLine=","Byte 4&5 (Message) : ",bDENRespByteArray[llIndexes[4]],",",bDENRespByteArray[llIndexes[5]]," (",strSCWHexString1,",",strSCWHexString2,")",lstrSCWResp)
//            UFConfigControl(sSCWFormID1,strSCWMemoMon,iSCWTagMemoMon,lstrSCWResp)
            Add(llAbsIndex,2,llAbsIndex)
          EndIf()

          // ACK.
          IfMC("AND",bDENRespByteArray[llIndexes[3]]=2,bDENRespByteArray[llIndexes[4]]=0,bDENRespByteArray[llIndexes[5]]=0)
            FormatStringBSL(bDENRespByteArray[llIndexes[6]],"0x%.2X",lstrSCWHexString1)
            Addn("AddTextLine=","Byte 6 (Checksum) : ",bDENRespByteArray[llIndexes[6]]," (",lstrSCWHexString1,")",lstrSCWResp)
//            AddStringLine(lstrSCWResp,"",lstrSCWResp)
//            UFConfigControl(sSCWFormID1,strSCWMemoMon,iSCWTagMemoMon,lstrSCWResp)
          	Addn("Byte 6 (Checksum) : ",lstrSCWHexString1,lstrSCWResp)
          	AddnMonitorText(lstrSCWResp)

            Add(llAbsIndex,1,llAbsIndex)
            Assign(1,lsLoopDoneFlag)
          EndIf()

          // NACK.
          IfMC("AND",lsLoopDoneFlag=0,bDENRespByteArray[llIndexes[3]]=3,bDENRespByteArray[llIndexes[4]]=0,bDENRespByteArray[llIndexes[5]]=1)
            IfMC("AND",bDENRespByteArray[llIndexes[6]]>=0,bDENRespByteArray[llIndexes[6]]<12)
              Assign(bDENRespByteArray[llIndexes[6]],bSCWNACKNum)
              FormatStringBSL(bDENRespByteArray[llIndexes[6]],"0x%.2X",lstrSCWHexString1)
//              Addn("AddTextLine=","Byte 6 (NACK #) : ",bDENRespByteArray[llIndexes[6]]," (",lstrSCWHexString1,")"," (",strSCWNACK[bSCWNACKNum],")",lstrSCWResp)
//              UFConfigControl(sSCWFormID1,strSCWMemoMon,iSCWTagMemoMon,lstrSCWResp)
	          	Addn("Byte 6 (NACK #) : ",lstrSCWHexString1,lstrSCWResp)
	          	AddnMonitorText(lstrSCWResp)
            EndIf()
            IfMC("OR",bDENRespByteArray[llIndexes[6]]<0,bDENRespByteArray[llIndexes[6]]>=12)
//              Addn("AddTextLine=","Byte 6 (NACK #) : ",bDENRespByteArray[llIndexes[6]],lstrSCWResp)
//              UFConfigControl(sSCWFormID1,strSCWMemoMon,iSCWTagMemoMon,lstrSCWResp)
	          	Addn("Byte 6 (NACK #) : ",bDENRespByteArray[llIndexes[6],lstrSCWResp)
	          	AddnMonitorText(lstrSCWResp)
            EndIf()
            FormatStringBSL(bDENRespByteArray[llIndexes[7]],"0x%.2X",lstrSCWHexString1)
//            Addn("AddTextLine=","Byte 7 (Checksum) : ",bDENRespByteArray[llIndexes[7]]," (",lstrSCWHexString1,")",lstrSCWResp)
//            AddStringLine(lstrSCWResp,"",lstrSCWResp)
//            UFConfigControl(sSCWFormID1,strSCWMemoMon,iSCWTagMemoMon,lstrSCWResp)
	          	Addn("Byte 7 (Checksum) : ",lstrSCWHexString1,lstrSCWResp)
	          	AddnMonitorText(lstrSCWResp)

            Add(llAbsIndex,2,llAbsIndex)
            Assign(1,lsLoopDoneFlag)
          EndIf()
    
          // Checksum seulement.
          IfMC("AND",lsLoopDoneFlag=0,bDENRespByteArray[llIndexes[3]]=2)
            FormatStringBSL(bDENRespByteArray[llAbsIndex],"0x%.2X",lstrSCWHexString1)
//            Addn("AddTextLine=","Byte ",llAbsIndex," (Checksum) : ",bDENRespByteArray[llAbsIndex]," (",lstrSCWHexString1,")",lstrSCWResp)
//            AddStringLine(lstrSCWResp,"",lstrSCWResp)
//            UFConfigControl(sSCWFormID1,strSCWMemoMon,iSCWTagMemoMon,lstrSCWResp)
	          	Addn("Byte ",llAbsIndex," (Checksum) : ",lstrSCWHexString1,lstrSCWResp)
	          	AddnMonitorText(lstrSCWResp)
            Add(llAbsIndex,1,llAbsIndex)
            Assign(1,lsLoopDoneFlag)
          EndIf()

          // Liste des données de réponse, incluant le Checksum à la toute fin.
          IfMC("AND",lsLoopDoneFlag=0,bDENRespByteArray[llIndexes[3]]>2)
            Sub(bDENRespByteArray[llIndexes[3]],2,llRemIndex)
            BeginLoop()
              Sub(llAbsIndex,llBaseIndex,llResIndex)
              FormatStringBSL(bDENRespByteArray[llAbsIndex],"0x%.2X",lstrSCWHexString1)
              //FormatStringBSL(bDENRespByteArray[llAbsIndex],"%1c",strSCWASCIIChar)
              IfMC("OR",bDENRespByteArray[llAbsIndex]<32,bDENRespByteArray[llAbsIndex]>126)
                //Addn("AddTextLine=","Byte ",llResIndex," : ",bDENRespByteArray[llAbsIndex]," (",lstrSCWHexString1,")",lstrSCWResp)
	          	Addn("Byte ",llResIndex," : ",lstrSCWHexString1,lstrSCWResp)
              EndIf()
              IfMC("AND",bDENRespByteArray[llAbsIndex]>=32,bDENRespByteArray[llAbsIndex]<=126)
            	Addn("Byte ",llResIndex," : ",lstrSCWHexString1,lstrSCWResp)
                //Addn("AddTextLine=","Byte ",llResIndex," : ",bDENRespByteArray[llAbsIndex]," (",lstrSCWHexString1,") (",strSCWASCIIChar,")",lstrSCWResp)
              EndIf()
	          	AddnMonitorText(lstrSCWResp)
//              UFConfigControl(sSCWFormID1,strSCWMemoMon,iSCWTagMemoMon,lstrSCWResp)
              Sub(llResIndex,5,llDiffIndex)
              Add(llAbsIndex,1,llAbsIndex)
              ExitLoopIf(llDiffIndex>=llRemIndex)
            EndLoop()
            // Checksum.
            Sub(llAbsIndex,llBaseIndex,llResIndex)
            FormatStringBSL(bDENRespByteArray[llAbsIndex],"0x%.2X",lstrSCWHexString1)
//            Addn("AddTextLine=","Byte ",llResIndex," (Checksum) : ",bDENRespByteArray[llAbsIndex]," (",lstrSCWHexString1,")",lstrSCWResp)
//            AddStringLine(lstrSCWResp,"",lstrSCWResp)
//            UFConfigControl(sSCWFormID1,strSCWMemoMon,iSCWTagMemoMon,lstrSCWResp)
          	Addn("Byte ",llResIndex," (Checksum) : ",lstrSCWHexString1,lstrSCWResp)
          	AddnMonitorText(lstrSCWResp)

            Add(llAbsIndex,1,llAbsIndex)
          EndIf()

          ExitLoopIf(llAbsIndex>=lDENRespLength)
    
        EndLoop()
  
      EndIf()
  
  }

  // Écriture dans les arguments de retour.

EndSub(DensiteBuilRespText)





/////////////
// SCWTxRx //
/////////////

BeginSub(DensiteTxRx)
// Envoi de la commande et réception de la réponse.
// Usage : GoSub(SCWTxRx).

  // Constantes opérationnelles locales.

  // Arguments.

  // Variables locales.
  LStrings(lstrTwinHex)
  LShorts(lsConvError)
  LLongs(llByteIndex,llTwinIndex,llCmdLength)

  // Lecture des arguments d'entrée et de retour.

  // Envoi et réception.
  {
    Assign(lSCWRxRegistersSize,lDENRespLength)
    FillArray(0,bDENRespByteArray,0,lDENRespLength)
    StringLength(strSCWCmd,llCmdLength)
    If(llCmdLength<2):::Assign(0,sSCWNoCOMError):::ExitSub(DensiteTxRx):::EndIf()
  

      // Communication réelle.
      CommTools(DenBuildCmdArray,24,1,strSCWCmd,bSCWCOMTxByteArray,0,llCmdLength)
      SerialComm(SetParameters,0,strSCWCOM,lSCWBaudRate,lSCWNDataBits,strSCWParityArg,strSCWNStopBitsArg,CTSFlowOFF,DSRFlowOFF,DTRENABLE,RTSENABLE,NoReportErrorNoAbort)
      SerialComm(SetTimeOuts,0,sSCWTimeOuts[0],sSCWTimeOuts[1],sSCWTimeOuts[2],sSCWTimeOuts[3],sSCWTimeOuts[4])
      SerialComm(Open,0,sSCWNoCOMError)
      If(sSCWNoCOMError=1)
        SerialComm(Send,0,bSCWCOMTxByteArray,llCmdLength,1,0,sSCWNoCOMError)
        msecDelay(lSCWWaitTimeDelay)
        If(sSCWNoCOMError=1)
          SerialComm(Receive,0,bDENRespByteArray,lDENRespLength,1,0,sSCWNoCOMError)
        EndIf()
      EndIf()
      SerialComm(Close,0,sSCWNoCOMError)

  }

  // Écriture dans les arguments de retour.

EndSub(DensiteTxRx)


BeginSub(DensiteSend1)

      // Boucle d'envoi d'une commande et de la réception de la réponse.
      // Boucle active seulement si la case 'Boucler' est cochée.
//      BeginLoop()

        // Affichage du texte 'Communication en cours...' dans la fenêtre "Moniteur'.
//        If(sSCWCheckBoxLoopState=0)
//          UFConfigControl(sSCWFormID1,strSCWMemoMon,iSCWTagMemoMon,"Text=Communication en cours...","AddTextLine=")
//        EndIf()

        // Envoi de la commande et réception de la réponse.
        GoSub(DensiteTxRx)

        // Traitement si pas d'erreur.
        If(sSCWNoCOMError=1)

//          // Affichage en fonction de l'activation ou non de la boucle continue envoi-réception.
//          If(sSCWCheckBoxLoopState=0)
//            UFConfigControl(sSCWFormID1,strSCWMemoMon,iSCWTagMemoMon,"AddTextLine=Communication réussie...","AddTextLine=")
//          Else()
//            UFConfigControl(sSCWFormID1,strSCWMemoMon,iSCWTagMemoMon,"Text=Communication réussie...","AddTextLine=")
//          EndIf()

          // Visionnement de la réponse.
          GoSub(DensiteBuilRespText)

        EndIf()

//        // Cas d'une erreur.
//        If(sSCWNoCOMError=0)
//          UFConfigControl(sSCWFormID1,strSCWMemoMon,iSCWTagMemoMon,"AddTextLine=Erreur ... !","AddTextLine=")
//        EndIf()

//        // Lecture des évènements et de l'état du bouton 'Arrêter' dans le cas d'une boucle continue.
//        Assign(0,sSCWExitLoopFlag1)
//        If(sSCWCheckBoxLoopState=0)
//          Assign(1,sSCWExitLoopFlag1)
//        ElseIf(sSCWCheckBoxLoopState=1)
//          UFGetReturnTagMod(sSCWReturnTag,sSCWReturnMod)
//          If(sSCWReturnTag=iSCWTagButtonStop)
//            UFResetReturnTag()
//            Assign(1,sSCWExitLoopFlag1)
//          EndIf()
//        EndIf()

        // Sortie de la boucle continue envoi-réception.
//        ExitLoopIf(sSCWExitLoopFlag1=1) 
//  
//      EndLoop()
  
EndSub(DensiteSend1)
*/


// Subs-Densité05.txt... Fin.

----------------------------------------------------------------------------------------------------
