

// Char generator for PT5202
//
// by PEH 2002-05-21
//


#include <graphics.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>


// fontsize 5*7 dots
//
unsigned char char_gen[] =
{
//      <sp>
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
//      !
        0x04, 0x04, 0x04, 0x04, 0x00, 0x00, 0x04,
//      "
        0x0A, 0x0A, 0x0A, 0x00, 0x00, 0x00, 0x00,
//      #
        0x0A, 0x0A, 0x1F, 0x0A, 0x1F, 0x0A, 0x0A,
//      $
        0x04, 0x0F, 0x14, 0x0E, 0x05, 0x1E, 0x04,
//      %
        0x18, 0x19, 0x02, 0x04, 0x08, 0x13, 0x03,
//      &
        0x0C, 0x12, 0x14, 0x08, 0x15, 0x12, 0x0D,
//      '
        0x0C, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00,
//      (
        0x02, 0x04, 0x08, 0x08, 0x08, 0x04, 0x02,
//      )
        0x08, 0x04, 0x02, 0x02, 0x02, 0x04, 0x08,
//      *
        0x00, 0x04, 0x15, 0x0E, 0x15, 0x04, 0x00,
//      +
        0x00, 0x04, 0x04, 0x1F, 0x04, 0x04, 0x00,
//      ,
        0x00, 0x00, 0x00, 0x00, 0x0C, 0x04, 0x08,
//      -
        0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00,
//      .
        0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C,
//      /
        0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x00,
//      0
        0x0E, 0x11, 0x13, 0x15, 0x19, 0x11, 0x0E,
//      1
        0x04, 0x0C, 0x04, 0x04, 0x04, 0x04, 0x0E,
//      2
        0x0E, 0x11, 0x01, 0x02, 0x04, 0x08, 0x1F,
//      3
        0x1F, 0x02, 0x04, 0x02, 0x01, 0x01, 0x0E,
//      4
        0x02, 0x06, 0x0A, 0x12, 0x1F, 0x02, 0x02,
//      5
        0x1F, 0x10, 0x1E, 0x01, 0x01, 0x11, 0x0E,
//      6
        0x06, 0x08, 0x10, 0x1E, 0x11, 0x11, 0x1E,
//      7
        0x1F, 0x01, 0x02, 0x04, 0x08, 0x08, 0x08,
//      8
        0x0E, 0x11, 0x11, 0x0E, 0x11, 0x11, 0x0E,
//      9
        0x0E, 0x11, 0x11, 0x0F, 0x01, 0x02, 0x0C,
//      :
        0x00, 0x0C, 0x0C, 0x00, 0x0C, 0x0C, 0x00,
//      ;
        0x00, 0x0C, 0x0C, 0x00, 0x0C, 0x04, 0x08,
//      <
        0x02, 0x04, 0x08, 0x10, 0x08, 0x04, 0x02,
//      =
        0x00, 0x00, 0x1F, 0x00, 0x1F, 0x00, 0x00,
//      >
        0x08, 0x04, 0x02, 0x01, 0x02, 0x04, 0x08,
//      ?
        0x0E, 0x11, 0x01, 0x02, 0x04, 0x00, 0x04,


//      @
        0x0E, 0x11, 0x01, 0x0D, 0x15, 0x15, 0x0E,
//      A
        0x0E, 0x11, 0x11, 0x11, 0x1F, 0x11, 0x11,
//      B
        0x1E, 0x11, 0x11, 0x1E, 0x11, 0x11, 0x1E,
//      C
        0x0E, 0x11, 0x10, 0x10, 0x10, 0x11, 0x0E,
//      D
        0x1C, 0x12, 0x11, 0x11, 0x11, 0x12, 0x1C,
//      E
        0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x1F,
//      F
        0x1F, 0x10, 0x10, 0x1E, 0x10, 0x10, 0x10,
//      G
        0x0E, 0x11, 0x10, 0x17, 0x11, 0x11, 0x0F,
//      H
        0x11, 0x11, 0x11, 0x1F, 0x11, 0x11, 0x11,
//      I
        0x0E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E,
//      J
        0x07, 0x02, 0x02, 0x02, 0x02, 0x12, 0x0C,
//      K
        0x11, 0x12, 0x14, 0x18, 0x14, 0x12, 0x11,
//      L
        0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x1F,
//      M
        0x11, 0x1B, 0x15, 0x15, 0x11, 0x11, 0x11,
//      N
        0x11, 0x11, 0x19, 0x15, 0x13, 0x11, 0x11,
//      O
        0x0E, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E,
//      P
        0x1E, 0x11, 0x11, 0x1E, 0x10, 0x10, 0x10,
//      Q
        0x0E, 0x11, 0x11, 0x11, 0x15, 0x12, 0x0D,
//      R
        0x1E, 0x11, 0x11, 0x1E, 0x14, 0x12, 0x11,
//      S
        0x0F, 0x10, 0x10, 0x0E, 0x01, 0x01, 0x1E,
//      T
        0x1F, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
//      U
        0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x0E,
//      V
        0x11, 0x11, 0x11, 0x11, 0x11, 0x0A, 0x04,
//      W
        0x11, 0x11, 0x11, 0x15, 0x15, 0x15, 0x0A,
//      X
        0x11, 0x11, 0x0A, 0x04, 0x0A, 0x11, 0x11,
//      Y
        0x11, 0x11, 0x11, 0x0A, 0x04, 0x04, 0x04,
//      Z
        0x1F, 0x01, 0x02, 0x04, 0x08, 0x10, 0x1F,
//      [
        0x0E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0E,
//      yen
        0x11, 0x0A, 0x1F, 0x04, 0x1F, 0x04, 0x04,
//      ]
        0x0E, 0x02, 0x02, 0x02, 0x02, 0x02, 0x0E,
//      ^
        0x04, 0x0A, 0x11, 0x00, 0x00, 0x00, 0x00,
//      _
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F,


//      `
        0x08, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00,
//      a
        0x00, 0x00, 0x0E, 0x01, 0x0F, 0x11, 0x0F,
//      b
        0x10, 0x10, 0x16, 0x19, 0x11, 0x11, 0x1E,
//      c
        0x00, 0x00, 0x0E, 0x10, 0x10, 0x11, 0x0E,
//      d
        0x01, 0x01, 0x0D, 0x13, 0x11, 0x11, 0x0F,
//      e
        0x00, 0x00, 0x0E, 0x11, 0x1F, 0x10, 0x0E,
//      f
        0x06, 0x09, 0x08, 0x1C, 0x08, 0x08, 0x08,
//      g
        0x00, 0x0F, 0x11, 0x11, 0x0F, 0x01, 0x0E,
//      h
        0x10, 0x10, 0x16, 0x19, 0x11, 0x11, 0x11,
//      i
        0x04, 0x00, 0x0C, 0x04, 0x04, 0x04, 0x0E,
//      j
        0x02, 0x00, 0x06, 0x02, 0x02, 0x12, 0x0C,
//      k
        0x10, 0x10, 0x12, 0x14, 0x18, 0x14, 0x12,
//      l
        0x0C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x0E,
//      m
        0x00, 0x00, 0x1A, 0x15, 0x15, 0x11, 0x11,
//      n
        0x00, 0x00, 0x16, 0x19, 0x11, 0x11, 0x11,
//      o
        0x00, 0x00, 0x0E, 0x11, 0x11, 0x11, 0x0E,
//      p
        0x00, 0x00, 0x1E, 0x11, 0x1E, 0x10, 0x10,
//      q
        0x00, 0x00, 0x1D, 0x13, 0x1E, 0x01, 0x01,
//      r
        0x00, 0x00, 0x16, 0x19, 0x10, 0x10, 0x10,
//      s
        0x00, 0x00, 0x0E, 0x10, 0x0E, 0x01, 0x1E,
//      t
        0x08, 0x08, 0x1C, 0x08, 0x08, 0x09, 0x06,
//      u
        0x00, 0x00, 0x11, 0x11, 0x11, 0x13, 0x0D,
//      v
        0x00, 0x00, 0x11, 0x11, 0x11, 0x0A, 0x04,
//      w
        0x00, 0x00, 0x11, 0x11, 0x15, 0x15, 0x0A,
//      x
        0x00, 0x00, 0x11, 0x0A, 0x04, 0x0A, 0x11,
//      y
        0x00, 0x00, 0x11, 0x11, 0x0F, 0x01, 0x0E,
//      z
        0x00, 0x00, 0x1F, 0x02, 0x04, 0x08, 0x1F,
//      {
        0x02, 0x04, 0x04, 0x08, 0x04, 0x04, 0x02,
//      |
        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04,
//      }
        0x08, 0x04, 0x04, 0x02, 0x04, 0x04, 0x08,
//      ==>
        0x00, 0x04, 0x02, 0x1F, 0x02, 0x04, 0x00,
//      <==
        0x00, 0x04, 0x08, 0x1F, 0x08, 0x04, 0x00

};

const int XY_GAIN = 4;


//unsigned int int_map[] = { BLACK,    DARKGRAY,    RED,  BROWN,
//                           LIGHTRED, LIGHTMAGENTA,GREEN,LIGHTGREEN,
//                           LIGHTCYAN,YELLOW,    LIGHTGRAY, WHITE };

unsigned int int_map[] = { BLACK,    DARKGRAY,    RED,  BROWN,
                           LIGHTRED, LIGHTMAGENTA,GREEN,LIGHTGREEN,
                           LIGHTCYAN,YELLOW,      WHITE };

void Plot_color_scale(void)
{


    for(int c = 0; c < sizeof(int_map) / sizeof(int); c++)
    {
          setfillstyle(SOLID_FILL, int_map[c]);
          fillellipse(XY_GAIN / 2+XY_GAIN*c, XY_GAIN / 2, XY_GAIN / 2, XY_GAIN / 2);
    }
}


/* ===============================================================
=  font with : 720 sample.       = 40 chars ==> 1 char = 18 sample
=  font high : 10 of screen  ==> 287 lines / 10 ==> 29
=
=============================================================== */

enum { X_Sample = 200, X_dotsize = 3, Y_dotsize = 4,
       Font_with = 5,  Font_high = 7 };

enum { Max_intval = 200 };


// plot to screen
void Save_line(int line, unsigned char *Data)
{
    //

    enum { Color_scale = 1 + (Max_intval / (sizeof(int_map) / sizeof(int))) };
    int y_gain;
    for(y_gain = 0; y_gain < Y_dotsize; y_gain++)
    {
       unsigned char *tmp_Data = Data;
       int x;
       int x_pos = XY_GAIN;

       for(x = 0; x < X_Sample; x++, x_pos += XY_GAIN)
       {
           int Value     = *tmp_Data++;
           int Value_map = Value / Color_scale;
           int Color;
           if(Value_map >= (sizeof(int_map) / sizeof(int)))
               Value_map = (sizeof(int_map) / sizeof(int)) - 1;

           Color     = int_map[Value_map];
           setfillstyle(SOLID_FILL, Color);
           fillellipse(x_pos, 3*XY_GAIN + XY_GAIN*(line*Y_dotsize+y_gain), XY_GAIN / 2, XY_GAIN / 2);
       }
    }
    //if(line == (Font_high - 1))
    //    printf("\n%d %d %d ", db_1, db_2, (int)Color_scale);
}


void Filter_line(unsigned char *Data)
{
    unsigned char *t_Data;
    int x, i;

    // orginal filter
    //enum { file_lengch = 4 };
    //int              Data_delay      [file_lengch] = { 0,   0,   0, 0 };
    //static const int Data_tap_factors[file_lengch] = { 3,  12,  12, 3 };
    //enum { file_scale = 30 };

    // "speed" optimized filter
    enum { file_lengch = 4 };
    int              Data_delay      [file_lengch] = { 0,   0,   0, 0 };
    static const int Data_tap_factors[file_lengch] = { 3,  13,  13, 3 };
    enum { file_scale = 32 };

    int Insert_index = 0;

    for(x = 0, t_Data = Data; x < X_Sample; x++, t_Data++, Insert_index++ )
    {
        int File_index;
        long int sum = 0;
        if(Insert_index >= file_lengch)
            Insert_index = 0;

        File_index = Insert_index;
        Data_delay[Insert_index] = *t_Data;

        for(i = 0, sum = 0; i < file_lengch; i++)
        {
            File_index++;
            if(File_index >= file_lengch)
                File_index = 0;

            sum += (long)Data_delay[File_index] * (long)Data_tap_factors[i];
        }
        if(sum < 0)
            sum = 0;
        *t_Data = (sum + (file_scale / 2)) / file_scale;
    }
}

void dump_data(unsigned char *Data)
{
    FILE * log = fopen("now.log", "wt");
    int i;
    if(! log)
         return;

    for(i = 0; i < X_Sample; i++)
    {
        fprintf(log, "%d\n", (int)(*Data++));
    }

    fclose(log);

}


void Plot_Str(const unsigned char *const str)
{
    unsigned char tmp_line[X_Sample];
    int l;

    // build a line
    for(l = 0; l < Font_high; l++)
    {
        const unsigned char *cur_char = str;
        unsigned char *t_ptr;
        int x;

        // init tmp_line to zero
        for(x = 0, t_ptr = tmp_line; x < X_Sample; x++)
            *t_ptr++ = 0;

        t_ptr = tmp_line;
        for(; *cur_char; cur_char++)
        {
           char *gc_ptr;
           unsigned char char_Val = *cur_char;

           if(char_Val < ' ' || char_Val > 0x7F)
               char_Val = '?';

           char_Val -= ' ';   // start of char_gen[]

           gc_ptr = char_gen + 7 * char_Val + l;

           for(x = 0; x < (Font_with + 1); x++)
           {
                unsigned dot_val = (*gc_ptr << x) & 0x20;

                int x_gain;
                for(x_gain = 0; x_gain < X_dotsize; x_gain++)
                {
                    if(dot_val)
                        (*t_ptr++) += Max_intval;
                    else
                        t_ptr++;
                }
           }
        }
        Filter_line(tmp_line);
        // if(l == (Font_high - 1))
        //     dump_data(tmp_line);
        Save_line(l, tmp_line);
    }

}


int main(void)
{
   /* request auto detection */
   int gdriver = DETECT, gmode, errorcode;

   /* initialize graphics mode */
   initgraph(&gdriver, &gmode, "E:\\BC3\\BGI");

   /* read result of initialization */
   errorcode = graphresult();

   if (errorcode != grOk)  /* an error occurred */
   {
      printf("Graphics error: %s\n", grapherrormsg(errorcode));
      printf("Press any key to halt:");
      getch();
      exit(1);             /* return with error code */
   }

   setcolor(RED);
   setcolor(DARKGRAY);
   Plot_color_scale();

   Plot_Str("DK-A");
   //Plot_Str(0,4, "udio");

    char answer = getch();

   answer = answer;


   /* clean up */
   closegraph();

   printf("\n char gen tab size %d ", (int)sizeof(char_gen));
   return 0;
}



