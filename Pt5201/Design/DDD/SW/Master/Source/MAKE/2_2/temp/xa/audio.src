; XA C compiler v2.0 r2                   SN00085795-Ccz (c) 1998 TASKING, Inc.
; options: -A1 -Cxag3 -e -g -Ic:\cxa\include -I..\..\rtxcdef\xa
;          -I..\..\rtxc\xa\include -I..\..\code\include\1_0 -I..\..\app_spec\xa
;          -Ml -O2 -s
$CASE
$NOZPAGE
	NAME	AUDIO
	SYMB	TOOL, "XA C compiler v2.0", 1
	SYMB	TYPE, 256, "bit", 'g', 0, 1
	SYMB	FILE, "..\\..\\code\\audio\\1_1\\audio.c"
; audio.c     1	/****************************************************************************/
; audio.c     2	/* MODULE:                                                                  */
; audio.c     3	/*  audio.c - Audio 									                                 	    */
; audio.c     4	/****************************************************************************/
; audio.c     5	/* FUNCTIONS:                                                               */
; audio.c     6	/*                                                                          */
; audio.c     7	/* TASKS:                                                                   */
; audio.c     8	/*                                                                          */
; audio.c     9	/* NOTES:                                                                   */
; audio.c    10	/*                                                                          */
; audio.c    11	/****************************************************************************/
; audio.c    12	/*
; audio.c    13	 *   PTV software for PT5201
; audio.c    14	 *   Copyright (c) 
; audio.c    15	 *   ProTeleVision Technologies A/S.
; audio.c    16	 *   ALL RIGHTS RESERVED
; audio.c    17	*/
; audio.c    18	/****************************************************************************/
; audio.c    19	
; audio.c    20	#include "define.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\define.h"
	SYMB	ENDF
; audio.c    21	#include "rtxcobj.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\rtxcobj.h"
	SYMB	FILE, "..\\..\\rtxc\\xa\\include\\rtxcapi.h"
	SYMB	FILE, "..\\..\\rtxc\\xa\\include\\typedef.h"
	SYMB	FILE, "..\\..\\rtxc\\xa\\include\\rtxcopts.h"
	SYMB	ENDF
	SYMB	TYPE, 257, "KOBJNUM", 'T', #3
	SYMB	TYPE, 258, "TASK", 'T', #2
	SYMB	ENDF
	SYMB	FILE, "..\\..\\rtxc\\xa\\include\\rtxstruc.h"
	SYMB	FILE, "..\\..\\rtxc\\xa\\include\\rtxcopts.h"
	SYMB	ENDF
	SYMB	TYPE, 259, "KSNUM", 'T', #3
	SYMB	TYPE, 260, "PRIORITY", 'T', #258
	SYMB	TYPE, 261, "TSTATE", 'T', #5
	SYMB	TYPE, 262, "size_t", 'T', #18
	SYMB	TYPE, 263, "TSLICE", 'T', #3
	SYMB	TYPE, 265, 'n', #264, 130
	SYMB	TYPE, 266, 'P', #265
	SYMB	TYPE, 268, 'n', #267, 130
	SYMB	TYPE, 269, 'P', #268
	SYMB	TYPE, 270, 'n', #259, 130
	SYMB	TYPE, 271, 'P', #270
	SYMB	TYPE, 272, 'X', 12, #1, 30, 0
	SYMB	TYPE, 273, 'n', #272, 129
	SYMB	TYPE, 274, 'P', #273
	SYMB	TYPE, 275, "frame", 'S', 24,\
		 "es", #3, 0,\
		 "cs", #3, 1,\
		 "ssel", #3, 2,\
		 "ds", #3, 3,\
		 "pksnum", #271, 4,\
		 "R2", #18, 8,\
		 "R3", #18, 10,\
		 "R4", #18, 12,\
		 "R5", #18, 14,\
		 "R6", #18, 16,\
		 "psw", #18, 18,\
		 "pc", #274, 20
	SYMB	TYPE, 276, 'n', #275, 130
	SYMB	TYPE, 277, 'P', #276
	SYMB	TYPE, 278, 'X', 12, #1, 30, 0
	SYMB	TYPE, 279, 'n', #278, 129
	SYMB	TYPE, 280, 'P', #279
	SYMB	TYPE, 281, 'n', #2, 130
	SYMB	TYPE, 282, 'P', #281
	SYMB	TYPE, 283, 'n', #1, 130
	SYMB	TYPE, 284, 'P', #283
	SYMB	TYPE, 264, "tcb", 'S', 36,\
		 "flink", #266, 0,\
		 "blink", #266, 4,\
		 "pclkblk", #269, 8,\
		 "task", #258, 12,\
		 "priority", #260, 13,\
		 "sp", #277, 14,\
		 "status", #261, 18,\
		 "pc_t0", #280, 20,\
		 "stackbase", #282, 24,\
		 "stacksize", #262, 28,\
		 "tslice", #263, 30,\
		 "newslice", #263, 31,\
		 "arg", #284, 32
	SYMB	TYPE, 285, "TCB", 'T', #264
	SYMB	TYPE, 286, "SEMA", 'T', #257
	SYMB	TYPE, 287, "MAP", 'T', #257
	SYMB	TYPE, 289, 'n', #288, 130
	SYMB	TYPE, 290, 'P', #289
	SYMB	TYPE, 288, "rtxcmsg", 'S', 8,\
		 "link", #290, 0,\
		 "task", #258, 4,\
		 "priority", #260, 5,\
		 "sema", #286, 6
	SYMB	TYPE, 291, "RTXCMSG", 'T', #288
	SYMB	TYPE, 292, "TICKS", 'T', #16
	SYMB	TYPE, 293, 'N',\
		 "DELAY_OBJ", 0,\
		 "SEMAPHORE_OBJ", 1,\
		 "PARTITION_OBJ", 2,\
		 "QUEUE_OBJ", 3,\
		 "RESOURCE_OBJ", 4,\
		 "MAILBOX_OBJ", 5,\
		 "TIMER_OBJ", 6
	SYMB	TYPE, 294, "OBJTYPE", 'T', #293
	SYMB	TYPE, 267, "clkblk", 'S', 18,\
		 "flink", #269, 0,\
		 "blink", #269, 4,\
		 "remain", #292, 8,\
		 "recycle", #292, 10,\
		 "task", #258, 12,\
		 "state", #2, 13,\
		 "objtype", #294, 14,\
		 "objid", #257, 16
	SYMB	TYPE, 295, 'N',\
		 "PRIORITY_INVERSION_OFF", 0,\
		 "PRIORITY_INVERSION_ON", 1
	SYMB	TYPE, 296, "RESATTR", 'T', #295
	SYMB	ENDF
	SYMB	TYPE, 297, 'N',\
		 "RC_GOOD", 0,\
		 "RC_WAIT_CONFLICT", 1,\
		 "RC_NO_TIMERS", 2,\
		 "RC_TIMER_INACTIVE", 3,\
		 "RC_TIMER_ILLEGAL", 4,\
		 "RC_TIMEOUT", 5,\
		 "RC_QUEUE_FULL", 6,\
		 "RC_QUEUE_EMPTY", 7,\
		 "RC_ILLEGAL_QUEUE_SIZE", 8,\
		 "RC_BUSY", 9,\
		 "RC_NESTED", 10,\
		 "RC_ILLEGAL_TASK", 11,\
		 "RC_ACTIVE_TASK", 12,\
		 "RC_NO_YIELD", 13,\
		 "RC_MISSED_EVENT", 14
	SYMB	TYPE, 298, "KSRC", 'T', #297
	SYMB	TYPE, 299, "SSTATE", 'T', #258
	SYMB	TYPE, 300, "MBOX", 'T', #257
	SYMB	TYPE, 301, "QUEUE", 'T', #257
	SYMB	TYPE, 302, 'N',\
		 "QNE", 0,\
		 "QNF", 1,\
		 "QF", 2,\
		 "QE", 3
	SYMB	TYPE, 303, "QCOND", 'T', #302
	SYMB	TYPE, 304, "RESOURCE", 'T', #257
	SYMB	TYPE, 305, "CLKBLK", 'T', #267
	SYMB	TYPE, 306, "time_t", 'T', #6
	SYMB	TYPE, 307, "FRAME", 'T', #275
	SYMB	ENDF
	SYMB	FILE, "..\\..\\rtxcdef\\xa\\ctask.h"
	SYMB	ENDF
	SYMB	FILE, "..\\..\\rtxcdef\\xa\\csema.h"
	SYMB	ENDF
	SYMB	FILE, "..\\..\\rtxcdef\\xa\\cres.h"
	SYMB	ENDF
	SYMB	FILE, "..\\..\\rtxcdef\\xa\\cqueue.h"
	SYMB	ENDF
	SYMB	FILE, "..\\..\\rtxcdef\\xa\\cpart.h"
	SYMB	ENDF
	SYMB	FILE, "..\\..\\rtxcdef\\xa\\cmbox.h"
	SYMB	ENDF
	SYMB	FILE, "..\\..\\rtxcdef\\xa\\cclock.h"
	SYMB	ENDF
	SYMB	TYPE, 309, 'n', #308, 130
	SYMB	TYPE, 310, 'P', #309
	SYMB	TYPE, 308, 'X', 12, #1, 30, 2, #310, #282
	SYMB	TYPE, 312, 'n', #311, 129
	SYMB	TYPE, 313, 'P', #312
	SYMB	TYPE, 314, 'X', 12, #1, 30, 1, #310
	SYMB	TYPE, 315, 'n', #314, 129
	SYMB	TYPE, 316, 'P', #315
	SYMB	TYPE, 317, 'n', #6, 130
	SYMB	TYPE, 318, 'P', #317
	SYMB	TYPE, 317, 'X', 12, #16, 30, 2, #310, #318
	SYMB	TYPE, 320, 'n', #319, 129
	SYMB	TYPE, 321, 'P', #320
	SYMB	TYPE, 322, 'X', 12, #1, 30, 1, #310
	SYMB	TYPE, 323, 'n', #322, 129
	SYMB	TYPE, 324, 'P', #323
	SYMB	TYPE, 325, 'X', 12, #1, 30, 1, #310
	SYMB	TYPE, 326, 'n', #325, 129
	SYMB	TYPE, 327, 'P', #326
	SYMB	TYPE, 328, 'X', 12, #16, 30, 1, #310
	SYMB	TYPE, 329, 'n', #328, 129
	SYMB	TYPE, 330, 'P', #329
	SYMB	TYPE, 308, "TEvent", 'S', 32,\
		 "ObjectID", #16, 0,\
		 "TEvent", #313, 2,\
		 "_TEvent", #316, 6,\
		 "Wait", #321, 10,\
		 "Set", #324, 14,\
		 "Clear", #327, 18,\
		 "IsSet", #330, 22,\
		 "ID", #286, 26,\
		 "Name", #282, 28
	SYMB	TYPE, 331, "TEvent", 'T', #308
	SYMB	TYPE, 333, 'n', #332, 130
	SYMB	TYPE, 334, 'P', #333
	SYMB	TYPE, 332, 'X', 12, #1, 30, 1, #334
	SYMB	TYPE, 336, 'n', #335, 129
	SYMB	TYPE, 337, 'P', #336
	SYMB	TYPE, 338, 'X', 12, #1, 30, 1, #334
	SYMB	TYPE, 339, 'n', #338, 129
	SYMB	TYPE, 340, 'P', #339
	SYMB	TYPE, 341, 'n', #331, 130
	SYMB	TYPE, 342, 'P', #341
	SYMB	TYPE, 341, 'X', 12, #16, 30, 2, #334, #342
	SYMB	TYPE, 344, 'n', #343, 129
	SYMB	TYPE, 345, 'P', #344
	SYMB	TYPE, 346, 'X', 12, #1, 30, 2, #334, #342
	SYMB	TYPE, 347, 'n', #346, 129
	SYMB	TYPE, 348, 'P', #347
	SYMB	TYPE, 349, 'X', 12, #16, 30, 2, #334, #342
	SYMB	TYPE, 350, 'n', #349, 129
	SYMB	TYPE, 351, 'P', #350
	SYMB	TYPE, 352, 'X', 12, #342, 30, 2, #334, #318
	SYMB	TYPE, 353, 'n', #352, 129
	SYMB	TYPE, 354, 'P', #353
	SYMB	TYPE, 355, 'Z', #2, 95
	SYMB	TYPE, 332, "TEventList", 'S', 122,\
		 "ObjectID", #16, 0,\
		 "TEventList", #337, 2,\
		 "_TEventList", #340, 6,\
		 "Append", #345, 10,\
		 "Clear", #348, 14,\
		 "InList", #351, 18,\
		 "Wait", #354, 22,\
		 "Align", #355, 26
	SYMB	TYPE, 357, "TEventList", 'T', #332
	SYMB	TYPE, 359, 'n', #358, 130
	SYMB	TYPE, 360, 'P', #359
	SYMB	TYPE, 358, 'X', 12, #1, 30, 2, #360, #282
	SYMB	TYPE, 362, 'n', #361, 129
	SYMB	TYPE, 363, 'P', #362
	SYMB	TYPE, 364, 'X', 12, #1, 30, 1, #360
	SYMB	TYPE, 365, 'n', #364, 129
	SYMB	TYPE, 366, 'P', #365
	SYMB	TYPE, 367, 'X', 12, #1, 30, 1, #360
	SYMB	TYPE, 368, 'n', #367, 129
	SYMB	TYPE, 369, 'P', #368
	SYMB	TYPE, 370, 'X', 12, #1, 30, 1, #360
	SYMB	TYPE, 371, 'n', #370, 129
	SYMB	TYPE, 372, 'P', #371
	SYMB	TYPE, 373, 'X', 12, #16, 30, 1, #360
	SYMB	TYPE, 374, 'n', #373, 129
	SYMB	TYPE, 375, 'P', #374
	SYMB	TYPE, 358, "TResource", 'S', 28,\
		 "ObjectID", #16, 0,\
		 "TResource", #363, 2,\
		 "_TResource", #366, 6,\
		 "Lock", #369, 10,\
		 "Unlock", #372, 14,\
		 "Owner", #375, 18,\
		 "ID", #304, 22,\
		 "Name", #282, 24
	SYMB	TYPE, 376, "TResource", 'T', #358
	SYMB	TYPE, 377, 'X', 12, #1, 30, 0
	SYMB	TYPE, 378, 'n', #377, 129
	SYMB	TYPE, 379, 'P', #378
	SYMB	TYPE, 381, 'n', #380, 130
	SYMB	TYPE, 382, 'P', #381
	SYMB	TYPE, 377, 'X', 12, #1, 30, 3, #382, #16, #379
	SYMB	TYPE, 384, 'n', #383, 129
	SYMB	TYPE, 385, 'P', #384
	SYMB	TYPE, 386, 'X', 12, #1, 30, 1, #382
	SYMB	TYPE, 387, 'n', #386, 129
	SYMB	TYPE, 388, 'P', #387
	SYMB	TYPE, 389, 'X', 12, #1, 30, 1, #382
	SYMB	TYPE, 390, 'n', #389, 129
	SYMB	TYPE, 391, 'P', #390
	SYMB	TYPE, 392, 'X', 12, #1, 30, 2, #382, #16
	SYMB	TYPE, 393, 'n', #392, 129
	SYMB	TYPE, 394, 'P', #393
	SYMB	TYPE, 395, 'X', 12, #1, 30, 1, #382
	SYMB	TYPE, 396, 'n', #395, 129
	SYMB	TYPE, 397, 'P', #396
	SYMB	TYPE, 398, 'X', 12, #16, 30, 1, #382
	SYMB	TYPE, 399, 'n', #398, 129
	SYMB	TYPE, 400, 'P', #399
	SYMB	TYPE, 401, 'X', 12, #1, 30, 2, #382, #16
	SYMB	TYPE, 402, 'n', #401, 129
	SYMB	TYPE, 403, 'P', #402
	SYMB	TYPE, 380, "TThread", 'S', 36,\
		 "ObjectID", #16, 0,\
		 "TThread", #385, 2,\
		 "Execute", #388, 6,\
		 "Terminate", #391, 10,\
		 "Suspend", #394, 14,\
		 "Resume", #397, 18,\
		 "GetPriority", #400, 22,\
		 "SetPriority", #403, 26,\
		 "ID", #258, 30,\
		 "Status", #2, 31,\
		 "Stack", #282, 32
	SYMB	TYPE, 404, "TThread", 'T', #380
	SYMB	TYPE, 406, 'n', #405, 130
	SYMB	TYPE, 407, 'P', #406
	SYMB	TYPE, 405, 'X', 12, #1, 30, 1, #407
	SYMB	TYPE, 409, 'n', #408, 129
	SYMB	TYPE, 410, 'P', #409
	SYMB	TYPE, 411, 'X', 12, #1, 30, 1, #407
	SYMB	TYPE, 412, 'n', #411, 129
	SYMB	TYPE, 413, 'P', #412
	SYMB	TYPE, 414, 'X', 12, #1, 30, 2, #407, #16
	SYMB	TYPE, 415, 'n', #414, 129
	SYMB	TYPE, 416, 'P', #415
	SYMB	TYPE, 417, 'X', 12, #16, 30, 1, #407
	SYMB	TYPE, 418, 'n', #417, 129
	SYMB	TYPE, 419, 'P', #418
	SYMB	TYPE, 420, 'X', 12, #1, 30, 2, #407, #16
	SYMB	TYPE, 421, 'n', #420, 129
	SYMB	TYPE, 422, 'P', #421
	SYMB	TYPE, 423, 'n', #305, 130
	SYMB	TYPE, 424, 'P', #423
	SYMB	TYPE, 405, "TTimer", 'S', 32,\
		 "ObjectID", #16, 0,\
		 "TTimer", #410, 2,\
		 "_TTimer", #413, 6,\
		 "SetPeriod", #416, 10,\
		 "GetPeriod", #419, 14,\
		 "Tick", #422, 18,\
		 "TimeOut", #342, 22,\
		 "Period", #4, 26,\
		 "Handle", #424, 28
	SYMB	TYPE, 425, "TTimer", 'T', #405
	SYMB	TYPE, 427, 'n', #426, 130
	SYMB	TYPE, 428, 'P', #427
	SYMB	TYPE, 426, 'X', 12, #1, 30, 3, #428, #16, #16
	SYMB	TYPE, 430, 'n', #429, 129
	SYMB	TYPE, 431, 'P', #430
	SYMB	TYPE, 432, 'X', 12, #1, 30, 1, #428
	SYMB	TYPE, 433, 'n', #432, 129
	SYMB	TYPE, 434, 'P', #433
	SYMB	TYPE, 435, 'X', 12, #282, 30, 2, #428, #284
	SYMB	TYPE, 436, 'n', #435, 129
	SYMB	TYPE, 437, 'P', #436
	SYMB	TYPE, 438, 'X', 12, #1, 30, 2, #428, #284
	SYMB	TYPE, 439, 'n', #438, 129
	SYMB	TYPE, 440, 'P', #439
	SYMB	TYPE, 426, "TStream", 'S', 28,\
		 "ObjectID", #16, 0,\
		 "TStream", #431, 2,\
		 "_TStream", #434, 6,\
		 "Get", #437, 10,\
		 "Put", #440, 14,\
		 "ID", #301, 18,\
		 "Width", #16, 20,\
		 "Depth", #16, 22,\
		 "Handle", #282, 24
	SYMB	TYPE, 441, "TStream", 'T', #426
	SYMB	ENDF
; audio.c    22	#include "audio.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\audio.h"
	SYMB	TYPE, 442, 'S', 14,\
		 "System", #16, 0,\
		 "Signal", #16, 2,\
		 "Level", #16, 4,\
		 "Timing", #10, 6,\
		 "Frequency", #16, 10,\
		 "Click", #16, 12
	SYMB	TYPE, 443, "AudioObject", 'T', #442
	SYMB	ENDF
; audio.c    23	#include "led_hw.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\led_hw.h"
	SYMB	TYPE, 444, 'N',\
		 "true", -1,\
		 "false", 0
	SYMB	TYPE, 445, "bool", 'T', #444
	SYMB	ENDF
; audio.c    24	#include "tables.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\tables.h"
	SYMB	ENDF
; audio.c    25	#include "instru.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\instru.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\nv_drv.h"
	SYMB	TYPE, 446, "NvPointer", 'T', #18
	SYMB	ENDF
	SYMB	FILE, "..\\..\\code\\include\\1_0\\genlock.h"
	SYMB	TYPE, 447, 'S', 6,\
		 "System", #3, 0,\
		 "Delay", #7, 2
	SYMB	TYPE, 448, "GenlockObject", 'T', #447
	SYMB	ENDF
	SYMB	FILE, "..\\..\\code\\include\\1_0\\bb.h"
	SYMB	TYPE, 449, 'S', 8,\
		 "System", #3, 0,\
		 "Delay", #7, 2,\
		 "ScHPhase", #16, 6
	SYMB	TYPE, 450, "BBObject", 'T', #449
	SYMB	ENDF
	SYMB	FILE, "..\\..\\code\\include\\1_0\\cbar.h"
	SYMB	TYPE, 451, 'S', 12,\
		 "System", #3, 0,\
		 "Pattern", #18, 2,\
		 "Delay", #7, 4,\
		 "ScHPhase", #16, 8,\
		 "EmbAudioSignal", #3, 10
	SYMB	TYPE, 452, "CBObject", 'T', #451
	SYMB	ENDF
	SYMB	FILE, "..\\..\\code\\include\\1_0\\audio.h"
	SYMB	ENDF
	SYMB	TYPE, 453, 'S', 32,\
		 "Date", #7, 0,\
		 "DACFactDate", #7, 4,\
		 "DACUserDate", #7, 8,\
		 "DACFactValue", #18, 12,\
		 "DACUserValue", #18, 14,\
		 "HPHZeroG", #7, 16,\
		 "PhaseG", #7, 20,\
		 "HPHZeroM", #7, 24,\
		 "PhaseM", #7, 28
	SYMB	TYPE, 454, "GenlockCalibrationObject", 'T', #453
	SYMB	TYPE, 455, 'S', 20,\
		 "Date", #7, 0,\
		 "PhaseG", #7, 4,\
		 "ScHPhaseG", #18, 8,\
		 "PhaseM", #7, 10,\
		 "ScHPhaseM", #18, 14,\
		 "DACGain", #3, 16,\
		 "DACOffset", #3, 17,\
		 "DACLevel", #3, 18
	SYMB	TYPE, 456, "BBCalibrationObject", 'T', #455
	SYMB	TYPE, 457, 'S', 20,\
		 "Date", #7, 0,\
		 "PhaseG", #7, 4,\
		 "ScHPhaseG", #3, 8,\
		 "PhaseM", #7, 10,\
		 "ScHPhaseM", #3, 14,\
		 "GainG", #3, 15,\
		 "ChromaGainG", #3, 16,\
		 "GainM", #3, 17,\
		 "ChromaGainM", #3, 18
	SYMB	TYPE, 458, "CBCalibrationObject", 'T', #457
	SYMB	TYPE, 459, 'S', 6,\
		 "Date", #7, 0,\
		 "AnalogLeftChannel", #3, 4,\
		 "AnalogRightChannel", #3, 5
	SYMB	TYPE, 460, "AudioCalibrationObject", 'T', #459
	SYMB	TYPE, 461, 'Z', #450, 2
	SYMB	TYPE, 463, 'Z', #443, 1
	SYMB	TYPE, 465, 'S', 74,\
		 "ActivePreset", #16, 0,\
		 "GenlockSetup", #448, 2,\
		 "BBSetup", #461, 8,\
		 "CBSetup", #452, 32,\
		 "AudioOutput", #16, 44,\
		 "AudioSetup", #463, 46
	SYMB	TYPE, 466, "SettingsObject", 'T', #465
	SYMB	TYPE, 467, 'Z', #2, 32
	SYMB	TYPE, 469, 'Z', #2, 8
	SYMB	TYPE, 471, 'Z', #2, 12
	SYMB	TYPE, 473, 'Z', #456, 2
	SYMB	TYPE, 475, 'S', 224,\
		 "Company", #467, 0,\
		 "Type", #467, 33,\
		 "KUNumber", #469, 66,\
		 "SWRevision", #469, 75,\
		 "NC12", #471, 84,\
		 "ResetSystem", #3, 97,\
		 "ProdDate", #7, 98,\
		 "UpdateDate", #7, 102,\
		 "GenlockCalibration", #454, 106,\
		 "BBCalibration", #473, 138,\
		 "CBCalibration", #458, 198,\
		 "AudioCalibration", #460, 218
	SYMB	TYPE, 476, "CalibrationObject", 'T', #475
	SYMB	ENDF
; audio.c    26														
; audio.c    27	/**************************************************************************/
; audio.c    28	// The following definitions are based upon the document be PF:
; audio.c    29	//  "I/O-ports for controlling the audio generator in PT5201."
; audio.c    30	
; audio.c    31	// Audio Mode Select Port
; audio.c    32	#define AUDIOMODE			0x000F
; audio.c    33	#define CLICKPERIOD		0x0100
; audio.c    34	
; audio.c    35	#define	AESEBU500HZ48KHZ 					0
; audio.c    36	#define	AESEBU1000HZ48KHZ					1
; audio.c    37	#define	AESEBU1000HZCLICK48KHZ		2
; audio.c    38	#define	AESEBU8000HZ48KHZ					3
; audio.c    39	 
; audio.c    40	#define	AESEBU500HZ441KHZ					4
; audio.c    41	#define	AESEBU1000HZ441KHZ				5
; audio.c    42	#define	AESEBU1000HZCLICK441KHZ		6
; audio.c    43	#define	AESEBU8000HZ441KHZ				7
; audio.c    44	
; audio.c    45	#define	ANALOG500HZ								8
; audio.c    46	#define	ANALOG1000HZ							9
; audio.c    47	#define	ANALOG1000HZCLICK					10
; audio.c    48	#define	ANALOG8000HZ							11
; audio.c    49	
; audio.c    50	#define AESEBUF48KHZOFFSET				0
; audio.c    51	#define AESEBUF441KHZOFFSET				4
; audio.c    52	#define ANALOGAUDIOOFFSET					8
; audio.c    53	
; audio.c    54	// Audio Level Select Port
; audio.c    55	#define AESEBULEVEL		0x0007
; audio.c    56	#define ANALOGLEVEL		0x001F
; audio.c    57	#define AUDIOLEVEL		AESEBULEVEL | ANALOGLEVEL
; audio.c    58	
; audio.c    59	// Audio Control Select Port
; audio.c    60	#define POTMETERS			0x000F
; audio.c    61	#define POT_CLK				0x0001
; audio.c    62	#define POT_SDI				0x0002
; audio.c    63	#define POT_CSAU			0x0004
; audio.c    64	#define POT_CSCB			0x0008
; audio.c    65	#define SELAESEBU			0x0010
; audio.c    66	#define SELANALOG			0x0020
; audio.c    67	#define NTSCPHASE			0x0040
; audio.c    68	#define RELAYTYPE			0x0080
; audio.c    69	#define PLLLOCK				0x0100
; audio.c    70	#define VIDEOLOCK			0x0200
; audio.c    71	
; audio.c    72	// End of definitions
; audio.c    73	/**************************************************************************/
; audio.c    74	
; audio.c    75	code UI TimingValues[] = {
AUDIO_RO	SEGMENT	HCODE ROMDATA
	RSEG	AUDIO_RO
	SYMB	TYPE, 477, 'Z', #18, -1
	SYMB	IDEN, "TimingValues", _TimingValues, #477, 129, 0
	SYMB	ALAB, _TimingValues, #477
	PUBLIC	_TimingValues
	ALIGN	1
_TimingValues:
	DW	00001H,00016H,0002BH,00041H,00056H,0006CH,00082H,00097H
	DW	000ADH,000C2H,000D8H,000EEH,00103H,00119H,0012EH,00144H
	DW	0015AH,0016FH,00185H,0019AH,001B0H,001C6H,001DBH,001F1H
; audio.c    76		0x001,	// 0.0us
; audio.c    77		0x016,	// 0.8us
; audio.c    78		0x02B,  // 1.6us
; audio.c    79		0x041, 	// 2.4us
; audio.c    80		0x056,	// 3.2us
; audio.c    81		0x06C,	// 4.0us
; audio.c    82		0x082,  // 4.8us
; audio.c    83		0x097, 	// 5.6us
; audio.c    84		0x0AD,	// 6.4us
; audio.c    85		0x0C2,	// 7.2us
; audio.c    86		0x0D8, 	// 8.0us
; audio.c    87		0x0EE, 	// 8.8us
; audio.c    88		0x103,	// 9.6us
; audio.c    89		0x119,	// 10.4us
; audio.c    90		0x12E, 	// 11.2us
; audio.c    91		0x144, 	// 12.0us
; audio.c    92		0x15A,	// 12.8us
; audio.c    93		0x16F,	// 13.6us
; audio.c    94		0x185, 	// 14.4us
; audio.c    95		0x19A, 	// 15.2us
; audio.c    96		0x1B0,	// 16.0us
; audio.c    97		0x1C6,	// 16.8us
; audio.c    98		0x1DB, 	// 17.6us
; audio.c    99		0x1F1, 	// 18.4us
; audio.c   100		0x206,	// 19.2us
; audio.c   101		0x21C		// 20.0us
; audio.c   102	};
; audio.c   103	
; audio.c   104	int AudioOutput;
; audio.c   105	AudioObject AudioSetup[NoOfAudioOutputs];
; audio.c   106	
; audio.c   107	volatile int AudioModePort _at(0x70000); 				// Port defined in PLD
; audio.c   108	volatile int AudioLevelPort _at(0x70002); 	 		// Port defined in PLD
; audio.c   109	volatile int AudioTimingPort _at(0x70004); 			// Port defined in PLD
; audio.c   110	volatile int AudioControlPort _at(0x70006);  		// Port defined in PLD
; audio.c   111	
; audio.c   112	static int AudioMode;
; audio.c   113	static int AudioLevel;
; audio.c   114	static int AudioTiming;
; audio.c   115	static int AudioControl;
; audio.c   116	
; audio.c   117	/**************************************************************************/
; audio.c   118	/* Write_AD8402																								 	  AUDIO.C */
; audio.c   119	/*																																				*/
; audio.c   120	/* Author:	 Peter Frederiksen/Kim Engedahl, DEV, 000329									*/
; audio.c   121	/* Revised:	 000603, KEn, DEV     																				*/
; audio.c   122	/*																																				*/
; audio.c   123	/* Function:   																														*/
; audio.c   124	/* Remarks:	 The Altera PLD V8 should be loaded before calling this 			*/
; audio.c   125	/*					 function.		 																								*/
; audio.c   126	/* Returns:																																*/
; audio.c   127	/* Updates:																																*/
; audio.c   128	/**************************************************************************/
; audio.c   129	int Write_AD8402( UC potmeter, UC channel, UC data)
; audio.c   130	{
	DW	00206H,0021CH
AUDIO_PR	SEGMENT	HCODE
	RSEG	AUDIO_PR
	ALIGN	1
	SYMB	LINE, 130
	PUBLIC	_Write_AD8402
_Write_AD8402:
	SYMB	TYPE, 479, 'X', 12, #16, 30, 3, #3, #3, #3
	SYMB	GFUN, "Write_AD8402", _Write_AD8402, #479, 0, 0, 0
	SYMB	ALAB, _Write_AD8402, #479
	SYMB	LTIM, "potmeter", 0, 0, 2253
	SYMB	LTIM, "channel", 1, 0, 2253
	SYMB	LTIM, "data", 4, 0, 2253
	SYMB	IDEN, "potmeter", 0, #3, 0, 2061
	SYMB	IDEN, "channel", 1, #3, 0, 2061
	SYMB	IDEN, "data", 4, #3, 0, 2061
	SYMB	IDEN, "d", -1, #18, 130, 5
	SYMB	LTIM, "d", -1, 0, 69
	SYMB	IDEN, "n", -1, #18, 130, 5
	SYMB	LTIM, "n", -1, 0, 69
; audio.c   131		UI d, n;
; audio.c   132	
; audio.c   133		if ( channel > 1)
	SYMB	LINE, 133
	CMP.B	R0H,#01H
	BL	_3
; audio.c   134			return( FAIL);
	SYMB	LINE, 134
	MOV.W	R0,#00H
	SYMB	LTIM, "channel", 1, 0, 2125
	SYMB	LTIM, "potmeter", 0, 0, 2125
	RET
_3:
	SYMB	LTIM, "potmeter", 0, 0, 2253
	SYMB	LTIM, "channel", 1, 0, 2253
	SYMB	LTIM, "data", 4, 0, 2125
	SYMB	LTIM, "data", 4, 0, 2253
; audio.c   135	
; audio.c   136		switch ( potmeter)
	SYMB	LINE, 136
	CMP.B	R0L,#00H
	BEQ	_6
	CMP.B	R0L,#01H
	BEQ	_4
	BR	_5
; audio.c   137		{
; audio.c   138			case CBPotMeter:
; audio.c   139				AudioControl &= ~POT_CSCB;
; audio.c   140				break;
; audio.c   141	
; audio.c   142			case AudioPotMeter:
	SYMB	LINE, 142
_4:
; audio.c   143				AudioControl &= ~POT_CSAU;
	SYMB	LINE, 143
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R2,#SOF( _AudioControl )
	MOV.W	R2,[R2]
	AND.W	R2,#0FFFBH
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R3,#SOF( _AudioControl )
	MOV.W	[R3],R2
; audio.c   144				break;
	SYMB	LINE, 144
	BR	_7
; audio.c   145	
; audio.c   146			default:
	SYMB	LINE, 146
_5:
; audio.c   147				return( FAIL);
	SYMB	LINE, 147
	MOV.W	R0,#00H
	SYMB	LTIM, "channel", 1, 0, 2125
	SYMB	LTIM, "potmeter", 0, 0, 2125
	RET
	SYMB	LINE, 138
_6:
	SYMB	LTIM, "channel", 1, 0, 2253
	SYMB	LTIM, "data", 4, 0, 2125
	SYMB	LTIM, "data", 4, 0, 2253
	SYMB	LINE, 139
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R2,#SOF( _AudioControl )
	MOV.W	R2,[R2]
	AND.W	R2,#0FFF7H
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R3,#SOF( _AudioControl )
	MOV.W	[R3],R2
; audio.c   148		}
	SYMB	LINE, 148
_7:
; audio.c   149	
; audio.c   150		AudioControlPort = AudioControl;
	SYMB	LINE, 150
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R2,#SOF( _AudioControl )
	MOV.W	R2,[R2]
	MOV.B	ES,#SEG( _AudioControlPort )
	MOV.W	R3,#SOF( _AudioControlPort )
	MOV.W	[R3],R2
; audio.c   151	
; audio.c   152		d = ( channel * 0x100) + data;
	SYMB	LINE, 152
	MOV.B	R2L,R0H
	MOVS.B	R2H,#00H
	ASL.W	R2,#08H
	MOV.B	R0L,R1L
	MOVS.B	R0H,#00H
	SYMB	LTIM, "channel", 1, 0, 2125
	ADD.W	R2,R0
	SYMB	LTIM, "d", 10, 0, 205
; audio.c   153	
; audio.c   154		for ( n = 0x200; n > 0; n /= 2)
	SYMB	LINE, 154
	MOV.W	R1,#0200H
	SYMB	LTIM, "data", 4, 0, 2125
	SYMB	LTIM, "n", 6, 0, 205
_8:
; audio.c   155		{
; audio.c   156			AudioControl  &= ~POT_CLK;
	SYMB	LINE, 156
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R0,#SOF( _AudioControl )
	MOV.W	R0,[R0]
	AND.W	R0,#0FFFEH
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R3,#SOF( _AudioControl )
	MOV.W	[R3],R0
; audio.c   157			AudioControlPort = AudioControl;
	SYMB	LINE, 157
	MOV.B	ES,#SEG( _AudioControlPort )
	MOV.W	R3,#SOF( _AudioControlPort )
	MOV.W	[R3],R0
; audio.c   158			
; audio.c   159			if ( d & n)
	SYMB	LINE, 159
	MOV.W	R3,R2
	AND.W	R3,R1
	BEQ	_9
; audio.c   160				AudioControl |= POT_SDI;
	SYMB	LINE, 160
	OR.W	R0,#02H
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R3,#SOF( _AudioControl )
	MOV.W	[R3],R0
	BR	_10
_9:
; audio.c   161			else
; audio.c   162				AudioControl &= ~POT_SDI;
	SYMB	LINE, 162
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R0,#SOF( _AudioControl )
	MOV.W	R0,[R0]
	AND.W	R0,#0FFFDH
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R3,#SOF( _AudioControl )
	MOV.W	[R3],R0
_10:
; audio.c   163	
; audio.c   164			AudioControlPort = AudioControl;
	SYMB	LINE, 164
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R0,#SOF( _AudioControl )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioControlPort )
	MOV.W	R3,#SOF( _AudioControlPort )
	MOV.W	[R3],R0
; audio.c   165	
; audio.c   166			AudioControl |= POT_CLK;
	SYMB	LINE, 166
	OR.W	R0,#01H
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R3,#SOF( _AudioControl )
	MOV.W	[R3],R0
; audio.c   167			AudioControlPort = AudioControl;
	SYMB	LINE, 167
	MOV.B	ES,#SEG( _AudioControlPort )
	MOV.W	R3,#SOF( _AudioControlPort )
	MOV.W	[R3],R0
	SYMB	LINE, 154
	LSR.W	R1,#01H
	SYMB	LTIM, "n", 6, 0, 77
	SYMB	LTIM, "n", 6, 0, 205
	CMP.W	R1,#00H
	BG	_8
; audio.c   168		}
; audio.c   169	
; audio.c   170		AudioControl |= ( POT_CLK | POT_SDI | POT_CSAU | POT_CSCB);
	SYMB	LINE, 170
	OR.W	R0,#0FH
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R1,#SOF( _AudioControl )
	MOV.W	[R1],R0
; audio.c   171		AudioControlPort = AudioControl;
	SYMB	LINE, 171
	MOV.B	ES,#SEG( _AudioControlPort )
	MOV.W	R1,#SOF( _AudioControlPort )
	MOV.W	[R1],R0
; audio.c   172	
; audio.c   173		return( OK);
	SYMB	LINE, 173
	MOV.W	R0,#0FFFFH
; audio.c   174	}
	SYMB	LINE, 174
_12:
	RET
	SYMB	LTIM, "n", 6, 0, 77
	SYMB	LTIM, "d", 10, 0, 77
	SYMB	EFUN
; audio.c   175	
; audio.c   176	/**************************************************************************/
; audio.c   177	/* WriteAnlAudioDACLevel																			 	  AUDIO.C */
; audio.c   178	/*																																				*/
; audio.c   179	/* Author:	 Kim Engedahl, DEV, 000504																		*/
; audio.c   180	/* Revised:	 000603, KEn, DEV     																				*/
; audio.c   181	/*																																				*/
; audio.c   182	/* Function:   																														*/
; audio.c   183	/* Remarks:	 																															*/
; audio.c   184	/* Returns:																																*/
; audio.c   185	/* Updates:																																*/
; audio.c   186	/**************************************************************************/
; audio.c   187	int WriteAnlAudioDACLevel( UC left, UC right)
; audio.c   188	{	
	ALIGN	1
	SYMB	LINE, 188
	PUBLIC	_WriteAnlAudioDACLevel
_WriteAnlAudioDACLevel:
	SYMB	TYPE, 480, 'X', 12, #16, 30, 2, #3, #3
	SYMB	GFUN, "WriteAnlAudioDACLevel", _WriteAnlAudioDACLevel, #480, 0, 0, 16
	SYMB	ALAB, _WriteAnlAudioDACLevel, #480
	PUSH.W	R4
	SYMB	SOFF, 2
	ADDS.W	R7,#0EH
	SYMB	SOFF, 4
	SYMB	LTIM, "left", 0, 0, 2253
	SYMB	LTIM, "right", 1, 0, 2253
	MOV.B	R4L,R0H
	SYMB	LTIM, "right", 1, 0, 2125
	SYMB	LTIM, "right", 16, 0, 2253
	SYMB	IDEN, "left", 0, #3, 0, 2061
	SYMB	IDEN, "right", 16, #3, 0, 2061
; audio.c   189		Write_AD8402( AudioPotMeter, AnlAudioLeftChannel, left);
	SYMB	LINE, 189
	MOV.B	R0H,#00H
	MOV.B	R1L,#01H
	MOV.B	[R7],R0L
	SYMB	LTIM, "left", 0, 0, 2125
	SYMB	LTIM, "left", -4, 130, 2245
	MOV.B	R0L,R1L
	MOV.B	R1L,[R7]
	CALL	_Write_AD8402
	SYMB	LTIM, "left", -4, 130, 2117
	SYMB	LTIM, "left", 4, 0, 2253
	SYMB	LTIM, "left", 4, 0, 2125
; audio.c   190		Write_AD8402( AudioPotMeter, AnlAudioRightChannel, right);
	SYMB	LINE, 190
	MOV.B	R0L,#01H
	MOV.B	R1L,R4L
	MOV.B	R0H,#01H
	CALL	_Write_AD8402
	SYMB	LTIM, "right", 16, 0, 2125
	SYMB	LTIM, "right", 4, 0, 2253
	SYMB	LTIM, "right", 4, 0, 2125
; audio.c   191	
; audio.c   192		return( OK);
	SYMB	LINE, 192
	MOV.W	R0,#0FFFFH
; audio.c   193	}
	SYMB	LINE, 193
	ADDS.W	R7,#02H
	SYMB	SOFF, 2
	POP.W	R4
	SYMB	SOFF, 0
	RET
	SYMB	EFUN
; audio.c   194	
; audio.c   195	/**************************************************************************/
; audio.c   196	/* AudioDefaults																							 	  AUDIO.C */
; audio.c   197	/*																																				*/
; audio.c   198	/* Author:	 Kim Engedahl, DEV, 000526																		*/
; audio.c   199	/* Revised:	 000617, KEn, DEV     																				*/
; audio.c   200	/*																																				*/
; audio.c   201	/* Function:   																														*/
; audio.c   202	/* Remarks:	 																															*/
; audio.c   203	/* Returns:																																*/
; audio.c   204	/* Updates:																																*/
; audio.c   205	/**************************************************************************/
; audio.c   206	void AudioDefaults( void)
; audio.c   207	{	
	ALIGN	1
	SYMB	LINE, 207
	PUBLIC	_AudioDefaults
_AudioDefaults:
	SYMB	TYPE, 481, 'X', 12, #1, 30, 0
	SYMB	GFUN, "AudioDefaults", _AudioDefaults, #481, 0, 0, 112
	SYMB	ALAB, _AudioDefaults, #481
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
; audio.c   208		Settings.AudioOutput = AudioOutput = AESEBUAudio;
	SYMB	LINE, 208
	MOV.B	ES,#SEG( _AudioOutput )
	MOV.W	R0,#SOF( _AudioOutput )
	MOV.W	[R0],#01H
	MOV.B	ES,#SEG( _Settings+44 )
	MOV.W	R0,#SOF( _Settings+44 )
	MOV.W	[R0],#01H
; audio.c   209	
; audio.c   210		if ( Calibration.ResetSystem < NTSC)
	SYMB	LINE, 210
	MOV.B	ES,#SEG( _Calibration+97 )
	MOV.W	R0,#SOF( _Calibration+97 )
	MOV.B	R0L,[R0]
	CMP.B	R0L,#02H
	BCC	_15
; audio.c   211			Settings.AudioSetup[AESEBUAudio].System = AudioSetup[AESEBUAudio].System = AudioPAL;
	SYMB	LINE, 211
	MOV.B	ES,#SEG( _AudioSetup+14 )
	MOV.W	R0,#SOF( _AudioSetup+14 )
	MOV.W	[R0],#00H
	MOV.B	ES,#SEG( _Settings+60 )
	MOV.W	R0,#SOF( _Settings+60 )
	MOV.W	[R0],#00H
	BR	_16
_15:
; audio.c   212		else
; audio.c   213			Settings.AudioSetup[AESEBUAudio].System = AudioSetup[AESEBUAudio].System = AudioNTSC;
	SYMB	LINE, 213
	MOV.B	ES,#SEG( _AudioSetup+14 )
	MOV.W	R0,#SOF( _AudioSetup+14 )
	MOV.W	[R0],#01H
	MOV.B	ES,#SEG( _Settings+60 )
	MOV.W	R0,#SOF( _Settings+60 )
	MOV.W	[R0],#01H
_16:
; audio.c   214	
; audio.c   215		Settings.AudioSetup[AESEBUAudio].Signal = AudioSetup[AESEBUAudio].Signal = S1kHz;
	SYMB	LINE, 215
	MOV.B	ES,#SEG( _AudioSetup+16 )
	MOV.W	R0,#SOF( _AudioSetup+16 )
	MOV.W	[R0],#01H
	MOV.B	ES,#SEG( _Settings+62 )
	MOV.W	R0,#SOF( _Settings+62 )
	MOV.W	[R0],#01H
; audio.c   216		Settings.AudioSetup[AESEBUAudio].Level = AudioSetup[AESEBUAudio].Level = 0;
	SYMB	LINE, 216
	MOV.B	ES,#SEG( _AudioSetup+18 )
	MOV.W	R0,#SOF( _AudioSetup+18 )
	MOV.W	[R0],#00H
	MOV.B	ES,#SEG( _Settings+64 )
	MOV.W	R0,#SOF( _Settings+64 )
	MOV.W	[R0],#00H
; audio.c   217		Settings.AudioSetup[AESEBUAudio].Timing = AudioSetup[AESEBUAudio].Timing = TimingValues[0];
	SYMB	LINE, 217
	MOV.B	CS,#SEG( _TimingValues )
	MOV.W	R1,#SOF( _TimingValues )
	MOVC.W	R0,[R1+]
	FCALL	__US2SPF
	MOV.B	ES,#SEG( _AudioSetup+20 )
	MOV.W	R2,#SOF( _AudioSetup+20 )
	MOV.W	[R2+],R0
	MOV.W	[R2],R1
	MOV.B	ES,#SEG( _Settings+66 )
	MOV.W	R2,#SOF( _Settings+66 )
	MOV.W	[R2+],R0
	MOV.W	[R2],R1
; audio.c   218		Settings.AudioSetup[AESEBUAudio].Click = AudioSetup[AESEBUAudio].Click = click3s;
	SYMB	LINE, 218
	MOV.B	ES,#SEG( _AudioSetup+26 )
	MOV.W	R0,#SOF( _AudioSetup+26 )
	MOV.W	[R0],#03H
	MOV.B	ES,#SEG( _Settings+72 )
	MOV.W	R0,#SOF( _Settings+72 )
	MOV.W	[R0],#03H
; audio.c   219		Settings.AudioSetup[AESEBUAudio].Frequency = AudioSetup[AESEBUAudio].Frequency = f48kHz;
	SYMB	LINE, 219
	MOV.B	ES,#SEG( _AudioSetup+24 )
	MOV.W	R0,#SOF( _AudioSetup+24 )
	MOV.W	[R0],#01H
	MOV.B	ES,#SEG( _Settings+70 )
	MOV.W	R0,#SOF( _Settings+70 )
	MOV.W	[R0],#01H
; audio.c   220	
; audio.c   221		Settings.AudioSetup[AnalogAudio].Signal = AudioSetup[AnalogAudio].Signal = S1kHz;
	SYMB	LINE, 221
	MOV.B	ES,#SEG( _AudioSetup+2 )
	MOV.W	R0,#SOF( _AudioSetup+2 )
	MOV.W	[R0],#01H
	MOV.B	ES,#SEG( _Settings+48 )
	MOV.W	R0,#SOF( _Settings+48 )
	MOV.W	[R0],#01H
; audio.c   222		Settings.AudioSetup[AnalogAudio].Level = AudioSetup[AnalogAudio].Level = 0; 
	SYMB	LINE, 222
	MOV.B	ES,#SEG( _AudioSetup+4 )
	MOV.W	R0,#SOF( _AudioSetup+4 )
	MOV.W	[R0],#00H
	MOV.B	ES,#SEG( _Settings+50 )
	MOV.W	R0,#SOF( _Settings+50 )
	MOV.W	[R0],#00H
; audio.c   223		Settings.AudioSetup[AnalogAudio].Click = AudioSetup[AnalogAudio].Click = click3s;
	SYMB	LINE, 223
	MOV.B	ES,#SEG( _AudioSetup+12 )
	MOV.W	R0,#SOF( _AudioSetup+12 )
	MOV.W	[R0],#03H
	MOV.B	ES,#SEG( _Settings+58 )
	MOV.W	R0,#SOF( _Settings+58 )
	MOV.W	[R0],#03H
; audio.c   224	
; audio.c   225		NV_Store( &Settings, SettingsPtr, sizeof( Settings));
	SYMB	LINE, 225
	MOV.W	R1,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.B	ES,#SEG( _SettingsPtr )
	MOV.W	R2,#SOF( _SettingsPtr )
	MOV.W	R2,[R2]
	MOV.W	R3,#04AH
	CALL	_NV_Store
; audio.c   226	}
	SYMB	LINE, 226
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	EFUN
; audio.c   227	
; audio.c   228	/**************************************************************************/
; audio.c   229	/* AudioInit																									 	  AUDIO.C */
; audio.c   230	/*																																				*/
; audio.c   231	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   232	/* Revised:	 000617, KEn, DEV     																				*/
; audio.c   233	/*																																				*/
; audio.c   234	/* Function:   																														*/
; audio.c   235	/* Remarks:	 																															*/
; audio.c   236	/* Returns:																																*/
; audio.c   237	/* Updates:																																*/
; audio.c   238	/**************************************************************************/
; audio.c   239	int AudioInit( void)
; audio.c   240	{	
	ALIGN	1
	SYMB	LINE, 240
	PUBLIC	_AudioInit
_AudioInit:
	SYMB	TYPE, 482, 'X', 12, #16, 30, 0
	SYMB	GFUN, "AudioInit", _AudioInit, #482, 0, 0, 0
	SYMB	ALAB, _AudioInit, #482
; audio.c   241		WriteAnlAudioDACLevel( Calibration.AudioCalibration.AnalogLeftChannel,
; audio.c   242											    	  Calibration.AudioCalibration.AnalogRightChannel);
	SYMB	LINE, 242
	MOV.B	ES,#SEG( _Calibration+222 )
	MOV.W	R0,#SOF( _Calibration+222 )
	MOV.B	R0L,[R0]
	MOV.B	ES,#SEG( _Calibration+223 )
	MOV.W	R1,#SOF( _Calibration+223 )
	MOV.B	R0H,[R1]
	CALL	_WriteAnlAudioDACLevel
; audio.c   243	
; audio.c   244		AudioSetup[AESEBUAudio].System = Settings.AudioSetup[AESEBUAudio].System;
	SYMB	LINE, 244
	MOV.B	ES,#SEG( _Settings+60 )
	MOV.W	R0,#SOF( _Settings+60 )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioSetup+14 )
	MOV.W	R1,#SOF( _AudioSetup+14 )
	MOV.W	[R1],R0
; audio.c   245		AudioSetup[AESEBUAudio].Signal = Settings.AudioSetup[AESEBUAudio].Signal;
	SYMB	LINE, 245
	MOV.B	ES,#SEG( _Settings+62 )
	MOV.W	R0,#SOF( _Settings+62 )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioSetup+16 )
	MOV.W	R1,#SOF( _AudioSetup+16 )
	MOV.W	[R1],R0
; audio.c   246		AudioSetup[AESEBUAudio].Level = Settings.AudioSetup[AESEBUAudio].Level;
	SYMB	LINE, 246
	MOV.B	ES,#SEG( _Settings+64 )
	MOV.W	R0,#SOF( _Settings+64 )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioSetup+18 )
	MOV.W	R1,#SOF( _AudioSetup+18 )
	MOV.W	[R1],R0
; audio.c   247		AudioSetup[AESEBUAudio].Timing = Settings.AudioSetup[AESEBUAudio].Timing;
	SYMB	LINE, 247
	MOV.B	ES,#SEG( _Settings+66 )
	MOV.W	R1,#SOF( _Settings+66 )
	MOV.W	R0,[R1+]
	MOV.W	R1,[R1]
	MOV.B	ES,#SEG( _AudioSetup+20 )
	MOV.W	R2,#SOF( _AudioSetup+20 )
	MOV.W	[R2+],R0
	MOV.W	[R2],R1
; audio.c   248		AudioSetup[AESEBUAudio].Click = Settings.AudioSetup[AESEBUAudio].Click;
	SYMB	LINE, 248
	MOV.B	ES,#SEG( _Settings+72 )
	MOV.W	R0,#SOF( _Settings+72 )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioSetup+26 )
	MOV.W	R1,#SOF( _AudioSetup+26 )
	MOV.W	[R1],R0
; audio.c   249		AudioSetup[AESEBUAudio].Frequency = Settings.AudioSetup[AESEBUAudio].Frequency;
	SYMB	LINE, 249
	MOV.B	ES,#SEG( _Settings+70 )
	MOV.W	R0,#SOF( _Settings+70 )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioSetup+24 )
	MOV.W	R1,#SOF( _AudioSetup+24 )
	MOV.W	[R1],R0
; audio.c   250	
; audio.c   251		AudioSetup[AnalogAudio].Signal = Settings.AudioSetup[AnalogAudio].Signal;
	SYMB	LINE, 251
	MOV.B	ES,#SEG( _Settings+48 )
	MOV.W	R0,#SOF( _Settings+48 )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioSetup+2 )
	MOV.W	R1,#SOF( _AudioSetup+2 )
	MOV.W	[R1],R0
; audio.c   252		AudioSetup[AnalogAudio].Level = Settings.AudioSetup[AnalogAudio].Level;
	SYMB	LINE, 252
	MOV.B	ES,#SEG( _Settings+50 )
	MOV.W	R0,#SOF( _Settings+50 )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioSetup+4 )
	MOV.W	R1,#SOF( _AudioSetup+4 )
	MOV.W	[R1],R0
; audio.c   253		AudioSetup[AnalogAudio].Click = Settings.AudioSetup[AnalogAudio].Click;
	SYMB	LINE, 253
	MOV.B	ES,#SEG( _Settings+58 )
	MOV.W	R0,#SOF( _Settings+58 )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioSetup+12 )
	MOV.W	R1,#SOF( _AudioSetup+12 )
	MOV.W	[R1],R0
; audio.c   254	
; audio.c   255		// NOTE!! WordClock is NOT defined for the analog audio, hence it is necessary
; audio.c   256		//  to ensure that either of the front WordClock LEDs is switched on if
; audio.c   257		//  the PT5201 is to start in analog audio mode, i.e. the wordclock LEDs is
; audio.c   258		//  updated with the state of the AESEBU audio wordclock even though analog audio
; audio.c   259		//  is selected.
; audio.c   260		LEDSet( WordClk441LED, AudioSetup[AESEBUAudio].Frequency == f441kHz);	
	SYMB	LINE, 260
	MOV.W	R0,#01000H
	MOV.B	ES,#SEG( _AudioSetup+24 )
	MOV.W	R1,#SOF( _AudioSetup+24 )
	MOV.W	R1,[R1]
	BNE	_18
	MOVS.W	R1,#01H
	BR	_19
_18:
	MOVS.W	R1,#00H
_19:
	CALL	_LEDSet
; audio.c   261		LEDSet( WordClk48LED, AudioSetup[AESEBUAudio].Frequency == f48kHz);
	SYMB	LINE, 261
	MOV.W	R0,#02000H
	MOV.B	ES,#SEG( _AudioSetup+24 )
	MOV.W	R1,#SOF( _AudioSetup+24 )
	MOV.W	R1,[R1]
	CMP.W	R1,#01H
	BNE	_20
	MOVS.W	R1,#01H
	BR	_22
_20:
	MOVS.W	R1,#00H
_22:
	CALL	_LEDSet
; audio.c   262	
; audio.c   263		return( 0);
	SYMB	LINE, 263
	MOV.W	R0,#00H
; audio.c   264	}
	SYMB	LINE, 264
	RET
	SYMB	EFUN
; audio.c   265	
; audio.c   266	/**************************************************************************/
; audio.c   267	/* AudioUpdate																								 	  AUDIO.C */
; audio.c   268	/*																																				*/
; audio.c   269	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   270	/* Revised:	 000628, KEn, DEV     																				*/
; audio.c   271	/*																																				*/
; audio.c   272	/* Function:   																														*/
; audio.c   273	/* Remarks:	 																															*/
; audio.c   274	/* Returns:																																*/
; audio.c   275	/* Updates:																																*/
; audio.c   276	/**************************************************************************/
; audio.c   277	int AudioUpdate( void)
; audio.c   278	{
	ALIGN	1
	SYMB	LINE, 278
	PUBLIC	_AudioUpdate
_AudioUpdate:
	SYMB	TYPE, 483, 'X', 12, #16, 30, 0
	SYMB	GFUN, "AudioUpdate", _AudioUpdate, #483, 0, 0, 0
	SYMB	ALAB, _AudioUpdate, #483
; audio.c   279	 	SetAudioOutput( Settings.AudioOutput);
	SYMB	LINE, 279
	MOV.B	ES,#SEG( _Settings+44 )
	MOV.W	R0,#SOF( _Settings+44 )
	MOV.W	R0,[R0]
	CALL	_SetAudioOutput
; audio.c   280	
; audio.c   281		return( OK);
	SYMB	LINE, 281
	MOV.W	R0,#0FFFFH
; audio.c   282	}
	SYMB	LINE, 282
	RET
	SYMB	EFUN
; audio.c   283	
; audio.c   284	/**************************************************************************/
; audio.c   285	/* AudioStatus																								 	  AUDIO.C */
; audio.c   286	/*																																				*/
; audio.c   287	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   288	/* Revised:	 000628, KEn, DEV     																				*/
; audio.c   289	/*																																				*/
; audio.c   290	/* Function:   																														*/
; audio.c   291	/* Remarks:	 																															*/
; audio.c   292	/* Returns:																																*/
; audio.c   293	/* Updates:																																*/
; audio.c   294	/**************************************************************************/
; audio.c   295	UC AudioStatus( void)
; audio.c   296	{
	ALIGN	1
	SYMB	LINE, 296
	PUBLIC	_AudioStatus
_AudioStatus:
	SYMB	TYPE, 484, 'X', 12, #3, 30, 0
	SYMB	GFUN, "AudioStatus", _AudioStatus, #484, 0, 0, 0
	SYMB	ALAB, _AudioStatus, #484
; audio.c   297		return(( AudioControlPort >> 8) && 0xFC);
	SYMB	LINE, 297
	MOV.B	ES,#SEG( _AudioControlPort )
	MOV.W	R0,#SOF( _AudioControlPort )
	MOV.W	R0,[R0]
	ASR.W	R0,#08H
	OR.W	R0,R0
	BEQ	_23
	MOV.B	R0L,#0FCH
_23:
	BEQ	_24
	MOVS.B	R0L,#01H
	BR	_25
_24:
	MOVS.B	R0L,#00H
_25:
; audio.c   298	 }
	SYMB	LINE, 298
	RET
	SYMB	EFUN
; audio.c   299	
; audio.c   300	/**************************************************************************/
; audio.c   301	/* SetAudioOutput																							 	  AUDIO.C */
; audio.c   302	/*																																				*/
; audio.c   303	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   304	/* Revised:	 000618, KEn, DEV     																				*/
; audio.c   305	/*																																				*/
; audio.c   306	/* Function:   																														*/
; audio.c   307	/* Remarks:	 																															*/
; audio.c   308	/* Returns:																																*/
; audio.c   309	/* Updates:																																*/
; audio.c   310	/**************************************************************************/
; audio.c   311	int SetAudioOutput( int output)
; audio.c   312	{
	ALIGN	1
	SYMB	LINE, 312
	PUBLIC	_SetAudioOutput
_SetAudioOutput:
	SYMB	TYPE, 485, 'X', 12, #16, 30, 1, #16
	SYMB	GFUN, "SetAudioOutput", _SetAudioOutput, #485, 0, 0, 112
	SYMB	ALAB, _SetAudioOutput, #485
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	ADDS.W	R7,#0EH
	SYMB	SOFF, 8
	SYMB	LTIM, "output", 2, 0, 2253
	SYMB	IDEN, "output", 2, #16, 0, 2061
; audio.c   313		Settings.ActivePreset = 0;
	SYMB	LINE, 313
	MOV.B	ES,#SEG( _Settings )
	MOV.W	R1,#SOF( _Settings )
	MOV.W	[R1],#00H
; audio.c   314	
; audio.c   315		Settings.AudioOutput = AudioOutput = output;
	SYMB	LINE, 315
	MOV.W	R4,R0
	MOV.B	ES,#SEG( _AudioOutput )
	MOV.W	R0,#SOF( _AudioOutput )
	MOV.W	[R0],R4
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", 18, 0, 2253
	MOV.B	ES,#SEG( _Settings+44 )
	MOV.W	R0,#SOF( _Settings+44 )
	MOV.W	[R0],R4
; audio.c   316		NV_Store( &Settings, SettingsPtr, sizeof( Settings));
	SYMB	LINE, 316
	MOV.W	R1,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.B	ES,#SEG( _SettingsPtr )
	MOV.W	R2,#SOF( _SettingsPtr )
	MOV.W	R2,[R2]
	MOV.W	R3,#04AH
	CALL	_NV_Store
; audio.c   317	
; audio.c   318		if ( output == AnalogAudio)
	SYMB	LINE, 318
	OR.W	R4,R4
	BNE	_26
; audio.c   319			AudioControl |= SELANALOG;			// Select analog output
	SYMB	LINE, 319
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R0,#SOF( _AudioControl )
	MOV.W	R0,[R0]
	OR.W	R0,#020H
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R1,#SOF( _AudioControl )
	MOV.W	[R1],R0
	BR	_27
_26:
; audio.c   320		else
; audio.c   321			AudioControl |= SELAESEBU;			// Select AES/EBU output
	SYMB	LINE, 321
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R0,#SOF( _AudioControl )
	MOV.W	R0,[R0]
	OR.W	R0,#010H
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R1,#SOF( _AudioControl )
	MOV.W	[R1],R0
_27:
; audio.c   322	
; audio.c   323		AudioControlPort = AudioControl; 	// Select output mode. The output selection
	SYMB	LINE, 323
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R0,#SOF( _AudioControl )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioControlPort )
	MOV.W	R1,#SOF( _AudioControlPort )
	MOV.W	[R1],R0
; audio.c   324																		 	//  requires the generation of a 50ms pulse.
; audio.c   325	
; audio.c   326		Sleep( 50);											 	// Sleep for 50 ms
	SYMB	LINE, 326
	MOV.W	R0,#032H
	CALL	_Sleep
; audio.c   327	
; audio.c   328		AudioControl &= ~( SELANALOG + SELAESEBU);	// End of 50ms pulse
	SYMB	LINE, 328
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R0,#SOF( _AudioControl )
	MOV.W	R0,[R0]
	AND.W	R0,#0FFCFH
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R1,#SOF( _AudioControl )
	MOV.W	[R1],R0
; audio.c   329	
; audio.c   330																					// Update output variable and LEDs
; audio.c   331		LEDSet( AnalogAudioLED, output == AnalogAudio);
	SYMB	LINE, 331
	MOV.W	R0,#0100H
	OR.W	R4,R4
	BNE	_28
	MOVS.W	R1,#01H
	BR	_29
_28:
	MOVS.W	R1,#00H
_29:
	CALL	_LEDSet
; audio.c   332		LEDSet( AESEBUAudioLED, output == AESEBUAudio);
	SYMB	LINE, 332
	MOV.W	R0,#0200H
	CMP.W	R4,#01H
	BNE	_30
	MOVS.W	R1,#01H
	BR	_32
_30:
	MOVS.W	R1,#00H
_32:
	CALL	_LEDSet
; audio.c   333	
; audio.c   334		SetAudioSystem( output, AudioSetup[output].System);
	SYMB	LINE, 334
	MOV.W	R0,#0EH
	MULU.W	R0,R4
	MOV.W	R6,R0
	MOV.W	R0,R6
	MOVS.W	R1,#00H
	MOV.B	ES,#SEG( _AudioSetup )
	MOV.W	R1,[R0+SOF( _AudioSetup )]
	MOV.W	[R7],R4
	MOV.W	R0,R4
	SYMB	LTIM, "output", 18, 0, 2125
	SYMB	LTIM, "output", -8, 130, 2245
	SYMB	LTIM, "output", -8, 130, 2117
	SYMB	LTIM, "output", 2, 0, 2253
	CALL	_SetAudioSystem
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", -8, 130, 2245
; audio.c   335		SetAudioSignal( output, AudioSetup[output].Signal);
	SYMB	LINE, 335
	MOV.W	R4,R6
	MOVS.W	R5,#00H
	MOV.B	ES,#SEG( _AudioSetup+2 )
	MOV.W	R1,[R4+SOF( _AudioSetup+2 )]
	MOV.W	R0,[R7]
	SYMB	LTIM, "output", -8, 130, 2117
	SYMB	LTIM, "output", 2, 0, 2253
	CALL	_SetAudioSignal
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", -8, 130, 2245
; audio.c   336		SetAudioLevel( output, AudioSetup[output].Level);
	SYMB	LINE, 336
	MOV.B	ES,#SEG( _AudioSetup+4 )
	MOV.W	R1,[R4+SOF( _AudioSetup+4 )]
	MOV.W	R0,[R7]
	SYMB	LTIM, "output", -8, 130, 2117
	SYMB	LTIM, "output", 2, 0, 2253
	CALL	_SetAudioLevel
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", -8, 130, 2245
; audio.c   337		SetAudioTiming( output, AudioSetup[output].Timing);
	SYMB	LINE, 337
	MOV.W	R2,R6
	MOVS.W	R3,#00H
	MOV.B	ES,#SEG( _AudioSetup+6 )
	MOV.W	R3,[R2+SOF( _AudioSetup+8 )]
	MOV.W	R2,[R2+SOF( _AudioSetup+6 )]
	MOV.W	R0,[R7]
	SYMB	LTIM, "output", -8, 130, 2117
	SYMB	LTIM, "output", 2, 0, 2253
	CALL	_SetAudioTiming
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", -8, 130, 2245
; audio.c   338		SetAudioWordClock( output, AudioSetup[output].Frequency);
	SYMB	LINE, 338
	MOV.B	ES,#SEG( _AudioSetup+10 )
	MOV.W	R1,[R4+SOF( _AudioSetup+10 )]
	MOV.W	R0,[R7]
	SYMB	LTIM, "output", -8, 130, 2117
	SYMB	LTIM, "output", 2, 0, 2253
	CALL	_SetAudioWordClock
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", -8, 130, 2245
; audio.c   339		SetAudioClick( output, AudioSetup[output].Click);
	SYMB	LINE, 339
	MOV.B	ES,#SEG( _AudioSetup+12 )
	MOV.W	R1,[R4+SOF( _AudioSetup+12 )]
	MOV.W	R0,[R7]
	CALL	_SetAudioClick
	SYMB	LTIM, "output", -8, 130, 2117
	SYMB	LTIM, "output", 2, 0, 2253
	SYMB	LTIM, "output", 2, 0, 2125
; audio.c   340	
; audio.c   341		return( OK);
	SYMB	LINE, 341
	MOV.W	R0,#0FFFFH
; audio.c   342	}
	SYMB	LINE, 342
	ADDS.W	R7,#02H
	SYMB	SOFF, 6
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	EFUN
; audio.c   343	
; audio.c   344	/**************************************************************************/
; audio.c   345	/* SetAudioSystem																							 	  AUDIO.C */
; audio.c   346	/*																																				*/
; audio.c   347	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   348	/* Revised:	 000618, KEn, DEV     																				*/
; audio.c   349	/*																																				*/
; audio.c   350	/* Function:   																														*/
; audio.c   351	/* Remarks:	 Only possible if the selected audio output is AES/EBU				*/
; audio.c   352	/* Returns:	 FAIL if the selected output is different from AES/EBU,				*/
; audio.c   353	/*					 otherwise is returns OK.																			*/
; audio.c   354	/* Updates:																																*/
; audio.c   355	/**************************************************************************/
; audio.c   356	int SetAudioSystem( int output, int system)
; audio.c   357	{
	ALIGN	1
	SYMB	LINE, 357
	PUBLIC	_SetAudioSystem
_SetAudioSystem:
	SYMB	TYPE, 486, 'X', 12, #16, 30, 2, #16, #16
	SYMB	GFUN, "SetAudioSystem", _SetAudioSystem, #486, 0, 0, 112
	SYMB	ALAB, _SetAudioSystem, #486
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	ADDS.W	R7,#0EH
	SYMB	SOFF, 8
	SYMB	LTIM, "output", 2, 0, 2253
	SYMB	LTIM, "system", 6, 0, 2253
	MOV.W	R2,R1
	SYMB	LTIM, "system", 6, 0, 2125
	SYMB	LTIM, "system", 10, 0, 2253
	SYMB	IDEN, "output", 2, #16, 0, 2061
	SYMB	IDEN, "system", 10, #16, 0, 2061
	SYMB	IDEN, "tmp", -1, #16, 130, 5
	SYMB	LTIM, "tmp", -1, 0, 69
; audio.c   358		int tmp = AudioControl;
	SYMB	LINE, 358
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R4,#SOF( _AudioControl )
	MOV.W	R4,[R4]
	MOV.W	R5,R4
	SYMB	LTIM, "tmp", 22, 0, 205
; audio.c   359	
; audio.c   360		if ( output != AESEBUAudio)
	SYMB	LINE, 360
	MOV.W	R6,R0
	CMP.W	R6,#01H
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", 26, 0, 2253
	BEQ	_33
; audio.c   361			return( FAIL);
	SYMB	LINE, 361
	MOV.W	R0,#00H
	BR	_37
_33:
	SYMB	LTIM, "output", 26, 0, 2125
	SYMB	LTIM, "output", 26, 0, 2253
	SYMB	LTIM, "system", 10, 0, 2125
	SYMB	LTIM, "system", 10, 0, 2253
	SYMB	LTIM, "tmp", 22, 0, 77
	SYMB	LTIM, "tmp", 22, 0, 205
; audio.c   362	
; audio.c   363		Settings.ActivePreset = 0;
	SYMB	LINE, 363
	MOV.B	ES,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.W	[R0],#00H
; audio.c   364	
; audio.c   365		Settings.AudioSetup[output].System = AudioSetup[output].System = system;
	SYMB	LINE, 365
	MOV.W	R0,#0EH
	MULU.W	R0,R6
	MOVS.W	R1,#00H
	MOV.B	ES,#SEG( _AudioSetup )
	MOV.W	[R0+SOF( _AudioSetup )],R2
	MOV.W	[R7],R2
	MOV.B	ES,#SEG( _Settings+46 )
	MOV.W	[R0+SOF( _Settings+46 )],R2
	SYMB	LTIM, "system", 10, 0, 2125
	SYMB	LTIM, "system", -8, 130, 2245
; audio.c   366		NV_Store( &Settings, SettingsPtr, sizeof( Settings));
	SYMB	LINE, 366
	MOV.W	R1,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.B	ES,#SEG( _SettingsPtr )
	MOV.W	R2,#SOF( _SettingsPtr )
	MOV.W	R2,[R2]
	MOV.W	R3,#04AH
	CALL	_NV_Store
; audio.c   367	
; audio.c   368		if ( system == AudioPAL)
	SYMB	LINE, 368
	MOV.W	R0,[R7]
	SYMB	LTIM, "system", -8, 130, 2117
	SYMB	LTIM, "system", 2, 0, 2253
	BNE	_34
; audio.c   369			tmp &= ~NTSCPHASE;
	SYMB	LINE, 369
	AND.W	R4,#0FFBFH
	MOV.W	R0,R4
	SYMB	LTIM, "system", 2, 0, 2125
	SYMB	LTIM, "tmp", 22, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
	BR	_35
_34:
	SYMB	LTIM, "tmp", 2, 0, 77
	SYMB	LTIM, "tmp", 22, 0, 205
; audio.c   370		else
; audio.c   371			tmp |= NTSCPHASE;
	SYMB	LINE, 371
	MOV.W	R0,R5
	OR.W	R0,#040H
	SYMB	LTIM, "tmp", 22, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
	SYMB	LTIM, "tmp", 2, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
_35:
; audio.c   372	
; audio.c   373		if ( output == AudioOutput)
	SYMB	LINE, 373
	MOV.B	ES,#SEG( _AudioOutput )
	MOV.W	R1,#SOF( _AudioOutput )
	MOV.W	R1,[R1]
	CMP.W	R6,R1
	BNE	_36
; audio.c   374		{
; audio.c   375			AudioControl = tmp;
	SYMB	LINE, 375
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R1,#SOF( _AudioControl )
	MOV.W	[R1],R0
; audio.c   376			AudioControlPort = AudioControl;
	SYMB	LINE, 376
	MOV.B	ES,#SEG( _AudioControlPort )
	MOV.W	R1,#SOF( _AudioControlPort )
	MOV.W	[R1],R0
; audio.c   377		}
	SYMB	LINE, 377
_36:
; audio.c   378	
; audio.c   379		return( OK);
	SYMB	LINE, 379
	MOV.W	R0,#0FFFFH
	SYMB	LTIM, "tmp", 2, 0, 77
; audio.c   380	}
	SYMB	LINE, 380
_37:
	ADDS.W	R7,#02H
	SYMB	SOFF, 6
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "output", 26, 0, 2125
	SYMB	EFUN
; audio.c   381	
; audio.c   382	/**************************************************************************/
; audio.c   383	/* SetAudioSignal																							 	  AUDIO.C */
; audio.c   384	/*																																				*/
; audio.c   385	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   386	/* Revised:	 000618, KEn, DEV     																				*/
; audio.c   387	/*																																				*/
; audio.c   388	/* Function:   																														*/
; audio.c   389	/* Remarks:	 																															*/
; audio.c   390	/* Returns:	 FAIL if signal is not valid, otherwise OK.										*/
; audio.c   391	/* Updates:																																*/
; audio.c   392	/**************************************************************************/
; audio.c   393	int SetAudioSignal( int output, int signal)
; audio.c   394	{
	ALIGN	1
	SYMB	LINE, 394
	PUBLIC	_SetAudioSignal
_SetAudioSignal:
	SYMB	TYPE, 487, 'X', 12, #16, 30, 2, #16, #16
	SYMB	GFUN, "SetAudioSignal", _SetAudioSignal, #487, 0, 0, 112
	SYMB	ALAB, _SetAudioSignal, #487
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	ADDS.W	R7,#0EH
	SYMB	SOFF, 8
	SYMB	LTIM, "output", 2, 0, 2253
	SYMB	LTIM, "signal", 6, 0, 2253
	MOV.W	R2,R0
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", 10, 0, 2253
	SYMB	IDEN, "output", 10, #16, 0, 2061
	SYMB	IDEN, "signal", 6, #16, 0, 2061
	SYMB	IDEN, "tmp", -1, #16, 130, 5
	SYMB	LTIM, "tmp", -1, 0, 69
; audio.c   395		int tmp;
; audio.c   396	
; audio.c   397		if ( signal > S8kHz)
	SYMB	LINE, 397
	MOV.W	R6,R1
	CMP.W	R6,#03H
	SYMB	LTIM, "signal", 6, 0, 2125
	SYMB	LTIM, "signal", 26, 0, 2253
	BLE	_40
; audio.c   398			return( FAIL);
	SYMB	LINE, 398
	MOV.W	R0,#00H
	BR	_46
_40:
	SYMB	LTIM, "output", 10, 0, 2125
	SYMB	LTIM, "output", 10, 0, 2253
	SYMB	LTIM, "signal", 26, 0, 2125
	SYMB	LTIM, "signal", 26, 0, 2253
; audio.c   399	
; audio.c   400		Settings.ActivePreset = 0;
	SYMB	LINE, 400
	MOV.B	ES,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.W	[R0],#00H
; audio.c   401	
; audio.c   402		Settings.AudioSetup[output].Signal = AudioSetup[output].Signal = signal;
	SYMB	LINE, 402
	MOV.W	R4,#0EH
	MOV.W	[R7],R2
	MULU.W	R4,R2
	SYMB	LTIM, "output", 10, 0, 2125
	SYMB	LTIM, "output", -8, 130, 2245
	MOVS.W	R5,#00H
	MOV.B	ES,#SEG( _AudioSetup+2 )
	MOV.W	[R4+SOF( _AudioSetup+2 )],R6
	MOV.B	ES,#SEG( _Settings+48 )
	MOV.W	[R4+SOF( _Settings+48 )],R6
; audio.c   403		NV_Store( &Settings, SettingsPtr, sizeof( Settings));
	SYMB	LINE, 403
	MOV.W	R1,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.B	ES,#SEG( _SettingsPtr )
	MOV.W	R2,#SOF( _SettingsPtr )
	MOV.W	R2,[R2]
	MOV.W	R3,#04AH
	CALL	_NV_Store
; audio.c   404	
; audio.c   405		if ( output == AnalogAudio)
	SYMB	LINE, 405
	MOV.W	R0,[R7]
	BNE	_41
; audio.c   406			tmp = ANALOGAUDIOOFFSET;				// Analog signal offset
	SYMB	LINE, 406
	MOV.W	R0,#08H
	SYMB	LTIM, "tmp", 2, 0, 205
	BR	_44
_41:
; audio.c   407		else
; audio.c   408		{
; audio.c   409			if ( AudioSetup[output].Frequency == f441kHz)
	SYMB	LINE, 409
	MOV.B	ES,#SEG( _AudioSetup+10 )
	MOV.W	R0,[R4+SOF( _AudioSetup+10 )]
	SYMB	LTIM, "tmp", 2, 0, 77
	BNE	_42
; audio.c   410				tmp = AESEBUF441KHZOFFSET;		// AESEBU 44.1kHz signal offset
	SYMB	LINE, 410
	MOV.W	R0,#04H
	SYMB	LTIM, "tmp", 2, 0, 205
	BR	_44
_42:
; audio.c   411			else
; audio.c   412				tmp = AESEBUF48KHZOFFSET;			// AESEBU 48kHz signal offset
	SYMB	LINE, 412
	MOV.W	R0,#00H
	SYMB	LTIM, "tmp", 2, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
; audio.c   413		}
	SYMB	LINE, 413
_44:
; audio.c   414	
; audio.c   415		tmp += signal;
	SYMB	LINE, 415
	ADD.W	R0,R6
	SYMB	LTIM, "tmp", 2, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
; audio.c   416		tmp += CLICKPERIOD*AudioSetup[output].Click;
	SYMB	LINE, 416
	MOV.B	ES,#SEG( _AudioSetup+12 )
	MOV.W	R1,[R4+SOF( _AudioSetup+12 )]
	ASL.W	R1,#08H
	ADD.W	R0,R1
	SYMB	LTIM, "tmp", 2, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
; audio.c   417	
; audio.c   418		if ( output == AudioOutput)
	SYMB	LINE, 418
	MOV.B	ES,#SEG( _AudioOutput )
	MOV.W	R1,#SOF( _AudioOutput )
	MOV.W	R1,[R1]
	MOV.W	R2,[R7]
	CMP.W	R2,R1
	SYMB	LTIM, "output", -8, 130, 2117
	SYMB	LTIM, "output", 10, 0, 2253
	BNE	_45
; audio.c   419		{
; audio.c   420			AudioMode = tmp;
	SYMB	LINE, 420
	MOV.B	ES,#SEG( _AudioMode )
	MOV.W	R1,#SOF( _AudioMode )
	MOV.W	[R1],R0
; audio.c   421			AudioModePort = AudioMode;
	SYMB	LINE, 421
	MOV.B	ES,#SEG( _AudioModePort )
	MOV.W	R1,#SOF( _AudioModePort )
	MOV.W	[R1],R0
; audio.c   422		}
	SYMB	LINE, 422
_45:
; audio.c   423	
; audio.c   424		return( OK);
	SYMB	LINE, 424
	MOV.W	R0,#0FFFFH
	SYMB	LTIM, "tmp", 2, 0, 77
; audio.c   425	}
	SYMB	LINE, 425
_46:
	ADDS.W	R7,#02H
	SYMB	SOFF, 6
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "output", 10, 0, 2125
	SYMB	LTIM, "signal", 26, 0, 2125
	SYMB	EFUN
; audio.c   426	
; audio.c   427	/**************************************************************************/
; audio.c   428	/* SetAudioLevel																							 	  AUDIO.C */
; audio.c   429	/*																																				*/
; audio.c   430	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   431	/* Revised:	 000618, KEn, DEV     																				*/
; audio.c   432	/*																																				*/
; audio.c   433	/* Function:   																														*/
; audio.c   434	/* Remarks:	 																															*/
; audio.c   435	/* Returns:	 FAIL if level is invalid, otherwise it returns OK.				 		*/
; audio.c   436	/* Updates:																																*/
; audio.c   437	/**************************************************************************/
; audio.c   438	int SetAudioLevel( int output, int level)
; audio.c   439	{
	ALIGN	1
	SYMB	LINE, 439
	PUBLIC	_SetAudioLevel
_SetAudioLevel:
	SYMB	TYPE, 488, 'X', 12, #16, 30, 2, #16, #16
	SYMB	GFUN, "SetAudioLevel", _SetAudioLevel, #488, 0, 0, 48
	SYMB	ALAB, _SetAudioLevel, #488
	PUSH.W	R4, R5
	SYMB	SOFF, 4
	SYMB	LTIM, "output", 2, 0, 2253
	SYMB	LTIM, "level", 6, 0, 2253
	MOV.W	R5,R1
	SYMB	LTIM, "level", 6, 0, 2125
	SYMB	LTIM, "level", 22, 0, 2253
	SYMB	IDEN, "output", 2, #16, 0, 2061
	SYMB	IDEN, "level", 22, #16, 0, 2061
; audio.c   440		if ( output == AESEBUAudio)
	SYMB	LINE, 440
	MOV.W	R4,R0
	CMP.W	R4,#01H
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", 18, 0, 2253
	BNE	_49
; audio.c   441		{
; audio.c   442			if ( level > AESEBUSilence)
	SYMB	LINE, 442
	CMP.W	R5,#07H
	BLE	_51
; audio.c   443				return( FAIL);
	SYMB	LINE, 443
	MOV.W	R0,#00H
	BR	_54
; audio.c   444		}
	SYMB	LINE, 444
_49:
	SYMB	LTIM, "output", 18, 0, 2125
	SYMB	LTIM, "output", 18, 0, 2253
	SYMB	LTIM, "level", 22, 0, 2125
	SYMB	LTIM, "level", 22, 0, 2253
; audio.c   445		else
; audio.c   446		{
; audio.c   447			if ( level > AnalogSilence)
	SYMB	LINE, 447
	CMP.W	R5,#01FH
	BLE	_51
; audio.c   448				return( FAIL);
	SYMB	LINE, 448
	MOV.W	R0,#00H
	BR	_54
; audio.c   449		}
	SYMB	LINE, 449
_51:
	SYMB	LTIM, "output", 18, 0, 2125
	SYMB	LTIM, "output", 18, 0, 2253
	SYMB	LTIM, "level", 22, 0, 2125
	SYMB	LTIM, "level", 22, 0, 2253
; audio.c   450	
; audio.c   451		Settings.ActivePreset = 0;
	SYMB	LINE, 451
	MOV.B	ES,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.W	[R0],#00H
; audio.c   452	
; audio.c   453		Settings.AudioSetup[output].Level = AudioSetup[output].Level = level;
	SYMB	LINE, 453
	MOV.W	R0,#0EH
	MULU.W	R0,R4
	MOVS.W	R1,#00H
	MOV.B	ES,#SEG( _AudioSetup+4 )
	MOV.W	[R0+SOF( _AudioSetup+4 )],R5
	MOV.B	ES,#SEG( _Settings+50 )
	MOV.W	[R0+SOF( _Settings+50 )],R5
; audio.c   454		NV_Store( &Settings, SettingsPtr, sizeof( Settings));
	SYMB	LINE, 454
	MOV.W	R1,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.B	ES,#SEG( _SettingsPtr )
	MOV.W	R2,#SOF( _SettingsPtr )
	MOV.W	R2,[R2]
	MOV.W	R3,#04AH
	CALL	_NV_Store
; audio.c   455	
; audio.c   456		if ( output == AudioOutput)
	SYMB	LINE, 456
	MOV.B	ES,#SEG( _AudioOutput )
	MOV.W	R0,#SOF( _AudioOutput )
	MOV.W	R0,[R0]
	CMP.W	R4,R0
	BNE	_52
; audio.c   457		{
; audio.c   458			AudioLevel &= ~AUDIOLEVEL;
	SYMB	LINE, 458
	MOV.B	ES,#SEG( _AudioLevel )
	MOV.W	R0,#SOF( _AudioLevel )
	MOV.W	R0,[R0]
	AND.W	R0,#0FFFFH
	MOV.B	ES,#SEG( _AudioLevel )
	MOV.W	R1,#SOF( _AudioLevel )
	MOV.W	[R1],R0
; audio.c   459			AudioLevel = level;
	SYMB	LINE, 459
	MOV.B	ES,#SEG( _AudioLevel )
	MOV.W	R0,#SOF( _AudioLevel )
	MOV.W	[R0],R5
; audio.c   460			AudioLevelPort = AudioLevel;
	SYMB	LINE, 460
	MOV.B	ES,#SEG( _AudioLevelPort )
	MOV.W	R0,#SOF( _AudioLevelPort )
	MOV.W	[R0],R5
; audio.c   461		}
	SYMB	LINE, 461
_52:
; audio.c   462	
; audio.c   463		return( OK);
	SYMB	LINE, 463
	MOV.W	R0,#0FFFFH
; audio.c   464	}
	SYMB	LINE, 464
_54:
	POP.W	R4, R5
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "level", 22, 0, 2125
	SYMB	LTIM, "output", 18, 0, 2125
	SYMB	EFUN
; audio.c   465	
; audio.c   466	/**************************************************************************/
; audio.c   467	/* SetAudioTiming																							 	  AUDIO.C */
; audio.c   468	/*																																				*/
; audio.c   469	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   470	/* Revised:	 000618, KEn, DEV     																				*/
; audio.c   471	/*																																				*/
; audio.c   472	/* Function:   																														*/
; audio.c   473	/* Remarks:	 																															*/
; audio.c   474	/* Returns:																																*/
; audio.c   475	/* Updates:																																*/
; audio.c   476	/**************************************************************************/
; audio.c   477	int SetAudioTiming( int output, float timing)
; audio.c   478	{
	ALIGN	1
	SYMB	LINE, 478
	PUBLIC	_SetAudioTiming
_SetAudioTiming:
	SYMB	TYPE, 489, 'X', 12, #16, 30, 2, #16, #10
	SYMB	GFUN, "SetAudioTiming", _SetAudioTiming, #489, 0, 0, 112
	SYMB	ALAB, _SetAudioTiming, #489
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	SUB.W	R7,#014H
	SYMB	SOFF, 26
	SYMB	LTIM, "output", 2, 0, 2253
	SYMB	LTIM, "timing", 11, 0, 2253
	SYMB	IDEN, "output", 2, #16, 0, 2061
	SYMB	IDEN, "timing", 11, #10, 0, 2061
	SYMB	IDEN, "tmp", -1, #16, 130, 5
	SYMB	LTIM, "tmp", -1, 0, 69
; audio.c   479		int tmp;
; audio.c   480	
; audio.c   481		Settings.ActivePreset = 0;
	SYMB	LINE, 481
	MOV.B	ES,#SEG( _Settings )
	MOV.W	R1,#SOF( _Settings )
	MOV.W	[R1],#00H
; audio.c   482	
; audio.c   483		Settings.AudioSetup[output].Timing = AudioSetup[output].Timing = timing;
	SYMB	LINE, 483
	MOV.W	R4,R0
	MOV.W	R0,#0EH
	MULU.W	R0,R4
	SYMB	LTIM, "output", 2, 0, 2125
	MOVS.W	R1,#00H
	MOV.B	ES,#SEG( _AudioSetup+6 )
	MOV.W	[R0+SOF( _AudioSetup+6 )],R2
	MOV.W	[R0+SOF( _AudioSetup+8 )],R3
	MOV.W	[R7+18],R3
	MOV.W	[R7+16],R2
	MOV.B	ES,#SEG( _Settings+52 )
	MOV.W	[R0+SOF( _Settings+52 )],R2
	MOV.W	[R0+SOF( _Settings+54 )],R3
	SYMB	LTIM, "timing", 11, 0, 2125
	SYMB	LTIM, "timing", -10, 130, 2245
; audio.c   484		NV_Store( &Settings, SettingsPtr, sizeof( Settings));
	SYMB	LINE, 484
	MOV.W	R1,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.B	ES,#SEG( _SettingsPtr )
	MOV.W	R2,#SOF( _SettingsPtr )
	MOV.W	R2,[R2]
	MOV.W	R3,#04AH
	CALL	_NV_Store
; audio.c   485	
; audio.c   486		if ( output == AudioOutput)
	SYMB	LINE, 486
	MOV.B	ES,#SEG( _AudioOutput )
	MOV.W	R0,#SOF( _AudioOutput )
	MOV.W	R0,[R0]
	CMP.W	R4,R0
	BNE	_63
; audio.c   487		{
; audio.c   488			tmp = (int)(( timing / 0.8) + 0.5 - ( 1*( timing < 0)));
	SYMB	LINE, 488
	MOV.W	R1,[R7+18]
	MOV.W	R0,[R7+16]
	FCALL	__SPF2DPF
	MOV.W	[R7+14],#03FE9H
	MOV.W	[R7+12],#09999H
	MOV.W	[R7+10],#09999H
	MOV.W	[R7+8],#0999AH
	LEA	R6,R7+8
	FCALL	__DIV_DPF
	MOV.W	[R7+14],#03FE0H
	MOV.W	[R7+12],#00H
	MOV.W	[R7+10],#00H
	MOV.W	[R7+8],#00H
	LEA	R6,R7+8
	FCALL	__ADD_DPF
	MOV.W	[R7+6],R3
	MOV.W	[R7+4],R2
	MOV.W	[R7+2],R1
	MOV.W	[R7],R0
	MOV.W	R3,#00H
	MOV.W	R2,#00H
	MOV.W	R1,[R7+18]
	MOV.W	R0,[R7+16]
	FCALL	__CMP_SPF
	CMP.B	R0L,#0FFH
	SYMB	LTIM, "timing", -10, 130, 2117
	SYMB	LTIM, "timing", 3, 0, 2253
	BNE	_65
	MOVS.W	R0,#00H
	MOVS.W	R1,#00H
	MOVS.W	R2,#00H
	MOV.W	R3,#03FF0H
	BR	_66
_65:
	MOVS.W	R0,#00H
	MOVS.W	R1,#00H
	MOVS.W	R2,#00H
	MOVS.W	R3,#00H
_66:
	SYMB	LTIM, "timing", 3, 0, 2125
	MOV.W	R6,R7
	FCALL	__SUBR_DPF
	FCALL	__DPF2S
	MOV.W	R1,R0
	SYMB	LTIM, "tmp", 6, 0, 205
; audio.c   489	
; audio.c   490			if ( tmp < 0)
	SYMB	LINE, 490
	CMP.W	R0,#00H
	BGE	_62
; audio.c   491				tmp += 26;
	SYMB	LINE, 491
	ADD.W	R0,#01AH
	MOV.W	R1,R0
	SYMB	LTIM, "tmp", 6, 0, 77
	SYMB	LTIM, "tmp", 6, 0, 205
_62:
; audio.c   492					
; audio.c   493			AudioTiming = TimingValues[tmp];
	SYMB	LINE, 493
	MOV.W	R0,R1
	ASL.W	R0,#01H
	SYMB	LTIM, "tmp", 6, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
	SYMB	LTIM, "tmp", 2, 0, 77
	MOV.W	R2,R0
	MOVS.W	R3,#00H
	MOV.W	R1,#SEG( _TimingValues )
	MOV.W	R0,#SOF( _TimingValues )
	ADD.W	R0,R2
	ADDC.W	R1,R3
	MOV.B	CS,R1L
	MOVC.W	R1,[R0+]
	MOV.B	ES,#SEG( _AudioTiming )
	MOV.W	R0,#SOF( _AudioTiming )
	MOV.W	[R0],R1
; audio.c   494			AudioTimingPort = AudioTiming;
	SYMB	LINE, 494
	MOV.B	ES,#SEG( _AudioTiming )
	MOV.W	R0,#SOF( _AudioTiming )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioTimingPort )
	MOV.W	R1,#SOF( _AudioTimingPort )
	MOV.W	[R1],R0
; audio.c   495		}
	SYMB	LINE, 495
_63:
; audio.c   496	
; audio.c   497		return( OK);
	SYMB	LINE, 497
	MOV.W	R0,#0FFFFH
; audio.c   498	}
	SYMB	LINE, 498
	ADD.W	R7,#014H
	SYMB	SOFF, 6
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	EFUN
; audio.c   499	
; audio.c   500	/**************************************************************************/
; audio.c   501	/* SetAudioWordClock																					 	  AUDIO.C */
; audio.c   502	/*																																				*/
; audio.c   503	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   504	/* Revised:	 000618, KEn, DEV     																				*/
; audio.c   505	/*																																				*/
; audio.c   506	/* Function:   																														*/
; audio.c   507	/* Remarks:	 WordClock and audio mode is integrated. This function is 		*/
; audio.c   508	/*					 only valid for the AES/EBU output.											 			*/
; audio.c   509	/* Returns:	 FAIL if click and is invalid, otherwise it returns OK.				*/
; audio.c   510	/* Updates:																																*/
; audio.c   511	/**************************************************************************/
; audio.c   512	int SetAudioWordClock( int output, int frequency)
; audio.c   513	{
	ALIGN	1
	SYMB	LINE, 513
	PUBLIC	_SetAudioWordClock
_SetAudioWordClock:
	SYMB	TYPE, 490, 'X', 12, #16, 30, 2, #16, #16
	SYMB	GFUN, "SetAudioWordClock", _SetAudioWordClock, #490, 0, 0, 112
	SYMB	ALAB, _SetAudioWordClock, #490
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	ADDS.W	R7,#0EH
	SYMB	SOFF, 8
	SYMB	LTIM, "output", 2, 0, 2253
	SYMB	LTIM, "frequency", 6, 0, 2253
	MOV.W	R2,R1
	SYMB	LTIM, "frequency", 6, 0, 2125
	SYMB	LTIM, "frequency", 10, 0, 2253
	SYMB	IDEN, "output", 2, #16, 0, 2061
	SYMB	IDEN, "frequency", 10, #16, 0, 2061
	SYMB	IDEN, "tmp", -1, #16, 130, 5
	SYMB	LTIM, "tmp", -1, 0, 69
; audio.c   514		int tmp;
; audio.c   515	
; audio.c   516		if ( output != AESEBUAudio)
	SYMB	LINE, 516
	MOV.W	R6,R0
	CMP.W	R6,#01H
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", 26, 0, 2253
	BEQ	_68
; audio.c   517			return( FAIL);
	SYMB	LINE, 517
	MOV.W	R0,#00H
	BR	_72
_68:
	SYMB	LTIM, "output", 26, 0, 2125
	SYMB	LTIM, "output", 26, 0, 2253
	SYMB	LTIM, "frequency", 10, 0, 2125
	SYMB	LTIM, "frequency", 10, 0, 2253
; audio.c   518	
; audio.c   519		Settings.ActivePreset = 0;
	SYMB	LINE, 519
	MOV.B	ES,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.W	[R0],#00H
; audio.c   520	
; audio.c   521		Settings.AudioSetup[output].Frequency = AudioSetup[output].Frequency = frequency;
	SYMB	LINE, 521
	MOV.W	R0,R6
	MULU.W	R0,#0EH
	MOV.W	R4,R0
	MOVS.W	R5,#00H
	MOV.B	ES,#SEG( _AudioSetup+10 )
	MOV.W	[R4+SOF( _AudioSetup+10 )],R2
	MOV.W	[R7],R2
	MOV.B	ES,#SEG( _Settings+56 )
	MOV.W	[R4+SOF( _Settings+56 )],R2
	SYMB	LTIM, "frequency", 10, 0, 2125
	SYMB	LTIM, "frequency", -8, 130, 2245
; audio.c   522		NV_Store( &Settings, SettingsPtr, sizeof( Settings));
	SYMB	LINE, 522
	MOV.W	R1,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.B	ES,#SEG( _SettingsPtr )
	MOV.W	R2,#SOF( _SettingsPtr )
	MOV.W	R2,[R2]
	MOV.W	R3,#04AH
	CALL	_NV_Store
; audio.c   523	
; audio.c   524		if ( frequency == f441kHz)
	SYMB	LINE, 524
	MOV.W	R0,[R7]
	BNE	_69
; audio.c   525			tmp = AESEBUF441KHZOFFSET;
	SYMB	LINE, 525
	MOV.W	R0,#04H
	SYMB	LTIM, "tmp", 2, 0, 205
	BR	_70
_69:
; audio.c   526		else
; audio.c   527			tmp = AESEBUF48KHZOFFSET;
	SYMB	LINE, 527
	MOV.W	R0,#00H
	SYMB	LTIM, "tmp", 2, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
_70:
; audio.c   528	
; audio.c   529		tmp += AudioSetup[output].Signal;
	SYMB	LINE, 529
	MOV.B	ES,#SEG( _AudioSetup+2 )
	ADD.W	R0,[R4+SOF( _AudioSetup+2 )]
	SYMB	LTIM, "tmp", 2, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
; audio.c   530		tmp += CLICKPERIOD*AudioSetup[output].Click;
	SYMB	LINE, 530
	MOV.B	ES,#SEG( _AudioSetup+12 )
	MOV.W	R1,[R4+SOF( _AudioSetup+12 )]
	ASL.W	R1,#08H
	ADD.W	R0,R1
	SYMB	LTIM, "tmp", 2, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
; audio.c   531	
; audio.c   532		if ( output == AudioOutput)
	SYMB	LINE, 532
	MOV.B	ES,#SEG( _AudioOutput )
	MOV.W	R1,#SOF( _AudioOutput )
	MOV.W	R1,[R1]
	CMP.W	R6,R1
	BNE	_71
; audio.c   533		{
; audio.c   534			AudioMode = tmp;
	SYMB	LINE, 534
	MOV.B	ES,#SEG( _AudioMode )
	MOV.W	R1,#SOF( _AudioMode )
	MOV.W	[R1],R0
; audio.c   535			AudioModePort = AudioMode;
	SYMB	LINE, 535
	MOV.B	ES,#SEG( _AudioModePort )
	MOV.W	R1,#SOF( _AudioModePort )
	MOV.W	[R1],R0
; audio.c   536	
; audio.c   537			LEDSet( WordClk441LED, frequency == f441kHz);	
	SYMB	LINE, 537
	MOV.W	R0,#01000H
	SYMB	LTIM, "tmp", 2, 0, 77
	MOV.W	R1,[R7]
	BNE	_75
	MOVS.W	R1,#01H
	BR	_76
_75:
	MOVS.W	R1,#00H
_76:
	CALL	_LEDSet
; audio.c   538			LEDSet( WordClk48LED, frequency == f48kHz);
	SYMB	LINE, 538
	MOV.W	R0,#02000H
	CMP.W	[R7],#01H
	BNE	_77
	MOVS.W	R1,#01H
	BR	_79
_77:
	MOVS.W	R1,#00H
_79:
	CALL	_LEDSet
; audio.c   539		}
	SYMB	LINE, 539
_71:
; audio.c   540	
; audio.c   541		AudioSetup[AudioOutput].Frequency = frequency;
	SYMB	LINE, 541
	MOV.B	ES,#SEG( _AudioOutput )
	MOV.W	R0,#SOF( _AudioOutput )
	MOV.W	R0,[R0]
	MULU.W	R0,#0EH
	MOVS.W	R1,#00H
	MOV.W	R2,[R7]
	MOV.B	ES,#SEG( _AudioSetup+10 )
	MOV.W	[R0+SOF( _AudioSetup+10 )],R2
	SYMB	LTIM, "frequency", -8, 130, 2117
	SYMB	LTIM, "frequency", 10, 0, 2253
; audio.c   542	
; audio.c   543		return( OK);
	SYMB	LINE, 543
	MOV.W	R0,#0FFFFH
; audio.c   544	}
	SYMB	LINE, 544
_72:
	ADDS.W	R7,#02H
	SYMB	SOFF, 6
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "frequency", 10, 0, 2125
	SYMB	LTIM, "output", 26, 0, 2125
	SYMB	EFUN
; audio.c   545	
; audio.c   546	/**************************************************************************/
; audio.c   547	/* SetAudioClick																							 	  AUDIO.C */
; audio.c   548	/*																																				*/
; audio.c   549	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   550	/* Revised:	 000618, KEn, DEV     																				*/
; audio.c   551	/*																																				*/
; audio.c   552	/* Function:   																														*/
; audio.c   553	/* Remarks:	 																															*/
; audio.c   554	/* Returns:  FAIL if audio output is invalid, otherwise it returns OK.		*/
; audio.c   555	/* Updates:																																*/
; audio.c   556	/**************************************************************************/
; audio.c   557	int SetAudioClick( int output, int click)
; audio.c   558	{
	ALIGN	1
	SYMB	LINE, 558
	PUBLIC	_SetAudioClick
_SetAudioClick:
	SYMB	TYPE, 491, 'X', 12, #16, 30, 2, #16, #16
	SYMB	GFUN, "SetAudioClick", _SetAudioClick, #491, 0, 0, 112
	SYMB	ALAB, _SetAudioClick, #491
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	ADDS.W	R7,#0AH
	SYMB	SOFF, 12
	SYMB	LTIM, "output", 2, 0, 2253
	SYMB	LTIM, "click", 6, 0, 2253
	MOV.W	R2,R1
	SYMB	LTIM, "click", 6, 0, 2125
	SYMB	LTIM, "click", 10, 0, 2253
	SYMB	IDEN, "output", 2, #16, 0, 2061
	SYMB	IDEN, "click", 10, #16, 0, 2061
	SYMB	IDEN, "tmp", -1, #16, 130, 5
	SYMB	LTIM, "tmp", -1, 0, 69
; audio.c   559		int tmp = AudioSetup[output].Signal;
	SYMB	LINE, 559
	MOV.W	R6,R0
	MOV.W	R0,#0EH
	MULU.W	R0,R6
	SYMB	LTIM, "output", 2, 0, 2125
	MOVS.W	R1,#00H
	MOV.W	[R7+2],R1
	MOV.W	[R7],R0
	MOV.B	ES,#SEG( _AudioSetup+2 )
	MOV.W	R5,[R0+SOF( _AudioSetup+2 )]
	MOV.W	R4,R5
	SYMB	LTIM, "tmp", 18, 0, 205
; audio.c   560	
; audio.c   561		if ( output > AESEBUAudio)
	SYMB	LINE, 561
	CMP.W	R6,#01H
	BLE	_80
; audio.c   562			return( FAIL);
	SYMB	LINE, 562
	MOV.W	R0,#00H
	BR	_86
_80:
	SYMB	LTIM, "output", 26, 0, 2253
	SYMB	LTIM, "click", 10, 0, 2125
	SYMB	LTIM, "click", 10, 0, 2253
	SYMB	LTIM, "tmp", 18, 0, 77
	SYMB	LTIM, "tmp", 18, 0, 205
; audio.c   563	
; audio.c   564		Settings.ActivePreset = 0;
	SYMB	LINE, 564
	MOV.B	ES,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.W	[R0],#00H
; audio.c   565	
; audio.c   566		Settings.AudioSetup[output].Click = AudioSetup[output].Click = click;
	SYMB	LINE, 566
	MOV.W	R1,[R7+2]
	MOV.W	R0,[R7]
	MOV.B	ES,#SEG( _AudioSetup+12 )
	MOV.W	[R0+SOF( _AudioSetup+12 )],R2
	MOV.W	[R7+4],R2
	MOV.W	R1,[R7+2]
	MOV.W	R0,[R7]
	MOV.B	ES,#SEG( _Settings+58 )
	MOV.W	[R0+SOF( _Settings+58 )],R2
	SYMB	LTIM, "click", 10, 0, 2125
	SYMB	LTIM, "click", -8, 130, 2245
; audio.c   567		NV_Store( &Settings, SettingsPtr, sizeof( Settings));
	SYMB	LINE, 567
	MOV.W	R1,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.B	ES,#SEG( _SettingsPtr )
	MOV.W	R2,#SOF( _SettingsPtr )
	MOV.W	R2,[R2]
	MOV.W	R3,#04AH
	CALL	_NV_Store
; audio.c   568	
; audio.c   569		if ( click == click1s)
	SYMB	LINE, 569
	MOV.W	R0,[R7+4]
	CMP.W	R0,#01H
	SYMB	LTIM, "click", -8, 130, 2117
	SYMB	LTIM, "click", 2, 0, 2253
	BNE	_81
; audio.c   570			tmp += CLICKPERIOD;
	SYMB	LINE, 570
	ADD.W	R5,#0100H
	MOV.W	R4,R5
	SYMB	LTIM, "tmp", 18, 0, 77
	SYMB	LTIM, "tmp", 18, 0, 205
_81:
; audio.c   571	
; audio.c   572		if ( output == AnalogAudio)
	SYMB	LINE, 572
	OR.W	R6,R6
	BNE	_82
; audio.c   573			tmp += ANALOGAUDIOOFFSET;					// Analog signal offset
	SYMB	LINE, 573
	ADD.W	R4,#08H
	SYMB	LTIM, "tmp", 18, 0, 77
	SYMB	LTIM, "tmp", 18, 0, 205
	BR	_84
_82:
; audio.c   574		else
; audio.c   575		{
; audio.c   576			if ( AudioSetup[output].Frequency == f441kHz)
	SYMB	LINE, 576
	MOV.W	R1,[R7+2]
	MOV.W	R0,[R7]
	MOV.B	ES,#SEG( _AudioSetup+10 )
	MOV.W	R0,[R0+SOF( _AudioSetup+10 )]
	SYMB	LTIM, "click", 2, 0, 2125
	BNE	_84
; audio.c   577				tmp += AESEBUF441KHZOFFSET;			// AESEBU 44.1kHz signal offset
	SYMB	LINE, 577
	ADDS.W	R4,#04H
	SYMB	LTIM, "tmp", 18, 0, 77
	SYMB	LTIM, "tmp", 18, 0, 205
; audio.c   578			else
; audio.c   579				tmp += AESEBUF48KHZOFFSET;	 		// AESEBU 48kHz signal offset
; audio.c   580		}
	SYMB	LINE, 580
_84:
; audio.c   581	
; audio.c   582		if ( output == AudioOutput)
	SYMB	LINE, 582
	MOV.B	ES,#SEG( _AudioOutput )
	MOV.W	R0,#SOF( _AudioOutput )
	MOV.W	R0,[R0]
	CMP.W	R6,R0
	BNE	_85
; audio.c   583		{
; audio.c   584			AudioMode = tmp;
	SYMB	LINE, 584
	MOV.B	ES,#SEG( _AudioMode )
	MOV.W	R0,#SOF( _AudioMode )
	MOV.W	[R0],R4
; audio.c   585			AudioModePort = AudioMode;
	SYMB	LINE, 585
	MOV.B	ES,#SEG( _AudioModePort )
	MOV.W	R0,#SOF( _AudioModePort )
	MOV.W	[R0],R4
; audio.c   586		}
	SYMB	LINE, 586
_85:
; audio.c   587	
; audio.c   588		return( OK);
	SYMB	LINE, 588
	MOV.W	R0,#0FFFFH
; audio.c   589	}
	SYMB	LINE, 589
_86:
	ADDS.W	R7,#06H
	SYMB	SOFF, 6
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "tmp", 18, 0, 77
	SYMB	LTIM, "output", 26, 0, 2125
	SYMB	EFUN
; audio.c   590	
	SYMB	ENDF

	SYMB	IDEN, "AudioControl", _AudioControl, #16, 130, 4
AUDIO_CLR_FA	SEGMENT	HDATA INSEGMENT CLEAR
	RSEG	AUDIO_CLR_FA
	ALIGN	1
_AudioControl:	DS	2
	SYMB	IDEN, "AudioOutput", _AudioOutput, #16, 130, 0
	SYMB	ALAB, _AudioOutput, #16
	PUBLIC	_AudioOutput
	ALIGN	1
_AudioOutput:	DS	2
	EXTRN	HCODE(__DIV_DPF)
	EXTRN	HCODE(__SUBR_DPF)
	EXTRN	HCODE(__SPF2DPF)
	SYMB	TYPE, 492, 'X', 12, #16, 30, 2, #18, #445
	SYMB	ALAB, _LEDSet, #492
	EXTRN	HCODE(_LEDSet)
	SYMB	IDEN, "AudioMode", _AudioMode, #16, 130, 4
	ALIGN	1
_AudioMode:	DS	2
	SYMB	IDEN, "AudioSetup", _AudioSetup, #463, 130, 0
	SYMB	ALAB, _AudioSetup, #463
	PUBLIC	_AudioSetup
	ALIGN	1
_AudioSetup:	DS	28
	SYMB	IDEN, "AudioTiming", _AudioTiming, #16, 130, 4
	ALIGN	1
_AudioTiming:	DS	2
	SYMB	ALAB, _SettingsPtr, #446
	EXTRN	HDATA(_SettingsPtr)
	SYMB	IDEN, "AudioLevelPort", _AudioLevelPort, #16, 130, 0
	SYMB	ALAB, _AudioLevelPort, #16
	HSEG AT 070002H
	PUBLIC	_AudioLevelPort
	ALIGN	1
_AudioLevelPort:	DS	2
	SYMB	ALAB, _Settings, #466
	EXTRN	HDATA(_Settings)
	SYMB	IDEN, "AudioTimingPort", _AudioTimingPort, #16, 130, 0
	SYMB	ALAB, _AudioTimingPort, #16
	HSEG AT 070004H
	PUBLIC	_AudioTimingPort
	ALIGN	1
_AudioTimingPort:	DS	2
	EXTRN	HCODE(__CMP_SPF)
	SYMB	TYPE, 493, 'X', 12, #16, 30, 3, #284, #446, #16
	SYMB	ALAB, _NV_Store, #493
	EXTRN	HCODE(_NV_Store)
	SYMB	IDEN, "AudioControlPort", _AudioControlPort, #16, 130, 0
	SYMB	ALAB, _AudioControlPort, #16
	HSEG AT 070006H
	PUBLIC	_AudioControlPort
	ALIGN	1
_AudioControlPort:	DS	2
	SYMB	ALAB, _Calibration, #476
	EXTRN	HDATA(_Calibration)
	EXTRN	HCODE(__ADD_DPF)
	SYMB	IDEN, "AudioModePort", _AudioModePort, #16, 130, 0
	SYMB	ALAB, _AudioModePort, #16
	HSEG AT 070000H
	PUBLIC	_AudioModePort
	ALIGN	1
_AudioModePort:	DS	2
	SYMB	IDEN, "AudioLevel", _AudioLevel, #16, 130, 4
	RSEG	AUDIO_CLR_FA
	ALIGN	1
_AudioLevel:	DS	2
	SYMB	TYPE, 494, 'X', 12, #1, 30, 1, #16
	SYMB	ALAB, _Sleep, #494
	EXTRN	HCODE(_Sleep)
	EXTRN	HCODE(__US2SPF)
	EXTRN	HCODE(__DPF2S)
	EXTRN	DATA(__lc_ub_xvwbuffer)
	EXTRN	DATA(__lc_ue_xvwbuffer)
	CALLS	'WriteAnlAudioDACLevel', 'Write_AD8402'
	CALLS	'AudioDefaults', 'NV_Store'
	CALLS	'AudioInit', 'WriteAnlAudioDACLevel'
	CALLS	'AudioInit', 'LEDSet'
	CALLS	'AudioUpdate', 'SetAudioOutput'
	CALLS	'SetAudioOutput', 'NV_Store'
	CALLS	'SetAudioOutput', 'Sleep'
	CALLS	'SetAudioOutput', 'LEDSet'
	CALLS	'SetAudioOutput', 'SetAudioSystem'
	CALLS	'SetAudioOutput', 'SetAudioSignal'
	CALLS	'SetAudioOutput', 'SetAudioLevel'
	CALLS	'SetAudioOutput', 'SetAudioTiming'
	CALLS	'SetAudioOutput', 'SetAudioWordClock'
	CALLS	'SetAudioOutput', 'SetAudioClick'
	CALLS	'SetAudioSystem', 'NV_Store'
	CALLS	'SetAudioSignal', 'NV_Store'
	CALLS	'SetAudioLevel', 'NV_Store'
	CALLS	'SetAudioTiming', 'NV_Store'
	CALLS	'SetAudioWordClock', 'NV_Store'
	CALLS	'SetAudioWordClock', 'LEDSet'
	CALLS	'SetAudioClick', 'NV_Store'
	END
