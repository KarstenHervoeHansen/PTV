; XA C compiler v2.0 r2                   SN00085795-Ccz (c) 1998 TASKING, Inc.
; options: -A1 -Cxag3 -e -g -Ic:\cxa\include -I..\..\rtxcdef\xa
;          -I..\..\rtxc\xa\include -I..\..\code\include\1_0 -I..\..\app_spec\xa
;          -Ml -O2 -s
$CASE
$NOZPAGE
	NAME	AUDIO
	SYMB	TOOL, "XA C compiler v2.0", 1
	SYMB	TYPE, 256, "bit", 'g', 0, 1
	SYMB	FILE, "..\\..\\code\\audio\\1_0\\audio.c"
; audio.c     1	/****************************************************************************/
; audio.c     2	/* MODULE:                                                                  */
; audio.c     3	/*  audio.c - Audio 									                                 	    */
; audio.c     4	/****************************************************************************/
; audio.c     5	/* FUNCTIONS:                                                               */
; audio.c     6	/*                                                                          */
; audio.c     7	/* TASKS:                                                                   */
; audio.c     8	/*                                                                          */
; audio.c     9	/* NOTES:                                                                   */
; audio.c    10	/*                                                                          */
; audio.c    11	/****************************************************************************/
; audio.c    12	/*
; audio.c    13	 *   PTV software for PT5201
; audio.c    14	 *   Copyright (c) 
; audio.c    15	 *   ProTeleVision Technologies A/S.
; audio.c    16	 *   ALL RIGHTS RESERVED
; audio.c    17	*/
; audio.c    18	/****************************************************************************/
; audio.c    19	
; audio.c    20	#include "define.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\define.h"
	SYMB	ENDF
; audio.c    21	#include "rtxcobj.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\rtxcobj.h"
	SYMB	FILE, "..\\..\\rtxc\\xa\\include\\rtxcapi.h"
	SYMB	FILE, "..\\..\\rtxc\\xa\\include\\typedef.h"
	SYMB	FILE, "..\\..\\rtxc\\xa\\include\\rtxcopts.h"
	SYMB	ENDF
	SYMB	TYPE, 257, "KOBJNUM", 'T', #3
	SYMB	TYPE, 258, "TASK", 'T', #2
	SYMB	ENDF
	SYMB	FILE, "..\\..\\rtxc\\xa\\include\\rtxstruc.h"
	SYMB	FILE, "..\\..\\rtxc\\xa\\include\\rtxcopts.h"
	SYMB	ENDF
	SYMB	TYPE, 259, "KSNUM", 'T', #3
	SYMB	TYPE, 260, "PRIORITY", 'T', #258
	SYMB	TYPE, 261, "TSTATE", 'T', #5
	SYMB	TYPE, 262, "size_t", 'T', #18
	SYMB	TYPE, 263, "TSLICE", 'T', #3
	SYMB	TYPE, 265, 'n', #264, 130
	SYMB	TYPE, 266, 'P', #265
	SYMB	TYPE, 268, 'n', #267, 130
	SYMB	TYPE, 269, 'P', #268
	SYMB	TYPE, 270, 'n', #259, 130
	SYMB	TYPE, 271, 'P', #270
	SYMB	TYPE, 272, 'X', 12, #1, 30, 0
	SYMB	TYPE, 273, 'n', #272, 129
	SYMB	TYPE, 274, 'P', #273
	SYMB	TYPE, 275, "frame", 'S', 24,\
		 "es", #3, 0,\
		 "cs", #3, 1,\
		 "ssel", #3, 2,\
		 "ds", #3, 3,\
		 "pksnum", #271, 4,\
		 "R2", #18, 8,\
		 "R3", #18, 10,\
		 "R4", #18, 12,\
		 "R5", #18, 14,\
		 "R6", #18, 16,\
		 "psw", #18, 18,\
		 "pc", #274, 20
	SYMB	TYPE, 276, 'n', #275, 130
	SYMB	TYPE, 277, 'P', #276
	SYMB	TYPE, 278, 'X', 12, #1, 30, 0
	SYMB	TYPE, 279, 'n', #278, 129
	SYMB	TYPE, 280, 'P', #279
	SYMB	TYPE, 281, 'n', #2, 130
	SYMB	TYPE, 282, 'P', #281
	SYMB	TYPE, 283, 'n', #1, 130
	SYMB	TYPE, 284, 'P', #283
	SYMB	TYPE, 264, "tcb", 'S', 36,\
		 "flink", #266, 0,\
		 "blink", #266, 4,\
		 "pclkblk", #269, 8,\
		 "task", #258, 12,\
		 "priority", #260, 13,\
		 "sp", #277, 14,\
		 "status", #261, 18,\
		 "pc_t0", #280, 20,\
		 "stackbase", #282, 24,\
		 "stacksize", #262, 28,\
		 "tslice", #263, 30,\
		 "newslice", #263, 31,\
		 "arg", #284, 32
	SYMB	TYPE, 285, "TCB", 'T', #264
	SYMB	TYPE, 286, "SEMA", 'T', #257
	SYMB	TYPE, 287, "MAP", 'T', #257
	SYMB	TYPE, 289, 'n', #288, 130
	SYMB	TYPE, 290, 'P', #289
	SYMB	TYPE, 288, "rtxcmsg", 'S', 8,\
		 "link", #290, 0,\
		 "task", #258, 4,\
		 "priority", #260, 5,\
		 "sema", #286, 6
	SYMB	TYPE, 291, "RTXCMSG", 'T', #288
	SYMB	TYPE, 292, "TICKS", 'T', #16
	SYMB	TYPE, 293, 'N',\
		 "DELAY_OBJ", 0,\
		 "SEMAPHORE_OBJ", 1,\
		 "PARTITION_OBJ", 2,\
		 "QUEUE_OBJ", 3,\
		 "RESOURCE_OBJ", 4,\
		 "MAILBOX_OBJ", 5,\
		 "TIMER_OBJ", 6
	SYMB	TYPE, 294, "OBJTYPE", 'T', #293
	SYMB	TYPE, 267, "clkblk", 'S', 18,\
		 "flink", #269, 0,\
		 "blink", #269, 4,\
		 "remain", #292, 8,\
		 "recycle", #292, 10,\
		 "task", #258, 12,\
		 "state", #2, 13,\
		 "objtype", #294, 14,\
		 "objid", #257, 16
	SYMB	TYPE, 295, 'N',\
		 "PRIORITY_INVERSION_OFF", 0,\
		 "PRIORITY_INVERSION_ON", 1
	SYMB	TYPE, 296, "RESATTR", 'T', #295
	SYMB	ENDF
	SYMB	TYPE, 297, 'N',\
		 "RC_GOOD", 0,\
		 "RC_WAIT_CONFLICT", 1,\
		 "RC_NO_TIMERS", 2,\
		 "RC_TIMER_INACTIVE", 3,\
		 "RC_TIMER_ILLEGAL", 4,\
		 "RC_TIMEOUT", 5,\
		 "RC_QUEUE_FULL", 6,\
		 "RC_QUEUE_EMPTY", 7,\
		 "RC_ILLEGAL_QUEUE_SIZE", 8,\
		 "RC_BUSY", 9,\
		 "RC_NESTED", 10,\
		 "RC_ILLEGAL_TASK", 11,\
		 "RC_ACTIVE_TASK", 12,\
		 "RC_NO_YIELD", 13,\
		 "RC_MISSED_EVENT", 14
	SYMB	TYPE, 298, "KSRC", 'T', #297
	SYMB	TYPE, 299, "SSTATE", 'T', #258
	SYMB	TYPE, 300, "MBOX", 'T', #257
	SYMB	TYPE, 301, "QUEUE", 'T', #257
	SYMB	TYPE, 302, 'N',\
		 "QNE", 0,\
		 "QNF", 1,\
		 "QF", 2,\
		 "QE", 3
	SYMB	TYPE, 303, "QCOND", 'T', #302
	SYMB	TYPE, 304, "RESOURCE", 'T', #257
	SYMB	TYPE, 305, "CLKBLK", 'T', #267
	SYMB	TYPE, 306, "time_t", 'T', #6
	SYMB	TYPE, 307, "FRAME", 'T', #275
	SYMB	ENDF
	SYMB	FILE, "..\\..\\rtxcdef\\xa\\ctask.h"
	SYMB	ENDF
	SYMB	FILE, "..\\..\\rtxcdef\\xa\\csema.h"
	SYMB	ENDF
	SYMB	FILE, "..\\..\\rtxcdef\\xa\\cres.h"
	SYMB	ENDF
	SYMB	FILE, "..\\..\\rtxcdef\\xa\\cqueue.h"
	SYMB	ENDF
	SYMB	FILE, "..\\..\\rtxcdef\\xa\\cpart.h"
	SYMB	ENDF
	SYMB	FILE, "..\\..\\rtxcdef\\xa\\cmbox.h"
	SYMB	ENDF
	SYMB	FILE, "..\\..\\rtxcdef\\xa\\cclock.h"
	SYMB	ENDF
	SYMB	TYPE, 309, 'n', #308, 130
	SYMB	TYPE, 310, 'P', #309
	SYMB	TYPE, 308, 'X', 12, #1, 30, 2, #310, #282
	SYMB	TYPE, 312, 'n', #311, 129
	SYMB	TYPE, 313, 'P', #312
	SYMB	TYPE, 314, 'X', 12, #1, 30, 1, #310
	SYMB	TYPE, 315, 'n', #314, 129
	SYMB	TYPE, 316, 'P', #315
	SYMB	TYPE, 317, 'n', #6, 130
	SYMB	TYPE, 318, 'P', #317
	SYMB	TYPE, 317, 'X', 12, #16, 30, 2, #310, #318
	SYMB	TYPE, 320, 'n', #319, 129
	SYMB	TYPE, 321, 'P', #320
	SYMB	TYPE, 322, 'X', 12, #1, 30, 1, #310
	SYMB	TYPE, 323, 'n', #322, 129
	SYMB	TYPE, 324, 'P', #323
	SYMB	TYPE, 325, 'X', 12, #1, 30, 1, #310
	SYMB	TYPE, 326, 'n', #325, 129
	SYMB	TYPE, 327, 'P', #326
	SYMB	TYPE, 328, 'X', 12, #16, 30, 1, #310
	SYMB	TYPE, 329, 'n', #328, 129
	SYMB	TYPE, 330, 'P', #329
	SYMB	TYPE, 308, "TEvent", 'S', 32,\
		 "ObjectID", #16, 0,\
		 "TEvent", #313, 2,\
		 "_TEvent", #316, 6,\
		 "Wait", #321, 10,\
		 "Set", #324, 14,\
		 "Clear", #327, 18,\
		 "IsSet", #330, 22,\
		 "ID", #286, 26,\
		 "Name", #282, 28
	SYMB	TYPE, 331, "TEvent", 'T', #308
	SYMB	TYPE, 333, 'n', #332, 130
	SYMB	TYPE, 334, 'P', #333
	SYMB	TYPE, 332, 'X', 12, #1, 30, 1, #334
	SYMB	TYPE, 336, 'n', #335, 129
	SYMB	TYPE, 337, 'P', #336
	SYMB	TYPE, 338, 'X', 12, #1, 30, 1, #334
	SYMB	TYPE, 339, 'n', #338, 129
	SYMB	TYPE, 340, 'P', #339
	SYMB	TYPE, 341, 'n', #331, 130
	SYMB	TYPE, 342, 'P', #341
	SYMB	TYPE, 341, 'X', 12, #16, 30, 2, #334, #342
	SYMB	TYPE, 344, 'n', #343, 129
	SYMB	TYPE, 345, 'P', #344
	SYMB	TYPE, 346, 'X', 12, #1, 30, 2, #334, #342
	SYMB	TYPE, 347, 'n', #346, 129
	SYMB	TYPE, 348, 'P', #347
	SYMB	TYPE, 349, 'X', 12, #16, 30, 2, #334, #342
	SYMB	TYPE, 350, 'n', #349, 129
	SYMB	TYPE, 351, 'P', #350
	SYMB	TYPE, 352, 'X', 12, #342, 30, 2, #334, #318
	SYMB	TYPE, 353, 'n', #352, 129
	SYMB	TYPE, 354, 'P', #353
	SYMB	TYPE, 355, 'Z', #2, 95
	SYMB	TYPE, 332, "TEventList", 'S', 122,\
		 "ObjectID", #16, 0,\
		 "TEventList", #337, 2,\
		 "_TEventList", #340, 6,\
		 "Append", #345, 10,\
		 "Clear", #348, 14,\
		 "InList", #351, 18,\
		 "Wait", #354, 22,\
		 "Align", #355, 26
	SYMB	TYPE, 357, "TEventList", 'T', #332
	SYMB	TYPE, 359, 'n', #358, 130
	SYMB	TYPE, 360, 'P', #359
	SYMB	TYPE, 358, 'X', 12, #1, 30, 2, #360, #282
	SYMB	TYPE, 362, 'n', #361, 129
	SYMB	TYPE, 363, 'P', #362
	SYMB	TYPE, 364, 'X', 12, #1, 30, 1, #360
	SYMB	TYPE, 365, 'n', #364, 129
	SYMB	TYPE, 366, 'P', #365
	SYMB	TYPE, 367, 'X', 12, #1, 30, 1, #360
	SYMB	TYPE, 368, 'n', #367, 129
	SYMB	TYPE, 369, 'P', #368
	SYMB	TYPE, 370, 'X', 12, #1, 30, 1, #360
	SYMB	TYPE, 371, 'n', #370, 129
	SYMB	TYPE, 372, 'P', #371
	SYMB	TYPE, 373, 'X', 12, #16, 30, 1, #360
	SYMB	TYPE, 374, 'n', #373, 129
	SYMB	TYPE, 375, 'P', #374
	SYMB	TYPE, 358, "TResource", 'S', 28,\
		 "ObjectID", #16, 0,\
		 "TResource", #363, 2,\
		 "_TResource", #366, 6,\
		 "Lock", #369, 10,\
		 "Unlock", #372, 14,\
		 "Owner", #375, 18,\
		 "ID", #304, 22,\
		 "Name", #282, 24
	SYMB	TYPE, 376, "TResource", 'T', #358
	SYMB	TYPE, 377, 'X', 12, #1, 30, 0
	SYMB	TYPE, 378, 'n', #377, 129
	SYMB	TYPE, 379, 'P', #378
	SYMB	TYPE, 381, 'n', #380, 130
	SYMB	TYPE, 382, 'P', #381
	SYMB	TYPE, 377, 'X', 12, #1, 30, 3, #382, #16, #379
	SYMB	TYPE, 384, 'n', #383, 129
	SYMB	TYPE, 385, 'P', #384
	SYMB	TYPE, 386, 'X', 12, #1, 30, 1, #382
	SYMB	TYPE, 387, 'n', #386, 129
	SYMB	TYPE, 388, 'P', #387
	SYMB	TYPE, 389, 'X', 12, #1, 30, 1, #382
	SYMB	TYPE, 390, 'n', #389, 129
	SYMB	TYPE, 391, 'P', #390
	SYMB	TYPE, 392, 'X', 12, #1, 30, 2, #382, #16
	SYMB	TYPE, 393, 'n', #392, 129
	SYMB	TYPE, 394, 'P', #393
	SYMB	TYPE, 395, 'X', 12, #1, 30, 1, #382
	SYMB	TYPE, 396, 'n', #395, 129
	SYMB	TYPE, 397, 'P', #396
	SYMB	TYPE, 398, 'X', 12, #16, 30, 1, #382
	SYMB	TYPE, 399, 'n', #398, 129
	SYMB	TYPE, 400, 'P', #399
	SYMB	TYPE, 401, 'X', 12, #1, 30, 2, #382, #16
	SYMB	TYPE, 402, 'n', #401, 129
	SYMB	TYPE, 403, 'P', #402
	SYMB	TYPE, 380, "TThread", 'S', 36,\
		 "ObjectID", #16, 0,\
		 "TThread", #385, 2,\
		 "Execute", #388, 6,\
		 "Terminate", #391, 10,\
		 "Suspend", #394, 14,\
		 "Resume", #397, 18,\
		 "GetPriority", #400, 22,\
		 "SetPriority", #403, 26,\
		 "ID", #258, 30,\
		 "Status", #2, 31,\
		 "Stack", #282, 32
	SYMB	TYPE, 404, "TThread", 'T', #380
	SYMB	TYPE, 406, 'n', #405, 130
	SYMB	TYPE, 407, 'P', #406
	SYMB	TYPE, 405, 'X', 12, #1, 30, 1, #407
	SYMB	TYPE, 409, 'n', #408, 129
	SYMB	TYPE, 410, 'P', #409
	SYMB	TYPE, 411, 'X', 12, #1, 30, 1, #407
	SYMB	TYPE, 412, 'n', #411, 129
	SYMB	TYPE, 413, 'P', #412
	SYMB	TYPE, 414, 'X', 12, #1, 30, 2, #407, #16
	SYMB	TYPE, 415, 'n', #414, 129
	SYMB	TYPE, 416, 'P', #415
	SYMB	TYPE, 417, 'X', 12, #16, 30, 1, #407
	SYMB	TYPE, 418, 'n', #417, 129
	SYMB	TYPE, 419, 'P', #418
	SYMB	TYPE, 420, 'X', 12, #1, 30, 2, #407, #16
	SYMB	TYPE, 421, 'n', #420, 129
	SYMB	TYPE, 422, 'P', #421
	SYMB	TYPE, 423, 'n', #305, 130
	SYMB	TYPE, 424, 'P', #423
	SYMB	TYPE, 405, "TTimer", 'S', 32,\
		 "ObjectID", #16, 0,\
		 "TTimer", #410, 2,\
		 "_TTimer", #413, 6,\
		 "SetPeriod", #416, 10,\
		 "GetPeriod", #419, 14,\
		 "Tick", #422, 18,\
		 "TimeOut", #342, 22,\
		 "Period", #4, 26,\
		 "Handle", #424, 28
	SYMB	TYPE, 425, "TTimer", 'T', #405
	SYMB	TYPE, 427, 'n', #426, 130
	SYMB	TYPE, 428, 'P', #427
	SYMB	TYPE, 426, 'X', 12, #1, 30, 3, #428, #16, #16
	SYMB	TYPE, 430, 'n', #429, 129
	SYMB	TYPE, 431, 'P', #430
	SYMB	TYPE, 432, 'X', 12, #1, 30, 1, #428
	SYMB	TYPE, 433, 'n', #432, 129
	SYMB	TYPE, 434, 'P', #433
	SYMB	TYPE, 435, 'X', 12, #282, 30, 2, #428, #284
	SYMB	TYPE, 436, 'n', #435, 129
	SYMB	TYPE, 437, 'P', #436
	SYMB	TYPE, 438, 'X', 12, #1, 30, 2, #428, #284
	SYMB	TYPE, 439, 'n', #438, 129
	SYMB	TYPE, 440, 'P', #439
	SYMB	TYPE, 426, "TStream", 'S', 28,\
		 "ObjectID", #16, 0,\
		 "TStream", #431, 2,\
		 "_TStream", #434, 6,\
		 "Get", #437, 10,\
		 "Put", #440, 14,\
		 "ID", #301, 18,\
		 "Width", #16, 20,\
		 "Depth", #16, 22,\
		 "Handle", #282, 24
	SYMB	TYPE, 441, "TStream", 'T', #426
	SYMB	ENDF
; audio.c    22	#include "audio.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\audio.h"
	SYMB	TYPE, 442, 'S', 14,\
		 "System", #16, 0,\
		 "Signal", #16, 2,\
		 "Level", #16, 4,\
		 "Timing", #10, 6,\
		 "Frequency", #16, 10,\
		 "Click", #16, 12
	SYMB	TYPE, 443, "AudioObject", 'T', #442
	SYMB	ENDF
; audio.c    23	#include "led_hw.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\led_hw.h"
	SYMB	TYPE, 444, 'N',\
		 "true", -1,\
		 "false", 0
	SYMB	TYPE, 445, "bool", 'T', #444
	SYMB	ENDF
; audio.c    24	#include "tables.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\tables.h"
	SYMB	ENDF
; audio.c    25	#include "instru.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\instru.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\nv_drv.h"
	SYMB	TYPE, 446, "NvPointer", 'T', #18
	SYMB	ENDF
	SYMB	FILE, "..\\..\\code\\include\\1_0\\genlock.h"
	SYMB	TYPE, 447, 'S', 6,\
		 "System", #3, 0,\
		 "Delay", #7, 2
	SYMB	TYPE, 448, "GenlockObject", 'T', #447
	SYMB	ENDF
	SYMB	FILE, "..\\..\\code\\include\\1_0\\bb.h"
	SYMB	TYPE, 449, 'S', 8,\
		 "System", #3, 0,\
		 "Delay", #7, 2,\
		 "ScHPhase", #16, 6
	SYMB	TYPE, 450, "BBObject", 'T', #449
	SYMB	ENDF
	SYMB	FILE, "..\\..\\code\\include\\1_0\\cbar.h"
	SYMB	TYPE, 451, 'S', 12,\
		 "System", #3, 0,\
		 "Pattern", #18, 2,\
		 "Delay", #7, 4,\
		 "ScHPhase", #16, 8,\
		 "EmbAudioSignal", #3, 10
	SYMB	TYPE, 452, "CBObject", 'T', #451
	SYMB	ENDF
	SYMB	FILE, "..\\..\\code\\include\\1_0\\audio.h"
	SYMB	ENDF
	SYMB	TYPE, 453, 'S', 32,\
		 "Date", #7, 0,\
		 "DACFactDate", #7, 4,\
		 "DACUserDate", #7, 8,\
		 "DACFactValue", #18, 12,\
		 "DACUserValue", #18, 14,\
		 "HPHZeroG", #7, 16,\
		 "PhaseG", #7, 20,\
		 "HPHZeroM", #7, 24,\
		 "PhaseM", #7, 28
	SYMB	TYPE, 454, "GenlockCalibrationObject", 'T', #453
	SYMB	TYPE, 455, 'S', 20,\
		 "Date", #7, 0,\
		 "PhaseG", #7, 4,\
		 "ScHPhaseG", #18, 8,\
		 "PhaseM", #7, 10,\
		 "ScHPhaseM", #18, 14,\
		 "DACGain", #3, 16,\
		 "DACOffset", #3, 17,\
		 "DACLevel", #3, 18
	SYMB	TYPE, 456, "BBCalibrationObject", 'T', #455
	SYMB	TYPE, 457, 'S', 20,\
		 "Date", #7, 0,\
		 "PhaseG", #7, 4,\
		 "ScHPhaseG", #3, 8,\
		 "PhaseM", #7, 10,\
		 "ScHPhaseM", #3, 14,\
		 "GainG", #3, 15,\
		 "ChromaGainG", #3, 16,\
		 "GainM", #3, 17,\
		 "ChromaGainM", #3, 18
	SYMB	TYPE, 458, "CBCalibrationObject", 'T', #457
	SYMB	TYPE, 459, 'S', 6,\
		 "Date", #7, 0,\
		 "AnalogLeftChannel", #3, 4,\
		 "AnalogRightChannel", #3, 5
	SYMB	TYPE, 460, "AudioCalibrationObject", 'T', #459
	SYMB	TYPE, 461, 'Z', #450, 2
	SYMB	TYPE, 463, 'Z', #443, 1
	SYMB	TYPE, 465, 'S', 74,\
		 "ActivePreset", #16, 0,\
		 "GenlockSetup", #448, 2,\
		 "BBSetup", #461, 8,\
		 "CBSetup", #452, 32,\
		 "AudioOutput", #16, 44,\
		 "AudioSetup", #463, 46
	SYMB	TYPE, 466, "SettingsObject", 'T', #465
	SYMB	TYPE, 467, 'Z', #2, 32
	SYMB	TYPE, 469, 'Z', #2, 8
	SYMB	TYPE, 471, 'Z', #2, 12
	SYMB	TYPE, 473, 'Z', #456, 2
	SYMB	TYPE, 475, 'S', 224,\
		 "Company", #467, 0,\
		 "Type", #467, 33,\
		 "KUNumber", #469, 66,\
		 "SWRevision", #469, 75,\
		 "NC12", #471, 84,\
		 "ResetSystem", #3, 97,\
		 "ProdDate", #7, 98,\
		 "UpdateDate", #7, 102,\
		 "GenlockCalibration", #454, 106,\
		 "BBCalibration", #473, 138,\
		 "CBCalibration", #458, 198,\
		 "AudioCalibration", #460, 218
	SYMB	TYPE, 476, "CalibrationObject", 'T', #475
	SYMB	ENDF
; audio.c    26														
; audio.c    27	/**************************************************************************/
; audio.c    28	// The following definitions are based upon the document be PF:
; audio.c    29	//  "I/O-ports for controlling the audio generator in PT5201."
; audio.c    30	
; audio.c    31	// Audio Mode Select Port
; audio.c    32	#define AUDIOMODE			0x000F
; audio.c    33	#define CLICKPERIOD		0x0100
; audio.c    34	
; audio.c    35	#define	AESEBU500HZ48KHZ 					0
; audio.c    36	#define	AESEBU1000HZ48KHZ					1
; audio.c    37	#define	AESEBU1000HZCLICK48KHZ		2
; audio.c    38	#define	AESEBU8000HZ48KHZ					3
; audio.c    39	 
; audio.c    40	#define	AESEBU500HZ441KHZ					4
; audio.c    41	#define	AESEBU1000HZ441KHZ				5
; audio.c    42	#define	AESEBU1000HZCLICK441KHZ		6
; audio.c    43	#define	AESEBU8000HZ441KHZ				7
; audio.c    44	
; audio.c    45	#define	ANALOG500HZ								8
; audio.c    46	#define	ANALOG1000HZ							9
; audio.c    47	#define	ANALOG1000HZCLICK					10
; audio.c    48	#define	ANALOG8000HZ							11
; audio.c    49	
; audio.c    50	#define AESEBUF48KHZOFFSET				0
; audio.c    51	#define AESEBUF441KHZOFFSET				4
; audio.c    52	#define ANALOGAUDIOOFFSET					8
; audio.c    53	
; audio.c    54	// Audio Level Select Port
; audio.c    55	#define AESEBULEVEL		0x0007
; audio.c    56	#define ANALOGLEVEL		0x001F
; audio.c    57	#define AUDIOLEVEL		AESEBULEVEL | ANALOGLEVEL
; audio.c    58	
; audio.c    59	// Audio Control Select Port
; audio.c    60	#define POTMETERS			0x000F
; audio.c    61	#define POT_CLK				0x0001
; audio.c    62	#define POT_SDI				0x0002
; audio.c    63	#define POT_CSAU			0x0004
; audio.c    64	#define POT_CSCB			0x0008
; audio.c    65	#define SELAESEBU			0x0010
; audio.c    66	#define SELANALOG			0x0020
; audio.c    67	#define NTSCPHASE			0x0040
; audio.c    68	#define RELAYTYPE			0x0080
; audio.c    69	#define PLLLOCK				0x0100
; audio.c    70	#define VIDEOLOCK			0x0200
; audio.c    71	
; audio.c    72	// End of definitions
; audio.c    73	/**************************************************************************/
; audio.c    74	
; audio.c    75	code UI TimingValues[] = {
AUDIO_RO	SEGMENT	HCODE ROMDATA
	RSEG	AUDIO_RO
	SYMB	TYPE, 477, 'Z', #18, -1
	SYMB	IDEN, "TimingValues", _TimingValues, #477, 129, 0
	SYMB	ALAB, _TimingValues, #477
	PUBLIC	_TimingValues
	ALIGN	1
_TimingValues:
	DW	00001H,00016H,0002BH,00041H,00056H,0006CH,00082H,00097H
	DW	000ADH,000C2H,000D8H,000EEH,00103H,00119H,0012EH,00144H
	DW	0015AH,0016FH,00185H,0019AH,001B0H,001C6H,001DBH,001F1H
; audio.c    76		0x001,	// 0.0us
; audio.c    77		0x016,	// 0.8us
; audio.c    78		0x02B,  // 1.6us
; audio.c    79		0x041, 	// 2.4us
; audio.c    80		0x056,	// 3.2us
; audio.c    81		0x06C,	// 4.0us
; audio.c    82		0x082,  // 4.8us
; audio.c    83		0x097, 	// 5.6us
; audio.c    84		0x0AD,	// 6.4us
; audio.c    85		0x0C2,	// 7.2us
; audio.c    86		0x0D8, 	// 8.0us
; audio.c    87		0x0EE, 	// 8.8us
; audio.c    88		0x103,	// 9.6us
; audio.c    89		0x119,	// 10.4us
; audio.c    90		0x12E, 	// 11.2us
; audio.c    91		0x144, 	// 12.0us
; audio.c    92		0x15A,	// 12.8us
; audio.c    93		0x16F,	// 13.6us
; audio.c    94		0x185, 	// 14.4us
; audio.c    95		0x19A, 	// 15.2us
; audio.c    96		0x1B0,	// 16.0us
; audio.c    97		0x1C6,	// 16.8us
; audio.c    98		0x1DB, 	// 17.6us
; audio.c    99		0x1F1, 	// 18.4us
; audio.c   100		0x206,	// 19.2us
; audio.c   101		0x21C		// 20.0us
; audio.c   102	};
; audio.c   103	
; audio.c   104	int AudioOutput;
; audio.c   105	AudioObject AudioSetup[NoOfAudioOutputs];
; audio.c   106	
; audio.c   107	volatile int AudioModePort _at(0x70000); 				// Port defined in PLD
; audio.c   108	volatile int AudioLevelPort _at(0x70002); 	 		// Port defined in PLD
; audio.c   109	volatile int AudioTimingPort _at(0x70004); 			// Port defined in PLD
; audio.c   110	volatile int AudioControlPort _at(0x70006);  		// Port defined in PLD
; audio.c   111	
; audio.c   112	static int AudioMode;
; audio.c   113	static int AudioLevel;
; audio.c   114	static int AudioTiming;
; audio.c   115	static int AudioControl;
; audio.c   116	
; audio.c   117	/**************************************************************************/
; audio.c   118	/* Write_AD8402																								 	  AUDIO.C */
; audio.c   119	/*																																				*/
; audio.c   120	/* Author:	 Peter Frederiksen/Kim Engedahl, DEV, 000329									*/
; audio.c   121	/* Revised:	 000603, KEn, DEV     																				*/
; audio.c   122	/*																																				*/
; audio.c   123	/* Function:   																														*/
; audio.c   124	/* Remarks:	 The Altera PLD V8 should be loaded before calling this 			*/
; audio.c   125	/*					 function.		 																								*/
; audio.c   126	/* Returns:																																*/
; audio.c   127	/* Updates:																																*/
; audio.c   128	/**************************************************************************/
; audio.c   129	int Write_AD8402( UC potmeter, UC channel, UC data)
; audio.c   130	{
	DW	00206H,0021CH
AUDIO_PR	SEGMENT	HCODE
	RSEG	AUDIO_PR
	ALIGN	1
	SYMB	LINE, 130
	PUBLIC	_Write_AD8402
_Write_AD8402:
	SYMB	TYPE, 479, 'X', 12, #16, 30, 3, #3, #3, #3
	SYMB	GFUN, "Write_AD8402", _Write_AD8402, #479, 0, 0, 0
	SYMB	ALAB, _Write_AD8402, #479
	SYMB	LTIM, "potmeter", 0, 0, 2253
	SYMB	LTIM, "channel", 1, 0, 2253
	SYMB	LTIM, "data", 4, 0, 2253
	SYMB	IDEN, "potmeter", 0, #3, 0, 2061
	SYMB	IDEN, "channel", 1, #3, 0, 2061
	SYMB	IDEN, "data", 4, #3, 0, 2061
	SYMB	IDEN, "d", -1, #18, 130, 5
	SYMB	LTIM, "d", -1, 0, 69
	SYMB	IDEN, "n", -1, #18, 130, 5
	SYMB	LTIM, "n", -1, 0, 69
; audio.c   131		UI d, n;
; audio.c   132	
; audio.c   133		if ( channel > 1)
	SYMB	LINE, 133
	CMP.B	R0H,#01H
	BL	_3
; audio.c   134			return( FAIL);
	SYMB	LINE, 134
	MOV.W	R0,#00H
	SYMB	LTIM, "channel", 1, 0, 2125
	SYMB	LTIM, "potmeter", 0, 0, 2125
	RET
_3:
	SYMB	LTIM, "potmeter", 0, 0, 2253
	SYMB	LTIM, "channel", 1, 0, 2253
	SYMB	LTIM, "data", 4, 0, 2125
	SYMB	LTIM, "data", 4, 0, 2253
; audio.c   135	
; audio.c   136		switch ( potmeter)
	SYMB	LINE, 136
	CMP.B	R0L,#00H
	BEQ	_6
	CMP.B	R0L,#01H
	BEQ	_4
	BR	_5
; audio.c   137		{
; audio.c   138			case CBPotMeter:
; audio.c   139				AudioControl &= ~POT_CSCB;
; audio.c   140				break;
; audio.c   141	
; audio.c   142			case AudioPotMeter:
	SYMB	LINE, 142
_4:
; audio.c   143				AudioControl &= ~POT_CSAU;
	SYMB	LINE, 143
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R2,#SOF( _AudioControl )
	MOV.W	R2,[R2]
	AND.W	R2,#0FFFBH
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R3,#SOF( _AudioControl )
	MOV.W	[R3],R2
; audio.c   144				break;
	SYMB	LINE, 144
	BR	_7
; audio.c   145	
; audio.c   146			default:
	SYMB	LINE, 146
_5:
; audio.c   147				return( FAIL);
	SYMB	LINE, 147
	MOV.W	R0,#00H
	SYMB	LTIM, "channel", 1, 0, 2125
	SYMB	LTIM, "potmeter", 0, 0, 2125
	RET
	SYMB	LINE, 138
_6:
	SYMB	LTIM, "channel", 1, 0, 2253
	SYMB	LTIM, "data", 4, 0, 2125
	SYMB	LTIM, "data", 4, 0, 2253
	SYMB	LINE, 139
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R2,#SOF( _AudioControl )
	MOV.W	R2,[R2]
	AND.W	R2,#0FFF7H
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R3,#SOF( _AudioControl )
	MOV.W	[R3],R2
; audio.c   148		}
	SYMB	LINE, 148
_7:
; audio.c   149	
; audio.c   150		AudioControlPort = AudioControl;
	SYMB	LINE, 150
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R2,#SOF( _AudioControl )
	MOV.W	R2,[R2]
	MOV.B	ES,#SEG( _AudioControlPort )
	MOV.W	R3,#SOF( _AudioControlPort )
	MOV.W	[R3],R2
; audio.c   151	
; audio.c   152		d = ( channel * 0x100) + data;
	SYMB	LINE, 152
	MOV.B	R2L,R0H
	MOVS.B	R2H,#00H
	ASL.W	R2,#08H
	MOV.B	R0L,R1L
	MOVS.B	R0H,#00H
	SYMB	LTIM, "channel", 1, 0, 2125
	ADD.W	R2,R0
	SYMB	LTIM, "d", 10, 0, 205
; audio.c   153	
; audio.c   154		for ( n = 0x200; n > 0; n /= 2)
	SYMB	LINE, 154
	MOV.W	R1,#0200H
	SYMB	LTIM, "data", 4, 0, 2125
	SYMB	LTIM, "n", 6, 0, 205
_8:
; audio.c   155		{
; audio.c   156			AudioControl  &= ~POT_CLK;
	SYMB	LINE, 156
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R0,#SOF( _AudioControl )
	MOV.W	R0,[R0]
	AND.W	R0,#0FFFEH
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R3,#SOF( _AudioControl )
	MOV.W	[R3],R0
; audio.c   157			AudioControlPort = AudioControl;
	SYMB	LINE, 157
	MOV.B	ES,#SEG( _AudioControlPort )
	MOV.W	R3,#SOF( _AudioControlPort )
	MOV.W	[R3],R0
; audio.c   158			
; audio.c   159			if ( d & n)
	SYMB	LINE, 159
	MOV.W	R3,R2
	AND.W	R3,R1
	BEQ	_9
; audio.c   160				AudioControl |= POT_SDI;
	SYMB	LINE, 160
	OR.W	R0,#02H
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R3,#SOF( _AudioControl )
	MOV.W	[R3],R0
	BR	_10
_9:
; audio.c   161			else
; audio.c   162				AudioControl &= ~POT_SDI;
	SYMB	LINE, 162
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R0,#SOF( _AudioControl )
	MOV.W	R0,[R0]
	AND.W	R0,#0FFFDH
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R3,#SOF( _AudioControl )
	MOV.W	[R3],R0
_10:
; audio.c   163	
; audio.c   164			AudioControlPort = AudioControl;
	SYMB	LINE, 164
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R0,#SOF( _AudioControl )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioControlPort )
	MOV.W	R3,#SOF( _AudioControlPort )
	MOV.W	[R3],R0
; audio.c   165	
; audio.c   166			AudioControl |= POT_CLK;
	SYMB	LINE, 166
	OR.W	R0,#01H
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R3,#SOF( _AudioControl )
	MOV.W	[R3],R0
; audio.c   167			AudioControlPort = AudioControl;
	SYMB	LINE, 167
	MOV.B	ES,#SEG( _AudioControlPort )
	MOV.W	R3,#SOF( _AudioControlPort )
	MOV.W	[R3],R0
	SYMB	LINE, 154
	LSR.W	R1,#01H
	SYMB	LTIM, "n", 6, 0, 77
	SYMB	LTIM, "n", 6, 0, 205
	CMP.W	R1,#00H
	BG	_8
; audio.c   168		}
; audio.c   169	
; audio.c   170		AudioControl |= ( POT_CLK | POT_SDI | POT_CSAU | POT_CSCB);
	SYMB	LINE, 170
	OR.W	R0,#0FH
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R1,#SOF( _AudioControl )
	MOV.W	[R1],R0
; audio.c   171		AudioControlPort = AudioControl;
	SYMB	LINE, 171
	MOV.B	ES,#SEG( _AudioControlPort )
	MOV.W	R1,#SOF( _AudioControlPort )
	MOV.W	[R1],R0
; audio.c   172	
; audio.c   173		return( OK);
	SYMB	LINE, 173
	MOV.W	R0,#0FFFFH
; audio.c   174	}
	SYMB	LINE, 174
_12:
	RET
	SYMB	LTIM, "n", 6, 0, 77
	SYMB	LTIM, "d", 10, 0, 77
	SYMB	EFUN
; audio.c   175	
; audio.c   176	/**************************************************************************/
; audio.c   177	/* WriteAnlAudioDACLevel																			 	  AUDIO.C */
; audio.c   178	/*																																				*/
; audio.c   179	/* Author:	 Kim Engedahl, DEV, 000504																		*/
; audio.c   180	/* Revised:	 000603, KEn, DEV     																				*/
; audio.c   181	/*																																				*/
; audio.c   182	/* Function:   																														*/
; audio.c   183	/* Remarks:	 																															*/
; audio.c   184	/* Returns:																																*/
; audio.c   185	/* Updates:																																*/
; audio.c   186	/**************************************************************************/
; audio.c   187	int WriteAnlAudioDACLevel( UC left, UC right)
; audio.c   188	{	
	ALIGN	1
	SYMB	LINE, 188
	PUBLIC	_WriteAnlAudioDACLevel
_WriteAnlAudioDACLevel:
	SYMB	TYPE, 480, 'X', 12, #16, 30, 2, #3, #3
	SYMB	GFUN, "WriteAnlAudioDACLevel", _WriteAnlAudioDACLevel, #480, 0, 0, 16
	SYMB	ALAB, _WriteAnlAudioDACLevel, #480
	PUSH.W	R4
	SYMB	SOFF, 2
	ADDS.W	R7,#0EH
	SYMB	SOFF, 4
	SYMB	LTIM, "left", 0, 0, 2253
	SYMB	LTIM, "right", 1, 0, 2253
	MOV.B	R4L,R0H
	SYMB	LTIM, "right", 1, 0, 2125
	SYMB	LTIM, "right", 16, 0, 2253
	SYMB	IDEN, "left", 0, #3, 0, 2061
	SYMB	IDEN, "right", 16, #3, 0, 2061
; audio.c   189		Write_AD8402( AudioPotMeter, AnlAudioLeftChannel, left);
	SYMB	LINE, 189
	MOV.B	R0H,#00H
	MOV.B	R1L,#01H
	MOV.B	[R7],R0L
	SYMB	LTIM, "left", 0, 0, 2125
	SYMB	LTIM, "left", -4, 130, 2245
	MOV.B	R0L,R1L
	MOV.B	R1L,[R7]
	CALL	_Write_AD8402
	SYMB	LTIM, "left", -4, 130, 2117
	SYMB	LTIM, "left", 4, 0, 2253
	SYMB	LTIM, "left", 4, 0, 2125
; audio.c   190		Write_AD8402( AudioPotMeter, AnlAudioRightChannel, right);
	SYMB	LINE, 190
	MOV.B	R0L,#01H
	MOV.B	R1L,R4L
	MOV.B	R0H,#01H
	CALL	_Write_AD8402
	SYMB	LTIM, "right", 16, 0, 2125
	SYMB	LTIM, "right", 4, 0, 2253
	SYMB	LTIM, "right", 4, 0, 2125
; audio.c   191	
; audio.c   192		return( OK);
	SYMB	LINE, 192
	MOV.W	R0,#0FFFFH
; audio.c   193	}
	SYMB	LINE, 193
	ADDS.W	R7,#02H
	SYMB	SOFF, 2
	POP.W	R4
	SYMB	SOFF, 0
	RET
	SYMB	EFUN
; audio.c   194	
; audio.c   195	/**************************************************************************/
; audio.c   196	/* AudioDefaults																							 	  AUDIO.C */
; audio.c   197	/*																																				*/
; audio.c   198	/* Author:	 Kim Engedahl, DEV, 000526																		*/
; audio.c   199	/* Revised:	 000617, KEn, DEV     																				*/
; audio.c   200	/*																																				*/
; audio.c   201	/* Function:   																														*/
; audio.c   202	/* Remarks:	 																															*/
; audio.c   203	/* Returns:																																*/
; audio.c   204	/* Updates:																																*/
; audio.c   205	/**************************************************************************/
; audio.c   206	void AudioDefaults( void)
; audio.c   207	{	
	ALIGN	1
	SYMB	LINE, 207
	PUBLIC	_AudioDefaults
_AudioDefaults:
	SYMB	TYPE, 481, 'X', 12, #1, 30, 0
	SYMB	GFUN, "AudioDefaults", _AudioDefaults, #481, 0, 0, 112
	SYMB	ALAB, _AudioDefaults, #481
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
; audio.c   208		Settings.AudioOutput = AudioOutput = AESEBUAudio;
	SYMB	LINE, 208
	MOV.B	ES,#SEG( _AudioOutput )
	MOV.W	R0,#SOF( _AudioOutput )
	MOV.W	[R0],#01H
	MOV.B	ES,#SEG( _Settings+44 )
	MOV.W	R0,#SOF( _Settings+44 )
	MOV.W	[R0],#01H
; audio.c   209	
; audio.c   210		if ( Calibration.ResetSystem < NTSC)
	SYMB	LINE, 210
	MOV.B	ES,#SEG( _Calibration+97 )
	MOV.W	R0,#SOF( _Calibration+97 )
	MOV.B	R0L,[R0]
	CMP.B	R0L,#02H
	BCC	_15
; audio.c   211			Settings.AudioSetup[AESEBUAudio].System = AudioSetup[AESEBUAudio].System = AudioPAL;
	SYMB	LINE, 211
	MOV.B	ES,#SEG( _AudioSetup+14 )
	MOV.W	R0,#SOF( _AudioSetup+14 )
	MOV.W	[R0],#00H
	MOV.B	ES,#SEG( _Settings+60 )
	MOV.W	R0,#SOF( _Settings+60 )
	MOV.W	[R0],#00H
	BR	_16
_15:
; audio.c   212		else
; audio.c   213			Settings.AudioSetup[AESEBUAudio].System = AudioSetup[AESEBUAudio].System = AudioNTSC;
	SYMB	LINE, 213
	MOV.B	ES,#SEG( _AudioSetup+14 )
	MOV.W	R0,#SOF( _AudioSetup+14 )
	MOV.W	[R0],#01H
	MOV.B	ES,#SEG( _Settings+60 )
	MOV.W	R0,#SOF( _Settings+60 )
	MOV.W	[R0],#01H
_16:
; audio.c   214	
; audio.c   215		Settings.AudioSetup[AESEBUAudio].Signal = AudioSetup[AESEBUAudio].Signal = S1kHz;
	SYMB	LINE, 215
	MOV.B	ES,#SEG( _AudioSetup+16 )
	MOV.W	R0,#SOF( _AudioSetup+16 )
	MOV.W	[R0],#01H
	MOV.B	ES,#SEG( _Settings+62 )
	MOV.W	R0,#SOF( _Settings+62 )
	MOV.W	[R0],#01H
; audio.c   216		Settings.AudioSetup[AESEBUAudio].Level = AudioSetup[AESEBUAudio].Level = 0;
	SYMB	LINE, 216
	MOV.B	ES,#SEG( _AudioSetup+18 )
	MOV.W	R0,#SOF( _AudioSetup+18 )
	MOV.W	[R0],#00H
	MOV.B	ES,#SEG( _Settings+64 )
	MOV.W	R0,#SOF( _Settings+64 )
	MOV.W	[R0],#00H
; audio.c   217		Settings.AudioSetup[AESEBUAudio].Timing = AudioSetup[AESEBUAudio].Timing = TimingValues[0];
	SYMB	LINE, 217
	MOV.B	CS,#SEG( _TimingValues )
	MOV.W	R1,#SOF( _TimingValues )
	MOVC.W	R0,[R1+]
	FCALL	__US2SPF
	MOV.B	ES,#SEG( _AudioSetup+20 )
	MOV.W	R2,#SOF( _AudioSetup+20 )
	MOV.W	[R2+],R0
	MOV.W	[R2],R1
	MOV.B	ES,#SEG( _Settings+66 )
	MOV.W	R2,#SOF( _Settings+66 )
	MOV.W	[R2+],R0
	MOV.W	[R2],R1
; audio.c   218		Settings.AudioSetup[AESEBUAudio].Click = AudioSetup[AESEBUAudio].Click = click3s;
	SYMB	LINE, 218
	MOV.B	ES,#SEG( _AudioSetup+26 )
	MOV.W	R0,#SOF( _AudioSetup+26 )
	MOV.W	[R0],#03H
	MOV.B	ES,#SEG( _Settings+72 )
	MOV.W	R0,#SOF( _Settings+72 )
	MOV.W	[R0],#03H
; audio.c   219		Settings.AudioSetup[AESEBUAudio].Frequency = AudioSetup[AESEBUAudio].Frequency = f48kHz;
	SYMB	LINE, 219
	MOV.B	ES,#SEG( _AudioSetup+24 )
	MOV.W	R0,#SOF( _AudioSetup+24 )
	MOV.W	[R0],#01H
	MOV.B	ES,#SEG( _Settings+70 )
	MOV.W	R0,#SOF( _Settings+70 )
	MOV.W	[R0],#01H
; audio.c   220	
; audio.c   221		Settings.AudioSetup[AnalogAudio].Signal = AudioSetup[AnalogAudio].Signal = S1kHz;
	SYMB	LINE, 221
	MOV.B	ES,#SEG( _AudioSetup+2 )
	MOV.W	R0,#SOF( _AudioSetup+2 )
	MOV.W	[R0],#01H
	MOV.B	ES,#SEG( _Settings+48 )
	MOV.W	R0,#SOF( _Settings+48 )
	MOV.W	[R0],#01H
; audio.c   222		Settings.AudioSetup[AnalogAudio].Level = AudioSetup[AnalogAudio].Level = 0; 
	SYMB	LINE, 222
	MOV.B	ES,#SEG( _AudioSetup+4 )
	MOV.W	R0,#SOF( _AudioSetup+4 )
	MOV.W	[R0],#00H
	MOV.B	ES,#SEG( _Settings+50 )
	MOV.W	R0,#SOF( _Settings+50 )
	MOV.W	[R0],#00H
; audio.c   223		Settings.AudioSetup[AnalogAudio].Click = AudioSetup[AnalogAudio].Click = click3s;
	SYMB	LINE, 223
	MOV.B	ES,#SEG( _AudioSetup+12 )
	MOV.W	R0,#SOF( _AudioSetup+12 )
	MOV.W	[R0],#03H
	MOV.B	ES,#SEG( _Settings+58 )
	MOV.W	R0,#SOF( _Settings+58 )
	MOV.W	[R0],#03H
; audio.c   224	
; audio.c   225		NV_Store( &Settings, SettingsPtr, sizeof( Settings));
	SYMB	LINE, 225
	MOV.W	R1,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.B	ES,#SEG( _SettingsPtr )
	MOV.W	R2,#SOF( _SettingsPtr )
	MOV.W	R2,[R2]
	MOV.W	R3,#04AH
	CALL	_NV_Store
; audio.c   226	}
	SYMB	LINE, 226
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	EFUN
; audio.c   227	
; audio.c   228	/**************************************************************************/
; audio.c   229	/* AudioInit																									 	  AUDIO.C */
; audio.c   230	/*																																				*/
; audio.c   231	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   232	/* Revised:	 000617, KEn, DEV     																				*/
; audio.c   233	/*																																				*/
; audio.c   234	/* Function:   																														*/
; audio.c   235	/* Remarks:	 																															*/
; audio.c   236	/* Returns:																																*/
; audio.c   237	/* Updates:																																*/
; audio.c   238	/**************************************************************************/
; audio.c   239	int AudioInit( void)
; audio.c   240	{	
	ALIGN	1
	SYMB	LINE, 240
	PUBLIC	_AudioInit
_AudioInit:
	SYMB	TYPE, 482, 'X', 12, #16, 30, 0
	SYMB	GFUN, "AudioInit", _AudioInit, #482, 0, 0, 0
	SYMB	ALAB, _AudioInit, #482
; audio.c   241		WriteAnlAudioDACLevel( Calibration.AudioCalibration.AnalogLeftChannel,
; audio.c   242											    	  Calibration.AudioCalibration.AnalogRightChannel);
	SYMB	LINE, 242
	MOV.B	ES,#SEG( _Calibration+222 )
	MOV.W	R0,#SOF( _Calibration+222 )
	MOV.B	R0L,[R0]
	MOV.B	ES,#SEG( _Calibration+223 )
	MOV.W	R1,#SOF( _Calibration+223 )
	MOV.B	R0H,[R1]
	CALL	_WriteAnlAudioDACLevel
; audio.c   243	
; audio.c   244		AudioSetup[AESEBUAudio].System = Settings.AudioSetup[AESEBUAudio].System;
	SYMB	LINE, 244
	MOV.B	ES,#SEG( _Settings+60 )
	MOV.W	R0,#SOF( _Settings+60 )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioSetup+14 )
	MOV.W	R1,#SOF( _AudioSetup+14 )
	MOV.W	[R1],R0
; audio.c   245		AudioSetup[AESEBUAudio].Signal = Settings.AudioSetup[AESEBUAudio].Signal;
	SYMB	LINE, 245
	MOV.B	ES,#SEG( _Settings+62 )
	MOV.W	R0,#SOF( _Settings+62 )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioSetup+16 )
	MOV.W	R1,#SOF( _AudioSetup+16 )
	MOV.W	[R1],R0
; audio.c   246		AudioSetup[AESEBUAudio].Level = Settings.AudioSetup[AESEBUAudio].Level;
	SYMB	LINE, 246
	MOV.B	ES,#SEG( _Settings+64 )
	MOV.W	R0,#SOF( _Settings+64 )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioSetup+18 )
	MOV.W	R1,#SOF( _AudioSetup+18 )
	MOV.W	[R1],R0
; audio.c   247		AudioSetup[AESEBUAudio].Timing = Settings.AudioSetup[AESEBUAudio].Timing;
	SYMB	LINE, 247
	MOV.B	ES,#SEG( _Settings+66 )
	MOV.W	R1,#SOF( _Settings+66 )
	MOV.W	R0,[R1+]
	MOV.W	R1,[R1]
	MOV.B	ES,#SEG( _AudioSetup+20 )
	MOV.W	R2,#SOF( _AudioSetup+20 )
	MOV.W	[R2+],R0
	MOV.W	[R2],R1
; audio.c   248		AudioSetup[AESEBUAudio].Click = Settings.AudioSetup[AESEBUAudio].Click;
	SYMB	LINE, 248
	MOV.B	ES,#SEG( _Settings+72 )
	MOV.W	R0,#SOF( _Settings+72 )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioSetup+26 )
	MOV.W	R1,#SOF( _AudioSetup+26 )
	MOV.W	[R1],R0
; audio.c   249		AudioSetup[AESEBUAudio].Frequency = Settings.AudioSetup[AESEBUAudio].Frequency;
	SYMB	LINE, 249
	MOV.B	ES,#SEG( _Settings+70 )
	MOV.W	R0,#SOF( _Settings+70 )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioSetup+24 )
	MOV.W	R1,#SOF( _AudioSetup+24 )
	MOV.W	[R1],R0
; audio.c   250	
; audio.c   251		AudioSetup[AnalogAudio].Signal = Settings.AudioSetup[AnalogAudio].Signal;
	SYMB	LINE, 251
	MOV.B	ES,#SEG( _Settings+48 )
	MOV.W	R0,#SOF( _Settings+48 )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioSetup+2 )
	MOV.W	R1,#SOF( _AudioSetup+2 )
	MOV.W	[R1],R0
; audio.c   252		AudioSetup[AnalogAudio].Level = Settings.AudioSetup[AnalogAudio].Level;
	SYMB	LINE, 252
	MOV.B	ES,#SEG( _Settings+50 )
	MOV.W	R0,#SOF( _Settings+50 )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioSetup+4 )
	MOV.W	R1,#SOF( _AudioSetup+4 )
	MOV.W	[R1],R0
; audio.c   253		AudioSetup[AnalogAudio].Click = Settings.AudioSetup[AnalogAudio].Click;
	SYMB	LINE, 253
	MOV.B	ES,#SEG( _Settings+58 )
	MOV.W	R0,#SOF( _Settings+58 )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioSetup+12 )
	MOV.W	R1,#SOF( _AudioSetup+12 )
	MOV.W	[R1],R0
; audio.c   254	
; audio.c   255		// NOTE!! WordClock is NOT defined for the analog audio, hence it is necessary
; audio.c   256		//  to ensure that either of the front WordClock LEDs is switched on if
; audio.c   257		//  the PT5201 is to start in analog audio mode, i.e. the wordclock LEDs is
; audio.c   258		//  updated with the state of the AESEBU audio wordclock even though analog audio
; audio.c   259		//  is selected.
; audio.c   260		LEDSet( WordClk441LED, AudioSetup[AESEBUAudio].Frequency == f441kHz);	
	SYMB	LINE, 260
	MOV.W	R0,#01000H
	MOV.B	ES,#SEG( _AudioSetup+24 )
	MOV.W	R1,#SOF( _AudioSetup+24 )
	MOV.W	R1,[R1]
	BNE	_18
	MOVS.W	R1,#01H
	BR	_19
_18:
	MOVS.W	R1,#00H
_19:
	CALL	_LEDSet
; audio.c   261		LEDSet( WordClk48LED, AudioSetup[AESEBUAudio].Frequency == f48kHz);
	SYMB	LINE, 261
	MOV.W	R0,#02000H
	MOV.B	ES,#SEG( _AudioSetup+24 )
	MOV.W	R1,#SOF( _AudioSetup+24 )
	MOV.W	R1,[R1]
	CMP.W	R1,#01H
	BNE	_20
	MOVS.W	R1,#01H
	BR	_22
_20:
	MOVS.W	R1,#00H
_22:
	CALL	_LEDSet
; audio.c   262	
; audio.c   263		return( SetAudioOutput( Settings.AudioOutput));
	SYMB	LINE, 263
	MOV.B	ES,#SEG( _Settings+44 )
	MOV.W	R0,#SOF( _Settings+44 )
	MOV.W	R0,[R0]
	CALL	_SetAudioOutput
; audio.c   264	}
	SYMB	LINE, 264
	RET
	SYMB	EFUN
; audio.c   265	
; audio.c   266	/**************************************************************************/
; audio.c   267	/* AudioStatus																								 	  AUDIO.C */
; audio.c   268	/*																																				*/
; audio.c   269	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   270	/* Revised:	 000628, KEn, DEV     																				*/
; audio.c   271	/*																																				*/
; audio.c   272	/* Function:   																														*/
; audio.c   273	/* Remarks:	 																															*/
; audio.c   274	/* Returns:																																*/
; audio.c   275	/* Updates:																																*/
; audio.c   276	/**************************************************************************/
; audio.c   277	UC AudioStatus( void)
; audio.c   278	{
	ALIGN	1
	SYMB	LINE, 278
	PUBLIC	_AudioStatus
_AudioStatus:
	SYMB	TYPE, 483, 'X', 12, #3, 30, 0
	SYMB	GFUN, "AudioStatus", _AudioStatus, #483, 0, 0, 0
	SYMB	ALAB, _AudioStatus, #483
; audio.c   279		return(( AudioControlPort >> 8) && 0xFC);
	SYMB	LINE, 279
	MOV.B	ES,#SEG( _AudioControlPort )
	MOV.W	R0,#SOF( _AudioControlPort )
	MOV.W	R0,[R0]
	ASR.W	R0,#08H
	OR.W	R0,R0
	BEQ	_23
	MOV.B	R0L,#0FCH
_23:
	BEQ	_24
	MOVS.B	R0L,#01H
	BR	_25
_24:
	MOVS.B	R0L,#00H
_25:
; audio.c   280	 }
	SYMB	LINE, 280
	RET
	SYMB	EFUN
; audio.c   281	
; audio.c   282	/**************************************************************************/
; audio.c   283	/* SetAudioOutput																							 	  AUDIO.C */
; audio.c   284	/*																																				*/
; audio.c   285	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   286	/* Revised:	 000618, KEn, DEV     																				*/
; audio.c   287	/*																																				*/
; audio.c   288	/* Function:   																														*/
; audio.c   289	/* Remarks:	 																															*/
; audio.c   290	/* Returns:																																*/
; audio.c   291	/* Updates:																																*/
; audio.c   292	/**************************************************************************/
; audio.c   293	int SetAudioOutput( int output)
; audio.c   294	{
	ALIGN	1
	SYMB	LINE, 294
	PUBLIC	_SetAudioOutput
_SetAudioOutput:
	SYMB	TYPE, 484, 'X', 12, #16, 30, 1, #16
	SYMB	GFUN, "SetAudioOutput", _SetAudioOutput, #484, 0, 0, 112
	SYMB	ALAB, _SetAudioOutput, #484
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	ADDS.W	R7,#0EH
	SYMB	SOFF, 8
	SYMB	LTIM, "output", 2, 0, 2253
	SYMB	IDEN, "output", 2, #16, 0, 2061
; audio.c   295		Settings.ActivePreset = 0;
	SYMB	LINE, 295
	MOV.B	ES,#SEG( _Settings )
	MOV.W	R1,#SOF( _Settings )
	MOV.W	[R1],#00H
; audio.c   296	
; audio.c   297		Settings.AudioOutput = AudioOutput = output;
	SYMB	LINE, 297
	MOV.W	R4,R0
	MOV.B	ES,#SEG( _AudioOutput )
	MOV.W	R0,#SOF( _AudioOutput )
	MOV.W	[R0],R4
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", 18, 0, 2253
	MOV.B	ES,#SEG( _Settings+44 )
	MOV.W	R0,#SOF( _Settings+44 )
	MOV.W	[R0],R4
; audio.c   298		NV_Store( &Settings, SettingsPtr, sizeof( Settings));
	SYMB	LINE, 298
	MOV.W	R1,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.B	ES,#SEG( _SettingsPtr )
	MOV.W	R2,#SOF( _SettingsPtr )
	MOV.W	R2,[R2]
	MOV.W	R3,#04AH
	CALL	_NV_Store
; audio.c   299	
; audio.c   300		if ( output == AnalogAudio)
	SYMB	LINE, 300
	OR.W	R4,R4
	BNE	_26
; audio.c   301			AudioControl |= SELANALOG;			// Select analog output
	SYMB	LINE, 301
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R0,#SOF( _AudioControl )
	MOV.W	R0,[R0]
	OR.W	R0,#020H
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R1,#SOF( _AudioControl )
	MOV.W	[R1],R0
	BR	_27
_26:
; audio.c   302		else
; audio.c   303			AudioControl |= SELAESEBU;			// Select AES/EBU output
	SYMB	LINE, 303
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R0,#SOF( _AudioControl )
	MOV.W	R0,[R0]
	OR.W	R0,#010H
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R1,#SOF( _AudioControl )
	MOV.W	[R1],R0
_27:
; audio.c   304	
; audio.c   305		AudioControlPort = AudioControl; 	// Select output mode. The output selection
	SYMB	LINE, 305
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R0,#SOF( _AudioControl )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioControlPort )
	MOV.W	R1,#SOF( _AudioControlPort )
	MOV.W	[R1],R0
; audio.c   306																		 	//  requires the generation of a 50ms pulse.
; audio.c   307	
; audio.c   308		Sleep( 50);											 	// Sleep for 50 ms
	SYMB	LINE, 308
	MOV.W	R0,#032H
	CALL	_Sleep
; audio.c   309	
; audio.c   310		AudioControl &= ~( SELANALOG + SELAESEBU);	// End of 50ms pulse
	SYMB	LINE, 310
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R0,#SOF( _AudioControl )
	MOV.W	R0,[R0]
	AND.W	R0,#0FFCFH
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R1,#SOF( _AudioControl )
	MOV.W	[R1],R0
; audio.c   311	
; audio.c   312																					// Update output variable and LEDs
; audio.c   313		LEDSet( AnalogAudioLED, output == AnalogAudio);
	SYMB	LINE, 313
	MOV.W	R0,#0100H
	OR.W	R4,R4
	BNE	_28
	MOVS.W	R1,#01H
	BR	_29
_28:
	MOVS.W	R1,#00H
_29:
	CALL	_LEDSet
; audio.c   314		LEDSet( AESEBUAudioLED, output == AESEBUAudio);
	SYMB	LINE, 314
	MOV.W	R0,#0200H
	CMP.W	R4,#01H
	BNE	_30
	MOVS.W	R1,#01H
	BR	_32
_30:
	MOVS.W	R1,#00H
_32:
	CALL	_LEDSet
; audio.c   315	
; audio.c   316		SetAudioSystem( output, AudioSetup[output].System);
	SYMB	LINE, 316
	MOV.W	R0,#0EH
	MULU.W	R0,R4
	MOV.W	R6,R0
	MOV.W	R0,R6
	MOVS.W	R1,#00H
	MOV.B	ES,#SEG( _AudioSetup )
	MOV.W	R1,[R0+SOF( _AudioSetup )]
	MOV.W	[R7],R4
	MOV.W	R0,R4
	SYMB	LTIM, "output", 18, 0, 2125
	SYMB	LTIM, "output", -8, 130, 2245
	SYMB	LTIM, "output", -8, 130, 2117
	SYMB	LTIM, "output", 2, 0, 2253
	CALL	_SetAudioSystem
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", -8, 130, 2245
; audio.c   317		SetAudioSignal( output, AudioSetup[output].Signal);
	SYMB	LINE, 317
	MOV.W	R4,R6
	MOVS.W	R5,#00H
	MOV.B	ES,#SEG( _AudioSetup+2 )
	MOV.W	R1,[R4+SOF( _AudioSetup+2 )]
	MOV.W	R0,[R7]
	SYMB	LTIM, "output", -8, 130, 2117
	SYMB	LTIM, "output", 2, 0, 2253
	CALL	_SetAudioSignal
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", -8, 130, 2245
; audio.c   318		SetAudioLevel( output, AudioSetup[output].Level);
	SYMB	LINE, 318
	MOV.B	ES,#SEG( _AudioSetup+4 )
	MOV.W	R1,[R4+SOF( _AudioSetup+4 )]
	MOV.W	R0,[R7]
	SYMB	LTIM, "output", -8, 130, 2117
	SYMB	LTIM, "output", 2, 0, 2253
	CALL	_SetAudioLevel
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", -8, 130, 2245
; audio.c   319		SetAudioTiming( output, AudioSetup[output].Timing);
	SYMB	LINE, 319
	MOV.W	R2,R6
	MOVS.W	R3,#00H
	MOV.B	ES,#SEG( _AudioSetup+6 )
	MOV.W	R3,[R2+SOF( _AudioSetup+8 )]
	MOV.W	R2,[R2+SOF( _AudioSetup+6 )]
	MOV.W	R0,[R7]
	SYMB	LTIM, "output", -8, 130, 2117
	SYMB	LTIM, "output", 2, 0, 2253
	CALL	_SetAudioTiming
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", -8, 130, 2245
; audio.c   320		SetAudioWordClock( output, AudioSetup[output].Frequency);
	SYMB	LINE, 320
	MOV.B	ES,#SEG( _AudioSetup+10 )
	MOV.W	R1,[R4+SOF( _AudioSetup+10 )]
	MOV.W	R0,[R7]
	SYMB	LTIM, "output", -8, 130, 2117
	SYMB	LTIM, "output", 2, 0, 2253
	CALL	_SetAudioWordClock
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", -8, 130, 2245
; audio.c   321		SetAudioClick( output, AudioSetup[output].Click);
	SYMB	LINE, 321
	MOV.B	ES,#SEG( _AudioSetup+12 )
	MOV.W	R1,[R4+SOF( _AudioSetup+12 )]
	MOV.W	R0,[R7]
	CALL	_SetAudioClick
	SYMB	LTIM, "output", -8, 130, 2117
	SYMB	LTIM, "output", 2, 0, 2253
	SYMB	LTIM, "output", 2, 0, 2125
; audio.c   322	
; audio.c   323		return( OK);
	SYMB	LINE, 323
	MOV.W	R0,#0FFFFH
; audio.c   324	}
	SYMB	LINE, 324
	ADDS.W	R7,#02H
	SYMB	SOFF, 6
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	EFUN
; audio.c   325	
; audio.c   326	/**************************************************************************/
; audio.c   327	/* SetAudioSystem																							 	  AUDIO.C */
; audio.c   328	/*																																				*/
; audio.c   329	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   330	/* Revised:	 000618, KEn, DEV     																				*/
; audio.c   331	/*																																				*/
; audio.c   332	/* Function:   																														*/
; audio.c   333	/* Remarks:	 Only possible if the selected audio output is AES/EBU				*/
; audio.c   334	/* Returns:	 FAIL if the selected output is different from AES/EBU,				*/
; audio.c   335	/*					 otherwise is returns OK.																			*/
; audio.c   336	/* Updates:																																*/
; audio.c   337	/**************************************************************************/
; audio.c   338	int SetAudioSystem( int output, int system)
; audio.c   339	{
	ALIGN	1
	SYMB	LINE, 339
	PUBLIC	_SetAudioSystem
_SetAudioSystem:
	SYMB	TYPE, 485, 'X', 12, #16, 30, 2, #16, #16
	SYMB	GFUN, "SetAudioSystem", _SetAudioSystem, #485, 0, 0, 112
	SYMB	ALAB, _SetAudioSystem, #485
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	ADDS.W	R7,#0EH
	SYMB	SOFF, 8
	SYMB	LTIM, "output", 2, 0, 2253
	SYMB	LTIM, "system", 6, 0, 2253
	MOV.W	R2,R1
	SYMB	LTIM, "system", 6, 0, 2125
	SYMB	LTIM, "system", 10, 0, 2253
	SYMB	IDEN, "output", 2, #16, 0, 2061
	SYMB	IDEN, "system", 10, #16, 0, 2061
	SYMB	IDEN, "tmp", -1, #16, 130, 5
	SYMB	LTIM, "tmp", -1, 0, 69
; audio.c   340		int tmp = AudioControl;
	SYMB	LINE, 340
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R4,#SOF( _AudioControl )
	MOV.W	R4,[R4]
	MOV.W	R5,R4
	SYMB	LTIM, "tmp", 22, 0, 205
; audio.c   341	
; audio.c   342		if ( output != AESEBUAudio)
	SYMB	LINE, 342
	MOV.W	R6,R0
	CMP.W	R6,#01H
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", 26, 0, 2253
	BEQ	_33
; audio.c   343			return( FAIL);
	SYMB	LINE, 343
	MOV.W	R0,#00H
	BR	_37
_33:
	SYMB	LTIM, "output", 26, 0, 2125
	SYMB	LTIM, "output", 26, 0, 2253
	SYMB	LTIM, "system", 10, 0, 2125
	SYMB	LTIM, "system", 10, 0, 2253
	SYMB	LTIM, "tmp", 22, 0, 77
	SYMB	LTIM, "tmp", 22, 0, 205
; audio.c   344	
; audio.c   345		Settings.ActivePreset = 0;
	SYMB	LINE, 345
	MOV.B	ES,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.W	[R0],#00H
; audio.c   346	
; audio.c   347		Settings.AudioSetup[output].System = AudioSetup[output].System = system;
	SYMB	LINE, 347
	MOV.W	R0,#0EH
	MULU.W	R0,R6
	MOVS.W	R1,#00H
	MOV.B	ES,#SEG( _AudioSetup )
	MOV.W	[R0+SOF( _AudioSetup )],R2
	MOV.W	[R7],R2
	MOV.B	ES,#SEG( _Settings+46 )
	MOV.W	[R0+SOF( _Settings+46 )],R2
	SYMB	LTIM, "system", 10, 0, 2125
	SYMB	LTIM, "system", -8, 130, 2245
; audio.c   348		NV_Store( &Settings, SettingsPtr, sizeof( Settings));
	SYMB	LINE, 348
	MOV.W	R1,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.B	ES,#SEG( _SettingsPtr )
	MOV.W	R2,#SOF( _SettingsPtr )
	MOV.W	R2,[R2]
	MOV.W	R3,#04AH
	CALL	_NV_Store
; audio.c   349	
; audio.c   350		if ( system == AudioPAL)
	SYMB	LINE, 350
	MOV.W	R0,[R7]
	SYMB	LTIM, "system", -8, 130, 2117
	SYMB	LTIM, "system", 2, 0, 2253
	BNE	_34
; audio.c   351			tmp &= ~NTSCPHASE;
	SYMB	LINE, 351
	AND.W	R4,#0FFBFH
	MOV.W	R0,R4
	SYMB	LTIM, "system", 2, 0, 2125
	SYMB	LTIM, "tmp", 22, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
	BR	_35
_34:
	SYMB	LTIM, "tmp", 2, 0, 77
	SYMB	LTIM, "tmp", 22, 0, 205
; audio.c   352		else
; audio.c   353			tmp |= NTSCPHASE;
	SYMB	LINE, 353
	MOV.W	R0,R5
	OR.W	R0,#040H
	SYMB	LTIM, "tmp", 22, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
	SYMB	LTIM, "tmp", 2, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
_35:
; audio.c   354	
; audio.c   355		if ( output == AudioOutput)
	SYMB	LINE, 355
	MOV.B	ES,#SEG( _AudioOutput )
	MOV.W	R1,#SOF( _AudioOutput )
	MOV.W	R1,[R1]
	CMP.W	R6,R1
	BNE	_36
; audio.c   356		{
; audio.c   357			AudioControl = tmp;
	SYMB	LINE, 357
	MOV.B	ES,#SEG( _AudioControl )
	MOV.W	R1,#SOF( _AudioControl )
	MOV.W	[R1],R0
; audio.c   358			AudioControlPort = AudioControl;
	SYMB	LINE, 358
	MOV.B	ES,#SEG( _AudioControlPort )
	MOV.W	R1,#SOF( _AudioControlPort )
	MOV.W	[R1],R0
; audio.c   359		}
	SYMB	LINE, 359
_36:
; audio.c   360	
; audio.c   361		return( OK);
	SYMB	LINE, 361
	MOV.W	R0,#0FFFFH
	SYMB	LTIM, "tmp", 2, 0, 77
; audio.c   362	}
	SYMB	LINE, 362
_37:
	ADDS.W	R7,#02H
	SYMB	SOFF, 6
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "output", 26, 0, 2125
	SYMB	EFUN
; audio.c   363	
; audio.c   364	/**************************************************************************/
; audio.c   365	/* SetAudioSignal																							 	  AUDIO.C */
; audio.c   366	/*																																				*/
; audio.c   367	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   368	/* Revised:	 000618, KEn, DEV     																				*/
; audio.c   369	/*																																				*/
; audio.c   370	/* Function:   																														*/
; audio.c   371	/* Remarks:	 																															*/
; audio.c   372	/* Returns:	 FAIL if signal is not valid, otherwise OK.										*/
; audio.c   373	/* Updates:																																*/
; audio.c   374	/**************************************************************************/
; audio.c   375	int SetAudioSignal( int output, int signal)
; audio.c   376	{
	ALIGN	1
	SYMB	LINE, 376
	PUBLIC	_SetAudioSignal
_SetAudioSignal:
	SYMB	TYPE, 486, 'X', 12, #16, 30, 2, #16, #16
	SYMB	GFUN, "SetAudioSignal", _SetAudioSignal, #486, 0, 0, 112
	SYMB	ALAB, _SetAudioSignal, #486
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	ADDS.W	R7,#0EH
	SYMB	SOFF, 8
	SYMB	LTIM, "output", 2, 0, 2253
	SYMB	LTIM, "signal", 6, 0, 2253
	MOV.W	R2,R0
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", 10, 0, 2253
	SYMB	IDEN, "output", 10, #16, 0, 2061
	SYMB	IDEN, "signal", 6, #16, 0, 2061
	SYMB	IDEN, "tmp", -1, #16, 130, 5
	SYMB	LTIM, "tmp", -1, 0, 69
; audio.c   377		int tmp;
; audio.c   378	
; audio.c   379		if ( signal > S8kHz)
	SYMB	LINE, 379
	MOV.W	R6,R1
	CMP.W	R6,#03H
	SYMB	LTIM, "signal", 6, 0, 2125
	SYMB	LTIM, "signal", 26, 0, 2253
	BLE	_40
; audio.c   380			return( FAIL);
	SYMB	LINE, 380
	MOV.W	R0,#00H
	BR	_46
_40:
	SYMB	LTIM, "output", 10, 0, 2125
	SYMB	LTIM, "output", 10, 0, 2253
	SYMB	LTIM, "signal", 26, 0, 2125
	SYMB	LTIM, "signal", 26, 0, 2253
; audio.c   381	
; audio.c   382		Settings.ActivePreset = 0;
	SYMB	LINE, 382
	MOV.B	ES,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.W	[R0],#00H
; audio.c   383	
; audio.c   384		Settings.AudioSetup[output].Signal = AudioSetup[output].Signal = signal;
	SYMB	LINE, 384
	MOV.W	R4,#0EH
	MOV.W	[R7],R2
	MULU.W	R4,R2
	SYMB	LTIM, "output", 10, 0, 2125
	SYMB	LTIM, "output", -8, 130, 2245
	MOVS.W	R5,#00H
	MOV.B	ES,#SEG( _AudioSetup+2 )
	MOV.W	[R4+SOF( _AudioSetup+2 )],R6
	MOV.B	ES,#SEG( _Settings+48 )
	MOV.W	[R4+SOF( _Settings+48 )],R6
; audio.c   385		NV_Store( &Settings, SettingsPtr, sizeof( Settings));
	SYMB	LINE, 385
	MOV.W	R1,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.B	ES,#SEG( _SettingsPtr )
	MOV.W	R2,#SOF( _SettingsPtr )
	MOV.W	R2,[R2]
	MOV.W	R3,#04AH
	CALL	_NV_Store
; audio.c   386	
; audio.c   387		if ( output == AnalogAudio)
	SYMB	LINE, 387
	MOV.W	R0,[R7]
	BNE	_41
; audio.c   388			tmp = ANALOGAUDIOOFFSET;				// Analog signal offset
	SYMB	LINE, 388
	MOV.W	R0,#08H
	SYMB	LTIM, "tmp", 2, 0, 205
	BR	_44
_41:
; audio.c   389		else
; audio.c   390		{
; audio.c   391			if ( AudioSetup[output].Frequency == f441kHz)
	SYMB	LINE, 391
	MOV.B	ES,#SEG( _AudioSetup+10 )
	MOV.W	R0,[R4+SOF( _AudioSetup+10 )]
	SYMB	LTIM, "tmp", 2, 0, 77
	BNE	_42
; audio.c   392				tmp = AESEBUF441KHZOFFSET;		// AESEBU 44.1kHz signal offset
	SYMB	LINE, 392
	MOV.W	R0,#04H
	SYMB	LTIM, "tmp", 2, 0, 205
	BR	_44
_42:
; audio.c   393			else
; audio.c   394				tmp = AESEBUF48KHZOFFSET;			// AESEBU 48kHz signal offset
	SYMB	LINE, 394
	MOV.W	R0,#00H
	SYMB	LTIM, "tmp", 2, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
; audio.c   395		}
	SYMB	LINE, 395
_44:
; audio.c   396	
; audio.c   397		tmp += signal;
	SYMB	LINE, 397
	ADD.W	R0,R6
	SYMB	LTIM, "tmp", 2, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
; audio.c   398		tmp += CLICKPERIOD*AudioSetup[output].Click;
	SYMB	LINE, 398
	MOV.B	ES,#SEG( _AudioSetup+12 )
	MOV.W	R1,[R4+SOF( _AudioSetup+12 )]
	ASL.W	R1,#08H
	ADD.W	R0,R1
	SYMB	LTIM, "tmp", 2, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
; audio.c   399	
; audio.c   400		if ( output == AudioOutput)
	SYMB	LINE, 400
	MOV.B	ES,#SEG( _AudioOutput )
	MOV.W	R1,#SOF( _AudioOutput )
	MOV.W	R1,[R1]
	MOV.W	R2,[R7]
	CMP.W	R2,R1
	SYMB	LTIM, "output", -8, 130, 2117
	SYMB	LTIM, "output", 10, 0, 2253
	BNE	_45
; audio.c   401		{
; audio.c   402			AudioMode = tmp;
	SYMB	LINE, 402
	MOV.B	ES,#SEG( _AudioMode )
	MOV.W	R1,#SOF( _AudioMode )
	MOV.W	[R1],R0
; audio.c   403			AudioModePort = AudioMode;
	SYMB	LINE, 403
	MOV.B	ES,#SEG( _AudioModePort )
	MOV.W	R1,#SOF( _AudioModePort )
	MOV.W	[R1],R0
; audio.c   404		}
	SYMB	LINE, 404
_45:
; audio.c   405	
; audio.c   406		return( OK);
	SYMB	LINE, 406
	MOV.W	R0,#0FFFFH
	SYMB	LTIM, "tmp", 2, 0, 77
; audio.c   407	}
	SYMB	LINE, 407
_46:
	ADDS.W	R7,#02H
	SYMB	SOFF, 6
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "output", 10, 0, 2125
	SYMB	LTIM, "signal", 26, 0, 2125
	SYMB	EFUN
; audio.c   408	
; audio.c   409	/**************************************************************************/
; audio.c   410	/* SetAudioLevel																							 	  AUDIO.C */
; audio.c   411	/*																																				*/
; audio.c   412	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   413	/* Revised:	 000618, KEn, DEV     																				*/
; audio.c   414	/*																																				*/
; audio.c   415	/* Function:   																														*/
; audio.c   416	/* Remarks:	 																															*/
; audio.c   417	/* Returns:	 FAIL if level is invalid, otherwise it returns OK.				 		*/
; audio.c   418	/* Updates:																																*/
; audio.c   419	/**************************************************************************/
; audio.c   420	int SetAudioLevel( int output, int level)
; audio.c   421	{
	ALIGN	1
	SYMB	LINE, 421
	PUBLIC	_SetAudioLevel
_SetAudioLevel:
	SYMB	TYPE, 487, 'X', 12, #16, 30, 2, #16, #16
	SYMB	GFUN, "SetAudioLevel", _SetAudioLevel, #487, 0, 0, 48
	SYMB	ALAB, _SetAudioLevel, #487
	PUSH.W	R4, R5
	SYMB	SOFF, 4
	SYMB	LTIM, "output", 2, 0, 2253
	SYMB	LTIM, "level", 6, 0, 2253
	MOV.W	R5,R1
	SYMB	LTIM, "level", 6, 0, 2125
	SYMB	LTIM, "level", 22, 0, 2253
	SYMB	IDEN, "output", 2, #16, 0, 2061
	SYMB	IDEN, "level", 22, #16, 0, 2061
; audio.c   422		if ( output == AESEBUAudio)
	SYMB	LINE, 422
	MOV.W	R4,R0
	CMP.W	R4,#01H
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", 18, 0, 2253
	BNE	_49
; audio.c   423		{
; audio.c   424			if ( level > AESEBUSilence)
	SYMB	LINE, 424
	CMP.W	R5,#07H
	BLE	_51
; audio.c   425				return( FAIL);
	SYMB	LINE, 425
	MOV.W	R0,#00H
	BR	_54
; audio.c   426		}
	SYMB	LINE, 426
_49:
	SYMB	LTIM, "output", 18, 0, 2125
	SYMB	LTIM, "output", 18, 0, 2253
	SYMB	LTIM, "level", 22, 0, 2125
	SYMB	LTIM, "level", 22, 0, 2253
; audio.c   427		else
; audio.c   428		{
; audio.c   429			if ( level > AnalogSilence)
	SYMB	LINE, 429
	CMP.W	R5,#01FH
	BLE	_51
; audio.c   430				return( FAIL);
	SYMB	LINE, 430
	MOV.W	R0,#00H
	BR	_54
; audio.c   431		}
	SYMB	LINE, 431
_51:
	SYMB	LTIM, "output", 18, 0, 2125
	SYMB	LTIM, "output", 18, 0, 2253
	SYMB	LTIM, "level", 22, 0, 2125
	SYMB	LTIM, "level", 22, 0, 2253
; audio.c   432	
; audio.c   433		Settings.ActivePreset = 0;
	SYMB	LINE, 433
	MOV.B	ES,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.W	[R0],#00H
; audio.c   434	
; audio.c   435		Settings.AudioSetup[output].Level = AudioSetup[output].Level = level;
	SYMB	LINE, 435
	MOV.W	R0,#0EH
	MULU.W	R0,R4
	MOVS.W	R1,#00H
	MOV.B	ES,#SEG( _AudioSetup+4 )
	MOV.W	[R0+SOF( _AudioSetup+4 )],R5
	MOV.B	ES,#SEG( _Settings+50 )
	MOV.W	[R0+SOF( _Settings+50 )],R5
; audio.c   436		NV_Store( &Settings, SettingsPtr, sizeof( Settings));
	SYMB	LINE, 436
	MOV.W	R1,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.B	ES,#SEG( _SettingsPtr )
	MOV.W	R2,#SOF( _SettingsPtr )
	MOV.W	R2,[R2]
	MOV.W	R3,#04AH
	CALL	_NV_Store
; audio.c   437	
; audio.c   438		if ( output == AudioOutput)
	SYMB	LINE, 438
	MOV.B	ES,#SEG( _AudioOutput )
	MOV.W	R0,#SOF( _AudioOutput )
	MOV.W	R0,[R0]
	CMP.W	R4,R0
	BNE	_52
; audio.c   439		{
; audio.c   440			AudioLevel &= ~AUDIOLEVEL;
	SYMB	LINE, 440
	MOV.B	ES,#SEG( _AudioLevel )
	MOV.W	R0,#SOF( _AudioLevel )
	MOV.W	R0,[R0]
	AND.W	R0,#0FFFFH
	MOV.B	ES,#SEG( _AudioLevel )
	MOV.W	R1,#SOF( _AudioLevel )
	MOV.W	[R1],R0
; audio.c   441			AudioLevel = level;
	SYMB	LINE, 441
	MOV.B	ES,#SEG( _AudioLevel )
	MOV.W	R0,#SOF( _AudioLevel )
	MOV.W	[R0],R5
; audio.c   442			AudioLevelPort = AudioLevel;
	SYMB	LINE, 442
	MOV.B	ES,#SEG( _AudioLevelPort )
	MOV.W	R0,#SOF( _AudioLevelPort )
	MOV.W	[R0],R5
; audio.c   443		}
	SYMB	LINE, 443
_52:
; audio.c   444	
; audio.c   445		return( OK);
	SYMB	LINE, 445
	MOV.W	R0,#0FFFFH
; audio.c   446	}
	SYMB	LINE, 446
_54:
	POP.W	R4, R5
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "level", 22, 0, 2125
	SYMB	LTIM, "output", 18, 0, 2125
	SYMB	EFUN
; audio.c   447	
; audio.c   448	/**************************************************************************/
; audio.c   449	/* SetAudioTiming																							 	  AUDIO.C */
; audio.c   450	/*																																				*/
; audio.c   451	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   452	/* Revised:	 000618, KEn, DEV     																				*/
; audio.c   453	/*																																				*/
; audio.c   454	/* Function:   																														*/
; audio.c   455	/* Remarks:	 																															*/
; audio.c   456	/* Returns:																																*/
; audio.c   457	/* Updates:																																*/
; audio.c   458	/**************************************************************************/
; audio.c   459	int SetAudioTiming( int output, float timing)
; audio.c   460	{
	ALIGN	1
	SYMB	LINE, 460
	PUBLIC	_SetAudioTiming
_SetAudioTiming:
	SYMB	TYPE, 488, 'X', 12, #16, 30, 2, #16, #10
	SYMB	GFUN, "SetAudioTiming", _SetAudioTiming, #488, 0, 0, 112
	SYMB	ALAB, _SetAudioTiming, #488
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	SUB.W	R7,#014H
	SYMB	SOFF, 26
	SYMB	LTIM, "output", 2, 0, 2253
	SYMB	LTIM, "timing", 11, 0, 2253
	SYMB	IDEN, "output", 2, #16, 0, 2061
	SYMB	IDEN, "timing", 11, #10, 0, 2061
	SYMB	IDEN, "tmp", -1, #16, 130, 5
	SYMB	LTIM, "tmp", -1, 0, 69
; audio.c   461		int tmp;
; audio.c   462	
; audio.c   463		Settings.ActivePreset = 0;
	SYMB	LINE, 463
	MOV.B	ES,#SEG( _Settings )
	MOV.W	R1,#SOF( _Settings )
	MOV.W	[R1],#00H
; audio.c   464	
; audio.c   465		Settings.AudioSetup[output].Timing = AudioSetup[output].Timing = timing;
	SYMB	LINE, 465
	MOV.W	R4,R0
	MOV.W	R0,#0EH
	MULU.W	R0,R4
	SYMB	LTIM, "output", 2, 0, 2125
	MOVS.W	R1,#00H
	MOV.B	ES,#SEG( _AudioSetup+6 )
	MOV.W	[R0+SOF( _AudioSetup+6 )],R2
	MOV.W	[R0+SOF( _AudioSetup+8 )],R3
	MOV.W	[R7+18],R3
	MOV.W	[R7+16],R2
	MOV.B	ES,#SEG( _Settings+52 )
	MOV.W	[R0+SOF( _Settings+52 )],R2
	MOV.W	[R0+SOF( _Settings+54 )],R3
	SYMB	LTIM, "timing", 11, 0, 2125
	SYMB	LTIM, "timing", -10, 130, 2245
; audio.c   466		NV_Store( &Settings, SettingsPtr, sizeof( Settings));
	SYMB	LINE, 466
	MOV.W	R1,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.B	ES,#SEG( _SettingsPtr )
	MOV.W	R2,#SOF( _SettingsPtr )
	MOV.W	R2,[R2]
	MOV.W	R3,#04AH
	CALL	_NV_Store
; audio.c   467	
; audio.c   468		if ( output == AudioOutput)
	SYMB	LINE, 468
	MOV.B	ES,#SEG( _AudioOutput )
	MOV.W	R0,#SOF( _AudioOutput )
	MOV.W	R0,[R0]
	CMP.W	R4,R0
	BNE	_63
; audio.c   469		{
; audio.c   470			tmp = (int)(( timing / 0.8) + 0.5 - ( 1*( timing < 0)));
	SYMB	LINE, 470
	MOV.W	R1,[R7+18]
	MOV.W	R0,[R7+16]
	FCALL	__SPF2DPF
	MOV.W	[R7+14],#03FE9H
	MOV.W	[R7+12],#09999H
	MOV.W	[R7+10],#09999H
	MOV.W	[R7+8],#0999AH
	LEA	R6,R7+8
	FCALL	__DIV_DPF
	MOV.W	[R7+14],#03FE0H
	MOV.W	[R7+12],#00H
	MOV.W	[R7+10],#00H
	MOV.W	[R7+8],#00H
	LEA	R6,R7+8
	FCALL	__ADD_DPF
	MOV.W	[R7+6],R3
	MOV.W	[R7+4],R2
	MOV.W	[R7+2],R1
	MOV.W	[R7],R0
	MOV.W	R3,#00H
	MOV.W	R2,#00H
	MOV.W	R1,[R7+18]
	MOV.W	R0,[R7+16]
	FCALL	__CMP_SPF
	CMP.B	R0L,#0FFH
	SYMB	LTIM, "timing", -10, 130, 2117
	SYMB	LTIM, "timing", 3, 0, 2253
	BNE	_65
	MOVS.W	R0,#00H
	MOVS.W	R1,#00H
	MOVS.W	R2,#00H
	MOV.W	R3,#03FF0H
	BR	_66
_65:
	MOVS.W	R0,#00H
	MOVS.W	R1,#00H
	MOVS.W	R2,#00H
	MOVS.W	R3,#00H
_66:
	SYMB	LTIM, "timing", 3, 0, 2125
	MOV.W	R6,R7
	FCALL	__SUBR_DPF
	FCALL	__DPF2S
	MOV.W	R1,R0
	SYMB	LTIM, "tmp", 6, 0, 205
; audio.c   471	
; audio.c   472			if ( tmp < 0)
	SYMB	LINE, 472
	CMP.W	R0,#00H
	BGE	_62
; audio.c   473				tmp += 26;
	SYMB	LINE, 473
	ADD.W	R0,#01AH
	MOV.W	R1,R0
	SYMB	LTIM, "tmp", 6, 0, 77
	SYMB	LTIM, "tmp", 6, 0, 205
_62:
; audio.c   474					
; audio.c   475			AudioTiming = TimingValues[tmp];
	SYMB	LINE, 475
	MOV.W	R0,R1
	ASL.W	R0,#01H
	SYMB	LTIM, "tmp", 6, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
	SYMB	LTIM, "tmp", 2, 0, 77
	MOV.W	R2,R0
	MOVS.W	R3,#00H
	MOV.W	R1,#SEG( _TimingValues )
	MOV.W	R0,#SOF( _TimingValues )
	ADD.W	R0,R2
	ADDC.W	R1,R3
	MOV.B	CS,R1L
	MOVC.W	R1,[R0+]
	MOV.B	ES,#SEG( _AudioTiming )
	MOV.W	R0,#SOF( _AudioTiming )
	MOV.W	[R0],R1
; audio.c   476			AudioTimingPort = AudioTiming;
	SYMB	LINE, 476
	MOV.B	ES,#SEG( _AudioTiming )
	MOV.W	R0,#SOF( _AudioTiming )
	MOV.W	R0,[R0]
	MOV.B	ES,#SEG( _AudioTimingPort )
	MOV.W	R1,#SOF( _AudioTimingPort )
	MOV.W	[R1],R0
; audio.c   477		}
	SYMB	LINE, 477
_63:
; audio.c   478	
; audio.c   479		return( OK);
	SYMB	LINE, 479
	MOV.W	R0,#0FFFFH
; audio.c   480	}
	SYMB	LINE, 480
	ADD.W	R7,#014H
	SYMB	SOFF, 6
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	EFUN
; audio.c   481	
; audio.c   482	/**************************************************************************/
; audio.c   483	/* SetAudioWordClock																					 	  AUDIO.C */
; audio.c   484	/*																																				*/
; audio.c   485	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   486	/* Revised:	 000618, KEn, DEV     																				*/
; audio.c   487	/*																																				*/
; audio.c   488	/* Function:   																														*/
; audio.c   489	/* Remarks:	 WordClock and audio mode is integrated. This function is 		*/
; audio.c   490	/*					 only valid for the AES/EBU output.											 			*/
; audio.c   491	/* Returns:	 FAIL if click and is invalid, otherwise it returns OK.				*/
; audio.c   492	/* Updates:																																*/
; audio.c   493	/**************************************************************************/
; audio.c   494	int SetAudioWordClock( int output, int frequency)
; audio.c   495	{
	ALIGN	1
	SYMB	LINE, 495
	PUBLIC	_SetAudioWordClock
_SetAudioWordClock:
	SYMB	TYPE, 489, 'X', 12, #16, 30, 2, #16, #16
	SYMB	GFUN, "SetAudioWordClock", _SetAudioWordClock, #489, 0, 0, 112
	SYMB	ALAB, _SetAudioWordClock, #489
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	ADDS.W	R7,#0EH
	SYMB	SOFF, 8
	SYMB	LTIM, "output", 2, 0, 2253
	SYMB	LTIM, "frequency", 6, 0, 2253
	MOV.W	R2,R1
	SYMB	LTIM, "frequency", 6, 0, 2125
	SYMB	LTIM, "frequency", 10, 0, 2253
	SYMB	IDEN, "output", 2, #16, 0, 2061
	SYMB	IDEN, "frequency", 10, #16, 0, 2061
	SYMB	IDEN, "tmp", -1, #16, 130, 5
	SYMB	LTIM, "tmp", -1, 0, 69
; audio.c   496		int tmp;
; audio.c   497	
; audio.c   498		if ( output != AESEBUAudio)
	SYMB	LINE, 498
	MOV.W	R6,R0
	CMP.W	R6,#01H
	SYMB	LTIM, "output", 2, 0, 2125
	SYMB	LTIM, "output", 26, 0, 2253
	BEQ	_68
; audio.c   499			return( FAIL);
	SYMB	LINE, 499
	MOV.W	R0,#00H
	BR	_72
_68:
	SYMB	LTIM, "output", 26, 0, 2125
	SYMB	LTIM, "output", 26, 0, 2253
	SYMB	LTIM, "frequency", 10, 0, 2125
	SYMB	LTIM, "frequency", 10, 0, 2253
; audio.c   500	
; audio.c   501		Settings.ActivePreset = 0;
	SYMB	LINE, 501
	MOV.B	ES,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.W	[R0],#00H
; audio.c   502	
; audio.c   503		Settings.AudioSetup[output].Frequency = AudioSetup[output].Frequency = frequency;
	SYMB	LINE, 503
	MOV.W	R0,R6
	MULU.W	R0,#0EH
	MOV.W	R4,R0
	MOVS.W	R5,#00H
	MOV.B	ES,#SEG( _AudioSetup+10 )
	MOV.W	[R4+SOF( _AudioSetup+10 )],R2
	MOV.W	[R7],R2
	MOV.B	ES,#SEG( _Settings+56 )
	MOV.W	[R4+SOF( _Settings+56 )],R2
	SYMB	LTIM, "frequency", 10, 0, 2125
	SYMB	LTIM, "frequency", -8, 130, 2245
; audio.c   504		NV_Store( &Settings, SettingsPtr, sizeof( Settings));
	SYMB	LINE, 504
	MOV.W	R1,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.B	ES,#SEG( _SettingsPtr )
	MOV.W	R2,#SOF( _SettingsPtr )
	MOV.W	R2,[R2]
	MOV.W	R3,#04AH
	CALL	_NV_Store
; audio.c   505	
; audio.c   506		if ( frequency == f441kHz)
	SYMB	LINE, 506
	MOV.W	R0,[R7]
	BNE	_69
; audio.c   507			tmp = AESEBUF441KHZOFFSET;
	SYMB	LINE, 507
	MOV.W	R0,#04H
	SYMB	LTIM, "tmp", 2, 0, 205
	BR	_70
_69:
; audio.c   508		else
; audio.c   509			tmp = AESEBUF48KHZOFFSET;
	SYMB	LINE, 509
	MOV.W	R0,#00H
	SYMB	LTIM, "tmp", 2, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
_70:
; audio.c   510	
; audio.c   511		tmp += AudioSetup[output].Signal;
	SYMB	LINE, 511
	MOV.B	ES,#SEG( _AudioSetup+2 )
	ADD.W	R0,[R4+SOF( _AudioSetup+2 )]
	SYMB	LTIM, "tmp", 2, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
; audio.c   512		tmp += CLICKPERIOD*AudioSetup[output].Click;
	SYMB	LINE, 512
	MOV.B	ES,#SEG( _AudioSetup+12 )
	MOV.W	R1,[R4+SOF( _AudioSetup+12 )]
	ASL.W	R1,#08H
	ADD.W	R0,R1
	SYMB	LTIM, "tmp", 2, 0, 77
	SYMB	LTIM, "tmp", 2, 0, 205
; audio.c   513	
; audio.c   514		if ( output == AudioOutput)
	SYMB	LINE, 514
	MOV.B	ES,#SEG( _AudioOutput )
	MOV.W	R1,#SOF( _AudioOutput )
	MOV.W	R1,[R1]
	CMP.W	R6,R1
	BNE	_71
; audio.c   515		{
; audio.c   516			AudioMode = tmp;
	SYMB	LINE, 516
	MOV.B	ES,#SEG( _AudioMode )
	MOV.W	R1,#SOF( _AudioMode )
	MOV.W	[R1],R0
; audio.c   517			AudioModePort = AudioMode;
	SYMB	LINE, 517
	MOV.B	ES,#SEG( _AudioModePort )
	MOV.W	R1,#SOF( _AudioModePort )
	MOV.W	[R1],R0
; audio.c   518	
; audio.c   519			LEDSet( WordClk441LED, frequency == f441kHz);	
	SYMB	LINE, 519
	MOV.W	R0,#01000H
	SYMB	LTIM, "tmp", 2, 0, 77
	MOV.W	R1,[R7]
	BNE	_75
	MOVS.W	R1,#01H
	BR	_76
_75:
	MOVS.W	R1,#00H
_76:
	CALL	_LEDSet
; audio.c   520			LEDSet( WordClk48LED, frequency == f48kHz);
	SYMB	LINE, 520
	MOV.W	R0,#02000H
	CMP.W	[R7],#01H
	BNE	_77
	MOVS.W	R1,#01H
	BR	_79
_77:
	MOVS.W	R1,#00H
_79:
	CALL	_LEDSet
; audio.c   521		}
	SYMB	LINE, 521
_71:
; audio.c   522	
; audio.c   523		AudioSetup[AudioOutput].Frequency = frequency;
	SYMB	LINE, 523
	MOV.B	ES,#SEG( _AudioOutput )
	MOV.W	R0,#SOF( _AudioOutput )
	MOV.W	R0,[R0]
	MULU.W	R0,#0EH
	MOVS.W	R1,#00H
	MOV.W	R2,[R7]
	MOV.B	ES,#SEG( _AudioSetup+10 )
	MOV.W	[R0+SOF( _AudioSetup+10 )],R2
	SYMB	LTIM, "frequency", -8, 130, 2117
	SYMB	LTIM, "frequency", 10, 0, 2253
; audio.c   524	
; audio.c   525		return( OK);
	SYMB	LINE, 525
	MOV.W	R0,#0FFFFH
; audio.c   526	}
	SYMB	LINE, 526
_72:
	ADDS.W	R7,#02H
	SYMB	SOFF, 6
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "frequency", 10, 0, 2125
	SYMB	LTIM, "output", 26, 0, 2125
	SYMB	EFUN
; audio.c   527	
; audio.c   528	/**************************************************************************/
; audio.c   529	/* SetAudioClick																							 	  AUDIO.C */
; audio.c   530	/*																																				*/
; audio.c   531	/* Author:	 Kim Engedahl, DEV, 000402																		*/
; audio.c   532	/* Revised:	 000618, KEn, DEV     																				*/
; audio.c   533	/*																																				*/
; audio.c   534	/* Function:   																														*/
; audio.c   535	/* Remarks:	 																															*/
; audio.c   536	/* Returns:  FAIL if audio output is invalid, otherwise it returns OK.		*/
; audio.c   537	/* Updates:																																*/
; audio.c   538	/**************************************************************************/
; audio.c   539	int SetAudioClick( int output, int click)
; audio.c   540	{
	ALIGN	1
	SYMB	LINE, 540
	PUBLIC	_SetAudioClick
_SetAudioClick:
	SYMB	TYPE, 490, 'X', 12, #16, 30, 2, #16, #16
	SYMB	GFUN, "SetAudioClick", _SetAudioClick, #490, 0, 0, 112
	SYMB	ALAB, _SetAudioClick, #490
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	ADDS.W	R7,#0AH
	SYMB	SOFF, 12
	SYMB	LTIM, "output", 2, 0, 2253
	SYMB	LTIM, "click", 6, 0, 2253
	MOV.W	R2,R1
	SYMB	LTIM, "click", 6, 0, 2125
	SYMB	LTIM, "click", 10, 0, 2253
	SYMB	IDEN, "output", 2, #16, 0, 2061
	SYMB	IDEN, "click", 10, #16, 0, 2061
	SYMB	IDEN, "tmp", -1, #16, 130, 5
	SYMB	LTIM, "tmp", -1, 0, 69
; audio.c   541		int tmp = AudioSetup[output].Signal;
	SYMB	LINE, 541
	MOV.W	R6,R0
	MOV.W	R0,#0EH
	MULU.W	R0,R6
	SYMB	LTIM, "output", 2, 0, 2125
	MOVS.W	R1,#00H
	MOV.W	[R7+2],R1
	MOV.W	[R7],R0
	MOV.B	ES,#SEG( _AudioSetup+2 )
	MOV.W	R5,[R0+SOF( _AudioSetup+2 )]
	MOV.W	R4,R5
	SYMB	LTIM, "tmp", 18, 0, 205
; audio.c   542	
; audio.c   543		if ( output > AESEBUAudio)
	SYMB	LINE, 543
	CMP.W	R6,#01H
	BLE	_80
; audio.c   544			return( FAIL);
	SYMB	LINE, 544
	MOV.W	R0,#00H
	BR	_86
_80:
	SYMB	LTIM, "output", 26, 0, 2253
	SYMB	LTIM, "click", 10, 0, 2125
	SYMB	LTIM, "click", 10, 0, 2253
	SYMB	LTIM, "tmp", 18, 0, 77
	SYMB	LTIM, "tmp", 18, 0, 205
; audio.c   545	
; audio.c   546		Settings.ActivePreset = 0;
	SYMB	LINE, 546
	MOV.B	ES,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.W	[R0],#00H
; audio.c   547	
; audio.c   548		Settings.AudioSetup[output].Click = AudioSetup[output].Click = click;
	SYMB	LINE, 548
	MOV.W	R1,[R7+2]
	MOV.W	R0,[R7]
	MOV.B	ES,#SEG( _AudioSetup+12 )
	MOV.W	[R0+SOF( _AudioSetup+12 )],R2
	MOV.W	[R7+4],R2
	MOV.W	R1,[R7+2]
	MOV.W	R0,[R7]
	MOV.B	ES,#SEG( _Settings+58 )
	MOV.W	[R0+SOF( _Settings+58 )],R2
	SYMB	LTIM, "click", 10, 0, 2125
	SYMB	LTIM, "click", -8, 130, 2245
; audio.c   549		NV_Store( &Settings, SettingsPtr, sizeof( Settings));
	SYMB	LINE, 549
	MOV.W	R1,#SEG( _Settings )
	MOV.W	R0,#SOF( _Settings )
	MOV.B	ES,#SEG( _SettingsPtr )
	MOV.W	R2,#SOF( _SettingsPtr )
	MOV.W	R2,[R2]
	MOV.W	R3,#04AH
	CALL	_NV_Store
; audio.c   550	
; audio.c   551		if ( click == click1s)
	SYMB	LINE, 551
	MOV.W	R0,[R7+4]
	CMP.W	R0,#01H
	SYMB	LTIM, "click", -8, 130, 2117
	SYMB	LTIM, "click", 2, 0, 2253
	BNE	_81
; audio.c   552			tmp += CLICKPERIOD;
	SYMB	LINE, 552
	ADD.W	R5,#0100H
	MOV.W	R4,R5
	SYMB	LTIM, "tmp", 18, 0, 77
	SYMB	LTIM, "tmp", 18, 0, 205
_81:
; audio.c   553	
; audio.c   554		if ( output == AnalogAudio)
	SYMB	LINE, 554
	OR.W	R6,R6
	BNE	_82
; audio.c   555			tmp += ANALOGAUDIOOFFSET;					// Analog signal offset
	SYMB	LINE, 555
	ADD.W	R4,#08H
	SYMB	LTIM, "tmp", 18, 0, 77
	SYMB	LTIM, "tmp", 18, 0, 205
	BR	_84
_82:
; audio.c   556		else
; audio.c   557		{
; audio.c   558			if ( AudioSetup[output].Frequency == f441kHz)
	SYMB	LINE, 558
	MOV.W	R1,[R7+2]
	MOV.W	R0,[R7]
	MOV.B	ES,#SEG( _AudioSetup+10 )
	MOV.W	R0,[R0+SOF( _AudioSetup+10 )]
	SYMB	LTIM, "click", 2, 0, 2125
	BNE	_84
; audio.c   559				tmp += AESEBUF441KHZOFFSET;			// AESEBU 44.1kHz signal offset
	SYMB	LINE, 559
	ADDS.W	R4,#04H
	SYMB	LTIM, "tmp", 18, 0, 77
	SYMB	LTIM, "tmp", 18, 0, 205
; audio.c   560			else
; audio.c   561				tmp += AESEBUF48KHZOFFSET;	 		// AESEBU 48kHz signal offset
; audio.c   562		}
	SYMB	LINE, 562
_84:
; audio.c   563	
; audio.c   564		if ( output == AudioOutput)
	SYMB	LINE, 564
	MOV.B	ES,#SEG( _AudioOutput )
	MOV.W	R0,#SOF( _AudioOutput )
	MOV.W	R0,[R0]
	CMP.W	R6,R0
	BNE	_85
; audio.c   565		{
; audio.c   566			AudioMode = tmp;
	SYMB	LINE, 566
	MOV.B	ES,#SEG( _AudioMode )
	MOV.W	R0,#SOF( _AudioMode )
	MOV.W	[R0],R4
; audio.c   567			AudioModePort = AudioMode;
	SYMB	LINE, 567
	MOV.B	ES,#SEG( _AudioModePort )
	MOV.W	R0,#SOF( _AudioModePort )
	MOV.W	[R0],R4
; audio.c   568		}
	SYMB	LINE, 568
_85:
; audio.c   569	
; audio.c   570		return( OK);
	SYMB	LINE, 570
	MOV.W	R0,#0FFFFH
; audio.c   571	}
	SYMB	LINE, 571
_86:
	ADDS.W	R7,#06H
	SYMB	SOFF, 6
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "tmp", 18, 0, 77
	SYMB	LTIM, "output", 26, 0, 2125
	SYMB	EFUN
; audio.c   572	
	SYMB	ENDF

	SYMB	IDEN, "AudioControl", _AudioControl, #16, 130, 4
AUDIO_CLR_FA	SEGMENT	HDATA INSEGMENT CLEAR
	RSEG	AUDIO_CLR_FA
	ALIGN	1
_AudioControl:	DS	2
	SYMB	IDEN, "AudioOutput", _AudioOutput, #16, 130, 0
	SYMB	ALAB, _AudioOutput, #16
	PUBLIC	_AudioOutput
	ALIGN	1
_AudioOutput:	DS	2
	EXTRN	HCODE(__DIV_DPF)
	EXTRN	HCODE(__SUBR_DPF)
	EXTRN	HCODE(__SPF2DPF)
	SYMB	TYPE, 491, 'X', 12, #16, 30, 2, #18, #445
	SYMB	ALAB, _LEDSet, #491
	EXTRN	HCODE(_LEDSet)
	SYMB	IDEN, "AudioMode", _AudioMode, #16, 130, 4
	ALIGN	1
_AudioMode:	DS	2
	SYMB	IDEN, "AudioSetup", _AudioSetup, #463, 130, 0
	SYMB	ALAB, _AudioSetup, #463
	PUBLIC	_AudioSetup
	ALIGN	1
_AudioSetup:	DS	28
	SYMB	IDEN, "AudioTiming", _AudioTiming, #16, 130, 4
	ALIGN	1
_AudioTiming:	DS	2
	SYMB	ALAB, _SettingsPtr, #446
	EXTRN	HDATA(_SettingsPtr)
	SYMB	IDEN, "AudioLevelPort", _AudioLevelPort, #16, 130, 0
	SYMB	ALAB, _AudioLevelPort, #16
	HSEG AT 070002H
	PUBLIC	_AudioLevelPort
	ALIGN	1
_AudioLevelPort:	DS	2
	SYMB	ALAB, _Settings, #466
	EXTRN	HDATA(_Settings)
	SYMB	IDEN, "AudioTimingPort", _AudioTimingPort, #16, 130, 0
	SYMB	ALAB, _AudioTimingPort, #16
	HSEG AT 070004H
	PUBLIC	_AudioTimingPort
	ALIGN	1
_AudioTimingPort:	DS	2
	EXTRN	HCODE(__CMP_SPF)
	SYMB	TYPE, 492, 'X', 12, #16, 30, 3, #284, #446, #16
	SYMB	ALAB, _NV_Store, #492
	EXTRN	HCODE(_NV_Store)
	SYMB	IDEN, "AudioControlPort", _AudioControlPort, #16, 130, 0
	SYMB	ALAB, _AudioControlPort, #16
	HSEG AT 070006H
	PUBLIC	_AudioControlPort
	ALIGN	1
_AudioControlPort:	DS	2
	SYMB	ALAB, _Calibration, #476
	EXTRN	HDATA(_Calibration)
	EXTRN	HCODE(__ADD_DPF)
	SYMB	IDEN, "AudioModePort", _AudioModePort, #16, 130, 0
	SYMB	ALAB, _AudioModePort, #16
	HSEG AT 070000H
	PUBLIC	_AudioModePort
	ALIGN	1
_AudioModePort:	DS	2
	SYMB	IDEN, "AudioLevel", _AudioLevel, #16, 130, 4
	RSEG	AUDIO_CLR_FA
	ALIGN	1
_AudioLevel:	DS	2
	SYMB	TYPE, 493, 'X', 12, #1, 30, 1, #16
	SYMB	ALAB, _Sleep, #493
	EXTRN	HCODE(_Sleep)
	EXTRN	HCODE(__US2SPF)
	EXTRN	HCODE(__DPF2S)
	EXTRN	DATA(__lc_ub_xvwbuffer)
	EXTRN	DATA(__lc_ue_xvwbuffer)
	CALLS	'WriteAnlAudioDACLevel', 'Write_AD8402'
	CALLS	'AudioDefaults', 'NV_Store'
	CALLS	'AudioInit', 'WriteAnlAudioDACLevel'
	CALLS	'AudioInit', 'LEDSet'
	CALLS	'AudioInit', 'SetAudioOutput'
	CALLS	'SetAudioOutput', 'NV_Store'
	CALLS	'SetAudioOutput', 'Sleep'
	CALLS	'SetAudioOutput', 'LEDSet'
	CALLS	'SetAudioOutput', 'SetAudioSystem'
	CALLS	'SetAudioOutput', 'SetAudioSignal'
	CALLS	'SetAudioOutput', 'SetAudioLevel'
	CALLS	'SetAudioOutput', 'SetAudioTiming'
	CALLS	'SetAudioOutput', 'SetAudioWordClock'
	CALLS	'SetAudioOutput', 'SetAudioClick'
	CALLS	'SetAudioSystem', 'NV_Store'
	CALLS	'SetAudioSignal', 'NV_Store'
	CALLS	'SetAudioLevel', 'NV_Store'
	CALLS	'SetAudioTiming', 'NV_Store'
	CALLS	'SetAudioWordClock', 'NV_Store'
	CALLS	'SetAudioWordClock', 'LEDSet'
	CALLS	'SetAudioClick', 'NV_Store'
	END
