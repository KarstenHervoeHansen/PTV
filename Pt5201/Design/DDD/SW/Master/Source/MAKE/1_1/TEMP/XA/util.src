; XA C compiler v2.0 r2                   SN00085795-Ccz (c) 1998 TASKING, Inc.
; options: -A1 -Cxag3 -e -g -Ic:\cxa\include -I..\..\rtxcdef\xa
;          -I..\..\rtxc\xa\include -I..\..\code\include\1_0 -I..\..\app_spec\xa
;          -Ml -O2 -s
$CASE
$NOZPAGE
	NAME	UTIL
	SYMB	TOOL, "XA C compiler v2.0", 1
	SYMB	TYPE, 256, "bit", 'g', 0, 1
	SYMB	FILE, "..\\..\\code\\interp\\1_0\\util.c"
; util.c      1	/****************************************************************************/
; util.c      2	/* MODULE:                                                                  */
; util.c      3	/*  util.c - 	General purpose utility function															*/
; util.c      4	/****************************************************************************/
; util.c      5	/* FUNCTIONS:                                                               */
; util.c      6	/*                                                                          */
; util.c      7	/*                                                                          */
; util.c      8	/* TASKS:                                                                   */
; util.c      9	/*                                                                          */
; util.c     10	/* NOTES:                                                                   */
; util.c     11	/*                                                                          */
; util.c     12	/****************************************************************************/
; util.c     13	/*
; util.c     14	 *   PTV software for PT5201    
; util.c     15	 *   Copyright (c) 
; util.c     16	 *   ProTeleVision Technologies A/S.
; util.c     17	 *   ALL RIGHTS RESERVED
; util.c     18	*/
; util.c     19	/**************************************************************************/
; util.c     20	/* Include files:																													*/
; util.c     21	#include <stdio.h>
	SYMB	FILE, "c:\\cxa\\include\\stdio.h"
	SYMB	FILE, "c:\\cxa\\include\\stdarg.h"
	SYMB	ENDF
	SYMB	TYPE, 257, 'n', #2, 130
	SYMB	TYPE, 258, 'P', #257
	SYMB	TYPE, 259, "_iobuf", 'S', 14,\
		 "_ptr", #258, 0,\
		 "_cnt", #16, 4,\
		 "_base", #258, 6,\
		 "_flag", #2, 10,\
		 "_file", #2, 11,\
		 "_bufsiz", #16, 12
	SYMB	TYPE, 260, "FILE", 'T', #259
	SYMB	TYPE, 261, 'n', #1, 130
	SYMB	TYPE, 262, 'P', #261
	SYMB	TYPE, 263, 'Z', #262, 0
	SYMB	TYPE, 265, "va_list", 'T', #263
	SYMB	TYPE, 266, "size_t", 'T', #18
	SYMB	TYPE, 267, "fpos_t", 'T', #7
	SYMB	ENDF
; util.c     22	#include <string.h>
	SYMB	FILE, "c:\\cxa\\include\\string.h"
	SYMB	ENDF
; util.c     23	#include <ctype.h>
	SYMB	FILE, "c:\\cxa\\include\\ctype.h"
	SYMB	ENDF
; util.c     24	
; util.c     25	#include "define.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\define.h"
	SYMB	ENDF
; util.c     26	#include "util.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\util.h"
	SYMB	ENDF
; util.c     27	
; util.c     28	/*************************************************************************/
; util.c     29	/*	NONE					   	 																				 		UTIL.C */
; util.c     30	/*									  																									 */
; util.c     31	/* Author:		Kim Engedahl, DEV, 960828	    		 												 */
; util.c     32	/* Revised:		970105				     		   																	 */
; util.c     33	/*									   																									 */
; util.c     34	/*	Function:	DOES ABSOLUTELY NOTHING!!!			  												 */
; util.c     35	/*	Remarks:		This one is primarily used in menu tables  							 */
; util.c     36	/*	Returns:		--					   																					 */
; util.c     37	/*	Updates:		--					   																					 */
; util.c     38	/*************************************************************************/
; util.c     39	void None( void)
; util.c     40	{
UTIL_PR	SEGMENT	HCODE
	RSEG	UTIL_PR
	ALIGN	1
	SYMB	LINE, 40
	PUBLIC	_None
_None:
	SYMB	TYPE, 268, 'X', 12, #1, 30, 0
	SYMB	GFUN, "None", _None, #268, 0, 0, 0
	SYMB	ALAB, _None, #268
; util.c     41	}
	SYMB	LINE, 41
	RET
	SYMB	EFUN
; util.c     42	
; util.c     43	/**************************************************************************/
; util.c     44	/* BitPos						  																					   UTIL.C */
; util.c     45	/*									 																											*/
; util.c     46	/* Author:		Kim Engedahl, DEV, 970919	    		 													*/
; util.c     47	/* Revised:		970919				     																				  */
; util.c     48	/*																																			  */
; util.c     49	/* Function:	Return the bit position of a variable											  */
; util.c     50	/* Remarks: 	If parameter contains more than one bit the number of the 	*/
; util.c     51	/*						first bit is returned		  																	*/
; util.c     52	/* Returns:		--																												  */
; util.c     53	/* Updates:		--					  																							*/
; util.c     54	/**************************************************************************/
; util.c     55	UC BitPos( UC value)
; util.c     56	{
	ALIGN	1
	SYMB	LINE, 56
	PUBLIC	_BitPos
_BitPos:
	SYMB	TYPE, 269, 'X', 12, #3, 30, 1, #3
	SYMB	GFUN, "BitPos", _BitPos, #269, 0, 0, 0
	SYMB	ALAB, _BitPos, #269
	SYMB	IDEN, "value", -1, #3, 130, 2053
	SYMB	LTIM, "value", -1, 0, 2117
	SYMB	IDEN, "cnt", -1, #3, 130, 5
	SYMB	LTIM, "cnt", -1, 0, 69
; util.c     57	
; util.c     58		UC cnt = 1;
	SYMB	LINE, 58
	MOV.B	R1L,#01H
	SYMB	LTIM, "cnt", 4, 0, 205
; util.c     59	
; util.c     60		while ( !( value & 0x01) && ( cnt < 9))
	SYMB	LINE, 60
	MOV.B	R0H,R0L
	AND.B	R0H,#01H
	BNE	_9
_7:
; util.c     61		{
; util.c     62			cnt++;
	SYMB	LINE, 62
	ADDS.B	R1L,#01H
	SYMB	LTIM, "cnt", 4, 0, 77
	SYMB	LTIM, "cnt", 4, 0, 205
; util.c     63			value >>= 1;
	SYMB	LINE, 63
	LSR.B	R0L,#01H
	SYMB	LINE, 60
	MOV.B	R0H,R0L
	AND.B	R0H,#01H
	BNE	_9
	CMP.B	R1L,#09H
	BCS	_7
; util.c     64		}
	SYMB	LINE, 64
_9:
; util.c     65	
; util.c     66		return( cnt);
	SYMB	LINE, 66
	MOV.B	R0L,R1L
	SYMB	LTIM, "cnt", 4, 0, 77
	SYMB	LTIM, "cnt", 0, 0, 205
; util.c     67	}
	SYMB	LINE, 67
	RET
	SYMB	LTIM, "cnt", 0, 0, 77
	SYMB	EFUN
; util.c     68	
; util.c     69	/**************************************************************************/
; util.c     70	/* HexToByte																 										   UTIL.C	*/
; util.c     71	/*																																				*/
; util.c     72	/* Author:		Kim Engedahl, DEV, 960828	    															*/
; util.c     73	/* Revised:		970105				     																					*/
; util.c     74	/*																																				*/
; util.c     75	/* Function:	Converts a char defined in hex to binary										*/
; util.c     76	/* Remarks:		--																													*/
; util.c     77	/* Returns:		A byte from 0-15																						*/
; util.c     78	/* Updates:		--																													*/
; util.c     79	/**************************************************************************/
; util.c     80	UC HexToByte( char s) {
	ALIGN	1
	SYMB	LINE, 80
	PUBLIC	_HexToByte
_HexToByte:
	SYMB	TYPE, 270, 'X', 12, #3, 30, 1, #2
	SYMB	GFUN, "HexToByte", _HexToByte, #270, 0, 0, 16
	SYMB	ALAB, _HexToByte, #270
	PUSH.W	R4
	SYMB	SOFF, 2
	SYMB	LTIM, "s", 0, 0, 2253
	SYMB	IDEN, "s", 0, #2, 0, 2061
; util.c     81	
; util.c     82		toupper( s);
	SYMB	LINE, 82
	MOV.B	R4L,R0L
	MOV.B	R0L,R4L
	SEXT.B	R0H
	SYMB	LTIM, "s", 0, 0, 2125
	SYMB	LTIM, "s", 16, 0, 2253
	CALL	_toupper
; util.c     83	
; util.c     84		if (( s >= 'A') && ( s <= 'F'))
	SYMB	LINE, 84
	CMP.B	R4L,#041H
	BLT	_12
	CMP.B	R4L,#046H
	BGT	_12
; util.c     85			return( s - 'A' + 10);
	SYMB	LINE, 85
	SUB.B	R4L,#037H
	SYMB	LTIM, "s", 16, 0, 2125
	MOV.B	R0L,R4L
	BR	_13
_12:
	SYMB	LTIM, "s", 16, 0, 2253
; util.c     86	
; util.c     87		return( s - '0');
	SYMB	LINE, 87
	SUB.B	R4L,#030H
	SYMB	LTIM, "s", 16, 0, 2125
	MOV.B	R0L,R4L
; util.c     88	}
	SYMB	LINE, 88
_13:
	POP.W	R4
	SYMB	SOFF, 0
	RET
	SYMB	EFUN
; util.c     89	
; util.c     90	/**************************************************************************/
; util.c     91	/* htol																		 		 										 UTIL.C	*/
; util.c     92	/*																																				*/
; util.c     93	/* Author:		Kim Engedahl, DEV, 960828	    															*/
; util.c     94	/* Revised:		970105				     																					*/
; util.c     95	/*																																				*/
; util.c     96	/* Function:	Converts a string containg a hex number to an unsigned long	*/
; util.c     97	/* Remarks:		--																													*/
; util.c     98	/* Returns:		--																													*/
; util.c     99	/* Updates:		--																													*/
; util.c    100	/**************************************************************************/
; util.c    101	UC htol( char* s, UL* result)
; util.c    102	{
	ALIGN	1
	SYMB	LINE, 102
	PUBLIC	_htol
_htol:
	SYMB	TYPE, 272, 'n', #7, 130
	SYMB	TYPE, 273, 'P', #272
	SYMB	TYPE, 271, 'X', 12, #3, 30, 2, #258, #273
	SYMB	GFUN, "htol", _htol, #271, 0, 0, 48
	SYMB	ALAB, _htol, #271
	PUSH.W	R4, R5
	SYMB	SOFF, 4
	ADDS.W	R7,#08H
	SYMB	SOFF, 12
	SYMB	LTIM, "result", 11, 0, 2253
	SYMB	IDEN, "s", -1, #258, 130, 2053
	SYMB	LTIM, "s", -1, 0, 2117
	SYMB	IDEN, "result", 11, #273, 0, 2061
; util.c    103		*result = 0;
	SYMB	LINE, 103
	MOV.B	ES,R3L
	MOV.W	[R2],#00H
	MOV.W	[R2+2],#00H
	MOV.W	[R7+6],R3
	MOV.W	[R7+4],R2
	SYMB	LTIM, "result", 11, 0, 2125
	SYMB	LTIM, "result", -8, 130, 2245
; util.c    104	
; util.c    105		while ( *s)
	SYMB	LINE, 105
	MOV.W	R5,R1
	MOV.W	R4,R0
	MOV.B	ES,R5L
	MOV.B	R0L,[R4]
	BEQ	_17
_16:
; util.c    106			*result = 16*(*result) + HexToByte( *s++);
	SYMB	LINE, 106
	MOV.W	R1,[R7+6]
	MOV.W	R0,[R7+4]
	MOV.B	ES,R1L
	MOV.W	R1,[R0+2]
	MOV.W	R0,[R0]
	ASL.D	R0,#04H
	MOV.W	[R7+2],R1
	MOV.W	[R7],R0
	MOV.B	ES,R5L
	MOV.B	R0L,[R4]
	CALL	_HexToByte
	MOVS.B	R0H,#00H
	MOVS.W	R1,#00H
	MOV.W	R3,[R7+2]
	MOV.W	R2,[R7]
	ADD.W	R0,R2
	ADDC.W	R1,R3
	MOV.W	R3,[R7+6]
	MOV.W	R2,[R7+4]
	MOV.B	ES,R3L
	MOV.W	[R2],R0
	MOV.W	[R2+2],R1
	SYMB	LTIM, "result", -8, 130, 2117
	SYMB	LTIM, "result", 11, 0, 2253
	SYMB	LTIM, "result", 11, 0, 2125
	SYMB	LTIM, "result", -8, 130, 2245
	ADD.W	R4,#01H
	SYMB	LINE, 105
	MOV.B	ES,R5L
	MOV.B	R0L,[R4]
	BNE	_16
	SYMB	LINE, 106
_17:
; util.c    107	
; util.c    108		return( 0);
	SYMB	LINE, 108
	MOV.B	R0L,#00H
; util.c    109	}
	SYMB	LINE, 109
	ADD.W	R7,#08H
	SYMB	SOFF, 4
	POP.W	R4, R5
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "result", -8, 130, 2117
	SYMB	EFUN
; util.c    110	
; util.c    111	/**************************************************************************/
; util.c    112	/* otol																		 											   UTIL.C	*/
; util.c    113	/*																																				*/
; util.c    114	/* Author:		Kim Engedahl, DEV, 960828	    															*/
; util.c    115	/* Revised:		970105				     																					*/
; util.c    116	/*																																				*/
; util.c    117	/* Function:	Converts a string containg an octal number to unsinged long	*/
; util.c    118	/* Remarks:		--																													*/
; util.c    119	/* Returns:		--																													*/
; util.c    120	/* Updates:		--																													*/
; util.c    121	/**************************************************************************/
; util.c    122	UC otol( char* s, UL* result)
; util.c    123	{
	ALIGN	1
	SYMB	LINE, 123
	PUBLIC	_otol
_otol:
	SYMB	TYPE, 274, 'X', 12, #3, 30, 2, #258, #273
	SYMB	GFUN, "otol", _otol, #274, 0, 0, 112
	SYMB	ALAB, _otol, #274
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	ADDS.W	R7,#0CH
	SYMB	SOFF, 10
	SYMB	LTIM, "result", 11, 0, 2253
	SYMB	IDEN, "s", -1, #258, 130, 2053
	SYMB	LTIM, "s", -1, 0, 2117
	SYMB	IDEN, "result", 11, #273, 0, 2061
; util.c    124		*result = 0;
	SYMB	LINE, 124
	MOV.B	ES,R3L
	MOV.W	[R2],#00H
	MOV.W	[R2+2],#00H
; util.c    125	
; util.c    126		while ( *s)
	SYMB	LINE, 126
	MOV.B	ES,R1L
	MOV.B	R4L,[R0]
	BEQ	_19
_18:
; util.c    127			*result = 8*(*result) + ( *s++ - '0');
	SYMB	LINE, 127
	MOV.B	ES,R3L
	MOV.W	R4,[R2]
	MOV.W	R5,[R2+2]
	ASL.D	R4,#03H
	MOV.W	[R7+2],R1
	MOV.W	[R7],R0
	MOV.B	ES,R1L
	MOV.B	R6L,[R0]
	SEXT.B	R6H
	SUB.W	R6,#030H
	MOV.W	R0,R6
	SEXT.W	R1
	ADD.W	R4,R0
	ADDC.W	R5,R1
	MOV.B	ES,R3L
	MOV.W	[R2],R4
	MOV.W	[R2+2],R5
	MOV.W	R1,[R7+2]
	MOV.W	R0,[R7]
	ADD.W	R0,#01H
	SYMB	LINE, 126
	MOV.B	ES,R1L
	MOV.B	R4L,[R0]
	BNE	_18
	SYMB	LINE, 127
_19:
; util.c    128	
; util.c    129		return( 0);
	SYMB	LINE, 129
	MOV.B	R0L,#00H
; util.c    130	}
	SYMB	LINE, 130
	ADDS.W	R7,#04H
	SYMB	SOFF, 6
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "result", 11, 0, 2125
	SYMB	EFUN
; util.c    131	
; util.c    132	/**************************************************************************/
; util.c    133	/* btol																											 		   UTIL.C	*/
; util.c    134	/*																																				*/
; util.c    135	/* Author:		Kim Engedahl, DEV, 960828	    															*/
; util.c    136	/* Revised:		970105				     																					*/
; util.c    137	/*																																				*/
; util.c    138	/* Function:	Converts a string containg a binary number to unsigned long	*/
; util.c    139	/* Remarks:		--																													*/
; util.c    140	/* Returns:		--																													*/
; util.c    141	/* Updates:		--																													*/
; util.c    142	/**************************************************************************/
; util.c    143	UC btol( char* s, UL* result)
; util.c    144	{
	ALIGN	1
	SYMB	LINE, 144
	PUBLIC	_btol
_btol:
	SYMB	TYPE, 275, 'X', 12, #3, 30, 2, #258, #273
	SYMB	GFUN, "btol", _btol, #275, 0, 0, 112
	SYMB	ALAB, _btol, #275
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	ADDS.W	R7,#0CH
	SYMB	SOFF, 10
	SYMB	LTIM, "result", 11, 0, 2253
	SYMB	IDEN, "s", -1, #258, 130, 2053
	SYMB	LTIM, "s", -1, 0, 2117
	SYMB	IDEN, "result", 11, #273, 0, 2061
; util.c    145		*result = 0;
	SYMB	LINE, 145
	MOV.B	ES,R3L
	MOV.W	[R2],#00H
	MOV.W	[R2+2],#00H
; util.c    146	
; util.c    147		while ( *s)
	SYMB	LINE, 147
	MOV.B	ES,R1L
	MOV.B	R4L,[R0]
	BEQ	_21
_20:
; util.c    148			*result = 2*(*result) + ( *s++ - '0');
	SYMB	LINE, 148
	MOV.B	ES,R3L
	MOV.W	R4,[R2]
	MOV.W	R5,[R2+2]
	ASL.D	R4,#01H
	MOV.W	[R7+2],R1
	MOV.W	[R7],R0
	MOV.B	ES,R1L
	MOV.B	R6L,[R0]
	SEXT.B	R6H
	SUB.W	R6,#030H
	MOV.W	R0,R6
	SEXT.W	R1
	ADD.W	R4,R0
	ADDC.W	R5,R1
	MOV.B	ES,R3L
	MOV.W	[R2],R4
	MOV.W	[R2+2],R5
	MOV.W	R1,[R7+2]
	MOV.W	R0,[R7]
	ADD.W	R0,#01H
	SYMB	LINE, 147
	MOV.B	ES,R1L
	MOV.B	R4L,[R0]
	BNE	_20
	SYMB	LINE, 148
_21:
; util.c    149	
; util.c    150		return( 0);
	SYMB	LINE, 150
	MOV.B	R0L,#00H
; util.c    151	}
	SYMB	LINE, 151
	ADDS.W	R7,#04H
	SYMB	SOFF, 6
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "result", 11, 0, 2125
	SYMB	EFUN
; util.c    152	
; util.c    153	/**************************************************************************/
; util.c    154	/* _ultoa																	 											   UTIL.C	*/
; util.c    155	/*																																				*/
; util.c    156	/* Author:		Kim Engedahl, DEV, 960828	    															*/
; util.c    157	/* Revised:		970219				     																					*/
; util.c    158	/*																																				*/
; util.c    159	/* Function:	Converts an unsigned long to a string												*/
; util.c    160	/* Remarks:		--																													*/
; util.c    161	/* Returns:		--																													*/
; util.c    162	/* Updates:		--																													*/
; util.c    163	/**************************************************************************/
; util.c    164	void _ultoa( UL val, char* result)
; util.c    165	{
	ALIGN	1
	SYMB	LINE, 165
	PUBLIC	__ultoa
__ultoa:
	SYMB	TYPE, 276, 'X', 12, #1, 30, 2, #7, #258
	SYMB	GFUN, "_ultoa", __ultoa, #276, 0, 0, 112
	SYMB	ALAB, __ultoa, #276
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	ADDS.W	R7,#08H
	SYMB	SOFF, 14
	SYMB	LTIM, "val", 3, 0, 2253
	SYMB	LTIM, "result", 11, 0, 2253
	MOV.W	[R7+6],R3
	MOV.W	[R7+4],R2
	SYMB	LTIM, "result", 11, 0, 2125
	SYMB	LTIM, "result", -10, 130, 2245
	SYMB	IDEN, "val", 3, #7, 0, 2061
	SYMB	IDEN, "result", -7, #258, 130, 2053
	SYMB	IDEN, "tmp", -1, #7, 130, 5
	SYMB	LTIM, "tmp", -1, 0, 69
	SYMB	IDEN, "__#STR0007S", -1, #258, 130, 5
	SYMB	LTIM, "__#STR0007S", -1, 0, 69
; util.c    166		UL tmp = val;
; util.c    167		UC i=0, j=0, TmpChar;
	SYMB	LINE, 167
	MOV.B	R6L,#00H
	SYMB	LTIM, "i", 24, 0, 205
	SYMB	IDEN, "i", 24, #3, 0, 13
	SYMB	IDEN, "j", -1, #3, 130, 5
	SYMB	LTIM, "j", -1, 0, 69
	MOV.B	R6H,#00H
	SYMB	LTIM, "j", 25, 0, 205
	SYMB	IDEN, "TmpChar", -1, #3, 130, 5
	SYMB	LTIM, "TmpChar", -1, 0, 69
; util.c    168	
; util.c    169		if ( val == 0)
	SYMB	LINE, 169
	MOV.W	R3,R1
	MOV.W	R2,R0
	OR.W	R1,R0
	SYMB	LTIM, "val", 3, 0, 2125
	SYMB	LTIM, "val", 11, 0, 2253
	BNE	_29
; util.c    170			strcpy( result, "0");
	SYMB	LINE, 170
	MOV.W	R1,[R7+6]
	MOV.W	R0,[R7+4]
	MOV.W	R3,#SEG( _22 )
	MOV.W	R2,#SOF( _22 )
	CALL	_strcpy
	SYMB	LTIM, "result", -10, 130, 2117
	SYMB	LTIM, "result", 3, 0, 2253
	SYMB	LTIM, "result", 3, 0, 2125
	SYMB	LTIM, "val", 11, 0, 2125
	BR	_34
_29:
	SYMB	LTIM, "val", 11, 0, 2253
	SYMB	LTIM, "result", -10, 130, 2245
	SYMB	LTIM, "i", 24, 0, 77
	SYMB	LTIM, "i", 24, 0, 205
	SYMB	LTIM, "j", 25, 0, 77
	SYMB	LTIM, "j", 25, 0, 205
; util.c    171		else
; util.c    172		{
; util.c    173			while ( val)
	SYMB	LINE, 173
	MOV.W	R5,R3
	MOV.W	R4,R2
	OR.W	R3,R2
	SYMB	LTIM, "val", 11, 0, 2125
	SYMB	LTIM, "val", 19, 0, 2253
	BEQ	_31
_30:
; util.c    174			{
; util.c    175				tmp = val / 10;
	SYMB	LINE, 175
	MOV.W	R1,R5
	MOV.W	R0,R4
	MOV.W	R3,#00H
	MOV.W	R2,#0AH
	FCALL	__UDIVL
	MOV.W	[R7+2],R1
	MOV.W	[R7],R0
	SYMB	LTIM, "tmp", -14, 130, 197
; util.c    176				result[i++] = (val % 10) + '0';
	SYMB	LINE, 176
	MOV.W	R1,R5
	MOV.W	R0,R4
	MOV.W	R3,#00H
	MOV.W	R2,#0AH
	FCALL	__UMODL
	SYMB	LTIM, "val", 19, 0, 2125
	SYMB	LTIM, "val", 3, 0, 2253
	SYMB	LTIM, "val", 3, 0, 2125
	MOV.B	R4L,R0L
	ADD.B	R4L,#030H
	MOV.B	R0L,R6L
	MOVS.B	R0H,#00H
	MOV.W	R2,R0
	MOVS.W	R3,#00H
	MOV.W	R1,[R7+6]
	MOV.W	R0,[R7+4]
	ADD.W	R0,R2
	MOV.B	ES,R1L
	MOV.B	[R0],R4L
	ADDS.B	R6L,#01H
	SYMB	LTIM, "i", 24, 0, 77
	SYMB	LTIM, "i", 24, 0, 205
; util.c    177				val = tmp;
	SYMB	LINE, 177
	MOV.W	R5,[R7+2]
	MOV.W	R4,[R7]
	SYMB	LTIM, "val", 19, 0, 2253
	SYMB	LINE, 173
	MOV.W	R1,[R7+2]
	MOV.W	R0,[R7]
	OR.W	R1,R0
	SYMB	LTIM, "tmp", -14, 130, 69
	SYMB	LTIM, "tmp", 3, 0, 205
	BNE	_30
; util.c    178			}
	SYMB	LINE, 178
_31:
; util.c    179			result[i--] = '\0';
	SYMB	LINE, 179
	MOV.B	R0L,R6L
	MOVS.B	R0H,#00H
	SYMB	LTIM, "tmp", 3, 0, 77
	MOVS.W	R1,#00H
	MOV.W	R3,[R7+6]
	MOV.W	R2,[R7+4]
	ADD.W	R2,R0
	MOV.B	ES,R3L
	MOV.B	[R2],#00H
	ADDS.B	R6L,#0FH
	SYMB	LTIM, "i", 24, 0, 77
	MOV.B	R2L,R6L
	SYMB	LTIM, "i", 8, 0, 205
	MOV.B	R0L,#00H
	MOVS.B	R0H,#00H
	MOVS.W	R1,#00H
	MOV.W	R5,[R7+6]
	MOV.W	R4,[R7+4]
	ADD.W	R4,R0
	SYMB	LTIM, "val", 19, 0, 2125
	MOV.W	[R7+2],R5
	MOV.W	[R7],R4
	SYMB	LTIM, "__#STR0007S", -14, 130, 197
; util.c    180	
; util.c    181			while ( i >= j)							// Reverse ASCII string
	SYMB	LINE, 181
	CMP.B	R2L,#00H
	BCS	_34
_32:
; util.c    182			{
; util.c    183				TmpChar = result[i];
	SYMB	LINE, 183
	MOV.B	R4L,R2L
	MOVS.B	R4H,#00H
	MOVS.W	R5,#00H
	MOV.W	R1,[R7+6]
	MOV.W	R0,[R7+4]
	ADD.W	R0,R4
	MOV.B	ES,R1L
	MOV.B	R2H,[R0]
	SYMB	LTIM, "TmpChar", 9, 0, 205
; util.c    184				result[i] = result[j];
	SYMB	LINE, 184
	MOV.W	R5,[R7+2]
	MOV.W	R4,[R7]
	MOV.B	ES,R5L
	MOV.B	R3L,[R4]
	MOV.B	ES,R1L
	MOV.B	[R0],R3L
; util.c    185				result[j] = TmpChar;
	SYMB	LINE, 185
	MOV.W	R1,[R7+2]
	MOV.W	R0,[R7]
	MOV.B	ES,R1L
	MOV.B	[R0],R2H
	SYMB	LTIM, "__#STR0007S", -14, 130, 69
	SYMB	LTIM, "__#STR0007S", 3, 0, 205
; util.c    186				i--;
	SYMB	LINE, 186
	ADDS.B	R2L,#0FH
	SYMB	LTIM, "i", 8, 0, 77
	SYMB	LTIM, "i", 8, 0, 205
; util.c    187				j++;
	SYMB	LINE, 187
	ADD.W	R0,#01H
	SYMB	LTIM, "__#STR0007S", 3, 0, 77
	MOV.W	[R7+2],R1
	MOV.W	[R7],R0
	SYMB	LTIM, "__#STR0007S", -14, 130, 197
	ADDS.B	R6H,#01H
	SYMB	LTIM, "j", 25, 0, 77
	SYMB	LTIM, "j", 25, 0, 205
	SYMB	LINE, 181
	CMP.B	R2L,R6H
	BCC	_32
; util.c    188			}
; util.c    189		}
	SYMB	LINE, 189
_34:
; util.c    190	}
	SYMB	LINE, 190
	ADD.W	R7,#08H
	SYMB	SOFF, 6
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "__#STR0007S", -14, 130, 69
	SYMB	LTIM, "j", 25, 0, 77
	SYMB	LTIM, "i", 8, 0, 77
	SYMB	LTIM, "result", -10, 130, 2117
	SYMB	LTIM, "TmpChar", 9, 0, 77
	SYMB	EFUN
; util.c    191	
; util.c    192	/**************************************************************************/
; util.c    193	/* Cstrlen																	 										   UTIL.C	*/
; util.c    194	/*																																				*/
; util.c    195	/* Author:		Kim Engedahl, DEV, 960828	    													 		*/
; util.c    196	/* Revised:		970105				     																					*/
; util.c    197	/*																															 					*/
; util.c    198	/* Function:	Calculates the length of a string from code memory					*/
; util.c    199	/* Remarks:		--																													*/
; util.c    200	/* Returns:		--																													*/
; util.c    201	/* Updates:		--																													*/
; util.c    202	/**************************************************************************/
; util.c    203	size_t Cstrlen( register char code* s)
; util.c    204	{
	ALIGN	1
	SYMB	LINE, 204
	PUBLIC	_Cstrlen
_Cstrlen:
	SYMB	TYPE, 278, 'n', #2, 129
	SYMB	TYPE, 279, 'P', #278
	SYMB	TYPE, 277, 'X', 12, #266, 30, 1, #279
	SYMB	GFUN, "Cstrlen", _Cstrlen, #277, 0, 0, 48
	SYMB	ALAB, _Cstrlen, #277
	PUSH.W	R4, R5
	SYMB	SOFF, 4
	SYMB	LTIM, "s", 3, 0, 2253
	SYMB	IDEN, "s", 3, #279, 0, 2061
	SYMB	IDEN, "cp", -1, #279, 130, 5
	SYMB	LTIM, "cp", -1, 0, 69
; util.c    205		register char code *	cp;
; util.c    206	
; util.c    207		cp = s;
; util.c    208		while( *cp++)
	SYMB	LINE, 208
	MOV.W	R5,R1
	MOV.W	R4,R0
	MOV.B	CS,R5L
	MOVC.B	R5L,[R4+]
	MOV.W	R3,R1
	MOV.W	R2,R0
	ADD.W	R2,#01H
	ADDC.W	R3,#00H
	SYMB	LTIM, "cp", 11, 0, 205
	OR.B	R5L,R5L
	BEQ	_40
_39:
	MOV.W	R5,R3
	MOV.W	R4,R2
	MOV.B	CS,R5L
	MOVC.B	R5L,[R4+]
	ADD.W	R2,#01H
	ADDC.W	R3,#00H
	SYMB	LTIM, "cp", 11, 0, 77
	SYMB	LTIM, "cp", 11, 0, 205
	OR.B	R5L,R5L
	BNE	_39
; util.c    209			continue;
	SYMB	LINE, 209
_40:
; util.c    210	
; util.c    211		return( cp-s-1);
	SYMB	LINE, 211
	SUB.W	R2,R0
	SUBB.W	R3,R1
	SYMB	LTIM, "cp", 11, 0, 77
	MOV.W	R0,R2
	ADDS.W	R0,#0FH
	SYMB	LTIM, "s", 3, 0, 2125
; util.c    212	}
	SYMB	LINE, 212
	POP.W	R4, R5
	SYMB	SOFF, 0
	RET
	SYMB	EFUN
; util.c    213	
; util.c    214	/**************************************************************************/
; util.c    215	/* Cstrcat																	 										   UTIL.C	*/
; util.c    216	/*																																				*/
; util.c    217	/* Author:		Kim Engedahl, DEV, 960828	    															*/
; util.c    218	/* Revised:		970105				     																					*/
; util.c    219	/*																																				*/
; util.c    220	/* Function:	Concatenate a string from code memory to data memory				*/
; util.c    221	/* Remarks:		--																													*/
; util.c    222	/* Returns:		--																													*/
; util.c    223	/* Updates:		--																													*/
; util.c    224	/**************************************************************************/
; util.c    225	char* Cstrcat( register char* to, register char code* from)
; util.c    226	{
	ALIGN	1
	SYMB	LINE, 226
	PUBLIC	_Cstrcat
_Cstrcat:
	SYMB	TYPE, 280, 'X', 12, #258, 30, 2, #258, #279
	SYMB	GFUN, "Cstrcat", _Cstrcat, #280, 0, 0, 112
	SYMB	ALAB, _Cstrcat, #280
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	SYMB	LTIM, "to", 3, 0, 2253
	SYMB	LTIM, "from", 11, 0, 2253
	SYMB	IDEN, "to", 3, #258, 0, 2061
	SYMB	IDEN, "from", 11, #279, 0, 2061
	SYMB	IDEN, "cp", -1, #258, 130, 5
	SYMB	LTIM, "cp", -1, 0, 69
; util.c    227		register char* cp;
; util.c    228	
; util.c    229		cp = to;
	SYMB	LINE, 229
	MOV.W	R5,R1
	MOV.W	R4,R0
	SYMB	LTIM, "cp", 19, 0, 205
; util.c    230		while( *cp)
	SYMB	LINE, 230
	MOV.B	ES,R1L
	MOV.B	R6L,[R0]
	BEQ	_42
_41:
; util.c    231			cp++;
	SYMB	LINE, 231
	ADD.W	R4,#01H
	SYMB	LTIM, "cp", 19, 0, 77
	SYMB	LTIM, "cp", 19, 0, 205
	SYMB	LINE, 230
	MOV.B	ES,R5L
	MOV.B	R6L,[R4]
	BNE	_41
	SYMB	LINE, 231
_42:
; util.c    232	
; util.c    233		*cp = *from++;
	SYMB	LINE, 233
	MOV.B	CS,R3L
	MOVC.B	R3L,[R2+]
	SYMB	LTIM, "from", 11, 0, 2125
	MOV.B	ES,R5L
	MOV.B	[R4],R3L
; util.c    234		while( *cp++)
	SYMB	LINE, 234
	MOV.B	ES,R5L
	MOV.B	R6L,[R4]
	ADD.W	R4,#01H
	SYMB	LTIM, "cp", 19, 0, 77
	MOV.W	R3,R5
	MOV.W	R2,R4
	SYMB	LTIM, "cp", 11, 0, 205
	OR.B	R6L,R6L
	BEQ	_44
_43:
	MOV.B	ES,R3L
	MOV.B	R4L,[R2]
	ADD.W	R2,#01H
	SYMB	LTIM, "cp", 11, 0, 77
	SYMB	LTIM, "cp", 11, 0, 205
	OR.B	R4L,R4L
	BNE	_43
; util.c    235			continue;
	SYMB	LINE, 235
_44:
; util.c    236	
; util.c    237		return( to);
; util.c    238	}
	SYMB	LINE, 238
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "to", 3, 0, 2125
	SYMB	LTIM, "cp", 11, 0, 77
	SYMB	EFUN
; util.c    239	
; util.c    240	/**************************************************************************/
; util.c    241	/* Cmemcpy																									 		   UTIL.C	*/
; util.c    242	/*																																				*/
; util.c    243	/* Author:		Kim Engedahl, DEV, 960828	    															*/
; util.c    244	/* Revised:		970105				     																					*/
; util.c    245	/*																																				*/
; util.c    246	/* Function:	Copy a memory-area from code-memory to RAM-memory						*/
; util.c    247	/* Remarks:		--																													*/
; util.c    248	/* Returns:		--																													*/
; util.c    249	/* Updates:		--																													*/
; util.c    250	/**************************************************************************/
; util.c    251	void* Cmemcpy( void* d1, void code* s1, register size_t n)
; util.c    252	{
	ALIGN	1
	SYMB	LINE, 252
	PUBLIC	_Cmemcpy
_Cmemcpy:
	SYMB	TYPE, 282, 'n', #1, 129
	SYMB	TYPE, 283, 'P', #282
	SYMB	TYPE, 281, 'X', 12, #262, 30, 3, #262, #283, #266
	SYMB	GFUN, "Cmemcpy", _Cmemcpy, #281, 0, 0, 112
	SYMB	ALAB, _Cmemcpy, #281
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	ADDS.W	R7,#0CH
	SYMB	SOFF, 10
	SYMB	LTIM, "d1", 3, 0, 2253
	SYMB	LTIM, "s1", 11, 0, 2253
	SYMB	LTIM, "n", 26, 0, 2253
	SYMB	IDEN, "d1", 3, #262, 0, 2061
	SYMB	IDEN, "s1", 11, #283, 0, 2061
	SYMB	IDEN, "n", 26, #266, 0, 2061
	SYMB	IDEN, "d", -1, #258, 130, 5
	SYMB	LTIM, "d", -1, 0, 69
	SYMB	IDEN, "s", -1, #279, 130, 5
	SYMB	LTIM, "s", -1, 0, 69
; util.c    253		register char* d;
; util.c    254		register char code* s;
; util.c    255	
; util.c    256		s = s1;
	SYMB	LINE, 256
	MOV.W	R5,R3
	MOV.W	R4,R2
	SYMB	LTIM, "s", 19, 0, 205
; util.c    257		d = d1;
	SYMB	LINE, 257
	MOV.W	[R7+2],R1
	MOV.W	[R7],R0
	MOV.W	R3,R1
	MOV.W	R2,R0
	SYMB	LTIM, "d1", 3, 0, 2125
	SYMB	LTIM, "d1", -10, 130, 2245
	SYMB	LTIM, "s1", 11, 0, 2125
	SYMB	LTIM, "d", 11, 0, 205
; util.c    258	
; util.c    259		while( n--)
	SYMB	LINE, 259
	MOV.W	R0,R6
	SYMB	LTIM, "n", 26, 0, 2125
	SYMB	LTIM, "n", 2, 0, 2253
	ADDS.W	R6,#0FH
	SYMB	LTIM, "n", 2, 0, 2125
	SYMB	LTIM, "n", 26, 0, 2253
	OR.W	R0,R0
	BEQ	_46
_45:
; util.c    260			*d++ = *s++;
	SYMB	LINE, 260
	MOV.W	R1,R5
	MOV.W	R0,R4
	MOV.B	CS,R5L
	MOVC.B	R5L,[R4+]
	SYMB	LTIM, "s", 19, 0, 77
	SYMB	LTIM, "s", 3, 0, 205
	MOV.B	ES,R3L
	MOV.B	[R2],R5L
	ADD.W	R0,#01H
	ADDC.W	R1,#00H
	SYMB	LTIM, "s", 3, 0, 77
	MOV.W	R5,R1
	MOV.W	R4,R0
	SYMB	LTIM, "s", 19, 0, 205
	ADD.W	R2,#01H
	SYMB	LTIM, "d", 11, 0, 77
	SYMB	LTIM, "d", 11, 0, 205
	SYMB	LINE, 259
	MOV.W	R0,R6
	SYMB	LTIM, "n", 26, 0, 2125
	SYMB	LTIM, "n", 2, 0, 2253
	ADDS.W	R6,#0FH
	SYMB	LTIM, "n", 2, 0, 2125
	SYMB	LTIM, "n", 26, 0, 2253
	OR.W	R0,R0
	BNE	_45
	SYMB	LINE, 260
_46:
; util.c    261	
; util.c    262		return( d1);
	SYMB	LINE, 262
	MOV.W	R1,[R7+2]
	MOV.W	R0,[R7]
	SYMB	LTIM, "d1", -10, 130, 2117
	SYMB	LTIM, "d1", 3, 0, 2253
; util.c    263	}
	SYMB	LINE, 263
	ADDS.W	R7,#04H
	SYMB	SOFF, 6
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "d1", 3, 0, 2125
	SYMB	LTIM, "d", 11, 0, 77
	SYMB	LTIM, "s", 19, 0, 77
	SYMB	LTIM, "n", 26, 0, 2125
	SYMB	EFUN
; util.c    264	
; util.c    265	/**************************************************************************/
; util.c    266	/* Cstrcpy																									 		   UTIL.C	*/
; util.c    267	/*																																				*/
; util.c    268	/* Author:		Kim Engedahl, DEV, 971003	    															*/
; util.c    269	/* Revised:		971003				     																					*/
; util.c    270	/*																																				*/
; util.c    271	/* Function:	Copy a string in code-memory to a string in RAM-memory			*/
; util.c    272	/* Remarks:		--																													*/
; util.c    273	/* Returns:		--																													*/
; util.c    274	/* Updates:		--																													*/
; util.c    275	/**************************************************************************/
; util.c    276	char* Cstrcpy( char* to, register char code * from)
; util.c    277	{
	ALIGN	1
	SYMB	LINE, 277
	PUBLIC	_Cstrcpy
_Cstrcpy:
	SYMB	TYPE, 284, 'X', 12, #258, 30, 2, #258, #279
	SYMB	GFUN, "Cstrcpy", _Cstrcpy, #284, 0, 0, 48
	SYMB	ALAB, _Cstrcpy, #284
	PUSH.W	R4, R5
	SYMB	SOFF, 4
	ADDS.W	R7,#0CH
	SYMB	SOFF, 8
	SYMB	LTIM, "to", 3, 0, 2253
	SYMB	IDEN, "to", 3, #258, 0, 2061
	SYMB	IDEN, "from", -1, #279, 130, 2053
	SYMB	LTIM, "from", -1, 0, 2117
	SYMB	IDEN, "cp", -1, #258, 130, 5
	SYMB	LTIM, "cp", -1, 0, 69
; util.c    278		register char*	cp;
; util.c    279	
; util.c    280		for ( cp=to; *from; *cp++ = *from++ )
	SYMB	LINE, 280
	MOV.W	R5,R1
	MOV.W	R4,R0
	SYMB	LTIM, "cp", 19, 0, 205
	MOV.W	[R7+2],R3
	MOV.W	[R7],R2
	MOV.B	CS,R3L
	MOVC.B	R3L,[R2+]
	BEQ	_48
_47:
	MOV.W	R3,[R7+2]
	MOV.W	R2,[R7]
	MOV.B	CS,R3L
	MOVC.B	R3L,[R2+]
	MOV.B	ES,R5L
	MOV.B	[R4],R3L
	MOV.W	R3,[R7+2]
	MOV.W	R2,[R7]
	ADD.W	R2,#01H
	ADDC.W	R3,#00H
	ADD.W	R4,#01H
	SYMB	LTIM, "cp", 19, 0, 77
	SYMB	LTIM, "cp", 19, 0, 205
	MOV.W	[R7+2],R3
	MOV.W	[R7],R2
	MOV.B	CS,R3L
	MOVC.B	R3L,[R2+]
	BNE	_47
; util.c    281			;
	SYMB	LINE, 281
_48:
; util.c    282	
; util.c    283		*cp = 0;
	SYMB	LINE, 283
	MOV.B	ES,R5L
	MOV.B	[R4],#00H
; util.c    284	
; util.c    285		return( to);
; util.c    286	}
	SYMB	LINE, 286
	ADDS.W	R7,#04H
	SYMB	SOFF, 4
	POP.W	R4, R5
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "to", 3, 0, 2125
	SYMB	LTIM, "cp", 19, 0, 77
	SYMB	EFUN
; util.c    287	
; util.c    288	/**************************************************************************/
; util.c    289	/* Cstrcmp																	 											 UTIL.C	*/
; util.c    290	/*																																				*/
; util.c    291	/* Author:		Kim Engedahl, DEV, 960828	    															*/
; util.c    292	/* Revised:		970105				     																					*/
; util.c    293	/*																																				*/
; util.c    294	/* Function:	Compare a string in code-memory to a string in RAM-memory		*/
; util.c    295	/* Remarks:		--																													*/
; util.c    296	/* Returns:		--																													*/
; util.c    297	/* Updates:		--																													*/
; util.c    298	/**************************************************************************/
; util.c    299	int Cstrcmp( register const char * s1, register char code * s2)
; util.c    300	{
	ALIGN	1
	SYMB	LINE, 300
	PUBLIC	_Cstrcmp
_Cstrcmp:
	SYMB	TYPE, 285, 'X', 12, #16, 30, 2, #258, #279
	SYMB	GFUN, "Cstrcmp", _Cstrcmp, #285, 0, 0, 112
	SYMB	ALAB, _Cstrcmp, #285
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	SYMB	IDEN, "s1", -1, #258, 130, 2053
	SYMB	LTIM, "s1", -1, 0, 2117
	SYMB	IDEN, "s2", -1, #279, 130, 2053
	SYMB	LTIM, "s2", -1, 0, 2117
	SYMB	IDEN, "r", -1, #2, 130, 5
	SYMB	LTIM, "r", -1, 0, 69
; util.c    301		register signed char	r;
; util.c    302	
; util.c    303		while( !(r = *s1 - *s2++) && *s1++)
	SYMB	LINE, 303
	MOV.B	ES,R1L
	MOV.B	R6L,[R0]
	MOV.W	R5,R3
	MOV.W	R4,R2
	MOV.B	CS,R5L
	MOVC.B	R5L,[R4+]
	MOV.B	R4L,R6L
	SUB.B	R4L,R5L
	SYMB	LTIM, "r", 16, 0, 205
	ADD.W	R2,#01H
	ADDC.W	R3,#00H
	SYMB	LTIM, "s2", 11, 0, 2253
	OR.B	R4L,R4L
	BNE	_52
	MOV.B	ES,R1L
	MOV.B	R4H,[R0]
	ADD.W	R0,#01H
	SYMB	LTIM, "s1", 3, 0, 2253
	OR.B	R4H,R4H
	BEQ	_52
_49:
	MOV.B	ES,R1L
	MOV.B	R6L,[R0]
	MOV.W	R5,R3
	MOV.W	R4,R2
	MOV.B	CS,R5L
	MOVC.B	R5L,[R4+]
	SUB.B	R6L,R5L
	MOV.B	R4L,R6L
	SYMB	LTIM, "r", 16, 0, 77
	SYMB	LTIM, "r", 16, 0, 205
	ADD.W	R2,#01H
	ADDC.W	R3,#00H
	SYMB	LTIM, "s2", 11, 0, 2125
	SYMB	LTIM, "s2", 11, 0, 2253
	OR.B	R4L,R4L
	BNE	_52
	MOV.B	ES,R1L
	MOV.B	R4H,[R0]
	ADD.W	R0,#01H
	SYMB	LTIM, "s1", 3, 0, 2125
	SYMB	LTIM, "s1", 3, 0, 2253
	OR.B	R4H,R4H
	BNE	_49
; util.c    304			continue;
	SYMB	LINE, 304
_52:
; util.c    305	
; util.c    306		return( r);
	SYMB	LINE, 306
	MOV.B	R0L,R4L
	SEXT.B	R0H
	SYMB	LTIM, "s1", 3, 0, 2125
; util.c    307	}
	SYMB	LINE, 307
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "r", 16, 0, 77
	SYMB	LTIM, "s2", 11, 0, 2125
	SYMB	EFUN
; util.c    308	
; util.c    309	/**************************************************************************/
; util.c    310	/* Cstrncmp																							 	         UTIL.C	*/
; util.c    311	/*																																				*/
; util.c    312	/* Author:		Kim Engedahl, DEV, 960828	    															*/
; util.c    313	/* Revised:	  970105				     																					*/
; util.c    314	/*																																				*/
; util.c    315	/* Function:	Compare a string in code-memory to a string in RAM-memory		*/
; util.c    316	/* Remarks:		--																													*/
; util.c    317	/* Returns:		--																													*/
; util.c    318	/* Updates:		--																													*/
; util.c    319	/**************************************************************************/
; util.c    320	int Cstrncmp( register const char * s1, register char code * s2, size_t len)
; util.c    321	{
	ALIGN	1
	SYMB	LINE, 321
	PUBLIC	_Cstrncmp
_Cstrncmp:
	SYMB	TYPE, 286, 'X', 12, #16, 30, 3, #258, #279, #266
	SYMB	GFUN, "Cstrncmp", _Cstrncmp, #286, 0, 0, 80
	SYMB	ALAB, _Cstrncmp, #286
	PUSH.W	R4, R6
	SYMB	SOFF, 4
	ADDS.W	R7,#0CH
	SYMB	SOFF, 8
	SYMB	LTIM, "len", 26, 0, 2253
	MOV.W	[R7+2],R3
	MOV.W	[R7],R2
	SYMB	IDEN, "s1", -1, #258, 130, 2053
	SYMB	LTIM, "s1", -1, 0, 2117
	SYMB	IDEN, "s2", -1, #279, 130, 2053
	SYMB	LTIM, "s2", -1, 0, 2117
	SYMB	IDEN, "len", 26, #266, 0, 2061
; util.c    322		while( len--)
	SYMB	LINE, 322
	MOV.W	R2,R6
	SYMB	LTIM, "len", 26, 0, 2125
	SYMB	LTIM, "len", 10, 0, 2253
	ADDS.W	R6,#0FH
	SYMB	LTIM, "len", 10, 0, 2125
	SYMB	LTIM, "len", 26, 0, 2253
	OR.W	R2,R2
	BEQ	_56
_53:
; util.c    323		{
; util.c    324			if ( *s1 == 0 || *s1 != *s2)
	SYMB	LINE, 324
	MOV.B	ES,R1L
	MOV.B	R4L,[R0]
	BEQ	_54
	MOV.W	R3,[R7+2]
	MOV.W	R2,[R7]
	MOV.B	CS,R3L
	MOVC.B	R3L,[R2+]
	MOV.B	ES,R1L
	CMP.B	[R0],R3L
	BEQ	_55
_54:
; util.c    325				return( *s1 - *s2);
	SYMB	LINE, 325
	MOV.B	R2L,R4L
	SEXT.B	R2H
	MOV.W	R1,[R7+2]
	MOV.W	R0,[R7]
	MOV.B	CS,R1L
	MOVC.B	R1L,[R0+]
	MOV.B	R0L,R1L
	SEXT.B	R0H
	SUB.W	R2,R0
	MOV.W	R0,R2
	BR	_57
_55:
	SYMB	LTIM, "len", 26, 0, 2125
	SYMB	LTIM, "len", 26, 0, 2253
; util.c    326	
; util.c    327			s1++;
	SYMB	LINE, 327
	ADD.W	R0,#01H
; util.c    328			s2++;
	SYMB	LINE, 328
	MOV.W	R3,[R7+2]
	MOV.W	R2,[R7]
	ADD.W	R2,#01H
	ADDC.W	R3,#00H
	MOV.W	[R7+2],R3
	MOV.W	[R7],R2
	MOV.W	R3,[R7+2]
	MOV.W	R2,[R7]
	SYMB	LINE, 322
	MOV.W	R2,R6
	SYMB	LTIM, "len", 26, 0, 2125
	SYMB	LTIM, "len", 10, 0, 2253
	ADDS.W	R6,#0FH
	SYMB	LTIM, "len", 10, 0, 2125
	SYMB	LTIM, "len", 26, 0, 2253
	OR.W	R2,R2
	BNE	_53
; util.c    329		}
	SYMB	LINE, 329
_56:
; util.c    330	
; util.c    331		return( 0);
	SYMB	LINE, 331
	MOV.W	R0,#00H
; util.c    332	}
	SYMB	LINE, 332
_57:
	ADDS.W	R7,#04H
	SYMB	SOFF, 4
	POP.W	R4, R6
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "len", 26, 0, 2125
	SYMB	EFUN
; util.c    333	
; util.c    334	/**************************************************************************/
; util.c    335	/* ValidateDate																					 	         UTIL.C	*/
; util.c    336	/*																																				*/
; util.c    337	/* Author:		Kim Engedahl, DEV, 000504	    															*/
; util.c    338	/* Revised:	  000504				     																					*/
; util.c    339	/*																																				*/
; util.c    340	/* Function:	--																													*/
; util.c    341	/* Remarks:		--																													*/
; util.c    342	/* Returns:		--																													*/
; util.c    343	/* Updates:		--																													*/
; util.c    344	/**************************************************************************/
; util.c    345	int ValidateDate( UI year, UI month, UI day)
; util.c    346	{
	ALIGN	1
	SYMB	LINE, 346
	PUBLIC	_ValidateDate
_ValidateDate:
	SYMB	TYPE, 287, 'X', 12, #16, 30, 3, #18, #18, #18
	SYMB	GFUN, "ValidateDate", _ValidateDate, #287, 0, 0, 0
	SYMB	ALAB, _ValidateDate, #287
	SYMB	LTIM, "year", 2, 0, 2253
	SYMB	LTIM, "month", 6, 0, 2253
	SYMB	LTIM, "day", 10, 0, 2253
	SYMB	IDEN, "year", 2, #18, 0, 2061
	SYMB	IDEN, "month", 6, #18, 0, 2061
	SYMB	IDEN, "day", 10, #18, 0, 2061
; util.c    347		switch ( month)
	SYMB	LINE, 347
	CMP.W	R1,#01H
	BEQ	_64
	CMP.W	R1,#03H
	BEQ	_64
	CMP.W	R1,#05H
	BEQ	_64
	CMP.W	R1,#07H
	BEQ	_64
	CMP.W	R1,#09H
	BEQ	_64
	CMP.W	R1,#0BH
	BEQ	_64
	CMP.W	R1,#02H
	BEQ	_65
	BR	_67
; util.c    348		{
; util.c    349			case January:
; util.c    350			case March:
; util.c    351			case May:
; util.c    352			case July:
; util.c    353			case September:
; util.c    354			case November:
	SYMB	LINE, 354
_64:
; util.c    355				if ( day > 31)
	SYMB	LINE, 355
	CMP.W	R2,#01FH
	BL	_71
; util.c    356					return( FAIL);
	SYMB	LINE, 356
	MOV.W	R0,#00H
	SYMB	LTIM, "year", 2, 0, 2125
	RET
; util.c    357				break;
; util.c    358	
; util.c    359			case February:
	SYMB	LINE, 359
_65:
	SYMB	LTIM, "year", 2, 0, 2253
	SYMB	LTIM, "day", 10, 0, 2125
	SYMB	LTIM, "day", 10, 0, 2253
; util.c    360				if ( year % 4)
	SYMB	LINE, 360
	XOR.W	R1,R1
	DIVU.D	R0,#04H
	SYMB	LTIM, "month", 6, 0, 2125
	OR.W	R1,R1
	BEQ	_66
; util.c    361				{
; util.c    362					if ( day > 29)
	SYMB	LINE, 362
	CMP.W	R2,#01DH
	BL	_71
; util.c    363						return( FAIL);
	SYMB	LINE, 363
	MOV.W	R0,#00H
	SYMB	LTIM, "year", 2, 0, 2125
	RET
; util.c    364				}
	SYMB	LINE, 364
_66:
	SYMB	LTIM, "day", 10, 0, 2125
	SYMB	LTIM, "day", 10, 0, 2253
; util.c    365				else
; util.c    366				{
; util.c    367					if ( day > 28)
	SYMB	LINE, 367
	CMP.W	R2,#01CH
	BL	_71
; util.c    368						return( FAIL);
	SYMB	LINE, 368
	MOV.W	R0,#00H
	RET
; util.c    369				}
; util.c    370				break;
; util.c    371	
; util.c    372			default:
	SYMB	LINE, 372
_67:
	SYMB	LTIM, "day", 10, 0, 2125
	SYMB	LTIM, "day", 10, 0, 2253
; util.c    373				if ( day > 30)
	SYMB	LINE, 373
	CMP.W	R2,#01EH
	BL	_71
; util.c    374					return( FAIL);
	SYMB	LINE, 374
	MOV.W	R0,#00H
	RET
; util.c    375				break;
; util.c    376		}
	SYMB	LINE, 376
_71:
; util.c    377	
; util.c    378		return( OK);
	SYMB	LINE, 378
	MOV.W	R0,#0FFFFH
; util.c    379	}
	SYMB	LINE, 379
_75:
	RET
	SYMB	LTIM, "day", 10, 0, 2125
	SYMB	EFUN
; util.c    380	
; util.c    381	/**************************************************************************/
; util.c    382	/* ROMChecksum																					 	         UTIL.C	*/
; util.c    383	/*																																				*/
; util.c    384	/* Author:		Kim Engedahl, DEV, 000705	    															*/
; util.c    385	/* Revised:	  000705				     																					*/
; util.c    386	/*																																				*/
; util.c    387	/* Function:	--																													*/
; util.c    388	/* Remarks:		--																													*/
; util.c    389	/* Returns:		--																													*/
; util.c    390	/* Updates:		--																													*/
; util.c    391	/**************************************************************************/
; util.c    392	UI ROMChecksum( UL start_addr, UL end_addr)
; util.c    393	{
	ALIGN	1
	SYMB	LINE, 393
	PUBLIC	_ROMChecksum
_ROMChecksum:
	SYMB	TYPE, 288, 'X', 12, #18, 30, 2, #7, #7
	SYMB	GFUN, "ROMChecksum", _ROMChecksum, #288, 0, 0, 112
	SYMB	ALAB, _ROMChecksum, #288
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	SYMB	LTIM, "start_addr", 3, 0, 2253
	SYMB	LTIM, "end_addr", 11, 0, 2253
	SYMB	IDEN, "start_addr", 3, #7, 0, 2061
	SYMB	IDEN, "end_addr", 11, #7, 0, 2061
	SYMB	TYPE, 289, 'n', #3, 129
	SYMB	TYPE, 290, 'P', #289
	SYMB	IDEN, "Sptr", -1, #290, 130, 5
	SYMB	LTIM, "Sptr", -1, 0, 69
	SYMB	IDEN, "Eptr", -1, #290, 130, 5
	SYMB	LTIM, "Eptr", -1, 0, 69
	SYMB	IDEN, "CalcChecksum", -1, #18, 130, 5
	SYMB	LTIM, "CalcChecksum", -1, 0, 69
; util.c    394		_rom UC *Sptr;
; util.c    395		_rom UC *Eptr;
; util.c    396	
; util.c    397		UI CalcChecksum = 0;
	SYMB	LINE, 397
	MOV.W	R6,#00H
	SYMB	LTIM, "CalcChecksum", 26, 0, 205
; util.c    398	
; util.c    399		Sptr = ( _rom UC *) ( start_addr);
	SYMB	LINE, 399
	MOV.W	R5,R1
	MOV.W	R4,R0
	MOV.W	R1,R5
	MOV.W	R0,R4
	SYMB	LTIM, "start_addr", 3, 0, 2125
	SYMB	LTIM, "Sptr", 3, 0, 205
	SYMB	LTIM, "end_addr", 11, 0, 2125
	SYMB	LTIM, "Eptr", 11, 0, 205
; util.c    400		Eptr = ( _rom UC *) ( end_addr);
; util.c    401	
; util.c    402		while ( Sptr <= Eptr)
	SYMB	LINE, 402
	CMP.W	R5,R3
	BNE	_82
	CMP.W	R4,R2
_82:
	BG	_81
_80:
; util.c    403			CalcChecksum += *Sptr++;
	SYMB	LINE, 403
	MOV.W	R5,R1
	MOV.W	R4,R0
	MOV.B	CS,R5L
	MOVC.B	R5L,[R4+]
	MOVS.B	R5H,#00H
	ADD.W	R6,R5
	SYMB	LTIM, "CalcChecksum", 26, 0, 77
	SYMB	LTIM, "CalcChecksum", 26, 0, 205
	ADD.W	R0,#01H
	ADDC.W	R1,#00H
	SYMB	LTIM, "Sptr", 3, 0, 77
	SYMB	LTIM, "Sptr", 3, 0, 205
	SYMB	LINE, 402
	CMP.W	R1,R3
	BNE	_83
	CMP.W	R0,R2
_83:
	BL	_80
	SYMB	LINE, 403
_81:
; util.c    404	
; util.c    405		return( CalcChecksum);
	SYMB	LINE, 405
	MOV.W	R0,R6
	SYMB	LTIM, "Sptr", 3, 0, 77
	SYMB	LTIM, "CalcChecksum", 26, 0, 77
	SYMB	LTIM, "CalcChecksum", 2, 0, 205
; util.c    406	}
	SYMB	LINE, 406
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "CalcChecksum", 2, 0, 77
	SYMB	LTIM, "Eptr", 11, 0, 77
	SYMB	EFUN
	SYMB	ENDF

	EXTRN	HCODE(__UMODL)
	SYMB	TYPE, 291, 'X', 12, #16, 30, 1, #16
	SYMB	ALAB, _toupper, #291
	EXTRN	HCODE(_toupper)
UTIL_INI_FA	SEGMENT	HDATA INSEGMENT INIT
	RSEG	UTIL_INI_FA
_22:	DB	030H,000H
	SYMB	TYPE, 292, 'X', 12, #258, 30, 2, #258, #258
	SYMB	ALAB, _strcpy, #292
	EXTRN	HCODE(_strcpy)
	EXTRN	HCODE(__UDIVL)
	EXTRN	DATA(__lc_ub_xvwbuffer)
	EXTRN	DATA(__lc_ue_xvwbuffer)
	CALLS	'HexToByte', 'toupper'
	CALLS	'htol', 'HexToByte'
	CALLS	'_ultoa', 'strcpy'
	END
