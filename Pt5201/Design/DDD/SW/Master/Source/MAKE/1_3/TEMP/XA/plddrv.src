; XA C compiler v2.0 r2                   SN00085795-Ccz (c) 1998 TASKING, Inc.
; options: -A1 -Cxag3 -e -g -Ic:\cxa\include -I..\..\rtxcdef\xa
;          -I..\..\rtxc\xa\include -I..\..\code\include\1_0 -I..\..\app_spec\xa
;          -Ml -O2 -s
$CASE
$NOZPAGE
	NAME	PLDDRV
	SYMB	TOOL, "XA C compiler v2.0", 1
	SYMB	TYPE, 256, "bit", 'g', 0, 1
	SYMB	FILE, "..\\..\\code\\devdrv\\xa\\plddrv\\1_0\\plddrv.c"
; plddrv.c    1	/****************************************************************************/
; plddrv.c    2	/* MODULE:                                                                  */
; plddrv.c    3	/*  pldrv.c - PLD load driver                                               */
; plddrv.c    4	/****************************************************************************/
; plddrv.c    5	/* FUNCTIONS:                                                               */
; plddrv.c    6	/*                                                                          */
; plddrv.c    7	/*  int pld_init( void);                                                		*/
; plddrv.c    8	/*  int pld_version( void);                                              		*/
; plddrv.c    9	/*                                                                          */
; plddrv.c   10	/* TASKS:                                                                   */
; plddrv.c   11	/*                                                                          */
; plddrv.c   12	/* NOTES:                                                                   */
; plddrv.c   13	/*                                                                          */
; plddrv.c   14	/****************************************************************************/
; plddrv.c   15	/*
; plddrv.c   16	 *   PTV software for PT5201    
; plddrv.c   17	 *   Copyright (c) 
; plddrv.c   18	 *   ProTeleVision Technologies A/S.
; plddrv.c   19	 *   ALL RIGHTS RESERVED
; plddrv.c   20	*/
; plddrv.c   21	/****************************************************************************/
; plddrv.c   22	
; plddrv.c   23	#include "define.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\define.h"
	SYMB	ENDF
; plddrv.c   24	#include "config.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\config.h"
	SYMB	ENDF
; plddrv.c   25	#include "plddrv.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\plddrv.h"
	SYMB	ENDF
; plddrv.c   26	#include "unitprg.h"
	SYMB	FILE, "..\\..\\code\\include\\1_0\\unitprg.h"
	SYMB	TYPE, 257, 'N',\
		 "true", -1,\
		 "false", 0
	SYMB	TYPE, 258, "bool", 'T', #257
	SYMB	ENDF
; plddrv.c   27													
; plddrv.c   28	#define nCONFIGMask   	0x01
; plddrv.c   29	#define DATAMask				0x02
; plddrv.c   30	#define DCLKMask				0x04
; plddrv.c   31	
; plddrv.c   32	#define nSTATUSMask			0x02
; plddrv.c   33	#define CONF_DONEMask		0x04
; plddrv.c   34	
; plddrv.c   35	#define Low			0
; plddrv.c   36	#define High		1
; plddrv.c   37	
; plddrv.c   38	#define Bit0  	0x01
; plddrv.c   39	
; plddrv.c   40	code UC DataArray[SizeOfPLDCode] _at( StartOfPLDCode);
; plddrv.c   41	
; plddrv.c   42	volatile UI SPGPLDPort _at( 0x6A01C);				// Port defined in VIDEO PLD
; plddrv.c   43	volatile UI PLDHWVersionPort _at(0x7000E); 	// Port defined in AUDIO PLD
; plddrv.c   44	volatile UI PLDTCXOStatusPort _at(0x7000A); 	// Port defined in AUDIO PLD
; plddrv.c   45	
; plddrv.c   46	
; plddrv.c   47	static UC SPGPLDBuf;
; plddrv.c   48	
; plddrv.c   49	/**************************************************************************/
; plddrv.c   50	/* TxByte																											   PLDDRV.C	*/
; plddrv.c   51	/*																																				*/
; plddrv.c   52	/* Author:	 Kim Engedahl, DEV, 000208																		*/
; plddrv.c   53	/* Revised:	 000321, KEn, DEV     																				*/
; plddrv.c   54	/*																																				*/
; plddrv.c   55	/* Function:   																														*/
; plddrv.c   56	/* Remarks:	 CLK period max.10MHz																					*/
; plddrv.c   57	/* Returns:																																*/
; plddrv.c   58	/* Updates:																																*/
; plddrv.c   59	/**************************************************************************/
; plddrv.c   60	void TxByte( UC X)
; plddrv.c   61	{
PLDDRV_PR	SEGMENT	HCODE
	RSEG	PLDDRV_PR
	ALIGN	1
	SYMB	LINE, 61
	PUBLIC	_TxByte
_TxByte:
	SYMB	TYPE, 259, 'X', 12, #1, 30, 1, #3
	SYMB	GFUN, "TxByte", _TxByte, #259, 0, 0, 0
	SYMB	ALAB, _TxByte, #259
	SYMB	IDEN, "X", -1, #3, 130, 2053
	SYMB	LTIM, "X", -1, 0, 2117
	SYMB	IDEN, "locvar", -1, #18, 130, 5
	SYMB	LTIM, "locvar", -1, 0, 69
; plddrv.c   62	  UI locvar;
; plddrv.c   63	
; plddrv.c   64	  for ( locvar = 8; locvar != 0; locvar--)
	SYMB	LINE, 64
	MOV.W	R1,#08H
	SYMB	LTIM, "locvar", 6, 0, 205
_7:
; plddrv.c   65	  {
; plddrv.c   66	    SPGPLDBuf &= ~DCLKMask;			// Clock line low
	SYMB	LINE, 66
	MOV.B	ES,#SEG( _SPGPLDBuf )
	MOV.W	R2,#SOF( _SPGPLDBuf )
	MOV.B	R0H,[R2]
	AND.B	R0H,#0FBH
	MOV.B	ES,#SEG( _SPGPLDBuf )
	MOV.W	R2,#SOF( _SPGPLDBuf )
	MOV.B	[R2],R0H
; plddrv.c   67	    SPGPLDPort = SPGPLDBuf;
	SYMB	LINE, 67
	MOV.B	R2L,R0H
	MOVS.B	R2H,#00H
	MOV.B	ES,#SEG( _SPGPLDPort )
	MOV.W	R3,#SOF( _SPGPLDPort )
	MOV.W	[R3],R2
; plddrv.c   68	
; plddrv.c   69	    if (( X & Bit0) == 0)				// Output databit
	SYMB	LINE, 69
	MOV.B	R2L,R0L
	AND.B	R2L,#01H
	BNE	_8
; plddrv.c   70	      SPGPLDBuf &= ~DATAMask;
	SYMB	LINE, 70
	AND.B	R0H,#0FDH
	MOV.B	ES,#SEG( _SPGPLDBuf )
	MOV.W	R2,#SOF( _SPGPLDBuf )
	MOV.B	[R2],R0H
	BR	_9
_8:
; plddrv.c   71	    else
; plddrv.c   72	      SPGPLDBuf |= DATAMask;
	SYMB	LINE, 72
	MOV.B	ES,#SEG( _SPGPLDBuf )
	MOV.W	R2,#SOF( _SPGPLDBuf )
	MOV.B	R0H,[R2]
	OR.B	R0H,#02H
	MOV.B	ES,#SEG( _SPGPLDBuf )
	MOV.W	R2,#SOF( _SPGPLDBuf )
	MOV.B	[R2],R0H
_9:
; plddrv.c   73	
; plddrv.c   74	    SPGPLDPort = SPGPLDBuf;
	SYMB	LINE, 74
	MOV.B	ES,#SEG( _SPGPLDBuf )
	MOV.W	R2,#SOF( _SPGPLDBuf )
	MOV.B	R0H,[R2]
	MOV.B	R2L,R0H
	MOVS.B	R2H,#00H
	MOV.B	ES,#SEG( _SPGPLDPort )
	MOV.W	R3,#SOF( _SPGPLDPort )
	MOV.W	[R3],R2
; plddrv.c   75	
; plddrv.c   76	    X /= 2;               		 	// Get next databit in position 
	SYMB	LINE, 76
	LSR.B	R0L,#01H
; plddrv.c   77														
; plddrv.c   78	    SPGPLDBuf |= DCLKMask;	   	// Clock line high
	SYMB	LINE, 78
	OR.B	R0H,#04H
	MOV.B	ES,#SEG( _SPGPLDBuf )
	MOV.W	R2,#SOF( _SPGPLDBuf )
	MOV.B	[R2],R0H
; plddrv.c   79	    SPGPLDPort = SPGPLDBuf;
	SYMB	LINE, 79
	MOV.B	R2L,R0H
	MOVS.B	R2H,#00H
	MOV.B	ES,#SEG( _SPGPLDPort )
	MOV.W	R3,#SOF( _SPGPLDPort )
	MOV.W	[R3],R2
	SYMB	LINE, 64
	ADDS.W	R1,#0FH
	SYMB	LTIM, "locvar", 6, 0, 77
	SYMB	LTIM, "locvar", 6, 0, 205
	BNE	_7
; plddrv.c   80	  }
; plddrv.c   81	}
	SYMB	LINE, 81
	RET
	SYMB	LTIM, "locvar", 6, 0, 77
	SYMB	EFUN
; plddrv.c   82	
; plddrv.c   83	/**************************************************************************/
; plddrv.c   84	/* pld_init																										   PLDDRV.C	*/
; plddrv.c   85	/*																																				*/
; plddrv.c   86	/* Author:	 Kim Engedahl, DEV, 000208																		*/
; plddrv.c   87	/* Revised:	 000401, KEn, DEV     																				*/
; plddrv.c   88	/*																																				*/
; plddrv.c   89	/* Function:   																														*/
; plddrv.c   90	/* Remarks:	 Set Config LOW										                				  	*/
; plddrv.c   91	/*           Wait min. 2us										                 						*/
; plddrv.c   92	/*           Set Config HIGH										               						*/
; plddrv.c   93	/*           Wait for nSTATUS HIGH										         						*/
; plddrv.c   94	/*           Ensure that CONF_DONE is LOW										   						*/
; plddrv.c   95	/*					 The SPG should be reset while downloading to prevent the SPG	*/	
; plddrv.c   96	/*						to begin executing as it uses the PLD for ports,latches etc.*/
; plddrv.c   97	/* Returns:																																*/
; plddrv.c   98	/* Updates:																																*/
; plddrv.c   99	/**************************************************************************/
; plddrv.c  100	int pld_init( void)
; plddrv.c  101	{
	ALIGN	1
	SYMB	LINE, 101
	PUBLIC	_pld_init
_pld_init:
	SYMB	TYPE, 260, 'X', 12, #16, 30, 0
	SYMB	GFUN, "pld_init", _pld_init, #260, 0, 0, 112
	SYMB	ALAB, _pld_init, #260
	PUSH.W	R4, R5, R6
	SYMB	SOFF, 6
	SYMB	IDEN, "i", -1, #16, 130, 5
	SYMB	LTIM, "i", -1, 0, 69
	SYMB	IDEN, "result", -1, #258, 130, 5
	SYMB	LTIM, "result", -1, 0, 69
	SYMB	TYPE, 261, 'n', #3, 129
	SYMB	TYPE, 262, 'P', #261
	SYMB	IDEN, "__#STR0009S", -1, #262, 129, 5
	SYMB	LTIM, "__#STR0009S", -1, 0, 69
	SYMB	IDEN, "__#STR0010S", -1, #262, 129, 5
	SYMB	LTIM, "__#STR0010S", -1, 0, 69
; plddrv.c  102	  int i;
; plddrv.c  103		bool result = false;
	SYMB	LINE, 103
	MOV.W	R6,#00H
	SYMB	LTIM, "result", 26, 0, 205
; plddrv.c  104																		
; plddrv.c  105		BBSPGReset( true, false, false);		// Reset the SPG ucontroller
	SYMB	LINE, 105
	MOV.W	R1,#00H
	MOV.W	R2,#00H
	MOV.W	R0,#0FFFFH
	CALL	_BBSPGReset
; plddrv.c  106	
; plddrv.c  107	  SPGPLDBuf &= ~DCLKMask;
	SYMB	LINE, 107
	MOV.B	ES,#SEG( _SPGPLDBuf )
	MOV.W	R0,#SOF( _SPGPLDBuf )
	MOV.B	R1L,[R0]
	AND.B	R1L,#0FBH
	MOV.B	ES,#SEG( _SPGPLDBuf )
	MOV.W	R0,#SOF( _SPGPLDBuf )
	MOV.B	[R0],R1L
; plddrv.c  108	  SPGPLDBuf &= ~nCONFIGMask;
	SYMB	LINE, 108
	AND.B	R1L,#0FEH
	MOV.B	ES,#SEG( _SPGPLDBuf )
	MOV.W	R0,#SOF( _SPGPLDBuf )
	MOV.B	[R0],R1L
; plddrv.c  109	  SPGPLDPort = SPGPLDBuf;
	SYMB	LINE, 109
	MOV.B	R0L,R1L
	MOVS.B	R0H,#00H
	MOV.B	ES,#SEG( _SPGPLDPort )
	MOV.W	R2,#SOF( _SPGPLDPort )
	MOV.W	[R2],R0
; plddrv.c  110	  
; plddrv.c  111	  for ( i = 0; i < 2000; i++)					// App. > 2us delay
	SYMB	LINE, 111
	MOV.W	R0,#00H
	SYMB	LTIM, "i", 2, 0, 205
_10:
	ADDS.W	R0,#01H
	SYMB	LTIM, "i", 2, 0, 77
	SYMB	LTIM, "i", 2, 0, 205
	CMP.W	R0,#07D0H
	BLT	_10
; plddrv.c  112		 ;
; plddrv.c  113	
; plddrv.c  114	  SPGPLDBuf |= nCONFIGMask;
	SYMB	LINE, 114
	OR.B	R1L,#01H
	MOV.B	ES,#SEG( _SPGPLDBuf )
	MOV.W	R0,#SOF( _SPGPLDBuf )
	MOV.B	[R0],R1L
; plddrv.c  115	  SPGPLDPort = SPGPLDBuf;
	SYMB	LINE, 115
	MOV.B	ES,#SEG( _SPGPLDBuf )
	MOV.W	R0,#SOF( _SPGPLDBuf )
	MOV.B	R0L,[R0]
	SYMB	LTIM, "i", 2, 0, 77
	MOVS.B	R0H,#00H
	MOV.B	ES,#SEG( _SPGPLDPort )
	MOV.W	R1,#SOF( _SPGPLDPort )
	MOV.W	[R1],R0
; plddrv.c  116	
; plddrv.c  117	  while ( !( SPGPLDPort & nSTATUSMask))
	SYMB	LINE, 117
	MOV.B	ES,#SEG( _SPGPLDPort )
	MOV.W	R0,#SOF( _SPGPLDPort )
	MOV.W	R0,[R0]
	AND.W	R0,#02H
	BNE	_12
_11:
	MOV.B	ES,#SEG( _SPGPLDPort )
	MOV.W	R0,#SOF( _SPGPLDPort )
	MOV.W	R0,[R0]
	AND.W	R0,#02H
	BEQ	_11
; plddrv.c  118		 ;
	SYMB	LINE, 118
_12:
; plddrv.c  119	
; plddrv.c  120	  for ( i = 0; i < 32500; i++)
	SYMB	LINE, 120
	MOV.W	R5,#SEG( _DataArray )
	MOV.W	R4,#SOF( _DataArray )
	SYMB	LTIM, "__#STR0009S", 19, 0, 205
_13:
; plddrv.c  121	    TxByte( DataArray[i]);
	SYMB	LINE, 121
	MOV.W	R1,R5
	MOV.W	R0,R4
	MOV.B	CS,R1L
	MOVC.B	R1L,[R0+]
	MOV.B	R0L,R1L
	CALL	_TxByte
	SYMB	LINE, 120
	ADD.W	R4,#01H
	ADDC.W	R5,#00H
	SYMB	LTIM, "__#STR0009S", 19, 0, 77
	SYMB	LTIM, "__#STR0009S", 19, 0, 205
	CMP.W	R5,#SEG( _DataArray+32500 )
	BNE	_19
	CMP.W	R4,#SOF( _DataArray+32500 )
_19:
	BCS	_13
; plddrv.c  122	
; plddrv.c  123	  if ( SPGPLDPort & CONF_DONEMask)
	SYMB	LINE, 123
	MOV.B	ES,#SEG( _SPGPLDPort )
	MOV.W	R0,#SOF( _SPGPLDPort )
	MOV.W	R0,[R0]
	AND.W	R0,#04H
	BEQ	_14
; plddrv.c  124			result = true;
	SYMB	LINE, 124
	MOV.W	R6,#0FFFFH
	SYMB	LTIM, "result", 26, 0, 77
	SYMB	LTIM, "result", 26, 0, 205
_14:
; plddrv.c  125	
; plddrv.c  126		BBSPGReset( false, false, false);		// Release the reset for the SPG ucontroller
	SYMB	LINE, 126
	MOV.W	R0,#00H
	MOV.W	R1,#00H
	MOV.W	R2,#00H
	CALL	_BBSPGReset
; plddrv.c  127	
; plddrv.c  128		if ( result)
	SYMB	LINE, 128
	OR.W	R6,R6
	BEQ	_15
; plddrv.c  129	    return( OK);
	SYMB	LINE, 129
	MOV.W	R0,#0FFFFH
	BR	_16
_15:
; plddrv.c  130	
; plddrv.c  131	  return( FAIL);
	SYMB	LINE, 131
	MOV.W	R0,#00H
; plddrv.c  132	}
	SYMB	LINE, 132
_16:
	POP.W	R4, R5, R6
	SYMB	SOFF, 0
	RET
	SYMB	LTIM, "result", 26, 0, 77
	SYMB	LTIM, "__#STR0009S", 19, 0, 77
	SYMB	EFUN
; plddrv.c  133	
; plddrv.c  134	/**************************************************************************/
; plddrv.c  135	/* pld_version																								   PLDDRV.C	*/
; plddrv.c  136	/*																																				*/
; plddrv.c  137	/* Author:	 Kim Engedahl, DEV, 000504																		*/
; plddrv.c  138	/* Revised:	 000504, KEn, DEV     																				*/
; plddrv.c  139	/*																																				*/
; plddrv.c  140	/* Function: Returns the HW version of the SPG/AUDIO PLD									*/
; plddrv.c  141	/* Remarks:	 Requires the SPG/AUDIO PLD to be loaded											*/
; plddrv.c  142	/* Returns:																																*/
; plddrv.c  143	/* Updates:																																*/
; plddrv.c  144	/**************************************************************************/
; plddrv.c  145	int pld_version( void)
; plddrv.c  146	{
	ALIGN	1
	SYMB	LINE, 146
	PUBLIC	_pld_version
_pld_version:
	SYMB	TYPE, 263, 'X', 12, #16, 30, 0
	SYMB	GFUN, "pld_version", _pld_version, #263, 0, 0, 0
	SYMB	ALAB, _pld_version, #263
; plddrv.c  147		return( PLDHWVersionPort);
	SYMB	LINE, 147
	MOV.B	ES,#SEG( _PLDHWVersionPort )
	MOV.W	R0,#SOF( _PLDHWVersionPort )
	MOV.W	R0,[R0]
; plddrv.c  148	}
	SYMB	LINE, 148
	RET
	SYMB	EFUN
; plddrv.c  149	
; plddrv.c  150	/**************************************************************************/
; plddrv.c  151	/* tcxo_status																								   PLDDRV.C	*/
; plddrv.c  152	/*																																				*/
; plddrv.c  153	/* Author:	 Kim Engedahl, DEV, 000504																		*/
; plddrv.c  154	/* Revised:	 000628, KEn, DEV     																				*/
; plddrv.c  155	/*																																				*/
; plddrv.c  156	/* Function: Returns the status of the TCXO																*/
; plddrv.c  157	/* Remarks:	 Requires the SPG/AUDIO PLD to be loaded											*/
; plddrv.c  158	/* Returns:																																*/
; plddrv.c  159	/* Updates:																																*/
; plddrv.c  160	/**************************************************************************/
; plddrv.c  161	int tcxo_status( void)
; plddrv.c  162	{
	ALIGN	1
	SYMB	LINE, 162
	PUBLIC	_tcxo_status
_tcxo_status:
	SYMB	TYPE, 264, 'X', 12, #16, 30, 0
	SYMB	GFUN, "tcxo_status", _tcxo_status, #264, 0, 0, 0
	SYMB	ALAB, _tcxo_status, #264
; plddrv.c  163		return( PLDTCXOStatusPort & 0xFFFC);
	SYMB	LINE, 163
	MOV.B	ES,#SEG( _PLDTCXOStatusPort )
	MOV.W	R0,#SOF( _PLDTCXOStatusPort )
	MOV.W	R0,[R0]
	AND.W	R0,#0FFFCH
; plddrv.c  164	}
	SYMB	LINE, 164
	RET
	SYMB	EFUN
	SYMB	ENDF

	SYMB	IDEN, "PLDTCXOStatusPort", _PLDTCXOStatusPort, #18, 130, 0
	SYMB	ALAB, _PLDTCXOStatusPort, #18
	HSEG AT 07000AH
	PUBLIC	_PLDTCXOStatusPort
	ALIGN	1
_PLDTCXOStatusPort:	DS	2
	SYMB	IDEN, "SPGPLDBuf", _SPGPLDBuf, #3, 130, 4
PLDDRV_CLR_FA	SEGMENT	HDATA INSEGMENT CLEAR
	RSEG	PLDDRV_CLR_FA
_SPGPLDBuf:	DS	1
	SYMB	TYPE, 265, 'Z', #3, 40959
	SYMB	IDEN, "DataArray", _DataArray, #265, 129, 0
	SYMB	ALAB, _DataArray, #265
	HCSEG AT 040000H
	PUBLIC	_DataArray
_DataArray:	DS	40960
	SYMB	IDEN, "PLDHWVersionPort", _PLDHWVersionPort, #18, 130, 0
	SYMB	ALAB, _PLDHWVersionPort, #18
	HSEG AT 07000EH
	PUBLIC	_PLDHWVersionPort
	ALIGN	1
_PLDHWVersionPort:	DS	2
	SYMB	IDEN, "SPGPLDPort", _SPGPLDPort, #18, 130, 0
	SYMB	ALAB, _SPGPLDPort, #18
	HSEG AT 06A01CH
	PUBLIC	_SPGPLDPort
	ALIGN	1
_SPGPLDPort:	DS	2
	SYMB	TYPE, 267, 'X', 12, #1, 30, 3, #258, #258, #258
	SYMB	ALAB, _BBSPGReset, #267
	EXTRN	HCODE(_BBSPGReset)
	EXTRN	DATA(__lc_ub_xvwbuffer)
	EXTRN	DATA(__lc_ue_xvwbuffer)
	CALLS	'pld_init', 'BBSPGReset'
	CALLS	'pld_init', 'TxByte'
	CALLS	'pld_init', 'BBSPGReset'
	END
