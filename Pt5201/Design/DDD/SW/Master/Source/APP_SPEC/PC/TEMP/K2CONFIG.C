/* k2config.c - kernel awareness configuration */

/***************************************/
/* ****** DO NOT EDIT THIS FILE ****** */
/***************************************/

/*************************************************************************/
/* This file must be compiled and linked with the application to support */
/* RTXC kernel awareness in debuggers and emulators                      */
/*************************************************************************/

/*
 *   RTXC Kernel Awareness 1.2
 *   Copyright (c) 1986-1998.
 *   Embedded System Products, Inc.
 *   ALL RIGHTS RESERVED
*/

/* Modification History
 *
 * 06/10/97 tdg - changed type of K2ver from unsigned short to unsigned long
 *                to meet packing requirements of i386 protected mode
 * 06/10/97 tdg - changed init_flags elements to iflags element in kernel_def
 *                structure in hopes to element name confusion.
 *
*/

#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>

#include "rtxcapi.h"
#include "rtxcarg.h"

#include "ctask.h"
#include "csema.h"
#include "cclock.h"

#ifdef HAS_MAILBOXES
#include "cmbox.h"
#endif

#ifdef HAS_PARTITIONS
#include "cpart.h"
#endif

#ifdef HAS_QUEUES
#include "cqueue.h"
#endif

#ifdef HAS_RESOURCES
#include "cres.h"
#endif

typedef unsigned char OSTYPE;  /* data type of entries in offset/sizeof tables */

/* structure of object class definition table */

typedef struct ocdt
{
   unsigned short attr; /* object class attribute mask */
   void *objptr;        /* ptr to base address of objects in RAM */
   short int  objsize;  /* size of object */
   char n_static;       /* # of static entities in object class */
   char n_dynamic;      /* # of dynamic entities in object class */
   char *names;         /* ptr to static name table */
   OSTYPE *offset_tbl;  /* offsets & sizes of members in obj class structs */
} OCDT;

/* structure of kernel definition table */

typedef struct kernel_def
{
   const char id_str[8];  /* ID string to locate kernel definition info */

   unsigned long K2ver;   /* compatible K2 version number */

   OSTYPE *koffset_tbl;   /* offsets/sizes of members in kernel structures */

   long processor_type;

   unsigned long RTXCver; /* rtxc version number */

   unsigned long pointer_bias;  /* add page # to 2-byte ptrs, if needed */
   unsigned long pointer_mask;  /* mask to correct pointer values > 16 bits */

   OSTYPE *ksizeof_tbl;   /* sizes of kernel data items */

   OSTYPE *sarg_tbl;      /* offs/szs of members: KS_wait(t) arg pkt */
   OSTYPE *sargm_tbl;     /* offs/szs of members: KS_waitm arg pkt */
   OSTYPE *qarg_tbl;      /* offs/szs of members: KS_en{de}queuew(t) arg pkt */
   OSTYPE *parg_tbl;      /* offs/szs of members: KS_allocw(t) arg pkt */
   OSTYPE *msgarg_tbl;    /* offs/szs of members: KS_sendw(t) arg pkt */
   OSTYPE *larg_tbl;      /* offs/szs of members: KS_lockw(t) arg pkt */
   OSTYPE *Frame_tbl;     /* offs/szs of members: FRAME struct */
   OSTYPE *FPFrame_tbl;   /* offs/szs of members: FPREGS struct */

   unsigned short global_attr; /* global attributes */

   OCDT const *ocdts;     /* pointer to array of object class descriptors */
   short int ocdtsz;      /* size of an object class descriptor table */
   OSTYPE *ooffset_tbl;   /* offsets/sizes of members in OCDT structures */

   char *rtxctos;         /* ptr to base addr of RTXC kernel stack */
   short int rtxcstksz;   /* size of RTXC kernel stack */

   TCB **hipritsk;        /* addr of ptr to current high pri task TCB */
   TCB near **fputask;         /* pointer to addr of current FPU task */

   char *namelen;         /* max length of object names */

   CLKBLK **clkqptr;      /* addr of ptr to first active timer in list */
   TICKS *rtctick;        /* pointer to free running timer, rtctick */
   time_t *rtctime;       /* pointer to current system time */
   TICKS clktick;         /* tick interval */

   char *isrmax;          /* ptr to worst case interrupt nesting level */

   short int fillnum;     /* random number used to init task stacks */

   char *iflags;          /* object class init flags */

   char *register_opts;   /* depends on target: reserved register, ... */
                          /* or whatever */
                          /* for 68K, could mean reserve register A5, ... */
                          /* for others, ??? */
} KERNEL_DEF;

typedef TICKS  TSLICE;    /* will be defined by RTXCgen later */

#define NAMMAX   8    /* max # chars in task/queue/etc names */
char k2_namelen = (char)NAMMAX;

#define ALIGNMNT 4 /* size of alignment factor, variable per target */
#define KOBJPTR  4 /* size of ptr to kernel object, variable per target */
#define CODEPTR  4 /* size of ptr to code (func entry,e.g.), variable per target */
#define STKPTR   4 /* size of ptr to stacks, variable per target */
#define CLKBPTR  4 /* size of ptr to clock blocks, variable per target */

#define HC11     1
#define HC12     2
#define HC16     3
#define CPU32    4
#define M68000   5
#define MPC500   6
#define I386PM   7
#define I86RM    8	// Intel/AMD x86

#ifdef RESERVE_REG_A5
char register_opts = 1;
#else
char register_opts = 0;
#endif

#define NULLPTR         ((void *)0)

#define  NO_ATTR        0

#ifdef RTXC_EL
#define LIB_B           1
#else
#ifdef RTXC_AL
#define LIB_B           2
#else /* RTXC_BL */
#define LIB_B           4
#endif
#endif

#ifdef CBUG
#define STATS
#define STATS_B         (unsigned short)32768  /* 0x8000 */
#else
#define STATS_B         0
#endif

#ifdef HAS_QUEUES
#define HQ_B            16
#else
#define HQ_B            0
#endif

#ifdef HAS_MAILBOXES
#define HM_B            32
#else
#define HM_B            0
#endif

#ifdef HAS_PARTITIONS
#define HP_B            64
#else
#define HP_B            0
#endif

#ifdef HAS_RESOURCES
#define HR_B            128
#else
#define HR_B            0
#endif

#define  GLOBAL_ATTR (LIB_B | STATS_B | HQ_B | HM_B | HP_B | HR_B)

#ifdef TIME_SLICE
#define TS_B            1
#else
#define TS_B            0
#endif

#ifdef HAS_INQTASK_ARG
#define HIA_B           2
#else
#define HIA_B           0
#endif

#ifdef FPU
#define FPU_B           4
#else
#define FPU_B           0
#endif

#ifdef DYNAMIC_TASKS
#define DT_B            8
#else
#define DT_B            0
#endif

#define  TASK_ATTR   (TS_B | HIA_B | FPU_B | DT_B)

#ifdef SEMAPHORE_TIMEOUTS
#define ST_B            1
#else
#define ST_B            0
#endif

#define  SEMA_ATTR   ST_B

#ifdef QUEUE_WAITERS
#define QW_B            1
#else
#define QW_B            0
#endif

#ifdef QUEUE_SEMAS
#define QS_B            2
#else
#define QS_B            0
#endif

#ifdef ENQUEUE_TIMEOUTS
#define EQT_B           4
#else
#define EQT_B           0
#endif

#ifdef DEQUEUE_TIMEOUTS
#define DQT_B           8
#else
#define DQT_B           0
#endif

#define  QUEUE_ATTR  (QW_B | QS_B | EQT_B | DQT_B)

#ifdef MAILBOX_WAITERS
#define MW_B            1
#else
#define MW_B            0
#endif

#ifdef MAILBOX_TIMEOUTS
#define MT_B            2
#else
#define MT_B            0
#endif

#ifdef MAILBOX_SEMAS
#define MS_B            4
#else
#define MS_B            0
#endif

#define  MBOX_ATTR  (MW_B | MT_B | MS_B)

#ifdef PARTITION_WAITERS
#define PW_B            1
#else
#define PW_B            0
#endif

#ifdef PARTITION_TIMEOUTS
#define PT_B            2
#else
#define PT_B            0
#endif

#ifdef DYNAMIC_PARTS
#define DP_B            4
#else
#define DP_B            0
#endif

#define  PART_ATTR  (PW_B | PT_B | DP_B)

#ifdef RESOURCE_WAITERS
#define RW_B            1
#else
#define RW_B            0
#endif

#ifdef RESOURCE_TIMEOUTS
#define RT_B            2
#else
#define RT_B            0
#endif

#ifdef PRIORITY_INVERSION
#define PI_B           4
#else
#define PI_B           0
#endif

#define  RES_ATTR   (RW_B | RT_B | PI_B)

#ifdef HAS_MAILBOXES
extern MHEADER mheader[];
extern const char mboxname[][NAMMAX+1];
#endif

#ifdef HAS_PARTITIONS
extern PHEADER pheader[];
extern const char partname[][NAMMAX+1];
#endif

#ifdef HAS_QUEUES
extern QHEADER qheader[];
extern const char queuename[][NAMMAX+1];
#endif

#ifdef HAS_RESOURCES
extern RHEADER rheader[];
extern const char resname[][NAMMAX+1];
#endif

extern SSTATE semat[];
extern const char semaname[][NAMMAX+1];

extern TCB rtxtcb[];
extern const char taskname[][NAMMAX+1];
extern TCB * hipritsk;
extern TCB * fputask;

extern CLKBLK clkq[];
extern CLKBLK *clkqptr;
extern volatile TICKS rtctick;
#if defined(RTXC_AL) || defined(RTXC_EL)
extern volatile time_t rtctime;
#endif

#ifdef HAS_KSTACK
extern char rtxctos[];
#endif

#ifdef STATS
extern char isrmax;
#endif

extern char init_flags;
extern unsigned long pointer_bias;

const OSTYPE toffset_tbl[] =
{
   offsetof(TCB, flink), sizeof(TCB near *),
   offsetof(TCB, pclkblk), sizeof(CLKBLK *),
   offsetof(TCB, task), sizeof(TASK),
   offsetof(TCB, priority), sizeof(PRIORITY),
   offsetof(TCB, sp), sizeof(FRAME *),       /* current stack frame pointer */
   offsetof(TCB, status), sizeof(TSTATE),
   offsetof(TCB, pc_t0), sizeof(void (*)()), /* entry point address */
   offsetof(TCB, stackbase), sizeof(char *),
   offsetof(TCB, stacksize), sizeof(size_t),
#ifdef TIME_SLICE /* { */
   offsetof(TCB, tslice), sizeof(TSLICE),    /* cur. time slice remaining */
   offsetof(TCB, newslice), sizeof(TSLICE),  /* reset for tslice, 0=no slice */
#else
   0,0,
   0,0,
#endif /* } TIME_SLICE */

#ifdef HAS_INQTASK_ARG /* { */
   offsetof(TCB, arg), sizeof(void *), /* ptr to task environment arg struct */
#else
   0,0,
#endif /* } HAS_INQTASK_ARG */

#ifdef FPU /* { */
   offsetof(TCB, fpregs), sizeof(FPREGS near *),  /* optional fpu context */
   offsetof(TCB, fpumode), sizeof(int)       /* dynamic fpu requirement, */
                                             /* 1=fpu in use */
#else
   0,0,
   0,0
#endif /* } FPU */
};

const OSTYPE Frame_tbl[] =
{
#ifdef CPU386
   offsetof(FRAME, edi), sizeof(unsigned long),
   offsetof(FRAME, esi), sizeof(unsigned long),
   offsetof(FRAME, ebp), sizeof(unsigned long),
   offsetof(FRAME, esp), sizeof(unsigned long),
   offsetof(FRAME, ebx), sizeof(unsigned long),
   offsetof(FRAME, edx), sizeof(unsigned long),
   offsetof(FRAME, ecx), sizeof(unsigned long),
   offsetof(FRAME, pksnum), sizeof(KSNUM *),
#ifdef KS_STK_NEAR /* { */
   offsetof(FRAME, pad), sizeof(unsigned short),
#endif /* } KS_STK_NEAR */
#else
   offsetof(FRAME, di), sizeof(unsigned short),
   offsetof(FRAME, si), sizeof(unsigned short),
   offsetof(FRAME, bp), sizeof(unsigned short),
   offsetof(FRAME, sp), sizeof(unsigned short),
   offsetof(FRAME, bx), sizeof(unsigned short),
   offsetof(FRAME, dx), sizeof(unsigned short),
#ifdef KS_STK_NEAR /* { */
   offsetof(FRAME, cx), sizeof(unsigned short),
   offsetof(FRAME, pksnum), sizeof(unsigned short),
#else
   offsetof(FRAME, pksnum), sizeof(unsigned short),		/* cx */
   offsetof(FRAME, pksnum) + 2, sizeof(unsigned short),  /* ax */
#endif /* } KS_STK_NEAR */
#endif
   offsetof(FRAME, es), sizeof(unsigned short),
   offsetof(FRAME, ds), sizeof(unsigned short),
   offsetof(FRAME, pc), sizeof(unsigned short),
   offsetof(FRAME, pc) + 2, sizeof(unsigned short),
   offsetof(FRAME, ccr), sizeof(unsigned short)
};

#ifdef FPU
const OSTYPE FPFRAME_tbl[] =
{
   offsetof(FPREGS, errno), sizeof(int)
};
#endif

/* make semat[] look like an object header, i.e., SHEADER, for K2 */
const OSTYPE soffset_tbl[] =
{
   (char)0, sizeof(SSTATE)  /* only one element, the sema state */
};

const OSTYPE coffset_tbl[] =
{
   offsetof(CLKBLK, flink), sizeof(TCB *),
   offsetof(CLKBLK, blink), sizeof(TCB *),
   offsetof(CLKBLK, remain), sizeof(TICKS),    /* time until timer expires */
   offsetof(CLKBLK, recycle), sizeof(TICKS),   /* cyclic amount if non-zero */
   offsetof(CLKBLK, task), sizeof(TASK),       /* associated task no. */
   offsetof(CLKBLK, state), sizeof(TSTATE),    /* TIMER_DONE or TIMER_ACTIVE */
   offsetof(CLKBLK, objtype), sizeof(OBJTYPE), /* object type */
   offsetof(CLKBLK, objid), sizeof(int)        /* object id */
};

#ifdef HAS_MAILBOXES
const OSTYPE moffset_tbl[] =
{
   offsetof(MHEADER, link), sizeof(TCB *),
#ifdef MAILBOX_WAITERS /* { */
   offsetof(MHEADER, waiters), sizeof(TCB near *), /* priority list, waiting tasks */
#else
   0,0,
#endif /* } MAILBOX_WAITERS */

#ifdef MAILBOX_SEMAS /* { */
   offsetof(MHEADER, nesema), sizeof(SEMA), /* not empty sema, init undef'd */
#else
   0,0,
#endif /* } MAILBOX_SEMAS */

#ifdef STATS /* { */
   offsetof(MHEADER, count), sizeof(int),    /* stats - no. of msgs sent */
#else
   0,0,
#endif /* } STATS */

   /* offsets in RTXCMSG struct */
   offsetof(RTXCMSG, task), sizeof(TASK),          /* sending task no. */
   offsetof(RTXCMSG, priority), sizeof(PRIORITY),  /* message priority */
   offsetof(RTXCMSG, sema), sizeof(SEMA),          /* response semaphore */
};
#endif /* } HAS_MAILBOXES */

#ifdef HAS_PARTITIONS
const OSTYPE poffset_tbl[] =
{
   offsetof(PHEADER, next), sizeof(struct xmap *), /* root of free pool list */
   offsetof(PHEADER, size), sizeof(size_t),     /* no. of bytes in blocks  */
   offsetof(PHEADER, count), sizeof(int),       /* initial no. blocks in map */

#ifdef PARTITION_WAITERS /* { */
   offsetof(PHEADER, waiters), sizeof(TCB near *), /* root of linked waiting tasks */
#else
   0,0,
#endif /* } PARTITION_WAITERS */

#ifdef DYNAMIC_PARTS /* { */
   offsetof(PHEADER, map), sizeof(MAP),     /* dynamic partition number */
   offsetof(PHEADER, addr), sizeof(char *), /* addr of RAM to use for part */
#else
   0,0,
   0,0,
#endif /* } DYNAMIC_PARTS */

#ifdef STATS /* { */
   offsetof(PHEADER, cur), sizeof(int),   /* current no. of used blocks */
   offsetof(PHEADER, worst), sizeof(int), /* worst case used level */
   offsetof(PHEADER, usage), sizeof(int),  /* no. of KS_free() calls to date */
#else
   0,0,
   0,0,
   0,0,
#endif /* } STATS */
};
#endif /* } HAS_PARTITIONS */

#ifdef HAS_QUEUES
const OSTYPE qoffset_tbl[] =
{ 
   offsetof(QHEADER, base), sizeof(char *),     /* &queue body */
   offsetof(QHEADER, width), sizeof(size_t),    /* width in bytes */
   offsetof(QHEADER, depth), sizeof(int),       /* max depth in entries */
   offsetof(QHEADER, putndx), sizeof(int), /* internal use, init = depth - 1 */
   offsetof(QHEADER, curndx), sizeof(int), /* internal use, init = 0 */
#ifdef QUEUE_WAITERS /* { */
   offsetof(QHEADER, waiters), sizeof(TCB near *), /* priority list, waiting tasks */
#else
   0,0,
#endif /* } QUEUE_WAITERS */

#ifdef QUEUE_SEMAS /* { */
   offsetof(QHEADER, fsema), sizeof(SEMA),  /* queue full sema, init PENDing */
   offsetof(QHEADER, nesema), sizeof(SEMA), /* queue not empty sema, init PENDing */
   offsetof(QHEADER, esema), sizeof(SEMA),  /* queue empty sema, init DONE */
   offsetof(QHEADER, nfsema), sizeof(SEMA), /* queue not full sema, init DONE */
#else
   0,0,
   0,0,
   0,0,
   0,0,
#endif /* } QUEUE_SEMAS */

#ifdef STATS /* { */
   offsetof(QHEADER, count), sizeof(int), /* stats - count */
   offsetof(QHEADER, worst), sizeof(int),  /* stats - worst case full level */
#else
   0,0,
   0,0,
#endif /* } STATS */
};
#endif /* } HAS_QUEUES */

#ifdef HAS_RESOURCES
const OSTYPE roffset_tbl[] =
{
   offsetof(RHEADER, owner), sizeof(TCB near *), /* task ownership, 0=no owner */
   offsetof(RHEADER, level), sizeof(int),   /* no. of nested locks */

#ifdef RESOURCE_WAITERS /* { */
   offsetof(RHEADER, waiters),sizeof(TCB near *), /* pri list-waiters, 0=no waiters */
#ifdef PRIORITY_INVERSION /* { */
   offsetof(RHEADER, priority),sizeof(PRIORITY), /* owner's orig pri iff inversion */
   offsetof(RHEADER, resattr),sizeof(RESATTR), /* pri inversion option switch */
#else
   0,0,
   0,0,
#endif /* } PRIORITY_INVERSION */
#else
   0,0,
   0,0,
   0,0,
#endif /* } RESOURCE_WAITERS */

#ifdef STATS /* { */
   offsetof(RHEADER, count), sizeof(int), /* stats - no. of locks performed */
   offsetof(RHEADER, conflict), sizeof(int), /* stats - no. resource conflicts */
#else
   0,0,
   0,0,
#endif /* } STATS */
};
#endif /* } HAS_RESOURCES */


/* offsets and sizes of needed elements in argument packets */

const OSTYPE sarg_tbl[] =
{
   offsetof(struct sarg, ksnum), sizeof(KSNUM),
   offsetof(struct sarg, sema),  sizeof(SEMA)
};

const OSTYPE sargm_tbl[] =
{
   offsetof(struct sargm, ksnum), sizeof(KSNUM),
   offsetof(struct sargm, list),  sizeof(SEMA *)
};

const OSTYPE qarg_tbl[] =
{
   offsetof(struct qarg, ksnum), sizeof(KSNUM),
   offsetof(struct qarg, queue), sizeof(QUEUE)
};

const OSTYPE parg_tbl[] =
{ 
   offsetof(struct parg, ksnum), sizeof(KSNUM),
   offsetof(struct parg, map),   sizeof(MAP)
};

const OSTYPE msgarg_tbl[] =
{ 
   offsetof(struct msgarg, ksnum), sizeof(KSNUM),
   offsetof(struct msgarg, sema),  sizeof(SEMA),
   offsetof(struct msgarg, mbox),  sizeof(MBOX)
};

const OSTYPE larg_tbl[] =
{ 
   offsetof(struct larg, ksnum),    sizeof(KSNUM),
   offsetof(struct larg, resource), sizeof(RESOURCE)
};


/* object class definition tables */

const OCDT k2_ocdts[] =
{
   {  TASK_ATTR,                       /* class 1: tasks */
      rtxtcb,
      sizeof(TCB),
      (char)NTASKS,
#ifdef DYNAMIC_TASKS
      (char)DNTASKS,
#else
      0,
#endif
      (char *)&taskname,
      (OSTYPE *)&toffset_tbl
   },
   {  SEMA_ATTR,                       /* class 2: semaphores */
      semat,
      sizeof(SSTATE),
      (char)NSEMAS,
      0,
      (char *)&semaname,
      (OSTYPE *)&soffset_tbl,
   },
   {  QUEUE_ATTR,                      /* class 3: queues */
#ifdef HAS_QUEUES
      qheader,
      sizeof(QHEADER),
      (char)NQUEUES,
      0,
      (char *)&queuename,
      (OSTYPE *)&qoffset_tbl
#else
      NULLPTR,
      0,
      0,
      0,
      NULLPTR,
      NULLPTR,
      NULLPTR
#endif
   },
   {  MBOX_ATTR,                       /* class 4: mailboxes */
#ifdef HAS_MAILBOXES
      mheader,
      sizeof(MHEADER),
      (char)NMBOXES,
      0,
      (char *)&mboxname,
      (OSTYPE *)&moffset_tbl
#else
      NULLPTR,
      0,
      0,
      0,
      NULLPTR,
      NULLPTR,
      NULLPTR
#endif
   },
   {  PART_ATTR,                       /* class 5: partitions */
#ifdef HAS_PARTITIONS
      pheader,
      sizeof(PHEADER),
      (char)NPARTS,
#ifdef DYNAMIC_PARTS
      (char)DNPARTS,
#else
      0,
#endif
      (char *)&partname,
      (OSTYPE *)&poffset_tbl
#else
      NULLPTR,
      0,
      0,
      0,
      NULLPTR,
      NULLPTR,
      NULLPTR
#endif
   },
   {  RES_ATTR,                        /* class 6: resources */
#ifdef HAS_RESOURCES
      rheader,
      sizeof(RHEADER),
      (char)NRES,
      0,
      (char *)&resname,
      (OSTYPE *)&roffset_tbl
#else
      NULLPTR,
      0,
      0,
      0,
      NULLPTR,
      NULLPTR,
      NULLPTR
#endif
   },
   {  NO_ATTR,                         /* class 7: clock (timers) */
      clkq,
      sizeof(CLKBLK),
      (char)NTMRS,
      0,
      NULLPTR,
      (OSTYPE *)&coffset_tbl
   }
};

const OSTYPE ooffset_tbl[] =
{
   offsetof(OCDT, attr), sizeof(unsigned short),
   offsetof(OCDT, objptr), sizeof(void *),
   offsetof(OCDT, objsize), sizeof(short int),
   offsetof(OCDT, n_static), sizeof(char),
   offsetof(OCDT, n_dynamic), sizeof(char),
   offsetof(OCDT, names), sizeof(char *),
   offsetof(OCDT, offset_tbl), sizeof(OSTYPE *)
};

const OSTYPE koffset_tbl[] =
{
   offsetof(KERNEL_DEF, processor_type), sizeof(long),
   offsetof(KERNEL_DEF, RTXCver), sizeof(long),
   offsetof(KERNEL_DEF, pointer_bias), sizeof(unsigned long),
   offsetof(KERNEL_DEF, pointer_mask), sizeof(unsigned long),
   offsetof(KERNEL_DEF, ksizeof_tbl), sizeof(OSTYPE *),
   offsetof(KERNEL_DEF, sarg_tbl), sizeof(OSTYPE *),
   offsetof(KERNEL_DEF, sargm_tbl), sizeof(OSTYPE *),
   offsetof(KERNEL_DEF, qarg_tbl), sizeof(OSTYPE *),
   offsetof(KERNEL_DEF, parg_tbl), sizeof(OSTYPE *),
   offsetof(KERNEL_DEF, msgarg_tbl), sizeof(OSTYPE *),
   offsetof(KERNEL_DEF, larg_tbl), sizeof(OSTYPE *),
   offsetof(KERNEL_DEF, Frame_tbl), sizeof(OSTYPE *),
   offsetof(KERNEL_DEF, FPFrame_tbl), sizeof(OSTYPE *),
   offsetof(KERNEL_DEF, global_attr), sizeof(unsigned short),
   offsetof(KERNEL_DEF, ocdts), sizeof(OCDT *),
   offsetof(KERNEL_DEF, ocdtsz), sizeof(short int),
   offsetof(KERNEL_DEF, ooffset_tbl), sizeof(OSTYPE *),
   offsetof(KERNEL_DEF, rtxctos), sizeof(char *),
   offsetof(KERNEL_DEF, rtxcstksz), sizeof(short int),
   offsetof(KERNEL_DEF, hipritsk), sizeof(TCB near * near *),
   offsetof(KERNEL_DEF, fputask), sizeof(TCB near **),
   offsetof(KERNEL_DEF, namelen), sizeof(char *),
   offsetof(KERNEL_DEF, clkqptr), sizeof(CLKBLK **),
   offsetof(KERNEL_DEF, rtctick), sizeof(TICKS *),
   offsetof(KERNEL_DEF, rtctime), sizeof(time_t *),
   offsetof(KERNEL_DEF, clktick), sizeof(TICKS),
   offsetof(KERNEL_DEF, isrmax), sizeof(char *),
   offsetof(KERNEL_DEF, fillnum), sizeof(short int),
   offsetof(KERNEL_DEF, iflags), sizeof(char *),
   offsetof(KERNEL_DEF, register_opts), sizeof(char *)
};

const OSTYPE ksizeof_tbl[] =
{
   ALIGNMNT,
   KOBJPTR,
   CODEPTR,
   STKPTR,
   CLKBPTR,
   sizeof(OBJNUM),    /* object number, e.g., TASK, QUEUES, etc. */
   sizeof(TICKS),
   sizeof(FRAME),     /* task stack frame */
   sizeof(KSNUM),
   sizeof(RTXCMSG)
};


const KERNEL_DEF kernel_def =
{
   "RtXcIdS",                 /* id string to locate kernel def struct */
   0x0102,                    /* compatible K2 version number */
   (OSTYPE *)&koffset_tbl,
   (long)I86RM,
   (long)0x00000302,          /* current RTXC version number */
   (unsigned long)&pointer_bias,    /* pointer bias */
   (unsigned long)0xFFFFFFFFL, /* pointer mask */
   (OSTYPE *)&ksizeof_tbl,
   (OSTYPE *)&sarg_tbl,
   (OSTYPE *)&sargm_tbl,
   (OSTYPE *)&qarg_tbl,
   (OSTYPE *)&parg_tbl,
   (OSTYPE *)&msgarg_tbl,
   (OSTYPE *)&larg_tbl,
   (OSTYPE *)&Frame_tbl,
#ifdef FPU
   (OSTYPE *)&FPFrame_tbl,
#else
   0,
#endif
   GLOBAL_ATTR,
   k2_ocdts,
   sizeof(OCDT),
   (OSTYPE *)&ooffset_tbl,
#ifdef HAS_KSTACK
   rtxctos,
   RTXCSTKSZ,
#else
   NULLPTR,
   0,
#endif
   &hipritsk,
#ifdef FPU
   &fputask,
#else
   NULLPTR,
#endif
   &k2_namelen,
   &clkqptr,
   &rtctick,
#if defined(RTXC_AL) || defined(RTXC_EL)
   &rtctime,
#else
   NULLPTR,
#endif
   CLKTICK,
#ifdef STATS
   &isrmax,
#else
   NULLPTR,
#endif
   STACK_FILL,
   &init_flags,
   &register_opts
};
