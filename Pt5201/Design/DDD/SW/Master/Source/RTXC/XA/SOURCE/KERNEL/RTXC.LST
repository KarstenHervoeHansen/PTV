XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page   1
D:\PROJECT\pt5201\master\source\RTXC\XA\SOURCE\KERNEL\cc71539b.src
ADDR   CODE            LINE SOURCELINE
                          1 ; XA C compiler v2.0 r2                   SN00085795-Ccz (c) 1998 TASKING, Inc.
                          2 ; options: -e -gn -O2 -err -Ic:\cxa\\include -I..\..\include -s -Cxag3 -Ml
                          4 $NOZPAGE
                          5         NAME    RTXC
                          6 ; rtxc.c      1 /* rtxc.c - RTXC entry point from isvcrtx() */
                          7 ; rtxc.c      2 
                          8 ; rtxc.c      3 /*
                          9 ; rtxc.c      4  *   RTXC    
                         10 ; rtxc.c      5  *   Copyright (c)
                         11 ; rtxc.c      6  *   Embedded System Products, Inc.
                         12 ; rtxc.c      7  *   ALL RIGHTS RESERVED
                         13 ; rtxc.c      8 */
                         14 ; rtxc.c      9 
                         15 ; rtxc.c     10 
                         16 ; rtxc.c     11 /*****************************************************************************/
                         17 ; rtxc.c     12 /* Changes made to the kernel : */
                         18 ; rtxc.c     13 
                         19 ; rtxc.c     14 /*    3/6-99 the following changes is made by TK-PTV */
                         20 ; rtxc.c     15 
                         21 ; rtxc.c     16 /*      KS_deftime(long)        corrected for reset of tick counter. */
                         22 ; rtxc.c     17 
                         23 ; rtxc.c     18 /*      KS_inqtime()            appended reading of tick count in variable
                         24 ; rtxc.c     19                                 rtctimetick after invocation of KS_inqtime().*/
                         25 ; rtxc.c     20 
                         26 ; rtxc.c     21 /*****************************************************************************/
                         27 ; rtxc.c     22 
                         28 ; rtxc.c     23 
                         29 ; rtxc.c     24 #include "typedef.h"
                         30 ; rtxc.c     25 #include "rtxstruc.h"
                         31 ; rtxc.c     26 #include "rtxcarg.h"
                         32 ; rtxc.c     27 #include "tstate.h"
                         33 ; rtxc.c     28 #include "enable.h"
                         34 ; rtxc.c     29 
                         35 ; rtxc.c     30 extern void * memcpy(void *, const void *, size_t);
                         36 ; rtxc.c     31 
                         37 ; rtxc.c     32 static void ks_memcpyFN(void ks_queue *, const void          *, size_t);
                         38 ; rtxc.c     33 static void ks_memcpyNF(void          *, const void ks_queue *, size_t);
                         39 ; rtxc.c     34 
                         40 ; rtxc.c     35 #if _MODEL == 'm' || _MODEL == 'l'
                         41 ; rtxc.c     36 unsigned long swap_pc_t0(unsigned long);
                         42 ; rtxc.c     37 #endif /* } _MODEL */
                         43 ; rtxc.c     38 
                         44 ; rtxc.c     39 /* state of CLKBLKs */
                         45 ; rtxc.c     40 #define TIMER_ACTIVE    1 /* timer counting down */
                         46 ; rtxc.c     41 #define TIMER_DONE      0 /* timer already expired */
                         47 ; rtxc.c     42 
                         48 ; rtxc.c     43 #define NULL     ((void *)0)
                         49 ; rtxc.c     44 #define NULLTCB  ((TCB ks_tbl *)0)
                         50 ; rtxc.c     45 #define NULLMAP  ((PHEADER ks_tbl *)0)
                         51 ; rtxc.c     46 #define NULLCLK  ((CLKBLK ks_clk *)0)
                         52 ; rtxc.c     47 #define NULLSEMA ((SEMA)0)
                         53 ; rtxc.c     48 #define NULLFUNC ((void (*)(void))0)
                         54 ; rtxc.c     49 #define NULLARG  ((void *)0)
                         55 ; rtxc.c     50 #ifdef FPU /* { */
                         56 ; rtxc.c     51 #define NULLFPREGS ((FPREGS ks_tbl *)0)
                         57 ; rtxc.c     52 #endif /* } FPU */
                         58 ; rtxc.c     53 
                         59 ; rtxc.c     54 #define SELFTASK ((TASK)0)
                         60 ; rtxc.c     55 
                         61 ; rtxc.c     56 /* stash sema in siglist */
                         62 ; rtxc.c     57 #define SIGNAL(sema) PUSHPSWH; DISABLE; *++semaput = sema; POPPSWH
                         63 ; rtxc.c     58 
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page   2

ADDR   CODE            LINE SOURCELINE
                         64 ; rtxc.c     59 extern TCB ks_tblx rtxtcb[];
                         65 ; rtxc.c     60 extern const KTCB rtxktcb[];
                         66 ; rtxc.c     61 extern const TASK ntasks;
                         67 ; rtxc.c     62 #ifdef DYNAMIC_TASKS /* { */
                         68 ; rtxc.c     63 extern const TASK dntasks;
                         69 ; rtxc.c     64 #endif /* } DYNAMIC_TASKS */
                         70 ; rtxc.c     65 
                         71 ; rtxc.c     66 extern SSTATE ks_tblx semat[];
                         72 ; rtxc.c     67 extern SEMA ks_datax siglist[];
                         73 ; rtxc.c     68 extern const SEMA nsemas;
                         74 ; rtxc.c     69 #ifdef BSS_NOT_ZERO /* { */
                         75 ; rtxc.c     70 extern const int siglistsize;
                         76 ; rtxc.c     71 #endif /* } BSS_NOT_ZERO */
                         77 ; rtxc.c     72 
                         78 ; rtxc.c     73 extern CLKBLK ks_clkx clkq[];
                         79 ; rtxc.c     74 extern const int ntmrs;
                         80 ; rtxc.c     75 
                         81 ; rtxc.c     76 #ifdef HAS_MAILBOXES /* { */
                         82 ; rtxc.c     77 extern MHEADER ks_tblx mheader[];
                         83 ; rtxc.c     78 extern const MBOX nmboxes;
                         84 ; rtxc.c     79 #endif /* } HAS_MAILBOXES */
                         85 ; rtxc.c     80 
                         86 ; rtxc.c     81 #ifdef HAS_PARTITIONS /* { */
                         87 ; rtxc.c     82 extern PHEADER ks_tblx pheader[];
                         88 ; rtxc.c     83 extern const PKHEADER pkheader[];
                         89 ; rtxc.c     84 extern const MAP nparts;
                         90 ; rtxc.c     85 #ifdef DYNAMIC_PARTS /* { */
                         91 ; rtxc.c     86 extern const MAP dnparts;
                         92 ; rtxc.c     87 #endif /* } DYNAMIC_PARTS */
                         93 ; rtxc.c     88 #endif /* } HAS_PARTITIONS */
                         94 ; rtxc.c     89 
                         95 ; rtxc.c     90 #ifdef HAS_QUEUES /* { */
                         96 ; rtxc.c     91 extern QHEADER ks_tblx qheader[];
                         97 ; rtxc.c     92 extern const QKHEADER qkheader[];
                         98 ; rtxc.c     93 extern const QUEUE nqueues;
                         99 ; rtxc.c     94 #endif /* } HAS_QUEUES */
                        100 ; rtxc.c     95 
                        101 ; rtxc.c     96 #ifdef HAS_RESOURCES /* { */
                        102 ; rtxc.c     97 extern RHEADER ks_tblx rheader[];
                        103 ; rtxc.c     98 extern const RESOURCE nres;
                        104 ; rtxc.c     99 #endif /* } HAS_RESOURCES */
                        105 ; rtxc.c    100 
                        106 ; rtxc.c    101 TCB ks_tbl * core_iramdata hipritsk; /* highest priority task */
                        107 ; rtxc.c    102 TCB ks_tbl * core_iramdata nsrttcb;  /* list of tcbs pending scheduling */
                        108 ; rtxc.c    103 
                        109 ; rtxc.c    104 volatile SEMA ks_data * core_iramdata semaput;
                        110 ; rtxc.c    105 
                        111 ; rtxc.c    106 SEMA ks_data * core_iramdata semaget;
                        112 ; rtxc.c    107 
                        113 ; rtxc.c    108 #ifdef DYNAMIC_TASKS /* { */
                        114 ; rtxc.c    109 TCB ks_tbl * ks_data dtcbfl; /* head of tcb free list,initially &rtxtcb[NTASKS+1]
                             */
                        115 ; rtxc.c    110 #endif /* } DYNAMIC_TASKS */
                        116 ; rtxc.c    111 
                        117 ; rtxc.c    112 #ifdef HAS_PARTITIONS /* { */
                        118 ; rtxc.c    113 #ifdef DYNAMIC_PARTS /* { */
                        119 ; rtxc.c    114 PHEADER ks_tbl * ks_data dphfl; /* head of partition header free list */
                        120 ; rtxc.c    115                                    /* initially &pheader[NPARTS+1] */
                        121 ; rtxc.c    116 static void dn_defpart(PHEADER ks_tbl *pph, KSNUM ks_stk *p2);
                        122 ; rtxc.c    117 #endif /* } DYNAMIC_PARTS */
                        123 ; rtxc.c    118 
                        124 ; rtxc.c    119 void * KS_ISRalloc(MAP);
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page   3

ADDR   CODE            LINE SOURCELINE
                        125 ; rtxc.c    120 #endif /* } HAS_PARTITIONS */
                        126 ; rtxc.c    121 
                        127 ; rtxc.c    122 volatile TICKS ks_data rtctick; /* no. of ticks since hw reset, initially 0 */
                        128 ; rtxc.c    123 
                        129 ; rtxc.c    124 #ifdef HAS_INQTIME /* { */
                        130 ; rtxc.c    125 volatile time_t ks_data rtctime; /* running seconds maintained by clock driver */
                            
                        131 ; rtxc.c    126 #endif /* } HAS_INQTIME */
                        132 ; rtxc.c    127 
                        133 ; rtxc.c    128 CLKBLK ks_clk * ks_data clkqptr; /* ptr to first active timer, initially NULLCLK 
                            */
                        134 ; rtxc.c    129 CLKBLK ks_clk * ks_data clkqfl;  /* ptr to timer free list, initially &clkq[0] */
                            
                        135 ; rtxc.c    130 #ifdef TIME_SLICE /* { */
                        136 ; rtxc.c    131 TCB ks_tbl * core_iramdata sliceup;
                        137 ; rtxc.c    132 #endif /* } TIME_SLICE */
                        138 ; rtxc.c    133 extern const int clkrate;
                        139 ; rtxc.c    134 
                        140 ; rtxc.c    135 #ifdef HAS_INQTIME /* { */
                        141 ; rtxc.c    136 static int ks_data ratecnt; /* clkrate counter (0 -> clkrate-1) */
                        142 ; rtxc.c    137 int rtctimetick;
                        143 ; rtxc.c    138 #endif /* } HAS_INQTIME */
                        144 ; rtxc.c    139 
                        145 ; rtxc.c    140 #ifdef FPU /* { */
                        146 ; rtxc.c    141 TCB ks_tbl * ks_data fputask; /* current owner of FPU */
                        147 ; rtxc.c    142 extern void fpuswap(FPREGS ks_tbl *oldregs, FPREGS ks_tbl *newregs);
                        148 ; rtxc.c    143 #endif /* } FPU */
                        149 ; rtxc.c    144 
                        150 ; rtxc.c    145 #ifdef CBUG /* { */
                        151 ; rtxc.c    146 char cbugflag; /* RTXCbug active flag */
                        152 ; rtxc.c    147 char isrmax;  /* worst case interrupt depth, initially = 0 */
                        153 ; rtxc.c    148 extern char ks_stkx rtxctos[];
                        154 ; rtxc.c    149 void stkinit(short ks_stk *, size_t);
                        155 ; rtxc.c    150 #endif /* } CBUG */
                        156 ; rtxc.c    151 
                        157 ; rtxc.c    152 char core_iramdata isrcnt; /* count of "levels" of interrupts, initially = 0 */
                        158 ; rtxc.c    153 unsigned char core_iramdata intlvl; /* current processor priority level for
                        159 ; rtxc.c    154                                        tasks. Initialized in startup code */
                        160 ; rtxc.c    155 
                        161 ; rtxc.c    156 static volatile char ks_data t_expired;
                        162 ; rtxc.c    157 
                        163 ; rtxc.c    158 static FRAME ks_stk *postem(void);
                        164 ; rtxc.c    159 
                        165 ; rtxc.c    160 #ifdef HAS_MAILBOXES /* { */
                        166 ; rtxc.c    161 static void insert_message(MHEADER ks_tbl *pmh, RTXCMSG *prtxcmsg);
                        167 ; rtxc.c    162 static RTXCMSG *remove_message(MHEADER ks_tbl *pmh, TASK task);
                        168 ; rtxc.c    163 #endif /* } HAS_MAILBOXES */
                        169 ; rtxc.c    164 
                        170 ; rtxc.c    165 static CLKBLK ks_clk *get_clkblk(void);
                        171 ; rtxc.c    166 static void insert_timer(CLKBLK ks_clk *pclkblk);
                        172 ; rtxc.c    167 static void unlink_timer(CLKBLK ks_clk *pclkblk);
                        173 ; rtxc.c    168 
                        174 ; rtxc.c    169 #if defined(MAILBOX_WAITERS)   || \ 
                        175 ; rtxc.c    170     defined(PARTITION_WAITERS) || \ 
                        176 ; rtxc.c    171     defined(QUEUE_WAITERS)     || \ 
                        177 ; rtxc.c    172     defined(RESOURCE_WAITERS) /* { */
                        178 ; rtxc.c    173 #define COMBO_WAIT (MSG_WAIT | PARTITION_WAIT | QUEUE_WAIT | RESOURCE_WAIT)
                        179 ; rtxc.c    174 static void porder(TCB ks_tbl *ptcb);
                        180 ; rtxc.c    175 static void reorder_waiters(TCB ks_tbl *ptcb);
                        181 ; rtxc.c    176 static void fwd_insert(TCB ks_tbl *ptcb);
                        182 ; rtxc.c    177 static void bwd_insert(TCB ks_tbl *ptcb);
                        183 ; rtxc.c    178 #endif /* } - MAILBOX_ || PARTITION_ || QUEUE_ || RESOURCE_WAITERS */
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page   4

ADDR   CODE            LINE SOURCELINE
                        184 ; rtxc.c    179 
                        185 ; rtxc.c    180 static void chgpriority(TCB ks_tbl *ptcb, PRIORITY priority);
                        186 ; rtxc.c    181 
                        187 ; rtxc.c    182 #ifdef PRIORITY_INVERSION /* { */
                        188 ; rtxc.c    183 /*
                        189 ; rtxc.c    184  *
                        190 ; rtxc.c    185  * the following variable defines the initial conditions of all
                        191 ; rtxc.c    186  * PRIORITY_INVERSION resource attributes. Setting to _OFF is
                        192 ; rtxc.c    187  * default. Use KS_defres() at runtime to set individual resources to _ON.
                        193 ; rtxc.c    188  *
                        194 ; rtxc.c    189 */
                        195 ; rtxc.c    190 #define PRIORITY_INVERSION_T0 PRIORITY_INVERSION_OFF
                        196 ; rtxc.c    191 #endif /* } PRIORITY_INVERSION */
                        197 ; rtxc.c    192 
                        198 ; rtxc.c    193 /* choice of function (smaller) code or inline (faster) */
                        199 ; rtxc.c    194 #ifdef INLINE_MACRO_EXPANSION /* { */
                        200 ; rtxc.c    195 #define UNLINK_HIPRITSK() hipritsk = hipritsk->flink; \ 
                        201 ; rtxc.c    196                           hipritsk->blink = (TCB ks_tbl *)&hipritsk
                        202 ; rtxc.c    197 
                        203 ; rtxc.c    198 #define UPDATE_SEMA(sema) if ((sema) != NULLSEMA) \ 
                        204 ; rtxc.c    199                           { \ 
                        205 ; rtxc.c    200                              psstate = (SSTATE ks_tbl *)&semat[(sema)]; \ 
                        206 ; rtxc.c    201                              \ 
                        207 ; rtxc.c    202                              if (*psstate == SEMA_PENDING) \ 
                        208 ; rtxc.c    203                                 *psstate = SEMA_DONE; \ 
                        209 ; rtxc.c    204                              else if (*psstate != SEMA_DONE) \ 
                        210 ; rtxc.c    205                              { \ 
                        211 ; rtxc.c    206                                 SIGNAL((sema)); \ 
                        212 ; rtxc.c    207                              } \ 
                        213 ; rtxc.c    208                           }
                        214 ; rtxc.c    209 #else /* } INLINE_MACRO_EXPANSION { */
                        215 ; rtxc.c    210 #define UNLINK_HIPRITSK() unlink_hipritsk()
                        216 ; rtxc.c    211 static void unlink_hipritsk(void)
                        217 ; rtxc.c    212 {
                        218 ; rtxc.c    213    hipritsk = hipritsk->flink;
                        219 ; rtxc.c    214    hipritsk->blink = (TCB ks_tbl *)&hipritsk;
                        220 ; rtxc.c    215 }
                        221 ; rtxc.c    216 #define UPDATE_SEMA(sema) if ((sema) != NULLSEMA) update_sema((sema))
                        222 ; rtxc.c    217 static void update_sema(SEMA sema)
                        223 ; rtxc.c    218 {
                        224 ; rtxc.c    219    unsigned char pswh;  /* local variable for saving processor interrupt state */
                            
                        225 ; rtxc.c    220    SSTATE ks_tbl *psstate;
                        226 ; rtxc.c    221 
                        227 ; rtxc.c    222    psstate = (SSTATE ks_tbl *)&semat[sema];
                        228 ; rtxc.c    223 
                        229 ; rtxc.c    224    if (*psstate == SEMA_PENDING)
                        230 ; rtxc.c    225       *psstate = SEMA_DONE;
                        231 ; rtxc.c    226    else if (*psstate != SEMA_DONE)
                        232 ; rtxc.c    227    {
                        233 ; rtxc.c    228       SIGNAL(sema);
                        234 ; rtxc.c    229    }
                        235 ; rtxc.c    230 }
                        236 ; rtxc.c    231 #endif /* } INLINE_MACRO_EXPANSION */
                        237 ; rtxc.c    232 
                        238 ; rtxc.c    233 /* local function prototypes */
                        239 ; rtxc.c    234 FRAME ks_stk * rtxc(FRAME ks_stk *);
                        240 ; rtxc.c    235 FRAME ks_stk * KS_ISRexit(FRAME ks_stk *, SEMA);
                        241 ; rtxc.c    236 void KS_ISRsignal(SEMA);
                        242 ; rtxc.c    237 int KS_ISRtick(void);
                        243 ; rtxc.c    238 void taskinit(void);
                        244 ; rtxc.c    239 void semainit(void);
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page   5

ADDR   CODE            LINE SOURCELINE
                        245 ; rtxc.c    240 void clockinit(void);
                        246 ; rtxc.c    241 #ifdef HAS_RESOURCES /* { */
                        247 ; rtxc.c    242 void resinit(void);
                        248 ; rtxc.c    243 #endif /* } HAS_RESOURCES */
                        249 ; rtxc.c    244 #ifdef HAS_MAILBOXES /* { */
                        250 ; rtxc.c    245 void mboxinit(void);
                        251 ; rtxc.c    246 #endif /* } HAS_MAILBOXES */
                        252 ; rtxc.c    247 #ifdef HAS_PARTITIONS /* { */
                        253 ; rtxc.c    248 void partinit(void);
                        254 ; rtxc.c    249 #endif /* } HAS_PARTITIONS */
                        255 ; rtxc.c    250 #ifdef HAS_QUEUES /* { */
                        256 ; rtxc.c    251 void queueinit(void);
                        257 ; rtxc.c    252 #endif /* } HAS_QUEUES */
                        258 ; rtxc.c    253 
                        259 ; rtxc.c    254 /* entry point for all kernel directives */
                        260 ; rtxc.c    255 FRAME ks_stk * rtxc(FRAME ks_stk *p)
                        261 ; rtxc.c    256 {
                        262         PUBLIC  _rtxc
000000                  263 RTXC_PR SEGMENT HCODE
000000                  264         RSEG    RTXC_PR
000000                  264         RSEG    RTXC_PR
000000                  265 _rtxc:
000000 0F70             266         PUSH.W  R4, R5, R6
000002 99720020         267         SUB.W   R7,#020H
                        268 ; rtxc.c    257    unsigned char pswh;  /* local variable for saving processor interrupt state */
                            
                        269 ; rtxc.c    258    KSNUM ks_stk *p2 = p->pksnum;
000006 862C42           270         MOV.B   ES,R1L
000009 8C4004           271         MOV.W   R4,[R0+4]
00000C 8C5006           272         MOV.W   R5,[R0+6]
000000                  273 RTXC_IR SEGMENT HCODE INSEGMENT ROMDATA
000000                  274         RSEG    RTXC_IR
                        275         ALIGN   1
000000                  276 __swtable433:
000000 rrrrrrrrrrrrrr   277         DW      SOF _10,SEG _10
       rrrrrrrrrrrrrr       
       rrrr                 
000004 rrrrrrrrrrrrrr   278         DW      SOF _3,SEG _3
       rrrrrrrrrrrrrr       
       rrrr                 
000008 rrrrrrrrrrrrrr   279         DW      SOF _21,SEG _21
       rrrrrrrrrrrrrr       
       rrrr                 
00000C rrrrrrrrrrrrrr   280         DW      SOF _112,SEG _112
       rrrrrrrrrrrrrr       
       rrrr                 
000010 rrrrrrrrrrrrrr   281         DW      SOF _129,SEG _129
       rrrrrrrrrrrrrr       
       rrrr                 
000014 rrrrrrrrrrrrrr   282         DW      SOF _30,SEG _30
       rrrrrrrrrrrrrr       
       rrrr                 
000018 rrrrrrrrrrrrrr   283         DW      SOF _34,SEG _34
       rrrrrrrrrrrrrr       
       rrrr                 
00001C rrrrrrrrrrrrrr   284         DW      SOF _38,SEG _38
       rrrrrrrrrrrrrr       
       rrrr                 
000020 rrrrrrrrrrrrrr   285         DW      SOF _41,SEG _41
       rrrrrrrrrrrrrr       
       rrrr                 
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page   6

ADDR   CODE            LINE SOURCELINE
000024 rrrrrrrrrrrrrr   286         DW      SOF _40,SEG _40
       rrrrrrrrrrrrrr       
       rrrr                 
000028 rrrrrrrrrrrrrr   287         DW      SOF _43,SEG _43
       rrrrrrrrrrrrrr       
       rrrr                 
00002C rrrrrrrrrrrrrr   288         DW      SOF _137,SEG _137
       rrrrrrrrrrrrrr       
       rrrr                 
000030 rrrrrrrrrrrrrr   289         DW      SOF _175,SEG _175
       rrrrrrrrrrrrrr       
       rrrr                 
000034 rrrrrrrrrrrrrr   290         DW      SOF _44,SEG _44
       rrrrrrrrrrrrrr       
       rrrr                 
000038 rrrrrrrrrrrrrr   291         DW      SOF _54,SEG _54
       rrrrrrrrrrrrrr       
       rrrr                 
00003C rrrrrrrrrrrrrr   292         DW      SOF _79,SEG _79
       rrrrrrrrrrrrrr       
       rrrr                 
000040 rrrrrrrrrrrrrr   293         DW      SOF _80,SEG _80
       rrrrrrrrrrrrrr       
       rrrr                 
000044 rrrrrrrrrrrrrr   294         DW      SOF _84,SEG _84
       rrrrrrrrrrrrrr       
       rrrr                 
000048 rrrrrrrrrrrrrr   295         DW      SOF _84,SEG _84
       rrrrrrrrrrrrrr       
       rrrr                 
00004C rrrrrrrrrrrrrr   296         DW      SOF _100,SEG _100
       rrrrrrrrrrrrrr       
       rrrr                 
000050 rrrrrrrrrrrrrr   297         DW      SOF _262,SEG _262
       rrrrrrrrrrrrrr       
       rrrr                 
000054 rrrrrrrrrrrrrr   298         DW      SOF _264,SEG _264
       rrrrrrrrrrrrrr       
       rrrr                 
000058 rrrrrrrrrrrrrr   299         DW      SOF _272,SEG _272
       rrrrrrrrrrrrrr       
       rrrr                 
00005C rrrrrrrrrrrrrr   300         DW      SOF _274,SEG _274
       rrrrrrrrrrrrrr       
       rrrr                 
000060 rrrrrrrrrrrrrr   301         DW      SOF _25,SEG _25
       rrrrrrrrrrrrrr       
       rrrr                 
000064 rrrrrrrrrrrrrr   302         DW      SOF _29,SEG _29
       rrrrrrrrrrrrrr       
       rrrr                 
000068 rrrrrrrrrrrrrr   303         DW      SOF _291,SEG _291
       rrrrrrrrrrrrrr       
       rrrr                 
00006C rrrrrrrrrrrrrr   304         DW      SOF _290,SEG _290
       rrrrrrrrrrrrrr       
       rrrr                 
000070 rrrrrrrrrrrrrr   305         DW      SOF _67,SEG _67
       rrrrrrrrrrrrrr       
       rrrr                 
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page   7

ADDR   CODE            LINE SOURCELINE
000074 rrrrrrrrrrrrrr   306         DW      SOF _73,SEG _73
       rrrrrrrrrrrrrr       
       rrrr                 
000078 rrrrrrrrrrrrrr   307         DW      SOF _233,SEG _233
       rrrrrrrrrrrrrr       
       rrrr                 
00007C rrrrrrrrrrrrrr   308         DW      SOF _235,SEG _235
       rrrrrrrrrrrrrr       
       rrrr                 
000080 rrrrrrrrrrrrrr   309         DW      SOF _224,SEG _224
       rrrrrrrrrrrrrr       
       rrrr                 
000084 rrrrrrrrrrrrrr   310         DW      SOF _14,SEG _14
       rrrrrrrrrrrrrr       
       rrrr                 
000088 rrrrrrrrrrrrrr   311         DW      SOF _107,SEG _107
       rrrrrrrrrrrrrr       
       rrrr                 
00008C rrrrrrrrrrrrrr   312         DW      SOF _110,SEG _110
       rrrrrrrrrrrrrr       
       rrrr                 
000090 rrrrrrrrrrrrrr   313         DW      SOF _111,SEG _111
       rrrrrrrrrrrrrr       
       rrrr                 
000094 rrrrrrrrrrrrrr   314         DW      SOF _64,SEG _64
       rrrrrrrrrrrrrr       
       rrrr                 
000098 rrrrrrrrrrrrrr   315         DW      SOF _65,SEG _65
       rrrrrrrrrrrrrr       
       rrrr                 
00009C rrrrrrrrrrrrrr   316         DW      SOF _268,SEG _268
       rrrrrrrrrrrrrr       
       rrrr                 
0000A0 rrrrrrrrrrrrrr   317         DW      SOF _270,SEG _270
       rrrrrrrrrrrrrr       
       rrrr                 
0000A4 rrrrrrrrrrrrrr   318         DW      SOF _108,SEG _108
       rrrrrrrrrrrrrr       
       rrrr                 
0000A8 rrrrrrrrrrrrrr   319         DW      SOF _5,SEG _5
       rrrrrrrrrrrrrr       
       rrrr                 
0000AC rrrrrrrrrrrrrr   320         DW      SOF _22,SEG _22
       rrrrrrrrrrrrrr       
       rrrr                 
0000B0 rrrrrrrrrrrrrr   321         DW      SOF _84,SEG _84
       rrrrrrrrrrrrrr       
       rrrr                 
0000B4 rrrrrrrrrrrrrr   322         DW      SOF _220,SEG _220
       rrrrrrrrrrrrrr       
       rrrr                 
0000B8 rrrrrrrrrrrrrr   323         DW      SOF _296,SEG _296
       rrrrrrrrrrrrrr       
       rrrr                 
00000F                  324         RSEG    RTXC_PR
                        325 ; rtxc.c    259    FRAME ks_stk *frame;
                        326 ; rtxc.c    260    TCB ks_tbl *ptcb;
                        327 ; rtxc.c    261    TASK task;
                        328 ; rtxc.c    262    CLKBLK ks_clk *pclkblk;
                        329 ; rtxc.c    263    TICKS tcnt; /* local copy of rtctick */
                        330 ; rtxc.c    264    SEMA sema;
                        331 ; rtxc.c    265    const SEMA *semalist;
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page   8

ADDR   CODE            LINE SOURCELINE
                        332 ; rtxc.c    266    SSTATE ks_tbl *sema_ptr = (SSTATE ks_tbl *)0;
00000F BC701E           333         MOV.W   [R7+30],#00H
000012 BC701C           334         MOV.W   [R7+28],#00H
                        335 ; rtxc.c    267    KSNUM ks_stk *p2a;
                        336 ; rtxc.c    268 
                        337 ; rtxc.c    269 #ifdef HAS_WAITM /* { */
                        338 ; rtxc.c    270    const SEMA *semalist2;
                        339 ; rtxc.c    271 #endif /* } HAS_WAITM */
                        340 ; rtxc.c    272 
                        341 ; rtxc.c    273 #ifdef HAS_BLOCK /* { */
                        342 ; rtxc.c    274    TASK endtask;
                        343 ; rtxc.c    275 #endif /* } HAS_BLOCK */
                        344 ; rtxc.c    276 
                        345 ; rtxc.c    277 #ifdef HAS_MAILBOXES /* { */
                        346 ; rtxc.c    278    MHEADER ks_tbl *pmh;
                        347 ; rtxc.c    279    RTXCMSG *prtxcmsg;
                        348 ; rtxc.c    280 #endif /* } HAS_MAILBOXES */
                        349 ; rtxc.c    281 
                        350 ; rtxc.c    282 #ifdef HAS_PARTITIONS /* { */
                        351 ; rtxc.c    283    PHEADER ks_tbl *pph;
                        352 ; rtxc.c    284    struct xmap *q;
                        353 ; rtxc.c    285 #endif /* } HAS_PARTITIONS */
                        354 ; rtxc.c    286 
                        355 ; rtxc.c    287 #ifdef HAS_QUEUES /* { */
                        356 ; rtxc.c    288    QHEADER ks_tbl *pqh;
                        357 ; rtxc.c    289    int qindex, depth;
                        358 ; rtxc.c    290    size_t width;
                        359 ; rtxc.c    291 #ifdef HAS_DEFQUEUE /* { */
                        360 ; rtxc.c    292    int cursz;
                        361 ; rtxc.c    293 #endif /* } HAS_DEFQUEUE */
                        362 ; rtxc.c    294 #endif /* } HAS_QUEUES */
                        363 ; rtxc.c    295 
                        364 ; rtxc.c    296 #ifdef HAS_RESOURCES /* { */
                        365 ; rtxc.c    297    RHEADER ks_tbl *prh;
                        366 ; rtxc.c    298 #endif /* } HAS_RESOURCES */
                        367 ; rtxc.c    299 
                        368 ; rtxc.c    300 #ifdef FPU /* { */
                        369 ; rtxc.c    301    FPREGS ks_tbl *fpregs;
                        370 ; rtxc.c    302 #endif /* } FPU */
                        371 ; rtxc.c    303 
                        372 ; rtxc.c    304 #if _MODEL == 'm' || _MODEL == 'l'
                        373 ; rtxc.c    305    unsigned long pc1;
                        374 ; rtxc.c    306 #endif /* } _MODEL */
                        375 ; rtxc.c    307 
                        376 ; rtxc.c    308 #ifdef INLINE_MACRO_EXPANSION /* { */
                        377 ; rtxc.c    309    SSTATE ks_tbl *psstate;
                        378 ; rtxc.c    310 #endif /* } INLINE_MACRO_EXPANSION */
                        379 ; rtxc.c    311 
                        380 ; rtxc.c    312    hipritsk->sp = (FRAME ks_stk *)p; /* always save &stk frame */
000015 8E3rrr           381         MOV.W   R3,_hipritsk+2
000018 8E2rrr           382         MOV.W   R2,_hipritsk
00001B 866C42           383         MOV.B   ES,R3L
00001E 8C0A0E           384         MOV.W   [R2+14],R0
000021 8C1A10           385         MOV.W   [R2+16],R1
                        386 ; rtxc.c    313 
                        387 ; rtxc.c    314 /* force the compiler to generate a JUMP TABLE - deterministic */
                        388 ; rtxc.c    315 #pragma optimize t
                        389 ; rtxc.c    316 
                        390 ; rtxc.c    317    switch(*p2)
000024 86AC42           391         MOV.B   ES,R5L
000027 8224             392         MOV.B   R1L,[R4]
000029 A12F             393         ADDS.B  R1L,#0FH
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page   9

ADDR   CODE            LINE SOURCELINE
00002B 91242E           394         CMP.B   R1L,#02EH
                        395         BG      _428
00002E F902            +395 ;       BL      _LG_0
000030 D517DE          +395 ;       JMP.L   _428
000030 D517DE00        +395 ;       JMP.L   _428
000034                 +395 _LG_0:
000034 7133             396         XOR.B   R1H,R1H
000036 D912             397         ASL.W   R1,#02H
000038 964843rr         398         MOV.B   CS,#SEG( __swtable433 )
00003C 9910rrrr         399         ADD.W   R1,#SOF( __swtable433 )
000040 8801             400         MOVC.W  R0,[R1+]
000042 0F01             401         PUSH.W  R0
000044 8801             402         MOVC.W  R0,[R1+]
000046 0F01             403         PUSH.W  R0
000048 D680             404         RET
000048 D680             404         RET
                        405 ; rtxc.c    318    {
                        406 ; rtxc.c    319 /************************/
                        407 ; rtxc.c    320       case RTXC_SIGNAL:
00004A                  408 _3:
                        409 ; rtxc.c    321 /************************/
                        410 ; rtxc.c    322          sema = ((struct sarg ks_stk *)p2)->sema;
00004A 8C5F1A           411         MOV.W   [R7+26],R5
00004D 8C4F18           412         MOV.W   [R7+24],R4
000050 86AC42           413         MOV.B   ES,R5L
000053 844404           414         MOV.B   R2L,[R4+4]
                        415 ; rtxc.c    323          sema_ptr = (SSTATE ks_tbl *)&semat[sema];
000056 8184             416         MOV.B   R4L,R2L
000058 B190             417         MOVS.B  R4H,#00H
00005A B950             418         MOVS.W  R5,#00H
00005C 9918rrrr         419         MOV.W   R1,#SEG( _semat )
000060 9908rrrr         420         MOV.W   R0,#SOF( _semat )
000064 0904             421         ADD.W   R0,R4
                        422 ; rtxc.c    324 
                        423 ; rtxc.c    325          if (*sema_ptr == SEMA_DONE)
000066 862C42           424         MOV.B   ES,R1L
000069 8250             425         MOV.B   R2H,[R0]
                        426         BEQ     _297
00006B F202            +426 ;       BNE     _LG_2
00006D D517B8          +426 ;       JMP.L   _297
00006D D517B8          +426 ;       JMP.L   _297
000070                 +426 _LG_2:
                        427 ; rtxc.c    326             ((struct sarg ks_stk *)p2)->ksrc = RC_MISSED_EVENT;
                        428 ; rtxc.c    327          else if (*sema_ptr == SEMA_PENDING)
000070 862C42           429         MOV.B   ES,R1L
000073 9204FF           430         CMP.B   [R0],#0FFH
000076 F204             431         BNE     _4
                        432 ; rtxc.c    328             *sema_ptr = SEMA_DONE;
000078 862C42           433         MOV.B   ES,R1L
00007B B200             434         MOV.B   [R0],#00H
                        435         BR      _428
00007D D517B7          +435         JMP.L   _428
00007D D517B7          +435         JMP.L   _428
000080                  436 _4:
                        437 ; rtxc.c    329          else
                        438 ; rtxc.c    330          {
                        439 ; rtxc.c    331             SIGNAL(sema);
000080 860401           440         MOV.B   R0L,0401H
000083 9648018D         441         MOV.B   0401H,#08DH
000087 9Er0rr0001       442         ADD.W   _semaput,#01H
00008C 8E5rrr           443         MOV.W   R5,_semaput+2
00008F 8E4rrr           444         MOV.W   R4,_semaput
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  10

ADDR   CODE            LINE SOURCELINE
000092 86AC42           445         MOV.B   ES,R5L
000095 824C             446         MOV.B   [R4],R2L
000097 8E5rrr           447         MOV.W   _semaput+2,R5
00009A 8E4rrr           448         MOV.W   _semaput,R4
00009D 860C01           449         MOV.B   0401H,R0L
                        450 ; rtxc.c    332          }
                        451 ; rtxc.c    333          break;
                        452         BR      _428
0000A0 D517A6          +452         JMP.L   _428
0000A0 D517A600        +452         JMP.L   _428
                        453 ; rtxc.c    334 
                        454 ; rtxc.c    335 #ifdef HAS_SIGNALM /* { */
                        455 ; rtxc.c    336 /************************/
                        456 ; rtxc.c    337       case RTXC_SIGNALM:
0000A4                  457 _5:
                        458 ; rtxc.c    338 /************************/
                        459 ; rtxc.c    339          for (semalist = ((struct sargm ks_stk *)p2)->list;
0000A4 8935             460         MOV.W   R3,R5
0000A6 8924             461         MOV.W   R2,R4
0000A8 866C42           462         MOV.B   ES,R3L
0000AB 8C3208           463         MOV.W   R3,[R2+8]
0000AE 8C2206           464         MOV.W   R2,[R2+6]
0000B1 8953             465         MOV.W   R5,R3
0000B3 8942             466         MOV.W   R4,R2
0000B5 866C42           467         MOV.B   ES,R3L
0000B8 8242             468         MOV.B   R2L,[R2]
                        469         BEQ     _428
0000BA F202            +469 ;       BNE     _LG_6
0000BC D51798          +469 ;       JMP.L   _428
0000BC D5179800        +469 ;       JMP.L   _428
0000C0                 +469 _LG_6:
0000C0                 +469 _LG_6:
0000C0                  470 _6:
                        471 ; rtxc.c    340             (sema = *semalist) != NULLSEMA; semalist++)
                        472 ; rtxc.c    341          {
                        473 ; rtxc.c    342             sema_ptr = (SSTATE ks_tbl *)&semat[sema];
0000C0 8104             474         MOV.B   R0L,R2L
0000C2 B110             475         MOVS.B  R0H,#00H
0000C4 B910             476         MOVS.W  R1,#00H
                        477 ; rtxc.c    343             if (*sema_ptr == SEMA_DONE)
0000C6 964842rr         478         MOV.B   ES,#SEG( _semat )
0000CA 8550rrrr         479         MOV.B   R2H,[R0+SOF( _semat )]
0000CE F318             480         BEQ     _9
                        481 ; rtxc.c    344                ;
                        482 ; rtxc.c    345             else if (*sema_ptr == SEMA_PENDING)
0000D0 9154FF           483         CMP.B   R2H,#0FFH
0000D3 F206             484         BNE     _7
                        485 ; rtxc.c    346                *sema_ptr = SEMA_DONE;
0000D5 964842rr         486         MOV.B   ES,#SEG( _semat )
0000D9 B500rrrr         487         MOV.B   [R0+SOF( _semat )],#00H
0000DD FE11             488         BR      _9
0000DD FE1100           488         BR      _9
0000E0                  489 _7:
                        490 ; rtxc.c    347             else
                        491 ; rtxc.c    348             {
                        492 ; rtxc.c    349                SIGNAL(sema);
0000E0 865401           493         MOV.B   R2H,0401H
0000E3 9648018D         494         MOV.B   0401H,#08DH
0000E7 9Er0rr0001       495         ADD.W   _semaput,#01H
0000EC 8E1rrr           496         MOV.W   R1,_semaput+2
0000EF 8E0rrr           497         MOV.W   R0,_semaput
0000F2 862C42           498         MOV.B   ES,R1L
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  11

ADDR   CODE            LINE SOURCELINE
0000F5 8248             499         MOV.B   [R0],R2L
0000F7 8E1rrr           500         MOV.W   _semaput+2,R1
0000FA 8E0rrr           501         MOV.W   _semaput,R0
0000FD 865C01           502         MOV.B   0401H,R2H
0000FD 865C01           502         MOV.B   0401H,R2H
                        503 ; rtxc.c    350             }
000100                  504 _9:
000100 99400001         505         ADD.W   R4,#01H
000104 86AC42           506         MOV.B   ES,R5L
000107 8244             507         MOV.B   R2L,[R4]
000109 F2DB             508         BNE     _6
                        509 ; rtxc.c    351          }
                        510 ; rtxc.c    352          break;
                        511         BR      _428
00010B D51770          +511         JMP.L   _428
00010B D51770          +511         JMP.L   _428
                        512 ; rtxc.c    353 #endif /* } HAS_SIGNALM */
                        513 ; rtxc.c    354 
                        514 ; rtxc.c    355 /************************/
                        515 ; rtxc.c    356       case RTXC_WAIT:
00010E                  516 _10:
                        517 ; rtxc.c    357 /************************/
                        518 ; rtxc.c    358          sema = ((struct sarg ks_stk *)p2)->sema;
00010E 8C5F16           519         MOV.W   [R7+22],R5
000111 8C4F14           520         MOV.W   [R7+20],R4
000114 86AC42           521         MOV.B   ES,R5L
000117 846404           522         MOV.B   R3L,[R4+4]
                        523 ; rtxc.c    359          sema_ptr = (SSTATE ks_tbl *)&semat[sema];
00011A 8186             524         MOV.B   R4L,R3L
00011C B190             525         MOVS.B  R4H,#00H
00011E B950             526         MOVS.W  R5,#00H
000120 9918rrrr         527         MOV.W   R1,#SEG( _semat )
000124 9908rrrr         528         MOV.W   R0,#SOF( _semat )
000128 0904             529         ADD.W   R0,R4
00012A 8C1F12           530         MOV.W   [R7+18],R1
00012D 8C0F10           531         MOV.W   [R7+16],R0
                        532 ; rtxc.c    360 
                        533 ; rtxc.c    361          if (*sema_ptr == SEMA_PENDING)
000130 964842rr         534         MOV.B   ES,#SEG( _semat )
000134 8504rrrr         535         MOV.B   R0L,[R4+SOF( _semat )]
000138 9104FF           536         CMP.B   R0L,#0FFH
00013B F250             537         BNE     _12
                        538 ; rtxc.c    362          {
                        539 ; rtxc.c    363             ptcb = hipritsk; /* save for later */
00013D 8E5rrr           540         MOV.W   R5,_hipritsk+2
000140 8E4rrr           541         MOV.W   R4,_hipritsk
                        542 ; rtxc.c    364 
                        543 ; rtxc.c    365 #ifdef SEMAPHORE_TIMEOUTS /* { */
                        544 ; rtxc.c    366             if ( ((struct sarg ks_stk *)p2)->ticks) /* if timeout active */
000143 8C1716           545         MOV.W   R1,[R7+22]
000146 8C0714           546         MOV.W   R0,[R7+20]
000149 862C42           547         MOV.B   ES,R1L
00014C 8C2006           548         MOV.W   R2,[R0+6]
00014F F326             549         BEQ     _11
                        550 ; rtxc.c    367             {
                        551 ; rtxc.c    368                pclkblk = ptcb->pclkblk = ((struct sarg ks_stk *)p2)->pclkblk;
000151 8C1716           552         MOV.W   R1,[R7+22]
000154 8C0714           553         MOV.W   R0,[R7+20]
000157 862C42           554         MOV.B   ES,R1L
00015A 8C100A           555         MOV.W   R1,[R0+10]
00015D 8C0008           556         MOV.W   R0,[R0+8]
000160 86AC42           557         MOV.B   ES,R5L
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  12

ADDR   CODE            LINE SOURCELINE
000163 8C0C08           558         MOV.W   [R4+8],R0
000166 8C1C0A           559         MOV.W   [R4+10],R1
                        560 ; rtxc.c    369                pclkblk->remain = ((struct sarg ks_stk *)p2)->ticks;
000169 862C42           561         MOV.B   ES,R1L
00016C 8C2808           562         MOV.W   [R0+8],R2
                        563 ; rtxc.c    370                pclkblk->recycle = (TICKS)0; /* non-cyclic */
00016F 862C42           564         MOV.B   ES,R1L
000172 BC000A           565         MOV.W   [R0+10],#00H
                        566 ; rtxc.c    371 
                        567 ; rtxc.c    372                /* mark object type */
                        568 ; rtxc.c    373                pclkblk->objtype = SEMAPHORE_OBJ;
000175 862C42           569         MOV.B   ES,R1L
000178 BC010E           570         MOV.W   [R0+14],#01H
                        571 ; rtxc.c    374                pclkblk->objid = sema;
00017B 862C42           572         MOV.B   ES,R1L
00017E 846810           573         MOV.B   [R0+16],R3L
                        574 ; rtxc.c    375                pclkblk->task = ptcb->task;
000181 86AC42           575         MOV.B   ES,R5L
000184 84440C           576         MOV.B   R2L,[R4+12]
000187 862C42           577         MOV.B   ES,R1L
00018A 84480C           578         MOV.B   [R0+12],R2L
                        579 ; rtxc.c    376 
                        580 ; rtxc.c    377                /* insert timer */
                        581 ; rtxc.c    378                insert_timer(pclkblk);
00018D C51F8D           582         CALL    _insert_timer
                        583 ; rtxc.c    379                ((struct sarg ks_stk *)p2)->ksrc = RC_TIMEOUT;
000190 8C1716           584         MOV.W   R1,[R7+22]
000193 8C0714           585         MOV.W   R0,[R7+20]
000196 862C42           586         MOV.B   ES,R1L
000199 BC0502           587         MOV.W   [R0+2],#05H
000199 BC0502           587         MOV.W   [R0+2],#05H
                        588 ; rtxc.c    380             }
00019C                  589 _11:
                        590 ; rtxc.c    381 #endif /* } SEMAPHORE_TIMEOUTS */
                        591 ; rtxc.c    382 
                        592 ; rtxc.c    383             /* put sema into wait state */
                        593 ; rtxc.c    384             *sema_ptr = (SSTATE)ptcb->task;
00019C 86AC42           594         MOV.B   ES,R5L
00019F 84040C           595         MOV.B   R0L,[R4+12]
0001A2 8C3712           596         MOV.W   R3,[R7+18]
0001A5 8C2710           597         MOV.W   R2,[R7+16]
0001A8 866C42           598         MOV.B   ES,R3L
0001AB 820A             599         MOV.B   [R2],R0L
                        600 ; rtxc.c    385 
                        601 ; rtxc.c    386             ptcb->status = SEMAPHORE_WAIT;
0001AD 86AC42           602         MOV.B   ES,R5L
0001B0 9C48120040       603         MOV.W   [R4+18],#040H
                        604 ; rtxc.c    387 
                        605 ; rtxc.c    388             UNLINK_HIPRITSK(); /* unlink first tcb */
0001B5 8E1rrr           606         MOV.W   R1,_hipritsk+2
0001B8 8E0rrr           607         MOV.W   R0,_hipritsk
0001BB 862C42           608         MOV.B   ES,R1L
0001BE 8C1002           609         MOV.W   R1,[R0+2]
0001C1 8A00             610         MOV.W   R0,[R0]
0001C3 8E1rrr           611         MOV.W   _hipritsk+2,R1
0001C6 8E0rrr           612         MOV.W   _hipritsk,R0
0001C9 9928rrrr         613         MOV.W   R2,#SOF( _hipritsk )
0001CD B930             614         MOVS.W  R3,#00H
0001CF 862C42           615         MOV.B   ES,R1L
0001D2 8C2804           616         MOV.W   [R0+4],R2
0001D5 8C3806           617         MOV.W   [R0+6],R3
                        618 ; rtxc.c    389             break;
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  13

ADDR   CODE            LINE SOURCELINE
                        619         BR      _428
0001D8 D5170A          +619         JMP.L   _428
0001D8 D5170A00        +619         JMP.L   _428
                        620 ; rtxc.c    390          }
0001DC                  621 _12:
                        622 ; rtxc.c    391 
                        623 ; rtxc.c    392          if (*sema_ptr == SEMA_DONE) /* if sema already done */
0001DC 8C1712           624         MOV.W   R1,[R7+18]
0001DF 8C0710           625         MOV.W   R0,[R7+16]
0001E2 862C42           626         MOV.B   ES,R1L
0001E5 8200             627         MOV.B   R0L,[R0]
0001E7 F208             628         BNE     _13
                        629 ; rtxc.c    393          {
                        630 ; rtxc.c    394             *sema_ptr = SEMA_PENDING;  /* set sema pending */
0001E9 8C1712           631         MOV.W   R1,[R7+18]
0001EC 8C0710           632         MOV.W   R0,[R7+16]
0001EF 862C42           633         MOV.B   ES,R1L
0001F2 9208FF           634         MOV.B   [R0],#0FFH
                        635 ; rtxc.c    395          }
                        636         BR      _428
0001F5 D516FB          +636         JMP.L   _428
0001F5 D516FB          +636         JMP.L   _428
0001F8                  637 _13:
                        638 ; rtxc.c    396          else     /* else sema was already in a wait state */
                        639 ; rtxc.c    397          {
                        640 ; rtxc.c    398             /* if here, application task design flaw */
                        641 ; rtxc.c    399                /* since no corresponding semaphore */
                        642 ; rtxc.c    400             ((struct sarg ks_stk *)p2)->ksrc = RC_WAIT_CONFLICT;
0001F8 8C1716           643         MOV.W   R1,[R7+22]
0001FB 8C0714           644         MOV.W   R0,[R7+20]
0001FE 862C42           645         MOV.B   ES,R1L
000201 BC0102           646         MOV.W   [R0+2],#01H
                        647 ; rtxc.c    401          }
                        648 ; rtxc.c    402          break;
                        649         BR      _428
000204 D516F4          +649         JMP.L   _428
000204 D516F400        +649         JMP.L   _428
                        650 ; rtxc.c    403 
                        651 ; rtxc.c    404 #ifdef HAS_WAITM /* { */
                        652 ; rtxc.c    405 /************************/
                        653 ; rtxc.c    406       case RTXC_WAITM:
000208                  654 _14:
                        655 ; rtxc.c    407 /************************/
                        656 ; rtxc.c    408          semalist = ((struct sargm ks_stk *)p2)->list;
000208 8915             657         MOV.W   R1,R5
00020A 8904             658         MOV.W   R0,R4
00020C 8C1F16           659         MOV.W   [R7+22],R1
00020F 8C0F14           660         MOV.W   [R7+20],R0
000212 862C42           661         MOV.B   ES,R1L
000215 8C1008           662         MOV.W   R1,[R0+8]
000218 8C0006           663         MOV.W   R0,[R0+6]
00021B 8931             664         MOV.W   R3,R1
00021D 8920             665         MOV.W   R2,R0
00021F 8C1F0E           666         MOV.W   [R7+14],R1
000222 8C0F0C           667         MOV.W   [R7+12],R0
                        668 ; rtxc.c    409          while (*semalist != NULLSEMA) /* while not at end of waitm list */
000225 8C3F12           669         MOV.W   [R7+18],R3
000228 8C2F10           670         MOV.W   [R7+16],R2
00022B 866C42           671         MOV.B   ES,R3L
00022E 8202             672         MOV.B   R0L,[R2]
000230 F32D             673         BEQ     _17
000232 8E5rrr           674         MOV.W   R5,_hipritsk+2
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  14

ADDR   CODE            LINE SOURCELINE
000235 8E4rrr           675         MOV.W   R4,_hipritsk
000238 9940000C         676         ADD.W   R4,#0CH
000238 9940000C         676         ADD.W   R4,#0CH
00023C                  677 _15:
                        678 ; rtxc.c    410          {
                        679 ; rtxc.c    411             sema_ptr = (SSTATE ks_tbl *)&semat[*semalist]; /* get ptr to sema */
00023C 8C170E           680         MOV.W   R1,[R7+14]
00023F 8C070C           681         MOV.W   R0,[R7+12]
000242 862C42           682         MOV.B   ES,R1L
000245 8200             683         MOV.B   R0L,[R0]
000247 B110             684         MOVS.B  R0H,#00H
000249 B910             685         MOVS.W  R1,#00H
00024B 9938rrrr         686         MOV.W   R3,#SEG( _semat )
00024F 9928rrrr         687         MOV.W   R2,#SOF( _semat )
000253 0920             688         ADD.W   R2,R0
000255 8C3F1E           689         MOV.W   [R7+30],R3
000258 8C2F1C           690         MOV.W   [R7+28],R2
                        691 ; rtxc.c    412 
                        692 ; rtxc.c    413             if (*sema_ptr == SEMA_PENDING)
00025B 964842rr         693         MOV.B   ES,#SEG( _semat )
00025F 8540rrrr         694         MOV.B   R2L,[R0+SOF( _semat )]
000263 9144FF           695         CMP.B   R2L,#0FFH
000266 F212             696         BNE     _17
                        697 ; rtxc.c    414             {
                        698 ; rtxc.c    415                *sema_ptr = (SSTATE)hipritsk->task; /* set sema waiting */
000268 86AC42           699         MOV.B   ES,R5L
00026B 8244             700         MOV.B   R2L,[R4]
00026D 964842rr         701         MOV.B   ES,#SEG( _semat )
000271 8548rrrr         702         MOV.B   [R0+SOF( _semat )],R2L
                        703 ; rtxc.c    416                semalist++;                          /* bump list ptr */
000275 8C170E           704         MOV.W   R1,[R7+14]
000278 8C070C           705         MOV.W   R0,[R7+12]
00027B 99000001         706         ADD.W   R0,#01H
00027F 8C1F0E           707         MOV.W   [R7+14],R1
000282 8C0F0C           708         MOV.W   [R7+12],R0
000285 862C42           709         MOV.B   ES,R1L
000288 8200             710         MOV.B   R0L,[R0]
00028A F2D8             711         BNE     _15
00028A F2D8             711         BNE     _15
                        712 ; rtxc.c    417             }
                        713 ; rtxc.c    418             else /* found sema in WAIT or DONE state */
                        714 ; rtxc.c    419                break;
                        715 ; rtxc.c    420          }
00028C                  716 _17:
                        717 ; rtxc.c    421 
                        718 ; rtxc.c    422          if (*semalist == NULLSEMA) /* all semas now in WAIT state */
00028C 8C170E           719         MOV.W   R1,[R7+14]
00028F 8C070C           720         MOV.W   R0,[R7+12]
000292 862C42           721         MOV.B   ES,R1L
000295 8200             722         MOV.B   R0L,[R0]
000297 F218             723         BNE     _18
                        724 ; rtxc.c    423          {
                        725 ; rtxc.c    424             hipritsk->status = SEMAPHORE_WAIT; /* mark status SEMAPHORE_WAIT */
000299 8E1rrr           726         MOV.W   R1,_hipritsk+2
00029C 8E0rrr           727         MOV.W   R0,_hipritsk
00029F 862C42           728         MOV.B   ES,R1L
0002A2 9C08120040       729         MOV.W   [R0+18],#040H
                        730 ; rtxc.c    425 
                        731 ; rtxc.c    426             UNLINK_HIPRITSK(); /* unlink first tcb */
0002A7 862C42           732         MOV.B   ES,R1L
0002AA 8C1002           733         MOV.W   R1,[R0+2]
0002AD 8A00             734         MOV.W   R0,[R0]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  15

ADDR   CODE            LINE SOURCELINE
0002AF 8E1rrr           735         MOV.W   _hipritsk+2,R1
0002B2 8E0rrr           736         MOV.W   _hipritsk,R0
0002B5 9928rrrr         737         MOV.W   R2,#SOF( _hipritsk )
0002B9 B930             738         MOVS.W  R3,#00H
0002BB 862C42           739         MOV.B   ES,R1L
0002BE 8C2804           740         MOV.W   [R0+4],R2
0002C1 8C3806           741         MOV.W   [R0+6],R3
                        742 ; rtxc.c    427             break;            /* force task switch */
                        743         BR      _428
0002C4 D51694          +743         JMP.L   _428
0002C4 D5169400        +743         JMP.L   _428
                        744 ; rtxc.c    428          }
0002C8                  745 _18:
                        746 ; rtxc.c    429 
                        747 ; rtxc.c    430          if (*sema_ptr == SEMA_DONE) /* found a sema in list in DONE state */
0002C8 8C371E           748         MOV.W   R3,[R7+30]
0002CB 8C271C           749         MOV.W   R2,[R7+28]
0002CE 866C42           750         MOV.B   ES,R3L
0002D1 8212             751         MOV.B   R0H,[R2]
0002D3 F226             752         BNE     _20
                        753 ; rtxc.c    431          {
                        754 ; rtxc.c    432             /* return sema to user */
                        755 ; rtxc.c    433             ((struct sargm ks_stk *)p2)->sema = *semalist;
0002D5 8C3716           756         MOV.W   R3,[R7+22]
0002D8 8C2714           757         MOV.W   R2,[R7+20]
0002DB 866C42           758         MOV.B   ES,R3L
0002DE 840A04           759         MOV.B   [R2+4],R0L
                        760 ; rtxc.c    434 
                        761 ; rtxc.c    435                /* set all semas in list to PEND state */
                        762 ; rtxc.c    436             for ( semalist2 = ((struct sargm ks_stk *)p2)->list;
0002E1 8C1712           763         MOV.W   R1,[R7+18]
0002E4 8C0710           764         MOV.W   R0,[R7+16]
0002E7 8C3712           765         MOV.W   R3,[R7+18]
0002EA 8C2710           766         MOV.W   R2,[R7+16]
0002ED 4C370E           767         CMP.W   R3,[R7+14]
0002F0 F202             768         BNE     _438
0002F2 4C270C           769         CMP.W   R2,[R7+12]
0002F2 4C270C00         769         CMP.W   R2,[R7+12]
0002F6                  770 _438:
                        771         BG      _428
0002F6 F902            +771 ;       BL      _LG_32
0002F8 D5167A          +771 ;       JMP.L   _428
0002F8 D5167A00        +771 ;       JMP.L   _428
0002FC                 +771 _LG_32:
0002FC                 +771 _LG_32:
0002FC                  772 _19:
                        773 ; rtxc.c    437                   semalist2 <= semalist;
                        774 ; rtxc.c    438                   semalist2++)
                        775 ; rtxc.c    439                semat[*semalist2] = SEMA_PENDING;
0002FC 862C42           776         MOV.B   ES,R1L
0002FF 8240             777         MOV.B   R2L,[R0]
000301 B150             778         MOVS.B  R2H,#00H
000303 B930             779         MOVS.W  R3,#00H
000305 964842rr         780         MOV.B   ES,#SEG( _semat )
000309 9528rrrrFF       781         MOV.B   [R2+SOF( _semat )],#0FFH
00030E 99000001         782         ADD.W   R0,#01H
000312 4C170E           783         CMP.W   R1,[R7+14]
000315 F202             784         BNE     _439
000317 4C070C           785         CMP.W   R0,[R7+12]
000317 4C070C           785         CMP.W   R0,[R7+12]
00031A                  786 _439:
00031A F9F0             787         BL      _19
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  16

ADDR   CODE            LINE SOURCELINE
                        788 ; rtxc.c    440          }
                        789         BR      _428
00031C D51668          +789         JMP.L   _428
00031C D5166800        +789         JMP.L   _428
000320                  790 _20:
                        791 ; rtxc.c    441          else /* semaphore was found already in a WAIT state */
                        792 ; rtxc.c    442          {
                        793 ; rtxc.c    443                /* if arrive here, application task design flaw */
                        794 ; rtxc.c    444                  /* since no corresponding semaphore waiting */
                        795 ; rtxc.c    445             hipritsk->status = SEMAPHORE_WAIT;
000320 8E1rrr           796         MOV.W   R1,_hipritsk+2
000323 8E0rrr           797         MOV.W   R0,_hipritsk
000326 862C42           798         MOV.B   ES,R1L
000329 9C08120040       799         MOV.W   [R0+18],#040H
                        800 ; rtxc.c    446 
                        801 ; rtxc.c    447             UNLINK_HIPRITSK(); /* unlink first tcb */
00032E 862C42           802         MOV.B   ES,R1L
000331 8C1002           803         MOV.W   R1,[R0+2]
000334 8A00             804         MOV.W   R0,[R0]
000336 8E1rrr           805         MOV.W   _hipritsk+2,R1
000339 8E0rrr           806         MOV.W   _hipritsk,R0
00033C 9928rrrr         807         MOV.W   R2,#SOF( _hipritsk )
000340 B930             808         MOVS.W  R3,#00H
000342 862C42           809         MOV.B   ES,R1L
000345 8C2804           810         MOV.W   [R0+4],R2
000348 8C3806           811         MOV.W   [R0+6],R3
                        812 ; rtxc.c    448          }
                        813 ; rtxc.c    449          break;
                        814         BR      _428
00034B D51650          +814         JMP.L   _428
00034B D51650          +814         JMP.L   _428
                        815 ; rtxc.c    450 #endif /* } HAS_WAITM */
                        816 ; rtxc.c    451 
                        817 ; rtxc.c    452 #ifdef HAS_PEND /* { */
                        818 ; rtxc.c    453 /************************/
                        819 ; rtxc.c    454       case RTXC_PEND:
00034E                  820 _21:
                        821 ; rtxc.c    455 /************************/
                        822 ; rtxc.c    456          sema = ((struct sarg ks_stk *)p2)->sema;
00034E 86AC42           823         MOV.B   ES,R5L
000351 840404           824         MOV.B   R0L,[R4+4]
                        825 ; rtxc.c    457          sema_ptr = (SSTATE ks_tbl *)&semat[sema];
000354 B110             826         MOVS.B  R0H,#00H
000356 B910             827         MOVS.W  R1,#00H
                        828 ; rtxc.c    458 
                        829 ; rtxc.c    459          if (*sema_ptr == SEMA_DONE)
000358 964842rr         830         MOV.B   ES,#SEG( _semat )
00035C 8540rrrr         831         MOV.B   R2L,[R0+SOF( _semat )]
                        832         BNE     _428
000360 F302            +832 ;       BEQ     _LG_38
000362 D51645          +832 ;       JMP.L   _428
000362 D5164500        +832 ;       JMP.L   _428
000366                 +832 _LG_38:
                        833 ; rtxc.c    460             *sema_ptr = SEMA_PENDING;
000366 964842rr         834         MOV.B   ES,#SEG( _semat )
00036A 9508rrrrFF       835         MOV.B   [R0+SOF( _semat )],#0FFH
                        836 ; rtxc.c    461          break;
                        837         BR      _428
00036F D5163E          +837         JMP.L   _428
00036F D5163E          +837         JMP.L   _428
                        838 ; rtxc.c    462 #endif /* } HAS_PEND */
                        839 ; rtxc.c    463 
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  17

ADDR   CODE            LINE SOURCELINE
                        840 ; rtxc.c    464 #ifdef HAS_PENDM /* { */
                        841 ; rtxc.c    465 /************************/
                        842 ; rtxc.c    466       case RTXC_PENDM:
000372                  843 _22:
                        844 ; rtxc.c    467 /************************/
                        845 ; rtxc.c    468          for (semalist = ((struct sargm ks_stk *)p2)->list;
000372 8915             846         MOV.W   R1,R5
000374 8904             847         MOV.W   R0,R4
000376 862C42           848         MOV.B   ES,R1L
000379 8C1008           849         MOV.W   R1,[R0+8]
00037C 8C0006           850         MOV.W   R0,[R0+6]
00037F 8931             851         MOV.W   R3,R1
000381 8920             852         MOV.W   R2,R0
000383 862C42           853         MOV.B   ES,R1L
000386 8200             854         MOV.B   R0L,[R0]
                        855         BEQ     _428
000388 F202            +855 ;       BNE     _LG_40
00038A D51631          +855 ;       JMP.L   _428
00038A D5163100        +855 ;       JMP.L   _428
00038E                 +855 _LG_40:
00038E                 +855 _LG_40:
00038E                  856 _23:
                        857 ; rtxc.c    469               (sema = *semalist) != NULLSEMA; semalist++)
                        858 ; rtxc.c    470          {
                        859 ; rtxc.c    471             sema_ptr = (SSTATE ks_tbl *)&semat[sema];
00038E B110             860         MOVS.B  R0H,#00H
000390 B910             861         MOVS.W  R1,#00H
                        862 ; rtxc.c    472             if (*sema_ptr == SEMA_DONE)
000392 964842rr         863         MOV.B   ES,#SEG( _semat )
000396 8580rrrr         864         MOV.B   R4L,[R0+SOF( _semat )]
00039A F205             865         BNE     _24
                        866 ; rtxc.c    473                *sema_ptr = SEMA_PENDING;
00039C 964842rr         867         MOV.B   ES,#SEG( _semat )
0003A0 9508rrrrFF       868         MOV.B   [R0+SOF( _semat )],#0FFH
0003A0 9508rrrrFF00     868         MOV.B   [R0+SOF( _semat )],#0FFH
0003A6                  869 _24:
0003A6 99200001         870         ADD.W   R2,#01H
0003AA 866C42           871         MOV.B   ES,R3L
0003AD 8202             872         MOV.B   R0L,[R2]
0003AF F2EF             873         BNE     _23
                        874 ; rtxc.c    474          }
                        875 ; rtxc.c    475          break;
                        876         BR      _428
0003B1 D5161D          +876         JMP.L   _428
0003B1 D5161D          +876         JMP.L   _428
                        877 ; rtxc.c    476 #endif /* } HAS_PENDM */
                        878 ; rtxc.c    477 
                        879 ; rtxc.c    478 #ifdef HAS_SUSPEND /* { */
                        880 ; rtxc.c    479 /************************/
                        881 ; rtxc.c    480       case RTXC_SUSPEND:
0003B4                  882 _25:
                        883 ; rtxc.c    481 /************************/
                        884 ; rtxc.c    482          if ( (task = ((struct targ ks_stk *)p2)->task) == SELFTASK)
0003B4 86AC42           885         MOV.B   ES,R5L
0003B7 840404           886         MOV.B   R0L,[R4+4]
0003BA 8110             887         MOV.B   R0H,R0L
0003BC F204             888         BNE     _26
                        889 ; rtxc.c    483             ptcb = hipritsk;
0003BE 8E3rrr           890         MOV.W   R3,_hipritsk+2
0003C1 8E2rrr           891         MOV.W   R2,_hipritsk
0003C4 FE17             892         BR      _28
0003C4 FE17             892         BR      _28
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  18

ADDR   CODE            LINE SOURCELINE
0003C6                  893 _26:
                        894 ; rtxc.c    484          else
                        895 ; rtxc.c    485          {
                        896 ; rtxc.c    486             ptcb = (TCB ks_tbl *)&rtxtcb[task];
0003C6 8100             897         MOV.B   R0L,R0L
0003C8 9019             898         SEXT.B  R0H
0003CA E9000024         899         MULU.W  R0,#024H
0003CE B910             900         MOVS.W  R1,#00H
0003D0 9958rrrr         901         MOV.W   R5,#SEG( _rtxtcb )
0003D4 9948rrrr         902         MOV.W   R4,#SOF( _rtxtcb )
0003D8 0940             903         ADD.W   R4,R0
0003DA 8935             904         MOV.W   R3,R5
0003DC 8924             905         MOV.W   R2,R4
                        906 ; rtxc.c    487             if (ptcb->status != READY)
0003DE 86AC42           907         MOV.B   ES,R5L
0003E1 8C0412           908         MOV.W   R0,[R4+18]
0003E4 F307             909         BEQ     _28
                        910 ; rtxc.c    488             {
                        911 ; rtxc.c    489                ptcb->status |= SUSPFLG; /* mark suspended */
0003E6 99060001         912         OR.W    R0,#01H
0003EA 86AC42           913         MOV.B   ES,R5L
0003ED 8C0C12           914         MOV.W   [R4+18],R0
                        915 ; rtxc.c    490                break;
                        916         BR      _428
0003F0 D515FE          +916         JMP.L   _428
0003F0 D515FE00        +916         JMP.L   _428
                        917 ; rtxc.c    491             }
                        918 ; rtxc.c    492          }
0003F4                  919 _28:
                        920 ; rtxc.c    493          ptcb->status |= SUSPFLG; /* mark suspended */
0003F4 866C42           921         MOV.B   ES,R3L
0003F7 9C26120001       922         OR.W    [R2+18],#01H
                        923 ; rtxc.c    494 
                        924 ; rtxc.c    495          ptcb->flink->blink = ptcb->blink; /* general task unlink */
0003FC 866C42           925         MOV.B   ES,R3L
0003FF 8C0204           926         MOV.W   R0,[R2+4]
000402 8C1206           927         MOV.W   R1,[R2+6]
000405 866C42           928         MOV.B   ES,R3L
000408 8A42             929         MOV.W   R4,[R2]
00040A 8C5202           930         MOV.W   R5,[R2+2]
00040D 86AC42           931         MOV.B   ES,R5L
000410 8C0C04           932         MOV.W   [R4+4],R0
000413 8C1C06           933         MOV.W   [R4+6],R1
                        934 ; rtxc.c    496          ptcb->blink->flink = ptcb->flink;
000416 866C42           935         MOV.B   ES,R3L
000419 8A02             936         MOV.W   R0,[R2]
00041B 8C1202           937         MOV.W   R1,[R2+2]
00041E 866C42           938         MOV.B   ES,R3L
000421 8C3206           939         MOV.W   R3,[R2+6]
000424 8C2204           940         MOV.W   R2,[R2+4]
000427 866C42           941         MOV.B   ES,R3L
00042A 8A0A             942         MOV.W   [R2],R0
00042C 8C1A02           943         MOV.W   [R2+2],R1
                        944 ; rtxc.c    497 
                        945 ; rtxc.c    498          break;
                        946         BR      _428
00042F D515DE          +946         JMP.L   _428
00042F D515DE          +946         JMP.L   _428
                        947 ; rtxc.c    499 #endif /* } HAS_SUSPEND */
                        948 ; rtxc.c    500 
                        949 ; rtxc.c    501 #ifdef HAS_RESUME /* { */
                        950 ; rtxc.c    502 /************************/
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  19

ADDR   CODE            LINE SOURCELINE
                        951 ; rtxc.c    503       case RTXC_RESUME:
000432                  952 _29:
                        953 ; rtxc.c    504 /************************/
                        954 ; rtxc.c    505          ptcb = (TCB ks_tbl *)&rtxtcb[((struct targ ks_stk *)p2)->task];
000432 86AC42           955         MOV.B   ES,R5L
000435 840404           956         MOV.B   R0L,[R4+4]
000438 9019             957         SEXT.B  R0H
00043A E9000024         958         MULU.W  R0,#024H
00043E B910             959         MOVS.W  R1,#00H
000440 9938rrrr         960         MOV.W   R3,#SEG( _rtxtcb )
000444 9928rrrr         961         MOV.W   R2,#SOF( _rtxtcb )
000448 0920             962         ADD.W   R2,R0
                        963 ; rtxc.c    506 
                        964 ; rtxc.c    507          if (ptcb->status != READY)
00044A 866C42           965         MOV.B   ES,R3L
00044D 8C0212           966         MOV.W   R0,[R2+18]
                        967         BEQ     _428
000450 F202            +967 ;       BNE     _LG_50
000452 D515CD          +967 ;       JMP.L   _428
000452 D515CD00        +967 ;       JMP.L   _428
000456                 +967 _LG_50:
                        968 ; rtxc.c    508          {
                        969 ; rtxc.c    509                /* clear suspended and test for ready now */
                        970 ; rtxc.c    510              if ( (ptcb->status &= ~SUSPFLG) == READY)
000456 9905FFFE         971         AND.W   R0,#0FFFEH
00045A 866C42           972         MOV.B   ES,R3L
00045D 8C0A12           973         MOV.W   [R2+18],R0
000460 6900             974         OR.W    R0,R0
                        975         BNE     _428
000462 F302            +975 ;       BEQ     _LG_52
000464 D515C4          +975 ;       JMP.L   _428
000464 D515C400        +975 ;       JMP.L   _428
000468                 +975 _LG_52:
                        976 ; rtxc.c    511              {
                        977 ; rtxc.c    512                  ptcb->flink = nsrttcb;
000468 8E1rrr           978         MOV.W   R1,_nsrttcb+2
00046B 8E0rrr           979         MOV.W   R0,_nsrttcb
00046E 866C42           980         MOV.B   ES,R3L
000471 8A0A             981         MOV.W   [R2],R0
000473 8C1A02           982         MOV.W   [R2+2],R1
                        983 ; rtxc.c    513                  nsrttcb = ptcb;
000476 8E3rrr           984         MOV.W   _nsrttcb+2,R3
000479 8E2rrr           985         MOV.W   _nsrttcb,R2
                        986 ; rtxc.c    514              }
                        987 ; rtxc.c    515          }
                        988 ; rtxc.c    516          break;
                        989         BR      _428
00047C D515B8          +989         JMP.L   _428
00047C D515B800        +989         JMP.L   _428
                        990 ; rtxc.c    517 #endif /* } HAS_RESUME */
                        991 ; rtxc.c    518 
                        992 ; rtxc.c    519 #ifdef HAS_PARTITIONS /* { */
                        993 ; rtxc.c    520 #ifdef HAS_ALLOC /* { */
                        994 ; rtxc.c    521 /************************/
                        995 ; rtxc.c    522       case RTXC_ALLOC:
000480                  996 _30:
                        997 ; rtxc.c    523 /************************/
                        998 ; rtxc.c    524          pph = (PHEADER ks_tbl *)&pheader[((struct parg ks_stk *)p2)->map];
000480 8915             999         MOV.W   R1,R5
000482 8904            1000         MOV.W   R0,R4
000484 8C1F16          1001         MOV.W   [R7+22],R1
000487 8C0F14          1002         MOV.W   [R7+20],R0
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  20

ADDR   CODE            LINE SOURCELINE
00048A 862C42          1003         MOV.B   ES,R1L
00048D 840004          1004         MOV.B   R0L,[R0+4]
000490 8120            1005         MOV.B   R1L,R0L
000492 E82016          1006         MULU.B  R1L,#016H
000495 8921            1007         MOV.W   R2,R1
000497 B930            1008         MOVS.W  R3,#00H
000499 9958rrrr        1009         MOV.W   R5,#SEG( _pheader )
00049D 9948rrrr        1010         MOV.W   R4,#SOF( _pheader )
0004A1 0942            1011         ADD.W   R4,R2
0004A3 8C5F12          1012         MOV.W   [R7+18],R5
0004A6 8C4F10          1013         MOV.W   [R7+16],R4
                       1014 ; rtxc.c    525 
                       1015 ; rtxc.c    526          /* Get 1st free block. If none available, thread waiter */
                       1016 ; rtxc.c    527          if ( (q = (struct xmap *)KS_ISRalloc(((struct parg ks_stk *)p2)->map))
                       1017 ; rtxc.c    528                                        == NULL)
0004A9 C519D4          1018         CALL    _KS_ISRalloc
0004AC 8C1F0E          1019         MOV.W   [R7+14],R1
0004AF 8C0F0C          1020         MOV.W   [R7+12],R0
0004B2 6910            1021         OR.W    R1,R0
0004B4 F24B            1022         BNE     _33
                       1023 ; rtxc.c    529          {
                       1024 ; rtxc.c    530 #ifdef PARTITION_WAITERS /* { */
                       1025 ; rtxc.c    531             if ( ((struct parg ks_stk *)p2)->wait)
0004B6 8C1716          1026         MOV.W   R1,[R7+22]
0004B9 8C0714          1027         MOV.W   R0,[R7+20]
0004BC 862C42          1028         MOV.B   ES,R1L
0004BF 84000C          1029         MOV.B   R0L,[R0+12]
0004C2 F344            1030         BEQ     _33
                       1031 ; rtxc.c    532             {
                       1032 ; rtxc.c    533                ptcb = hipritsk; /* save hipritsk for later use */
0004C4 8E5rrr          1033         MOV.W   R5,_hipritsk+2
0004C7 8E4rrr          1034         MOV.W   R4,_hipritsk
                       1035 ; rtxc.c    534 
                       1036 ; rtxc.c    535                ptcb->status = PARTITION_WAIT;
0004CA 86AC42          1037         MOV.B   ES,R5L
0004CD BC4212          1038         MOV.W   [R4+18],#02H
                       1039 ; rtxc.c    536 
                       1040 ; rtxc.c    537                porder((TCB ks_tbl *)&pph->waiters);
0004D0 8C1712          1041         MOV.W   R1,[R7+18]
0004D3 8C0710          1042         MOV.W   R0,[R7+16]
0004D6 99000008        1043         ADD.W   R0,#08H
0004DA C51E9F          1044         CALL    _porder
                       1045 ; rtxc.c    538 
                       1046 ; rtxc.c    539 #ifdef PARTITION_TIMEOUTS /* { */
                       1047 ; rtxc.c    540                if ( ((struct parg ks_stk *)p2)->ticks)
0004DD 8C1716          1048         MOV.W   R1,[R7+22]
0004E0 8C0714          1049         MOV.W   R0,[R7+20]
0004E3 862C42          1050         MOV.B   ES,R1L
0004E6 8C200E          1051         MOV.W   R2,[R0+14]
0004E9 F331            1052         BEQ     _33
                       1053 ; rtxc.c    541                {
                       1054 ; rtxc.c    542                   ptcb->pclkblk = ((struct parg ks_stk *)p2)->pclkblk;
0004EB 8C1716          1055         MOV.W   R1,[R7+22]
0004EE 8C0714          1056         MOV.W   R0,[R7+20]
0004F1 862C42          1057         MOV.B   ES,R1L
0004F4 8C1012          1058         MOV.W   R1,[R0+18]
0004F7 8C0010          1059         MOV.W   R0,[R0+16]
0004FA 86AC42          1060         MOV.B   ES,R5L
0004FD 8C0C08          1061         MOV.W   [R4+8],R0
000500 8C1C0A          1062         MOV.W   [R4+10],R1
                       1063 ; rtxc.c    543                   pclkblk = ptcb->pclkblk;
000503 86AC42          1064         MOV.B   ES,R5L
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  21

ADDR   CODE            LINE SOURCELINE
000506 8C0408          1065         MOV.W   R0,[R4+8]
000509 8C140A          1066         MOV.W   R1,[R4+10]
                       1067 ; rtxc.c    544                   pclkblk->remain = ((struct parg ks_stk *)p2)->ticks;
00050C 862C42          1068         MOV.B   ES,R1L
00050F 8C2808          1069         MOV.W   [R0+8],R2
                       1070 ; rtxc.c    545                   pclkblk->recycle = (TICKS)0;
000512 862C42          1071         MOV.B   ES,R1L
000515 BC000A          1072         MOV.W   [R0+10],#00H
                       1073 ; rtxc.c    546 
                       1074 ; rtxc.c    547                   /* mark object type */
                       1075 ; rtxc.c    548                   pclkblk->objtype = PARTITION_OBJ;
000518 862C42          1076         MOV.B   ES,R1L
00051B BC020E          1077         MOV.W   [R0+14],#02H
                       1078 ; rtxc.c    549                   pclkblk->objid = ((struct parg ks_stk *)p2)->map;
00051E 8C3716          1079         MOV.W   R3,[R7+22]
000521 8C2714          1080         MOV.W   R2,[R7+20]
000524 866C42          1081         MOV.B   ES,R3L
000527 844204          1082         MOV.B   R2L,[R2+4]
00052A 862C42          1083         MOV.B   ES,R1L
00052D 844810          1084         MOV.B   [R0+16],R2L
                       1085 ; rtxc.c    550                   pclkblk->task = ptcb->task;
000530 86AC42          1086         MOV.B   ES,R5L
000533 84440C          1087         MOV.B   R2L,[R4+12]
000536 862C42          1088         MOV.B   ES,R1L
000539 84480C          1089         MOV.B   [R0+12],R2L
                       1090 ; rtxc.c    551 
                       1091 ; rtxc.c    552                   /* insert timer */
                       1092 ; rtxc.c    553                   insert_timer(pclkblk);
00053C C51DB6          1093         CALL    _insert_timer
                       1094 ; rtxc.c    554 
                       1095 ; rtxc.c    555                   ((struct parg ks_stk *)p2)->ksrc = RC_TIMEOUT;
00053F 8C1716          1096         MOV.W   R1,[R7+22]
000542 8C0714          1097         MOV.W   R0,[R7+20]
000545 862C42          1098         MOV.B   ES,R1L
000548 BC0502          1099         MOV.W   [R0+2],#05H
000548 BC050200        1099         MOV.W   [R0+2],#05H
                       1100 ; rtxc.c    556                }
                       1101 ; rtxc.c    557 #endif /* } PARTITION_TIMEOUTS */
                       1102 ; rtxc.c    558             }
                       1103 ; rtxc.c    559 #endif /* } PARTITION_WAITERS */
                       1104 ; rtxc.c    560          }
00054C                 1105 _33:
                       1106 ; rtxc.c    561          ((struct parg ks_stk *)p2)->val = (char *)q;
00054C 8C170E          1107         MOV.W   R1,[R7+14]
00054F 8C070C          1108         MOV.W   R0,[R7+12]
000552 8C3716          1109         MOV.W   R3,[R7+22]
000555 8C2714          1110         MOV.W   R2,[R7+20]
000558 866C42          1111         MOV.B   ES,R3L
00055B 8C0A06          1112         MOV.W   [R2+6],R0
00055E 8C1A08          1113         MOV.W   [R2+8],R1
                       1114 ; rtxc.c    562          break;
                       1115         BR      _428
000561 D51545         +1115         JMP.L   _428
000561 D51545         +1115         JMP.L   _428
                       1116 ; rtxc.c    563 #endif /* } HAS_ALLOC */
                       1117 ; rtxc.c    564 
                       1118 ; rtxc.c    565 #ifdef HAS_FREE /* { */
                       1119 ; rtxc.c    566 /************************/
                       1120 ; rtxc.c    567       case RTXC_FREE:
000564                 1121 _34:
                       1122 ; rtxc.c    568 /************************/
                       1123 ; rtxc.c    569          q = (struct xmap *)((struct parg ks_stk *)p2)->val;
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  22

ADDR   CODE            LINE SOURCELINE
000564 8915            1124         MOV.W   R1,R5
000566 8904            1125         MOV.W   R0,R4
000568 862C42          1126         MOV.B   ES,R1L
00056B 8C2006          1127         MOV.W   R2,[R0+6]
00056E 8C3008          1128         MOV.W   R3,[R0+8]
                       1129 ; rtxc.c    570 
                       1130 ; rtxc.c    571          pph = (PHEADER ks_tbl *)&pheader[((struct parg ks_stk *)p2)->map];
000571 862C42          1131         MOV.B   ES,R1L
000574 840004          1132         MOV.B   R0L,[R0+4]
000577 E80016          1133         MULU.B  R0L,#016H
00057A B910            1134         MOVS.W  R1,#00H
00057C 9958rrrr        1135         MOV.W   R5,#SEG( _pheader )
000580 9948rrrr        1136         MOV.W   R4,#SOF( _pheader )
000584 0940            1137         ADD.W   R4,R0
                       1138 ; rtxc.c    572 
                       1139 ; rtxc.c    573 #ifdef CBUG /* { */
                       1140 ; rtxc.c    574          pph->usage++; /* increment no. frees */
                       1141 ; rtxc.c    575 #endif /* } CBUG */
                       1142 ; rtxc.c    576 
                       1143 ; rtxc.c    577 #ifdef PARTITION_WAITERS /* { */
                       1144 ; rtxc.c    578          if ( (ptcb = pph->waiters) != NULLTCB) /* if any waiters */
000586 8915            1145         MOV.W   R1,R5
000588 8904            1146         MOV.W   R0,R4
00058A 99400008        1147         ADD.W   R4,#08H
00058E 8C5F12          1148         MOV.W   [R7+18],R5
000591 8C4F10          1149         MOV.W   [R7+16],R4
000594 8C1F16          1150         MOV.W   [R7+22],R1
000597 8C0F14          1151         MOV.W   [R7+20],R0
00059A 862C42          1152         MOV.B   ES,R1L
00059D 8C4008          1153         MOV.W   R4,[R0+8]
0005A0 8C500A          1154         MOV.W   R5,[R0+10]
0005A3 8915            1155         MOV.W   R1,R5
0005A5 8904            1156         MOV.W   R0,R4
0005A7 6910            1157         OR.W    R1,R0
0005A9 F357            1158         BEQ     _37
                       1159 ; rtxc.c    579          {
                       1160 ; rtxc.c    580             /* pass ptr directly from freeing task to allocating task */
                       1161 ; rtxc.c    581             p2a = ((FRAME ks_stk *)(ptcb->sp))->pksnum;
0005AB 86AC42          1162         MOV.B   ES,R5L
0005AE 8C040E          1163         MOV.W   R0,[R4+14]
0005B1 8C1410          1164         MOV.W   R1,[R4+16]
0005B4 862C42          1165         MOV.B   ES,R1L
0005B7 8C1006          1166         MOV.W   R1,[R0+6]
0005BA 8C0004          1167         MOV.W   R0,[R0+4]
                       1168 ; rtxc.c    582             ((struct parg ks_stk *)p2a)->val = (char *)q;
0005BD 862C42          1169         MOV.B   ES,R1L
0005C0 8C2806          1170         MOV.W   [R0+6],R2
0005C3 8C3808          1171         MOV.W   [R0+8],R3
0005C6 8C1F0E          1172         MOV.W   [R7+14],R1
0005C9 8C0F0C          1173         MOV.W   [R7+12],R0
                       1174 ; rtxc.c    583 
                       1175 ; rtxc.c    584             /* remove first waiter from list */
                       1176 ; rtxc.c    585             if ( (pph->waiters = ptcb->flink) != NULLTCB)
0005CC 86AC42          1177         MOV.B   ES,R5L
0005CF 8A04            1178         MOV.W   R0,[R4]
0005D1 8C1402          1179         MOV.W   R1,[R4+2]
0005D4 8C3716          1180         MOV.W   R3,[R7+22]
0005D7 8C2714          1181         MOV.W   R2,[R7+20]
0005DA 866C42          1182         MOV.B   ES,R3L
0005DD 8C0A08          1183         MOV.W   [R2+8],R0
0005E0 8C1A0A          1184         MOV.W   [R2+10],R1
0005E3 6910            1185         OR.W    R1,R0
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  23

ADDR   CODE            LINE SOURCELINE
0005E5 F30C            1186         BEQ     _35
                       1187 ; rtxc.c    586                ptcb->flink->blink = (TCB ks_tbl *)&pph->waiters;
0005E7 8C1712          1188         MOV.W   R1,[R7+18]
0005EA 8C0710          1189         MOV.W   R0,[R7+16]
0005ED 86AC42          1190         MOV.B   ES,R5L
0005F0 8A24            1191         MOV.W   R2,[R4]
0005F2 8C3402          1192         MOV.W   R3,[R4+2]
0005F5 866C42          1193         MOV.B   ES,R3L
0005F8 8C0A04          1194         MOV.W   [R2+4],R0
0005FB 8C1A06          1195         MOV.W   [R2+6],R1
0005FB 8C1A06          1195         MOV.W   [R2+6],R1
0005FE                 1196 _35:
                       1197 ; rtxc.c    587 
                       1198 ; rtxc.c    588             /* "resume" first waiter */
                       1199 ; rtxc.c    589             if ( (ptcb->status &= ~PARTITION_WAIT) == READY)
0005FE 86AC42          1200         MOV.B   ES,R5L
000601 8C0412          1201         MOV.W   R0,[R4+18]
000604 9905FFFD        1202         AND.W   R0,#0FFFDH
000608 86AC42          1203         MOV.B   ES,R5L
00060B 9C4512FFFD      1204         AND.W   [R4+18],#0FFFDH
000610 6900            1205         OR.W    R0,R0
000612 F20A            1206         BNE     _36
                       1207 ; rtxc.c    590             {
                       1208 ; rtxc.c    591                /* insert waiter into READY list */
                       1209 ; rtxc.c    592                ptcb->flink = nsrttcb;
000614 8E1rrr          1210         MOV.W   R1,_nsrttcb+2
000617 8E0rrr          1211         MOV.W   R0,_nsrttcb
00061A 86AC42          1212         MOV.B   ES,R5L
00061D 8A0C            1213         MOV.W   [R4],R0
00061F 8C1C02          1214         MOV.W   [R4+2],R1
                       1215 ; rtxc.c    593                nsrttcb = ptcb;
000622 8E5rrr          1216         MOV.W   _nsrttcb+2,R5
000625 8E4rrr          1217         MOV.W   _nsrttcb,R4
000625 8E4rrr          1217         MOV.W   _nsrttcb,R4
                       1218 ; rtxc.c    594             }
000628                 1219 _36:
                       1220 ; rtxc.c    595 
                       1221 ; rtxc.c    596 #ifdef PARTITION_TIMEOUTS /* { */
                       1222 ; rtxc.c    597             /* cleanup any pending timeout */
                       1223 ; rtxc.c    598             if ( (pclkblk = ptcb->pclkblk) != NULLCLK)
000628 86AC42          1224         MOV.B   ES,R5L
00062B 8C0408          1225         MOV.W   R0,[R4+8]
00062E 8C140A          1226         MOV.W   R1,[R4+10]
000631 8931            1227         MOV.W   R3,R1
000633 8920            1228         MOV.W   R2,R0
000635 6932            1229         OR.W    R3,R2
                       1230         BEQ     _428
000637 F202           +1230 ;       BNE     _LG_66
000639 D514D9         +1230 ;       JMP.L   _428
000639 D514D9         +1230 ;       JMP.L   _428
00063C                +1230 _LG_66:
                       1231 ; rtxc.c    599             {
                       1232 ; rtxc.c    600                /* mark waiter GOOD */
                       1233 ; rtxc.c    601                ((struct parg ks_stk *)p2a)->ksrc = RC_GOOD;
00063C 8C370E          1234         MOV.W   R3,[R7+14]
00063F 8C270C          1235         MOV.W   R2,[R7+12]
000642 866C42          1236         MOV.B   ES,R3L
000645 BC2002          1237         MOV.W   [R2+2],#00H
                       1238 ; rtxc.c    602 
                       1239 ; rtxc.c    603                unlink_timer(pclkblk);
000648 C51DAC          1240         CALL    _unlink_timer
                       1241 ; rtxc.c    604                ptcb->pclkblk = NULLCLK;
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  24

ADDR   CODE            LINE SOURCELINE
00064B 86AC42          1242         MOV.B   ES,R5L
00064E BC4008          1243         MOV.W   [R4+8],#00H
000651 BC400A          1244         MOV.W   [R4+10],#00H
                       1245 ; rtxc.c    605             }
                       1246 ; rtxc.c    606 #endif /* } PARTITION_TIMEOUTS */
                       1247 ; rtxc.c    607          }
                       1248         BR      _428
000654 D514CC         +1248         JMP.L   _428
000654 D514CC00       +1248         JMP.L   _428
000658                 1249 _37:
                       1250 ; rtxc.c    608          else
                       1251 ; rtxc.c    609 #endif /* } PARTITION_WAITERS */
                       1252 ; rtxc.c    610          {
                       1253 ; rtxc.c    611             /* put block back on free list */
                       1254 ; rtxc.c    612             PUSHPSWH; /* save current processor priority level */
000658 860401          1255         MOV.B   R0L,0401H
                       1256 ; rtxc.c    613             DISABLE;
00065B 9648018D        1257         MOV.B   0401H,#08DH
                       1258 ; rtxc.c    614             q->link = pph->next;
00065F 8C5716          1259         MOV.W   R5,[R7+22]
000662 8C4714          1260         MOV.W   R4,[R7+20]
000665 86AC42          1261         MOV.B   ES,R5L
000668 8C5402          1262         MOV.W   R5,[R4+2]
00066B 8A44            1263         MOV.W   R4,[R4]
00066D 866C42          1264         MOV.B   ES,R3L
000670 8A4A            1265         MOV.W   [R2],R4
000672 8C5A02          1266         MOV.W   [R2+2],R5
                       1267 ; rtxc.c    615             pph->next = q;
000675 8C5716          1268         MOV.W   R5,[R7+22]
000678 8C4714          1269         MOV.W   R4,[R7+20]
00067B 86AC42          1270         MOV.B   ES,R5L
00067E 8A2C            1271         MOV.W   [R4],R2
000680 8C3C02          1272         MOV.W   [R4+2],R3
                       1273 ; rtxc.c    616             POPPSWH;  /* restore current PPL */
000683 860C01          1274         MOV.B   0401H,R0L
                       1275 ; rtxc.c    617 
                       1276 ; rtxc.c    618 #ifdef CBUG /* { */
                       1277 ; rtxc.c    619             pph->cur--;   /* track current no. used */
                       1278 ; rtxc.c    620 #endif /* } CBUG */
                       1279 ; rtxc.c    621          }
                       1280 ; rtxc.c    622          break;
                       1281         BR      _428
000686 D514B3         +1281         JMP.L   _428
000686 D514B300       +1281         JMP.L   _428
                       1282 ; rtxc.c    623 #endif /* } HAS_FREE */
                       1283 ; rtxc.c    624 
                       1284 ; rtxc.c    625 #ifdef HAS_CREATE_PART /* { */
                       1285 ; rtxc.c    626 /************************/
                       1286 ; rtxc.c    627       case RTXC_CREATE_PART:
00068A                 1287 _38:
                       1288 ; rtxc.c    628 /************************/
                       1289 ; rtxc.c    629          if ( (pph = (PHEADER ks_tbl *)dphfl) != NULLMAP)
00068A 964842rr        1290         MOV.B   ES,#SEG( _dphfl )
00068E 9918rrrr        1291         MOV.W   R1,#SOF( _dphfl )
000692 8B01            1292         MOV.W   R0,[R1+]
000694 8A11            1293         MOV.W   R1,[R1]
000696 8931            1294         MOV.W   R3,R1
000698 8920            1295         MOV.W   R2,R0
00069A 6932            1296         OR.W    R3,R2
00069C F31D            1297         BEQ     _39
                       1298 ; rtxc.c    630          {
                       1299 ; rtxc.c    631             /* allocate pheader by removing 1st from free list */
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  25

ADDR   CODE            LINE SOURCELINE
                       1300 ; rtxc.c    632             dphfl = (PHEADER ks_tbl *)pph->next;
00069E 862C42          1301         MOV.B   ES,R1L
0006A1 8A20            1302         MOV.W   R2,[R0]
0006A3 8C3002          1303         MOV.W   R3,[R0+2]
0006A6 964842rr        1304         MOV.B   ES,#SEG( _dphfl )
0006AA 9968rrrr        1305         MOV.W   R6,#SOF( _dphfl )
0006AE 8B2E            1306         MOV.W   [R6+],R2
0006B0 8A3E            1307         MOV.W   [R6],R3
                       1308 ; rtxc.c    633 
                       1309 ; rtxc.c    634             /* put map number in arg packet */
                       1310 ; rtxc.c    635             ((struct parg ks_stk *)p2)->map = pph->map;
0006B2 8C1F16          1311         MOV.W   [R7+22],R1
0006B5 8C0F14          1312         MOV.W   [R7+20],R0
0006B8 862C42          1313         MOV.B   ES,R1L
0006BB 844010          1314         MOV.B   R2L,[R0+16]
0006BE 8915            1315         MOV.W   R1,R5
0006C0 8904            1316         MOV.W   R0,R4
0006C2 862C42          1317         MOV.B   ES,R1L
0006C5 844804          1318         MOV.B   [R0+4],R2L
                       1319 ; rtxc.c    636 
                       1320 ; rtxc.c    637             /* use header to define partition */
                       1321 ; rtxc.c    638             dn_defpart(pph, p2);
0006C8 8C1716          1322         MOV.W   R1,[R7+22]
0006CB 8C0714          1323         MOV.W   R0,[R7+20]
0006CE 8935            1324         MOV.W   R3,R5
0006D0 8924            1325         MOV.W   R2,R4
0006D2 C52005          1326         CALL    _dn_defpart
                       1327 ; rtxc.c    639          }
                       1328         BR      _428
0006D5 D5148B         +1328         JMP.L   _428
0006D5 D5148B         +1328         JMP.L   _428
0006D8                 1329 _39:
                       1330 ; rtxc.c    640          else  /* pheader not available, return 0 */
                       1331 ; rtxc.c    641             ((struct parg ks_stk *)p2)->map = (MAP)0;
0006D8 86AC42          1332         MOV.B   ES,R5L
0006DB B44004          1333         MOV.B   [R4+4],#00H
                       1334 ; rtxc.c    642 
                       1335 ; rtxc.c    643          break;
                       1336         BR      _428
0006DE D51487         +1336         JMP.L   _428
0006DE D5148700       +1336         JMP.L   _428
                       1337 ; rtxc.c    644 #endif /* } HAS_CREATE_PART */
                       1338 ; rtxc.c    645 
                       1339 ; rtxc.c    646 #ifdef HAS_DEFPART /* { */
                       1340 ; rtxc.c    647 /************************/
                       1341 ; rtxc.c    648       case RTXC_DEFPART:
0006E2                 1342 _40:
                       1343 ; rtxc.c    649 /************************/
                       1344 ; rtxc.c    650          pph = (PHEADER ks_tbl *)&pheader[((struct parg ks_stk *)p2)->map];
0006E2 8915            1345         MOV.W   R1,R5
0006E4 8904            1346         MOV.W   R0,R4
0006E6 862C42          1347         MOV.B   ES,R1L
0006E9 840004          1348         MOV.B   R0L,[R0+4]
0006EC E80016          1349         MULU.B  R0L,#016H
0006EF 8920            1350         MOV.W   R2,R0
0006F1 B930            1351         MOVS.W  R3,#00H
0006F3 9918rrrr        1352         MOV.W   R1,#SEG( _pheader )
0006F7 9908rrrr        1353         MOV.W   R0,#SOF( _pheader )
0006FB 0902            1354         ADD.W   R0,R2
                       1355 ; rtxc.c    651          dn_defpart(pph, p2);  /* use header to define partition */
0006FD 8935            1356         MOV.W   R3,R5
0006FF 8924            1357         MOV.W   R2,R4
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  26

ADDR   CODE            LINE SOURCELINE
000701 C51FED          1358         CALL    _dn_defpart
                       1359 ; rtxc.c    652 
                       1360 ; rtxc.c    653          break;
                       1361         BR      _428
000704 D51474         +1361         JMP.L   _428
000704 D5147400       +1361         JMP.L   _428
                       1362 ; rtxc.c    654 #endif /* } HAS_DEFPART */
                       1363 ; rtxc.c    655 
                       1364 ; rtxc.c    656 #ifdef HAS_ALLOC_PART /* { */
                       1365 ; rtxc.c    657 /************************/
                       1366 ; rtxc.c    658       case RTXC_ALLOC_PART:
000708                 1367 _41:
                       1368 ; rtxc.c    659 /************************/
                       1369 ; rtxc.c    660          if ( (pph = (PHEADER ks_tbl *)dphfl) != NULLMAP)
000708 964842rr        1370         MOV.B   ES,#SEG( _dphfl )
00070C 9918rrrr        1371         MOV.W   R1,#SOF( _dphfl )
000710 8B01            1372         MOV.W   R0,[R1+]
000712 8A11            1373         MOV.W   R1,[R1]
000714 8931            1374         MOV.W   R3,R1
000716 8920            1375         MOV.W   R2,R0
000718 6932            1376         OR.W    R3,R2
00071A F312            1377         BEQ     _42
                       1378 ; rtxc.c    661          {
                       1379 ; rtxc.c    662             /* allocate pheader by removing 1st from free list */
                       1380 ; rtxc.c    663             dphfl = (PHEADER ks_tbl *)pph->next;
00071C 862C42          1381         MOV.B   ES,R1L
00071F 8A20            1382         MOV.W   R2,[R0]
000721 8C3002          1383         MOV.W   R3,[R0+2]
000724 964842rr        1384         MOV.B   ES,#SEG( _dphfl )
000728 9968rrrr        1385         MOV.W   R6,#SOF( _dphfl )
00072C 8B2E            1386         MOV.W   [R6+],R2
00072E 8A3E            1387         MOV.W   [R6],R3
                       1388 ; rtxc.c    664 
                       1389 ; rtxc.c    665             /* put map number in arg packet */
                       1390 ; rtxc.c    666             ((struct parg ks_stk *)p2)->map = pph->map;
000730 862C42          1391         MOV.B   ES,R1L
000733 840010          1392         MOV.B   R0L,[R0+16]
000736 86AC42          1393         MOV.B   ES,R5L
000739 840C04          1394         MOV.B   [R4+4],R0L
                       1395 ; rtxc.c    667          }
                       1396         BR      _428
00073C D51458         +1396         JMP.L   _428
00073C D5145800       +1396         JMP.L   _428
000740                 1397 _42:
                       1398 ; rtxc.c    668          else /* pheader not available, return 0 */
                       1399 ; rtxc.c    669             ((struct parg ks_stk *)p2)->map = (MAP)0;
000740 86AC42          1400         MOV.B   ES,R5L
000743 B44004          1401         MOV.B   [R4+4],#00H
                       1402 ; rtxc.c    670 
                       1403 ; rtxc.c    671          break;
                       1404         BR      _428
000746 D51453         +1404         JMP.L   _428
000746 D5145300       +1404         JMP.L   _428
                       1405 ; rtxc.c    672 #endif /* } HAS_ALLOC_PART */
                       1406 ; rtxc.c    673 
                       1407 ; rtxc.c    674 #ifdef HAS_FREE_PART /* { */
                       1408 ; rtxc.c    675 /************************/
                       1409 ; rtxc.c    676       case RTXC_FREE_PART:
00074A                 1410 _43:
                       1411 ; rtxc.c    677 /************************/
                       1412 ; rtxc.c    678          pph = (PHEADER ks_tbl *)&pheader[((struct parg ks_stk *)p2)->map];
00074A 86AC42          1413         MOV.B   ES,R5L
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  27

ADDR   CODE            LINE SOURCELINE
00074D 840404          1414         MOV.B   R0L,[R4+4]
000750 E80016          1415         MULU.B  R0L,#016H
000753 B910            1416         MOVS.W  R1,#00H
000755 9938rrrr        1417         MOV.W   R3,#SEG( _pheader )
000759 9928rrrr        1418         MOV.W   R2,#SOF( _pheader )
00075D 0920            1419         ADD.W   R2,R0
                       1420 ; rtxc.c    679 
                       1421 ; rtxc.c    680          /* reset dimension and stats */
                       1422 ; rtxc.c    681          pph->size = 0;
00075F 866C42          1423         MOV.B   ES,R3L
000762 BC2004          1424         MOV.W   [R2+4],#00H
                       1425 ; rtxc.c    682          pph->count = 0;
000765 866C42          1426         MOV.B   ES,R3L
000768 BC2006          1427         MOV.W   [R2+6],#00H
                       1428 ; rtxc.c    683 #ifdef PARTITION_WAITERS /* { */
                       1429 ; rtxc.c    684          pph->waiters = NULLTCB;
00076B 866C42          1430         MOV.B   ES,R3L
00076E BC2008          1431         MOV.W   [R2+8],#00H
000771 BC200A          1432         MOV.W   [R2+10],#00H
                       1433 ; rtxc.c    685          pph->dummy = NULLTCB;
000774 866C42          1434         MOV.B   ES,R3L
000777 BC200C          1435         MOV.W   [R2+12],#00H
00077A BC200E          1436         MOV.W   [R2+14],#00H
                       1437 ; rtxc.c    686 #endif /* } PARTITION_WAITERS */
                       1438 ; rtxc.c    687 
                       1439 ; rtxc.c    688 #ifdef CBUG /* { */
                       1440 ; rtxc.c    689          pph->cur = 0;
                       1441 ; rtxc.c    690          pph->worst = 0;
                       1442 ; rtxc.c    691          pph->usage = 0;
                       1443 ; rtxc.c    692 #endif /* } CBUG */
                       1444 ; rtxc.c    693 
                       1445 ; rtxc.c    694          /* re-insert pheader into pheader free list for dynamic partitions */
                       1446 ; rtxc.c    695          pph->next = (struct xmap *)dphfl;
00077D 964842rr        1447         MOV.B   ES,#SEG( _dphfl )
000781 9918rrrr        1448         MOV.W   R1,#SOF( _dphfl )
000785 8B01            1449         MOV.W   R0,[R1+]
000787 8A11            1450         MOV.W   R1,[R1]
000789 866C42          1451         MOV.B   ES,R3L
00078C 8A0A            1452         MOV.W   [R2],R0
00078E 8C1A02          1453         MOV.W   [R2+2],R1
                       1454 ; rtxc.c    696          dphfl = (PHEADER ks_tbl *)pph;
000791 964842rr        1455         MOV.B   ES,#SEG( _dphfl )
000795 9908rrrr        1456         MOV.W   R0,#SOF( _dphfl )
000799 8B28            1457         MOV.W   [R0+],R2
00079B 8A38            1458         MOV.W   [R0],R3
                       1459 ; rtxc.c    697 
                       1460 ; rtxc.c    698          ((struct parg ks_stk *)p2)->addr = pph->addr;
00079D 866C42          1461         MOV.B   ES,R3L
0007A0 8C3214          1462         MOV.W   R3,[R2+20]
0007A3 8C2212          1463         MOV.W   R2,[R2+18]
0007A6 86AC42          1464         MOV.B   ES,R5L
0007A9 8C2C14          1465         MOV.W   [R4+20],R2
0007AC 8C3C16          1466         MOV.W   [R4+22],R3
                       1467 ; rtxc.c    699 
                       1468 ; rtxc.c    700          break;
                       1469         BR      _428
0007AF D5141E         +1469         JMP.L   _428
0007AF D5141E         +1469         JMP.L   _428
                       1470 ; rtxc.c    701 #endif /* } HAS_FREE_PART */
                       1471 ; rtxc.c    702 
                       1472 ; rtxc.c    703 #endif /* } HAS_PARTITIONS */
                       1473 ; rtxc.c    704 
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  28

ADDR   CODE            LINE SOURCELINE
                       1474 ; rtxc.c    705 #ifdef HAS_RESOURCES /* { */
                       1475 ; rtxc.c    706 #ifdef HAS_LOCK /* { */
                       1476 ; rtxc.c    707 /************************/
                       1477 ; rtxc.c    708       case RTXC_LOCK:
0007B2                 1478 _44:
                       1479 ; rtxc.c    709 /************************/
                       1480 ; rtxc.c    710          prh = (RHEADER ks_tbl *)&rheader[((struct larg ks_stk *)p2)->resource];
0007B2 8915            1481         MOV.W   R1,R5
0007B4 8904            1482         MOV.W   R0,R4
0007B6 99400004        1483         ADD.W   R4,#04H
0007BA 8C5F12          1484         MOV.W   [R7+18],R5
0007BD 8C4F10          1485         MOV.W   [R7+16],R4
0007C0 8C1F16          1486         MOV.W   [R7+22],R1
0007C3 8C0F14          1487         MOV.W   [R7+20],R0
0007C6 862C42          1488         MOV.B   ES,R1L
0007C9 840004          1489         MOV.B   R0L,[R0+4]
0007CC E80012          1490         MULU.B  R0L,#012H
0007CF B910            1491         MOVS.W  R1,#00H
0007D1 9938rrrr        1492         MOV.W   R3,#SEG( _rheader )
0007D5 9928rrrr        1493         MOV.W   R2,#SOF( _rheader )
0007D9 0920            1494         ADD.W   R2,R0
0007DB 8953            1495         MOV.W   R5,R3
0007DD 8942            1496         MOV.W   R4,R2
                       1497 ; rtxc.c    711 
                       1498 ; rtxc.c    712 #ifdef CBUG /* { */
                       1499 ; rtxc.c    713          prh->count++; /* update statistics */
                       1500 ; rtxc.c    714 #endif /* } CBUG */
                       1501 ; rtxc.c    715 
                       1502 ; rtxc.c    716          if (prh->owner == NULLTCB)  /* if resource not currently owned */
0007DF 964842rr        1503         MOV.B   ES,#SEG( _rheader )
0007E3 8D20rrrr        1504         MOV.W   R2,[R0+SOF( _rheader )]
0007E7 8D30rrrr        1505         MOV.W   R3,[R0+SOF( _rheader+2 )]
0007EB 6932            1506         OR.W    R3,R2
0007ED F216            1507         BNE     _45
                       1508 ; rtxc.c    717          {
                       1509 ; rtxc.c    718             prh->owner = hipritsk; /* lock resource with task */
0007EF 8E3rrr          1510         MOV.W   R3,_hipritsk+2
0007F2 8E2rrr          1511         MOV.W   R2,_hipritsk
0007F5 964842rr        1512         MOV.B   ES,#SEG( _rheader )
0007F9 8D28rrrr        1513         MOV.W   [R0+SOF( _rheader )],R2
0007FD 8D38rrrr        1514         MOV.W   [R0+SOF( _rheader+2 )],R3
                       1515 ; rtxc.c    719             prh->level = 1;         /* set nesting level = 1 */
000801 8915            1516         MOV.W   R1,R5
000803 8904            1517         MOV.W   R0,R4
000805 862C42          1518         MOV.B   ES,R1L
000808 B40104          1519         MOV.B   [R0+4],#01H
                       1520 ; rtxc.c    720             ((struct larg ks_stk *)p2)->ksrc = RC_GOOD;
00080B 8C1716          1521         MOV.W   R1,[R7+22]
00080E 8C0714          1522         MOV.W   R0,[R7+20]
000811 862C42          1523         MOV.B   ES,R1L
000814 BC0002          1524         MOV.W   [R0+2],#00H
                       1525 ; rtxc.c    721             break;
                       1526         BR      _428
000817 D513EA         +1526         JMP.L   _428
000817 D513EA         +1526         JMP.L   _428
                       1527 ; rtxc.c    722          }
00081A                 1528 _45:
                       1529 ; rtxc.c    723 
                       1530 ; rtxc.c    724          if (prh->owner == hipritsk) /* if nested lock */
00081A 8E3rrr          1531         MOV.W   R3,_hipritsk+2
00081D 8E2rrr          1532         MOV.W   R2,_hipritsk
000820 86AC42          1533         MOV.B   ES,R5L
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  29

ADDR   CODE            LINE SOURCELINE
000823 4C3C02          1534         CMP.W   [R4+2],R3
000826 F201            1535         BNE     _440
000828 4A2C            1536         CMP.W   [R4],R2
000828 4A2C            1536         CMP.W   [R4],R2
00082A                 1537 _440:
00082A F20E            1538         BNE     _46
                       1539 ; rtxc.c    725          {
                       1540 ; rtxc.c    726             prh->level++; /* bump nesting level only */
00082C 8915            1541         MOV.W   R1,R5
00082E 8904            1542         MOV.W   R0,R4
000830 862C42          1543         MOV.B   ES,R1L
000833 A40104          1544         ADDS.B  [R0+4],#01H
                       1545 ; rtxc.c    727                    /* indicate NESTED lock */
                       1546 ; rtxc.c    728             ((struct larg ks_stk *)p2)->ksrc = RC_NESTED;
000836 8C1716          1547         MOV.W   R1,[R7+22]
000839 8C0714          1548         MOV.W   R0,[R7+20]
00083C 862C42          1549         MOV.B   ES,R1L
00083F 9C0802000A      1550         MOV.W   [R0+2],#0AH
                       1551 ; rtxc.c    729             break;
                       1552         BR      _428
000844 D513D4         +1552         JMP.L   _428
000844 D513D400       +1552         JMP.L   _428
                       1553 ; rtxc.c    730          }
000848                 1554 _46:
                       1555 ; rtxc.c    731 
                       1556 ; rtxc.c    732 #ifdef CBUG /* { */
                       1557 ; rtxc.c    733          prh->conflict++; /* count resource bottlenecks */
                       1558 ; rtxc.c    734 #endif /* } CBUG */
                       1559 ; rtxc.c    735 
                       1560 ; rtxc.c    736 #ifdef RESOURCE_WAITERS /* { */
                       1561 ; rtxc.c    737          /* if wait on resource not available */
                       1562 ; rtxc.c    738          if ( ((struct larg ks_stk *)p2)->wait)
000848 8C1716          1563         MOV.W   R1,[R7+22]
00084B 8C0714          1564         MOV.W   R0,[R7+20]
00084E 862C42          1565         MOV.B   ES,R1L
000851 840005          1566         MOV.B   R0L,[R0+5]
                       1567         BEQ     _53
000854 F202           +1567 ;       BNE     _LG_78
000856 D500B1         +1567 ;       JMP.L   _53
000856 D500B100       +1567 ;       JMP.L   _53
00085A                +1567 _LG_78:
                       1568 ; rtxc.c    739          {
                       1569 ; rtxc.c    740 #ifdef PRIORITY_INVERSION /* { */
                       1570 ; rtxc.c    741             if (prh->resattr == PRIORITY_INVERSION_ON)
00085A 8C5F0E          1571         MOV.W   [R7+14],R5
00085D 8C4F0C          1572         MOV.W   [R7+12],R4
000860 86AC42          1573         MOV.B   ES,R5L
000863 9C44100001      1574         CMP.W   [R4+16],#01H
000868 F261            1575         BNE     _52
                       1576 ; rtxc.c    742             {
                       1577 ; rtxc.c    743                /* if owner is lower priority than requestor */
                       1578 ; rtxc.c    744                if ( (ptcb = prh->owner)->priority > hipritsk->priority)
00086A 8C170E          1579         MOV.W   R1,[R7+14]
00086D 8C070C          1580         MOV.W   R0,[R7+12]
000870 862C42          1581         MOV.B   ES,R1L
000873 8C1002          1582         MOV.W   R1,[R0+2]
000876 8A00            1583         MOV.W   R0,[R0]
000878 8C1F0A          1584         MOV.W   [R7+10],R1
00087B 8C0F08          1585         MOV.W   [R7+8],R0
00087E 8953            1586         MOV.W   R5,R3
000880 8942            1587         MOV.W   R4,R2
000882 9940000D        1588         ADD.W   R4,#0DH
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  30

ADDR   CODE            LINE SOURCELINE
000886 8C5F06          1589         MOV.W   [R7+6],R5
000889 8C4F04          1590         MOV.W   [R7+4],R4
00088C 866C42          1591         MOV.B   ES,R3L
00088F 84420D          1592         MOV.B   R2L,[R2+13]
000892 8C570A          1593         MOV.W   R5,[R7+10]
000895 8C4708          1594         MOV.W   R4,[R7+8]
000898 86AC42          1595         MOV.B   ES,R5L
00089B 444C0D          1596         CMP.B   [R4+13],R2L
00089E FD46            1597         BLE     _52
                       1598 ; rtxc.c    745                {
                       1599 ; rtxc.c    746                   /* priority inversion is necessary */
                       1600 ; rtxc.c    747 
                       1601 ; rtxc.c    748                   /* save owner's priority only for first conflict */
                       1602 ; rtxc.c    749                   if (prh->priority == (PRIORITY)0)
0008A0 8C370E          1603         MOV.W   R3,[R7+14]
0008A3 8C270C          1604         MOV.W   R2,[R7+12]
0008A6 866C42          1605         MOV.B   ES,R3L
0008A9 84420E          1606         MOV.B   R2L,[R2+14]
0008AC F209            1607         BNE     _47
                       1608 ; rtxc.c    750                      prh->priority = ptcb->priority;
0008AE 862C42          1609         MOV.B   ES,R1L
0008B1 84400D          1610         MOV.B   R2L,[R0+13]
0008B4 8C570E          1611         MOV.W   R5,[R7+14]
0008B7 8C470C          1612         MOV.W   R4,[R7+12]
0008BA 86AC42          1613         MOV.B   ES,R5L
0008BD 844C0E          1614         MOV.B   [R4+14],R2L
0008BD 844C0E          1614         MOV.B   [R4+14],R2L
0008C0                 1615 _47:
                       1616 ; rtxc.c    751 
                       1617 ; rtxc.c    752                   /* but always elevate owner's priority to hipri->priority */
                       1618 ; rtxc.c    753                   ptcb->priority = hipritsk->priority;
0008C0 8C5706          1619         MOV.W   R5,[R7+6]
0008C3 8C4704          1620         MOV.W   R4,[R7+4]
0008C6 86AC42          1621         MOV.B   ES,R5L
0008C9 8244            1622         MOV.B   R2L,[R4]
0008CB 862C42          1623         MOV.B   ES,R1L
0008CE 84480D          1624         MOV.B   [R0+13],R2L
                       1625 ; rtxc.c    754 
                       1626 ; rtxc.c    755                   /* change priority - whatever it takes */
                       1627 ; rtxc.c    756                   if (ptcb->status == READY)
0008D1 862C42          1628         MOV.B   ES,R1L
0008D4 8C2012          1629         MOV.W   R2,[R0+18]
0008D7 F225            1630         BNE     _48
                       1631 ; rtxc.c    757                   {
                       1632 ; rtxc.c    758                      /* unlink owner task from RUN list */
                       1633 ; rtxc.c    759                      ptcb->flink->blink = ptcb->blink;
0008D9 862C42          1634         MOV.B   ES,R1L
0008DC 8C2004          1635         MOV.W   R2,[R0+4]
0008DF 8C3006          1636         MOV.W   R3,[R0+6]
0008E2 862C42          1637         MOV.B   ES,R1L
0008E5 8A40            1638         MOV.W   R4,[R0]
0008E7 8C5002          1639         MOV.W   R5,[R0+2]
0008EA 86AC42          1640         MOV.B   ES,R5L
0008ED 8C2C04          1641         MOV.W   [R4+4],R2
0008F0 8C3C06          1642         MOV.W   [R4+6],R3
                       1643 ; rtxc.c    760                      ptcb->blink->flink = ptcb->flink;
0008F3 862C42          1644         MOV.B   ES,R1L
0008F6 8A20            1645         MOV.W   R2,[R0]
0008F8 8C3002          1646         MOV.W   R3,[R0+2]
0008FB 862C42          1647         MOV.B   ES,R1L
0008FE 8C4004          1648         MOV.W   R4,[R0+4]
000901 8C5006          1649         MOV.W   R5,[R0+6]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  31

ADDR   CODE            LINE SOURCELINE
000904 86AC42          1650         MOV.B   ES,R5L
000907 8A2C            1651         MOV.W   [R4],R2
000909 8C3C02          1652         MOV.W   [R4+2],R3
                       1653 ; rtxc.c    761 
                       1654 ; rtxc.c    762                      /* re-insert task */
                       1655 ; rtxc.c    763                      ptcb->flink = nsrttcb;
00090C 8E3rrr          1656         MOV.W   R3,_nsrttcb+2
00090F 8E2rrr          1657         MOV.W   R2,_nsrttcb
000912 862C42          1658         MOV.B   ES,R1L
000915 8A28            1659         MOV.W   [R0],R2
000917 8C3802          1660         MOV.W   [R0+2],R3
                       1661 ; rtxc.c    764                      nsrttcb = ptcb;
00091A 8E1rrr          1662         MOV.W   _nsrttcb+2,R1
00091D 8E0rrr          1663         MOV.W   _nsrttcb,R0
                       1664 ; rtxc.c    765                   }
000920 FE05            1665         BR      _52
000920 FE05            1665         BR      _52
000922                 1666 _48:
                       1667 ; rtxc.c    766                   else
                       1668 ; rtxc.c    767                   {
                       1669 ; rtxc.c    768                      /* if task being changed is in a WAITER list */
                       1670 ; rtxc.c    769                      if (ptcb->status & COMBO_WAIT)
000922 992500AA        1671         AND.W   R2,#0AAH
000926 F302            1672         BEQ     _52
                       1673 ; rtxc.c    770                      {
                       1674 ; rtxc.c    771                         /*
                       1675 ; rtxc.c    772                          * need to re-order within partition, queue, resource,
                       1676 ; rtxc.c    773                          * or mailbox header
                       1677 ; rtxc.c    774                         */
                       1678 ; rtxc.c    775                         reorder_waiters(ptcb);
000928 C51CE1          1679         CALL    _reorder_waiters
000928 C51CE100        1679         CALL    _reorder_waiters
                       1680 ; rtxc.c    776                      }
                       1681 ; rtxc.c    777                      else
                       1682 ; rtxc.c    778                      {
                       1683 ; rtxc.c    779                         /* task is suspended, terminated or blocked */
                       1684 ; rtxc.c    780                         /* priority change above is all that is needed */
                       1685 ; rtxc.c    781                      }
                       1686 ; rtxc.c    782                   }
                       1687 ; rtxc.c    783                }
                       1688 ; rtxc.c    784             }
00092C                 1689 _52:
                       1690 ; rtxc.c    785 #endif /* } PRIORITY_INVERSION */
                       1691 ; rtxc.c    786 
                       1692 ; rtxc.c    787             ptcb = hipritsk; /* save hipritsk for later use */
00092C 8E5rrr          1693         MOV.W   R5,_hipritsk+2
00092F 8E4rrr          1694         MOV.W   R4,_hipritsk
                       1695 ; rtxc.c    788 
                       1696 ; rtxc.c    789             ptcb->status = RESOURCE_WAIT; /* mark task waiting */
000932 86AC42          1697         MOV.B   ES,R5L
000935 9C48120008      1698         MOV.W   [R4+18],#08H
                       1699 ; rtxc.c    790 
                       1700 ; rtxc.c    791             /* thread waiting task in priority order */
                       1701 ; rtxc.c    792             porder((TCB ks_tbl *)&prh->waiters);
00093A 8C170E          1702         MOV.W   R1,[R7+14]
00093D 8C070C          1703         MOV.W   R0,[R7+12]
000940 99000006        1704         ADD.W   R0,#06H
000944 C51C6A          1705         CALL    _porder
                       1706 ; rtxc.c    793 
                       1707 ; rtxc.c    794 #ifdef RESOURCE_TIMEOUTS /* { */
                       1708 ; rtxc.c    795             if ( ((struct larg ks_stk *)p2)->ticks) /* if timeout active */
000947 8C1716          1709         MOV.W   R1,[R7+22]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  32

ADDR   CODE            LINE SOURCELINE
00094A 8C0714          1710         MOV.W   R0,[R7+20]
00094D 862C42          1711         MOV.B   ES,R1L
000950 8C2006          1712         MOV.W   R2,[R0+6]
                       1713         BEQ     _428
000953 F202           +1713 ;       BNE     _LG_90
000955 D5134B         +1713 ;       JMP.L   _428
000955 D5134B         +1713 ;       JMP.L   _428
000958                +1713 _LG_90:
                       1714 ; rtxc.c    796             {
                       1715 ; rtxc.c    797                ptcb->pclkblk = ((struct larg ks_stk *)p2)->pclkblk;
000958 8C1716          1716         MOV.W   R1,[R7+22]
00095B 8C0714          1717         MOV.W   R0,[R7+20]
00095E 862C42          1718         MOV.B   ES,R1L
000961 8C100A          1719         MOV.W   R1,[R0+10]
000964 8C0008          1720         MOV.W   R0,[R0+8]
000967 86AC42          1721         MOV.B   ES,R5L
00096A 8C0C08          1722         MOV.W   [R4+8],R0
00096D 8C1C0A          1723         MOV.W   [R4+10],R1
                       1724 ; rtxc.c    798                pclkblk = ptcb->pclkblk;
000970 86AC42          1725         MOV.B   ES,R5L
000973 8C0408          1726         MOV.W   R0,[R4+8]
000976 8C140A          1727         MOV.W   R1,[R4+10]
                       1728 ; rtxc.c    799                pclkblk->remain = ((struct larg ks_stk *)p2)->ticks;
000979 862C42          1729         MOV.B   ES,R1L
00097C 8C2808          1730         MOV.W   [R0+8],R2
                       1731 ; rtxc.c    800                pclkblk->recycle = (TICKS)0;
00097F 862C42          1732         MOV.B   ES,R1L
000982 BC000A          1733         MOV.W   [R0+10],#00H
                       1734 ; rtxc.c    801 
                       1735 ; rtxc.c    802                /* mark object type */
                       1736 ; rtxc.c    803                pclkblk->objtype = RESOURCE_OBJ;
000985 862C42          1737         MOV.B   ES,R1L
000988 BC040E          1738         MOV.W   [R0+14],#04H
                       1739 ; rtxc.c    804                pclkblk->objid = ((struct larg ks_stk *)p2)->resource;
00098B 8C3712          1740         MOV.W   R3,[R7+18]
00098E 8C2710          1741         MOV.W   R2,[R7+16]
000991 866C42          1742         MOV.B   ES,R3L
000994 8242            1743         MOV.B   R2L,[R2]
000996 862C42          1744         MOV.B   ES,R1L
000999 844810          1745         MOV.B   [R0+16],R2L
                       1746 ; rtxc.c    805                pclkblk->task = ptcb->task;
00099C 86AC42          1747         MOV.B   ES,R5L
00099F 84440C          1748         MOV.B   R2L,[R4+12]
0009A2 862C42          1749         MOV.B   ES,R1L
0009A5 84480C          1750         MOV.B   [R0+12],R2L
                       1751 ; rtxc.c    806 
                       1752 ; rtxc.c    807                /* insert timer */
                       1753 ; rtxc.c    808                insert_timer(pclkblk);
0009A8 C51B80          1754         CALL    _insert_timer
                       1755 ; rtxc.c    809 
                       1756 ; rtxc.c    810                ((struct larg ks_stk *)p2)->ksrc = RC_TIMEOUT;
0009AB 8C1716          1757         MOV.W   R1,[R7+22]
0009AE 8C0714          1758         MOV.W   R0,[R7+20]
0009B1 862C42          1759         MOV.B   ES,R1L
0009B4 BC0502          1760         MOV.W   [R0+2],#05H
                       1761 ; rtxc.c    811             }
                       1762 ; rtxc.c    812 #endif /* } RESOURCE_TIMEOUTS */
                       1763 ; rtxc.c    813          }
                       1764         BR      _428
0009B7 D5131A         +1764         JMP.L   _428
0009B7 D5131A         +1764         JMP.L   _428
0009BA                 1765 _53:
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  33

ADDR   CODE            LINE SOURCELINE
                       1766 ; rtxc.c    814          else
                       1767 ; rtxc.c    815 #endif /* } RESOURCE_WAITERS */
                       1768 ; rtxc.c    816          {
                       1769 ; rtxc.c    817                    /* indicate lock failure */
                       1770 ; rtxc.c    818             ((struct larg ks_stk *)p2)->ksrc = RC_BUSY;
0009BA 8C1716          1771         MOV.W   R1,[R7+22]
0009BD 8C0714          1772         MOV.W   R0,[R7+20]
0009C0 862C42          1773         MOV.B   ES,R1L
0009C3 9C08020009      1774         MOV.W   [R0+2],#09H
                       1775 ; rtxc.c    819          }
                       1776 ; rtxc.c    820          break;
                       1777         BR      _428
0009C8 D51312         +1777         JMP.L   _428
0009C8 D5131200       +1777         JMP.L   _428
                       1778 ; rtxc.c    821 #endif /* } HAS_LOCK */
                       1779 ; rtxc.c    822 
                       1780 ; rtxc.c    823 #ifdef HAS_UNLOCK /* { */
                       1781 ; rtxc.c    824 /************************/
                       1782 ; rtxc.c    825       case RTXC_UNLOCK:
0009CC                 1783 _54:
                       1784 ; rtxc.c    826 /************************/
                       1785 ; rtxc.c    827          prh = (RHEADER ks_tbl *)&rheader[((struct larg ks_stk *)p2)->resource];
0009CC 8C5F16          1786         MOV.W   [R7+22],R5
0009CF 8C4F14          1787         MOV.W   [R7+20],R4
0009D2 86AC42          1788         MOV.B   ES,R5L
0009D5 840404          1789         MOV.B   R0L,[R4+4]
0009D8 E80012          1790         MULU.B  R0L,#012H
0009DB B910            1791         MOVS.W  R1,#00H
0009DD 9938rrrr        1792         MOV.W   R3,#SEG( _rheader )
0009E1 9928rrrr        1793         MOV.W   R2,#SOF( _rheader )
0009E5 0920            1794         ADD.W   R2,R0
0009E7 8953            1795         MOV.W   R5,R3
0009E9 8942            1796         MOV.W   R4,R2
                       1797 ; rtxc.c    828 
                       1798 ; rtxc.c    829          if (prh->owner == NULLTCB) /* if no owner, then NOP */
0009EB 964842rr        1799         MOV.B   ES,#SEG( _rheader )
0009EF 8D10rrrr        1800         MOV.W   R1,[R0+SOF( _rheader+2 )]
0009F3 8D00rrrr        1801         MOV.W   R0,[R0+SOF( _rheader )]
0009F7 6910            1802         OR.W    R1,R0
0009F9 F208            1803         BNE     _55
                       1804 ; rtxc.c    830          {
                       1805 ; rtxc.c    831             ((struct larg ks_stk *)p2)->ksrc = RC_GOOD;
0009FB 8C1716          1806         MOV.W   R1,[R7+22]
0009FE 8C0714          1807         MOV.W   R0,[R7+20]
000A01 862C42          1808         MOV.B   ES,R1L
000A04 BC0002          1809         MOV.W   [R0+2],#00H
                       1810 ; rtxc.c    832             break;
                       1811         BR      _428
000A07 D512F2         +1811         JMP.L   _428
000A07 D512F2         +1811         JMP.L   _428
                       1812 ; rtxc.c    833          }
000A0A                 1813 _55:
                       1814 ; rtxc.c    834 
                       1815 ; rtxc.c    835          if (prh->owner != hipritsk) /* if hipritsk not owner, then NOP */
000A0A 8E3rrr          1816         MOV.W   R3,_hipritsk+2
000A0D 8E2rrr          1817         MOV.W   R2,_hipritsk
000A10 86AC42          1818         MOV.B   ES,R5L
000A13 4C3C02          1819         CMP.W   [R4+2],R3
000A16 F201            1820         BNE     _443
000A18 4A2C            1821         CMP.W   [R4],R2
000A18 4A2C            1821         CMP.W   [R4],R2
000A1A                 1822 _443:
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  34

ADDR   CODE            LINE SOURCELINE
000A1A F309            1823         BEQ     _56
                       1824 ; rtxc.c    836          {
                       1825 ; rtxc.c    837             ((struct larg ks_stk *)p2)->ksrc = RC_BUSY;
000A1C 8C1716          1826         MOV.W   R1,[R7+22]
000A1F 8C0714          1827         MOV.W   R0,[R7+20]
000A22 862C42          1828         MOV.B   ES,R1L
000A25 9C08020009      1829         MOV.W   [R0+2],#09H
                       1830 ; rtxc.c    838             break;
                       1831         BR      _428
000A2A D512E1         +1831         JMP.L   _428
000A2A D512E100       +1831         JMP.L   _428
                       1832 ; rtxc.c    839          }
000A2E                 1833 _56:
                       1834 ; rtxc.c    840 
                       1835 ; rtxc.c    841          if (--prh->level) /* if more nesting remaining, then NOP */
000A2E 8C5F12          1836         MOV.W   [R7+18],R5
000A31 8C4F10          1837         MOV.W   [R7+16],R4
000A34 99400004        1838         ADD.W   R4,#04H
000A38 8C5F0E          1839         MOV.W   [R7+14],R5
000A3B 8C4F0C          1840         MOV.W   [R7+12],R4
000A3E 8C1712          1841         MOV.W   R1,[R7+18]
000A41 8C0710          1842         MOV.W   R0,[R7+16]
000A44 862C42          1843         MOV.B   ES,R1L
000A47 840004          1844         MOV.B   R0L,[R0+4]
000A4A A10F            1845         ADDS.B  R0L,#0FH
000A4C 8C5712          1846         MOV.W   R5,[R7+18]
000A4F 8C4710          1847         MOV.W   R4,[R7+16]
000A52 86AC42          1848         MOV.B   ES,R5L
000A55 A44F04          1849         ADDS.B  [R4+4],#0FH
000A58 6100            1850         OR.B    R0L,R0L
000A5A F309            1851         BEQ     _57
                       1852 ; rtxc.c    842          {
                       1853 ; rtxc.c    843             ((struct larg ks_stk *)p2)->ksrc = RC_NESTED;
000A5C 8C1716          1854         MOV.W   R1,[R7+22]
000A5F 8C0714          1855         MOV.W   R0,[R7+20]
000A62 862C42          1856         MOV.B   ES,R1L
000A65 9C0802000A      1857         MOV.W   [R0+2],#0AH
                       1858 ; rtxc.c    844             break;
                       1859         BR      _428
000A6A D512C1         +1859         JMP.L   _428
000A6A D512C100       +1859         JMP.L   _428
                       1860 ; rtxc.c    845          }
000A6E                 1861 _57:
                       1862 ; rtxc.c    846 
                       1863 ; rtxc.c    847 #ifdef RESOURCE_WAITERS /* { */
                       1864 ; rtxc.c    848 #ifdef PRIORITY_INVERSION /* { */
                       1865 ; rtxc.c    849          if (prh->resattr == PRIORITY_INVERSION_ON)
000A6E 8C1712          1866         MOV.W   R1,[R7+18]
000A71 8C0710          1867         MOV.W   R0,[R7+16]
000A74 862C42          1868         MOV.B   ES,R1L
000A77 9C04100001      1869         CMP.W   [R0+16],#01H
000A7C F244            1870         BNE     _60
                       1871 ; rtxc.c    850          {
                       1872 ; rtxc.c    851             if (prh->priority != (PRIORITY)0)
000A7E 8C1712          1873         MOV.W   R1,[R7+18]
000A81 8C0710          1874         MOV.W   R0,[R7+16]
000A84 9900000E        1875         ADD.W   R0,#0EH
000A88 8C1F0A          1876         MOV.W   [R7+10],R1
000A8B 8C0F08          1877         MOV.W   [R7+8],R0
000A8E 8C1712          1878         MOV.W   R1,[R7+18]
000A91 8C0710          1879         MOV.W   R0,[R7+16]
000A94 862C42          1880         MOV.B   ES,R1L
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  35

ADDR   CODE            LINE SOURCELINE
000A97 84000E          1881         MOV.B   R0L,[R0+14]
000A9A F335            1882         BEQ     _60
                       1883 ; rtxc.c    852             {
                       1884 ; rtxc.c    853                /* return owner task to pre-inversion priority
                       1885 ; rtxc.c    854                 *
                       1886 ; rtxc.c    855                 * note - owner task may have manually changed its priority
                       1887 ; rtxc.c    856                 *        unbeknownst to kernel
                       1888 ; rtxc.c    857                */
                       1889 ; rtxc.c    858 
                       1890 ; rtxc.c    859                /* iff relative priorities are changed then re-prioritize */
                       1891 ; rtxc.c    860                if ( (hipritsk->priority = prh->priority) >
                       1892 ; rtxc.c    861                     hipritsk->flink->priority)
000A9C 866C42          1893         MOV.B   ES,R3L
000A9F 840A0D          1894         MOV.B   [R2+13],R0L
000AA2 866C42          1895         MOV.B   ES,R3L
000AA5 8A42            1896         MOV.W   R4,[R2]
000AA7 8C5202          1897         MOV.W   R5,[R2+2]
000AAA 86AC42          1898         MOV.B   ES,R5L
000AAD 84840D          1899         MOV.B   R4L,[R4+13]
000AB0 8C1712          1900         MOV.W   R1,[R7+18]
000AB3 8C0710          1901         MOV.W   R0,[R7+16]
000AB6 862C42          1902         MOV.B   ES,R1L
000AB9 44880E          1903         CMP.B   [R0+14],R4L
000ABC FD1E            1904         BLE     _58
                       1905 ; rtxc.c    862                {
                       1906 ; rtxc.c    863                   ptcb = hipritsk; /* save for later */
                       1907 ; rtxc.c    864 
                       1908 ; rtxc.c    865                   /* remove self from READY list (ALWAYS first in list) */
                       1909 ; rtxc.c    866                   UNLINK_HIPRITSK();
000ABE 866C42          1910         MOV.B   ES,R3L
000AC1 8A42            1911         MOV.W   R4,[R2]
000AC3 8C5202          1912         MOV.W   R5,[R2+2]
000AC6 8913            1913         MOV.W   R1,R3
000AC8 8902            1914         MOV.W   R0,R2
000ACA 8E5rrr          1915         MOV.W   _hipritsk+2,R5
000ACD 8E4rrr          1916         MOV.W   _hipritsk,R4
000AD0 9928rrrr        1917         MOV.W   R2,#SOF( _hipritsk )
000AD4 B930            1918         MOVS.W  R3,#00H
000AD6 8E5rrr          1919         MOV.W   R5,_hipritsk+2
000AD9 8E4rrr          1920         MOV.W   R4,_hipritsk
000ADC 86AC42          1921         MOV.B   ES,R5L
000ADF 8C2C04          1922         MOV.W   [R4+4],R2
000AE2 8C3C06          1923         MOV.W   [R4+6],R3
                       1924 ; rtxc.c    867 
                       1925 ; rtxc.c    868                   /* re-insert task */
                       1926 ; rtxc.c    869                   ptcb->flink = nsrttcb;
000AE5 8E3rrr          1927         MOV.W   R3,_nsrttcb+2
000AE8 8E2rrr          1928         MOV.W   R2,_nsrttcb
000AEB 862C42          1929         MOV.B   ES,R1L
000AEE 8A28            1930         MOV.W   [R0],R2
000AF0 8C3802          1931         MOV.W   [R0+2],R3
                       1932 ; rtxc.c    870                   nsrttcb = ptcb;
000AF3 8E1rrr          1933         MOV.W   _nsrttcb+2,R1
000AF6 8E0rrr          1934         MOV.W   _nsrttcb,R0
000AF6 8E0rrr00        1934         MOV.W   _nsrttcb,R0
                       1935 ; rtxc.c    871                }
000AFA                 1936 _58:
                       1937 ; rtxc.c    872 
                       1938 ; rtxc.c    873                prh->priority = 0; /* reset priority inversion history flag */
000AFA 8C170A          1939         MOV.W   R1,[R7+10]
000AFD 8C0708          1940         MOV.W   R0,[R7+8]
000B00 862C42          1941         MOV.B   ES,R1L
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  36

ADDR   CODE            LINE SOURCELINE
000B03 B200            1942         MOV.B   [R0],#00H
000B03 B20000          1942         MOV.B   [R0],#00H
                       1943 ; rtxc.c    874             }
                       1944 ; rtxc.c    875          }
000B06                 1945 _60:
                       1946 ; rtxc.c    876 #endif /* } PRIORITY_INVERSION */
                       1947 ; rtxc.c    877 
                       1948 ; rtxc.c    878          /* if any task is waiting for the resource */
                       1949 ; rtxc.c    879          if ( (ptcb = prh->waiters) != NULLTCB)
000B06 8C1712          1950         MOV.W   R1,[R7+18]
000B09 8C0710          1951         MOV.W   R0,[R7+16]
000B0C 99000006        1952         ADD.W   R0,#06H
000B10 8C3712          1953         MOV.W   R3,[R7+18]
000B13 8C2710          1954         MOV.W   R2,[R7+16]
000B16 866C42          1955         MOV.B   ES,R3L
000B19 8C4206          1956         MOV.W   R4,[R2+6]
000B1C 8C5208          1957         MOV.W   R5,[R2+8]
000B1F 8935            1958         MOV.W   R3,R5
000B21 8924            1959         MOV.W   R2,R4
000B23 6932            1960         OR.W    R3,R2
000B25 F363            1961         BEQ     _63
                       1962 ; rtxc.c    880          {
                       1963 ; rtxc.c    881             /* remove first waiter from list */
                       1964 ; rtxc.c    882             if ( (prh->waiters = ptcb->flink) != NULLTCB)
000B27 8C5F0A          1965         MOV.W   [R7+10],R5
000B2A 8C4F08          1966         MOV.W   [R7+8],R4
000B2D 86AC42          1967         MOV.B   ES,R5L
000B30 8A24            1968         MOV.W   R2,[R4]
000B32 8C3402          1969         MOV.W   R3,[R4+2]
000B35 8C5712          1970         MOV.W   R5,[R7+18]
000B38 8C4710          1971         MOV.W   R4,[R7+16]
000B3B 86AC42          1972         MOV.B   ES,R5L
000B3E 8C2C06          1973         MOV.W   [R4+6],R2
000B41 8C3C08          1974         MOV.W   [R4+8],R3
000B44 6932            1975         OR.W    R3,R2
000B46 F30C            1976         BEQ     _61
                       1977 ; rtxc.c    883                ptcb->flink->blink = (TCB ks_tbl *)&prh->waiters;
000B48 8C370A          1978         MOV.W   R3,[R7+10]
000B4B 8C2708          1979         MOV.W   R2,[R7+8]
000B4E 866C42          1980         MOV.B   ES,R3L
000B51 8C3202          1981         MOV.W   R3,[R2+2]
000B54 8A22            1982         MOV.W   R2,[R2]
000B56 866C42          1983         MOV.B   ES,R3L
000B59 8C0A04          1984         MOV.W   [R2+4],R0
000B5C 8C1A06          1985         MOV.W   [R2+6],R1
000B5C 8C1A0600        1985         MOV.W   [R2+6],R1
000B60                 1986 _61:
                       1987 ; rtxc.c    884 
                       1988 ; rtxc.c    885                  /* "resume" first waiter */
                       1989 ; rtxc.c    886             if ( (ptcb->status &= ~RESOURCE_WAIT) == READY)
000B60 8C170A          1990         MOV.W   R1,[R7+10]
000B63 8C0708          1991         MOV.W   R0,[R7+8]
000B66 862C42          1992         MOV.B   ES,R1L
000B69 8C0012          1993         MOV.W   R0,[R0+18]
000B6C 9905FFF7        1994         AND.W   R0,#0FFF7H
000B70 8C570A          1995         MOV.W   R5,[R7+10]
000B73 8C4708          1996         MOV.W   R4,[R7+8]
000B76 86AC42          1997         MOV.B   ES,R5L
000B79 9C4512FFF7      1998         AND.W   [R4+18],#0FFF7H
000B7E 6900            1999         OR.W    R0,R0
000B80 F20A            2000         BNE     _62
                       2001 ; rtxc.c    887             {
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  37

ADDR   CODE            LINE SOURCELINE
                       2002 ; rtxc.c    888                /* insert waiter into READY list */
                       2003 ; rtxc.c    889                ptcb->flink = nsrttcb;
000B82 8E1rrr          2004         MOV.W   R1,_nsrttcb+2
000B85 8E0rrr          2005         MOV.W   R0,_nsrttcb
000B88 86AC42          2006         MOV.B   ES,R5L
000B8B 8A0C            2007         MOV.W   [R4],R0
000B8D 8C1C02          2008         MOV.W   [R4+2],R1
                       2009 ; rtxc.c    890                nsrttcb = ptcb;
000B90 8E5rrr          2010         MOV.W   _nsrttcb+2,R5
000B93 8E4rrr          2011         MOV.W   _nsrttcb,R4
000B93 8E4rrr          2011         MOV.W   _nsrttcb,R4
                       2012 ; rtxc.c    891             }
000B96                 2013 _62:
                       2014 ; rtxc.c    892 
                       2015 ; rtxc.c    893             prh->owner = ptcb; /* mark resource owned */
000B96 8C3712          2016         MOV.W   R3,[R7+18]
000B99 8C2710          2017         MOV.W   R2,[R7+16]
000B9C 866C42          2018         MOV.B   ES,R3L
000B9F 8A4A            2019         MOV.W   [R2],R4
000BA1 8C5A02          2020         MOV.W   [R2+2],R5
                       2021 ; rtxc.c    894             prh->level = 1;
000BA4 8C170E          2022         MOV.W   R1,[R7+14]
000BA7 8C070C          2023         MOV.W   R0,[R7+12]
000BAA 862C42          2024         MOV.B   ES,R1L
000BAD B201            2025         MOV.B   [R0],#01H
                       2026 ; rtxc.c    895 
                       2027 ; rtxc.c    896 #ifdef RESOURCE_TIMEOUTS /* { */
                       2028 ; rtxc.c    897             /* cleanup any pending timeout */
                       2029 ; rtxc.c    898             if ( (pclkblk = ptcb->pclkblk) != NULLCLK)
000BAF 86AC42          2030         MOV.B   ES,R5L
000BB2 8C0408          2031         MOV.W   R0,[R4+8]
000BB5 8C140A          2032         MOV.W   R1,[R4+10]
000BB8 8931            2033         MOV.W   R3,R1
000BBA 8920            2034         MOV.W   R2,R0
000BBC 6932            2035         OR.W    R3,R2
                       2036         BEQ     _428
000BBE F202           +2036 ;       BNE     _LG_112
000BC0 D51216         +2036 ;       JMP.L   _428
000BC0 D5121600       +2036 ;       JMP.L   _428
000BC4                +2036 _LG_112:
                       2037 ; rtxc.c    899             {
                       2038 ; rtxc.c    900                p2a = ((FRAME ks_stk *)(ptcb->sp))->pksnum;
000BC4 86AC42          2039         MOV.B   ES,R5L
000BC7 8C240E          2040         MOV.W   R2,[R4+14]
000BCA 8C3410          2041         MOV.W   R3,[R4+16]
000BCD 866C42          2042         MOV.B   ES,R3L
000BD0 8C3206          2043         MOV.W   R3,[R2+6]
000BD3 8C2204          2044         MOV.W   R2,[R2+4]
                       2045 ; rtxc.c    901                ((struct larg ks_stk *)p2a)->ksrc = RC_GOOD;
000BD6 866C42          2046         MOV.B   ES,R3L
000BD9 BC2002          2047         MOV.W   [R2+2],#00H
                       2048 ; rtxc.c    902 
                       2049 ; rtxc.c    903                unlink_timer(pclkblk);
000BDC C51AE2          2050         CALL    _unlink_timer
                       2051 ; rtxc.c    904                ptcb->pclkblk = NULLCLK;
000BDF 86AC42          2052         MOV.B   ES,R5L
000BE2 BC4008          2053         MOV.W   [R4+8],#00H
000BE5 BC400A          2054         MOV.W   [R4+10],#00H
                       2055 ; rtxc.c    905             }
                       2056 ; rtxc.c    906 #endif /* } RESOURCE_TIMEOUTS */
                       2057 ; rtxc.c    907          }
                       2058         BR      _428
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  38

ADDR   CODE            LINE SOURCELINE
000BE8 D51202         +2058         JMP.L   _428
000BE8 D5120200       +2058         JMP.L   _428
000BEC                 2059 _63:
                       2060 ; rtxc.c    908          else
                       2061 ; rtxc.c    909 #endif /* } RESOURCE_WAITERS */
                       2062 ; rtxc.c    910          {
                       2063 ; rtxc.c    911             prh->owner = NULLTCB; /* mark resource not owned */
000BEC 8C1712          2064         MOV.W   R1,[R7+18]
000BEF 8C0710          2065         MOV.W   R0,[R7+16]
000BF2 862C42          2066         MOV.B   ES,R1L
000BF5 BA00            2067         MOV.W   [R0],#00H
000BF7 BC0002          2068         MOV.W   [R0+2],#00H
                       2069 ; rtxc.c    912             ((struct larg ks_stk *)p2)->ksrc = RC_GOOD;
000BFA 8C1716          2070         MOV.W   R1,[R7+22]
000BFD 8C0714          2071         MOV.W   R0,[R7+20]
000C00 862C42          2072         MOV.B   ES,R1L
000C03 BC0002          2073         MOV.W   [R0+2],#00H
                       2074 ; rtxc.c    913          }
                       2075 ; rtxc.c    914          break;
                       2076         BR      _428
000C06 D511F3         +2076         JMP.L   _428
000C06 D511F300       +2076         JMP.L   _428
                       2077 ; rtxc.c    915 #endif /* } HAS_UNLOCK */
                       2078 ; rtxc.c    916 
                       2079 ; rtxc.c    917 #ifdef HAS_INQRES /* { */
                       2080 ; rtxc.c    918 /************************/
                       2081 ; rtxc.c    919       case RTXC_INQRES:
000C0A                 2082 _64:
                       2083 ; rtxc.c    920 /************************/
                       2084 ; rtxc.c    921          prh = (RHEADER ks_tbl *)&rheader[((struct larg ks_stk *)p2)->resource];
000C0A 86AC42          2085         MOV.B   ES,R5L
000C0D 840404          2086         MOV.B   R0L,[R4+4]
000C10 E80012          2087         MULU.B  R0L,#012H
000C13 B910            2088         MOVS.W  R1,#00H
                       2089 ; rtxc.c    922 
                       2090 ; rtxc.c    923          /* return owner task or 0 if none (0 set in API since faster) */
                       2091 ; rtxc.c    924          if (prh->owner != NULLTCB)
000C15 964842rr        2092         MOV.B   ES,#SEG( _rheader )
000C19 8D20rrrr        2093         MOV.W   R2,[R0+SOF( _rheader )]
000C1D 8D30rrrr        2094         MOV.W   R3,[R0+SOF( _rheader+2 )]
000C21 6932            2095         OR.W    R3,R2
                       2096         BEQ     _428
000C23 F202           +2096 ;       BNE     _LG_114
000C25 D511E3         +2096 ;       JMP.L   _428
000C25 D511E3         +2096 ;       JMP.L   _428
000C28                +2096 _LG_114:
                       2097 ; rtxc.c    925             ((struct larg ks_stk *)p2)->task = prh->owner->task;
000C28 964842rr        2098         MOV.B   ES,#SEG( _rheader )
000C2C 8D10rrrr        2099         MOV.W   R1,[R0+SOF( _rheader+2 )]
000C30 8D00rrrr        2100         MOV.W   R0,[R0+SOF( _rheader )]
000C34 862C42          2101         MOV.B   ES,R1L
000C37 84000C          2102         MOV.B   R0L,[R0+12]
000C3A 86AC42          2103         MOV.B   ES,R5L
000C3D 840C0C          2104         MOV.B   [R4+12],R0L
                       2105 ; rtxc.c    926          break;
                       2106         BR      _428
000C40 D511D6         +2106         JMP.L   _428
000C40 D511D600       +2106         JMP.L   _428
                       2107 ; rtxc.c    927 #endif /* } HAS_INQRES */
                       2108 ; rtxc.c    928 
                       2109 ; rtxc.c    929 #ifdef PRIORITY_INVERSION /* { */
                       2110 ; rtxc.c    930 #ifdef HAS_DEFRES /* { */
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  39

ADDR   CODE            LINE SOURCELINE
                       2111 ; rtxc.c    931 /************************/
                       2112 ; rtxc.c    932       case RTXC_DEFRES:
000C44                 2113 _65:
                       2114 ; rtxc.c    933 /************************/
                       2115 ; rtxc.c    934          prh = (RHEADER ks_tbl *)&rheader[((struct larg ks_stk *)p2)->resource];
000C44 86AC42          2116         MOV.B   ES,R5L
000C47 840404          2117         MOV.B   R0L,[R4+4]
000C4A E80012          2118         MULU.B  R0L,#012H
000C4D B910            2119         MOVS.W  R1,#00H
000C4F 9938rrrr        2120         MOV.W   R3,#SEG( _rheader )
000C53 9928rrrr        2121         MOV.W   R2,#SOF( _rheader )
000C57 0920            2122         ADD.W   R2,R0
                       2123 ; rtxc.c    935 
                       2124 ; rtxc.c    936          /* note: ksrc initialized to RC_GOOD in API */
                       2125 ; rtxc.c    937 
                       2126 ; rtxc.c    938          if (prh->owner == NULLTCB)
000C59 964842rr        2127         MOV.B   ES,#SEG( _rheader )
000C5D 8D10rrrr        2128         MOV.W   R1,[R0+SOF( _rheader+2 )]
000C61 8D00rrrr        2129         MOV.W   R0,[R0+SOF( _rheader )]
000C65 6910            2130         OR.W    R1,R0
000C67 F208            2131         BNE     _66
                       2132 ; rtxc.c    939             prh->resattr = ((struct larg ks_stk *)p2)->resattr;
000C69 86AC42          2133         MOV.B   ES,R5L
000C6C 8C040E          2134         MOV.W   R0,[R4+14]
000C6F 866C42          2135         MOV.B   ES,R3L
000C72 8C0A10          2136         MOV.W   [R2+16],R0
                       2137         BR      _428
000C75 D511BB         +2137         JMP.L   _428
000C75 D511BB         +2137         JMP.L   _428
000C78                 2138 _66:
                       2139 ; rtxc.c    940          else
                       2140 ; rtxc.c    941             ((struct larg ks_stk *)p2)->ksrc = RC_BUSY;
000C78 86AC42          2141         MOV.B   ES,R5L
000C7B 9C48020009      2142         MOV.W   [R4+2],#09H
                       2143 ; rtxc.c    942          break;
                       2144         BR      _428
000C80 D511B6         +2144         JMP.L   _428
000C80 D511B600       +2144         JMP.L   _428
                       2145 ; rtxc.c    943 #endif /* } HAS_DEFRES */
                       2146 ; rtxc.c    944 #endif /* } PRIORITY_INVERSION */
                       2147 ; rtxc.c    945 
                       2148 ; rtxc.c    946 #endif /* } HAS_RESOURCES */
                       2149 ; rtxc.c    947 
                       2150 ; rtxc.c    948 #ifdef HAS_BLOCK /* { */
                       2151 ; rtxc.c    949 /************************/
                       2152 ; rtxc.c    950       case RTXC_BLOCK:
000C84                 2153 _67:
                       2154 ; rtxc.c    951 /************************/
                       2155 ; rtxc.c    952          /* handle block world (all tasks) */
                       2156 ; rtxc.c    953          if ( (endtask = ((struct blkarg ks_stk *)p2)->endtask) == SELFTASK)
000C84 86AC42          2157         MOV.B   ES,R5L
000C87 847402          2158         MOV.B   R3H,[R4+2]
000C8A F206            2159         BNE     _68
                       2160 ; rtxc.c    954             endtask = hipritsk->task; /* -1 could block null task 0 */
000C8C 8E3rrr          2161         MOV.W   R3,_hipritsk+2
000C8F 8E2rrr          2162         MOV.W   R2,_hipritsk
000C92 866C42          2163         MOV.B   ES,R3L
000C95 84720C          2164         MOV.B   R3H,[R2+12]
000C95 84720C          2164         MOV.B   R3H,[R2+12]
000C98                 2165 _68:
                       2166 ; rtxc.c    955 
                       2167 ; rtxc.c    956          if ( (task = ((struct blkarg ks_stk *)p2)->starttask) == SELFTASK)
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  40

ADDR   CODE            LINE SOURCELINE
000C98 86AC42          2168         MOV.B   ES,R5L
000C9B 846401          2169         MOV.B   R3L,[R4+1]
000C9E F206            2170         BNE     _69
                       2171 ; rtxc.c    957             task = hipritsk->task; /* +1 could block past last task */
000CA0 8E1rrr          2172         MOV.W   R1,_hipritsk+2
000CA3 8E0rrr          2173         MOV.W   R0,_hipritsk
000CA6 862C42          2174         MOV.B   ES,R1L
000CA9 84600C          2175         MOV.B   R3L,[R0+12]
000CA9 84600C          2175         MOV.B   R3L,[R0+12]
000CAC                 2176 _69:
                       2177 ; rtxc.c    958 
                       2178 ; rtxc.c    959          for (ptcb = (TCB ks_tbl *)&rtxtcb[task]; task <= endtask; task++, ptcb++
                            )
000CAC 8106            2179         MOV.B   R0L,R3L
000CAE 9019            2180         SEXT.B  R0H
000CB0 E9000024        2181         MULU.W  R0,#024H
000CB4 8940            2182         MOV.W   R4,R0
000CB6 B950            2183         MOVS.W  R5,#00H
000CB8 9918rrrr        2184         MOV.W   R1,#SEG( _rtxtcb )
000CBC 9908rrrr        2185         MOV.W   R0,#SOF( _rtxtcb )
000CC0 0904            2186         ADD.W   R0,R4
000CC2 8C1F16          2187         MOV.W   [R7+22],R1
000CC5 8C0F14          2188         MOV.W   [R7+20],R0
000CC8 4167            2189         CMP.B   R3L,R3H
                       2190         BGT     _428
000CCA FD02           +2190 ;       BLE     _LG_122
000CCC D51190         +2190 ;       JMP.L   _428
000CCC D5119000       +2190 ;       JMP.L   _428
000CD0                +2190 _LG_122:
000CD0                +2190 _LG_122:
000CD0                 2191 _70:
                       2192 ; rtxc.c    960          {
                       2193 ; rtxc.c    961             if (hipritsk->task == task) /* never block self */
000CD0 8E1rrr          2194         MOV.W   R1,_hipritsk+2
000CD3 8E0rrr          2195         MOV.W   R0,_hipritsk
000CD6 862C42          2196         MOV.B   ES,R1L
000CD9 44680C          2197         CMP.B   [R0+12],R3L
000CDC F343            2198         BEQ     _72
                       2199 ; rtxc.c    962                continue;
                       2200 ; rtxc.c    963 
                       2201 ; rtxc.c    964             if (ptcb->status == READY)
000CDE 8C1716          2202         MOV.W   R1,[R7+22]
000CE1 8C0714          2203         MOV.W   R0,[R7+20]
000CE4 99000012        2204         ADD.W   R0,#012H
000CE8 8C1F12          2205         MOV.W   [R7+18],R1
000CEB 8C0F10          2206         MOV.W   [R7+16],R0
000CEE 8C1716          2207         MOV.W   R1,[R7+22]
000CF1 8C0714          2208         MOV.W   R0,[R7+20]
000CF4 862C42          2209         MOV.B   ES,R1L
000CF7 8C2012          2210         MOV.W   R2,[R0+18]
000CFA F22C            2211         BNE     _71
                       2212 ; rtxc.c    965             {
                       2213 ; rtxc.c    966                ptcb->flink->blink = ptcb->blink; /* general unlink */
000CFC 8C1716          2214         MOV.W   R1,[R7+22]
000CFF 8C0714          2215         MOV.W   R0,[R7+20]
000D02 862C42          2216         MOV.B   ES,R1L
000D05 8C4004          2217         MOV.W   R4,[R0+4]
000D08 8C5006          2218         MOV.W   R5,[R0+6]
000D0B 8C1716          2219         MOV.W   R1,[R7+22]
000D0E 8C0714          2220         MOV.W   R0,[R7+20]
000D11 862C42          2221         MOV.B   ES,R1L
000D14 8C1002          2222         MOV.W   R1,[R0+2]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  41

ADDR   CODE            LINE SOURCELINE
000D17 8A00            2223         MOV.W   R0,[R0]
000D19 862C42          2224         MOV.B   ES,R1L
000D1C 8C4804          2225         MOV.W   [R0+4],R4
000D1F 8C5806          2226         MOV.W   [R0+6],R5
                       2227 ; rtxc.c    967                ptcb->blink->flink = ptcb->flink;
000D22 8C1716          2228         MOV.W   R1,[R7+22]
000D25 8C0714          2229         MOV.W   R0,[R7+20]
000D28 862C42          2230         MOV.B   ES,R1L
000D2B 8A40            2231         MOV.W   R4,[R0]
000D2D 8C5002          2232         MOV.W   R5,[R0+2]
000D30 8C5F0E          2233         MOV.W   [R7+14],R5
000D33 8C4F0C          2234         MOV.W   [R7+12],R4
000D36 8C1716          2235         MOV.W   R1,[R7+22]
000D39 8C0714          2236         MOV.W   R0,[R7+20]
000D3C 862C42          2237         MOV.B   ES,R1L
000D3F 8C4004          2238         MOV.W   R4,[R0+4]
000D42 8C5006          2239         MOV.W   R5,[R0+6]
000D45 8C170E          2240         MOV.W   R1,[R7+14]
000D48 8C070C          2241         MOV.W   R0,[R7+12]
000D4B 86AC42          2242         MOV.B   ES,R5L
000D4E 8A0C            2243         MOV.W   [R4],R0
000D50 8C1C02          2244         MOV.W   [R4+2],R1
000D50 8C1C0200        2244         MOV.W   [R4+2],R1
                       2245 ; rtxc.c    968             }
000D54                 2246 _71:
                       2247 ; rtxc.c    969 
                       2248 ; rtxc.c    970             ptcb->status |= BLOCK_WAIT;
000D54 99260010        2249         OR.W    R2,#010H
000D58 8C1712          2250         MOV.W   R1,[R7+18]
000D5B 8C0710          2251         MOV.W   R0,[R7+16]
000D5E 862C42          2252         MOV.B   ES,R1L
000D61 8A28            2253         MOV.W   [R0],R2
000D61 8A2800          2253         MOV.W   [R0],R2
000D64                 2254 _72:
000D64 A161            2255         ADDS.B  R3L,#01H
000D66 8C1716          2256         MOV.W   R1,[R7+22]
000D69 8C0714          2257         MOV.W   R0,[R7+20]
000D6C 99000024        2258         ADD.W   R0,#024H
000D70 8C1F16          2259         MOV.W   [R7+22],R1
000D73 8C0F14          2260         MOV.W   [R7+20],R0
000D76 4167            2261         CMP.B   R3L,R3H
000D78 FDAB            2262         BLE     _70
                       2263 ; rtxc.c    971          }
                       2264 ; rtxc.c    972          break;
                       2265         BR      _428
000D7A D51139         +2265         JMP.L   _428
000D7A D5113900       +2265         JMP.L   _428
                       2266 ; rtxc.c    973 #endif /* } HAS_BLOCK */
                       2267 ; rtxc.c    974 
                       2268 ; rtxc.c    975 #ifdef HAS_UNBLOCK /* { */
                       2269 ; rtxc.c    976 /************************/
                       2270 ; rtxc.c    977       case RTXC_UNBLOCK:
000D7E                 2271 _73:
                       2272 ; rtxc.c    978 /************************/
                       2273 ; rtxc.c    979          if ( (endtask = ((struct blkarg ks_stk *)p2)->endtask) == SELFTASK)
000D7E 86AC42          2274         MOV.B   ES,R5L
000D81 845402          2275         MOV.B   R2H,[R4+2]
000D84 F206            2276         BNE     _74
                       2277 ; rtxc.c    980             endtask = hipritsk->task; /* -1 could unblock null task */
000D86 8E3rrr          2278         MOV.W   R3,_hipritsk+2
000D89 8E2rrr          2279         MOV.W   R2,_hipritsk
000D8C 866C42          2280         MOV.B   ES,R3L
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  42

ADDR   CODE            LINE SOURCELINE
000D8F 84520C          2281         MOV.B   R2H,[R2+12]
000D8F 84520C          2281         MOV.B   R2H,[R2+12]
000D92                 2282 _74:
                       2283 ; rtxc.c    981 
                       2284 ; rtxc.c    982          if ( (task = ((struct blkarg ks_stk *)p2)->starttask) == SELFTASK)
000D92 86AC42          2285         MOV.B   ES,R5L
000D95 844401          2286         MOV.B   R2L,[R4+1]
000D98 F206            2287         BNE     _75
                       2288 ; rtxc.c    983             task = hipritsk->task; /* +1 could unblock past last task */
000D9A 8E1rrr          2289         MOV.W   R1,_hipritsk+2
000D9D 8E0rrr          2290         MOV.W   R0,_hipritsk
000DA0 862C42          2291         MOV.B   ES,R1L
000DA3 84400C          2292         MOV.B   R2L,[R0+12]
000DA3 84400C          2292         MOV.B   R2L,[R0+12]
000DA6                 2293 _75:
                       2294 ; rtxc.c    984 
                       2295 ; rtxc.c    985          for (ptcb = (TCB ks_tbl *)&rtxtcb[task]; task <= endtask; task++, ptcb++
                            )
000DA6 8104            2296         MOV.B   R0L,R2L
000DA8 9019            2297         SEXT.B  R0H
000DAA E9000024        2298         MULU.W  R0,#024H
000DAE 8940            2299         MOV.W   R4,R0
000DB0 B950            2300         MOVS.W  R5,#00H
000DB2 9918rrrr        2301         MOV.W   R1,#SEG( _rtxtcb )
000DB6 9908rrrr        2302         MOV.W   R0,#SOF( _rtxtcb )
000DBA 0904            2303         ADD.W   R0,R4
000DBC 4145            2304         CMP.B   R2L,R2H
                       2305         BGT     _428
000DBE FD02           +2305 ;       BLE     _LG_134
000DC0 D51116         +2305 ;       JMP.L   _428
000DC0 D5111600       +2305 ;       JMP.L   _428
000DC4                +2305 _LG_134:
000DC4                +2305 _LG_134:
000DC4                 2306 _76:
                       2307 ; rtxc.c    986          {
                       2308 ; rtxc.c    987             if (ptcb->status == READY)
000DC4 862C42          2309         MOV.B   ES,R1L
000DC7 8C3012          2310         MOV.W   R3,[R0+18]
000DCA F312            2311         BEQ     _78
                       2312 ; rtxc.c    988                continue;
                       2313 ; rtxc.c    989 
                       2314 ; rtxc.c    990             if ( (ptcb->status &= ~BLOCK_WAIT) == READY)
000DCC 9935FFEF        2315         AND.W   R3,#0FFEFH
000DD0 862C42          2316         MOV.B   ES,R1L
000DD3 9C0512FFEF      2317         AND.W   [R0+18],#0FFEFH
000DD8 6933            2318         OR.W    R3,R3
000DDA F20A            2319         BNE     _78
                       2320 ; rtxc.c    991             {
                       2321 ; rtxc.c    992                ptcb->flink = nsrttcb;
000DDC 8E5rrr          2322         MOV.W   R5,_nsrttcb+2
000DDF 8E4rrr          2323         MOV.W   R4,_nsrttcb
000DE2 862C42          2324         MOV.B   ES,R1L
000DE5 8A48            2325         MOV.W   [R0],R4
000DE7 8C5802          2326         MOV.W   [R0+2],R5
                       2327 ; rtxc.c    993                nsrttcb = ptcb;
000DEA 8E1rrr          2328         MOV.W   _nsrttcb+2,R1
000DED 8E0rrr          2329         MOV.W   _nsrttcb,R0
000DED 8E0rrr          2329         MOV.W   _nsrttcb,R0
000DF0                 2330 _78:
000DF0 A141            2331         ADDS.B  R2L,#01H
000DF2 99000024        2332         ADD.W   R0,#024H
000DF6 4145            2333         CMP.B   R2L,R2H
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  43

ADDR   CODE            LINE SOURCELINE
000DF8 FDE5            2334         BLE     _76
                       2335 ; rtxc.c    994             }
                       2336 ; rtxc.c    995          }
                       2337 ; rtxc.c    996          break;
                       2338         BR      _428
000DFA D510F9         +2338         JMP.L   _428
000DFA D510F900       +2338         JMP.L   _428
                       2339 ; rtxc.c    997 #endif /* } HAS_UNBLOCK */
                       2340 ; rtxc.c    998 
                       2341 ; rtxc.c    999 #ifdef HAS_ALLOC_TIMER /* { */
                       2342 ; rtxc.c   1000 /************************/
                       2343 ; rtxc.c   1001       case RTXC_ALLOC_TIMER:
000DFE                 2344 _79:
                       2345 ; rtxc.c   1002 /************************/
                       2346 ; rtxc.c   1003          ((struct clkarg ks_stk *)p2)->pclkblk = get_clkblk();
000DFE C518C7          2347         CALL    _get_clkblk
000E01 86AC42          2348         MOV.B   ES,R5L
000E04 8C0C0A          2349         MOV.W   [R4+10],R0
000E07 8C1C0C          2350         MOV.W   [R4+12],R1
                       2351 ; rtxc.c   1004          break;
                       2352         BR      _428
000E0A D510F1         +2352         JMP.L   _428
000E0A D510F100       +2352         JMP.L   _428
                       2353 ; rtxc.c   1005 #endif /* } HAS_ALLOC_TIMER */
                       2354 ; rtxc.c   1006 
                       2355 ; rtxc.c   1007 #ifdef HAS_FREE_TIMER /* { */
                       2356 ; rtxc.c   1008 /************************/
                       2357 ; rtxc.c   1009       case RTXC_FREE_TIMER:
000E0E                 2358 _80:
                       2359 ; rtxc.c   1010 /************************/
                       2360 ; rtxc.c   1011          pclkblk = ((struct clkarg ks_stk *)p2)->pclkblk;
000E0E 86AC42          2361         MOV.B   ES,R5L
000E11 8C540C          2362         MOV.W   R5,[R4+12]
000E14 8C440A          2363         MOV.W   R4,[R4+10]
                       2364 ; rtxc.c   1012 
                       2365 ; rtxc.c   1013          if (pclkblk->state == TIMER_ACTIVE)
000E17 86AC42          2366         MOV.B   ES,R5L
000E1A 94440D01        2367         CMP.B   [R4+13],#01H
000E1E F204            2368         BNE     _81
000E20 8915            2369         MOV.W   R1,R5
000E22 8904            2370         MOV.W   R0,R4
                       2371 ; rtxc.c   1014          {
                       2372 ; rtxc.c   1015             unlink_timer(pclkblk);
000E24 C519BE          2373         CALL    _unlink_timer
000E24 C519BE00        2373         CALL    _unlink_timer
                       2374 ; rtxc.c   1016          }
000E28                 2375 _81:
                       2376 ; rtxc.c   1017 
                       2377 ; rtxc.c   1018          pclkblk->flink = clkqfl; /* insert block at front of free list */
000E28 964842rr        2378         MOV.B   ES,#SEG( _clkqfl )
000E2C 9918rrrr        2379         MOV.W   R1,#SOF( _clkqfl )
000E30 8B01            2380         MOV.W   R0,[R1+]
000E32 8A11            2381         MOV.W   R1,[R1]
000E34 86AC42          2382         MOV.B   ES,R5L
000E37 8A0C            2383         MOV.W   [R4],R0
000E39 8C1C02          2384         MOV.W   [R4+2],R1
                       2385 ; rtxc.c   1019          clkqfl = pclkblk;
000E3C 964842rr        2386         MOV.B   ES,#SEG( _clkqfl )
000E40 9908rrrr        2387         MOV.W   R0,#SOF( _clkqfl )
000E44 8B48            2388         MOV.W   [R0+],R4
000E46 8A58            2389         MOV.W   [R0],R5
                       2390 ; rtxc.c   1020          break;
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  44

ADDR   CODE            LINE SOURCELINE
                       2391         BR      _428
000E48 D510D2         +2391         JMP.L   _428
000E48 D510D200       +2391         JMP.L   _428
                       2392 ; rtxc.c   1021 #endif /* } HAS_FREE_TIMER */
                       2393 ; rtxc.c   1022 
                       2394 ; rtxc.c   1023 #ifdef HAS_STOP_TIMER /* { */
                       2395 ; rtxc.c   1024 /************************/
                       2396 ; rtxc.c   1025       case RTXC_STOP_TIMER:
                       2397 ; rtxc.c   1026 /************************/
                       2398 ; rtxc.c   1027          /* fall through to common code */
                       2399 ; rtxc.c   1028 #endif /* } HAS_STOP_TIMER */
                       2400 ; rtxc.c   1029 #ifdef HAS_RESTART_TIMER /* { */
                       2401 ; rtxc.c   1030 /************************/
                       2402 ; rtxc.c   1031       case RTXC_RESTART_TIMER:
                       2403 ; rtxc.c   1032 /************************/
                       2404 ; rtxc.c   1033          /* fall through to common code */
                       2405 ; rtxc.c   1034 #endif /* } HAS_RESTART_TIMER */
                       2406 ; rtxc.c   1035 #ifdef HAS_START_TIMER /* { */
                       2407 ; rtxc.c   1036 /************************/
                       2408 ; rtxc.c   1037       case RTXC_START_TIMER:
000E4C                 2409 _84:
                       2410 ; rtxc.c   1038 /************************/
                       2411 ; rtxc.c   1039 
                       2412 ; rtxc.c   1040          if ( (pclkblk = ((struct clkarg ks_stk *)p2)->pclkblk) == NULLCLK)
000E4C 8935            2413         MOV.W   R3,R5
000E4E 8924            2414         MOV.W   R2,R4
000E50 8913            2415         MOV.W   R1,R3
000E52 8902            2416         MOV.W   R0,R2
000E54 9900000A        2417         ADD.W   R0,#0AH
000E58 8C1F12          2418         MOV.W   [R7+18],R1
000E5B 8C0F10          2419         MOV.W   [R7+16],R0
000E5E 8C3F16          2420         MOV.W   [R7+22],R3
000E61 8C2F14          2421         MOV.W   [R7+20],R2
000E64 866C42          2422         MOV.B   ES,R3L
000E67 8C020A          2423         MOV.W   R0,[R2+10]
000E6A 8C120C          2424         MOV.W   R1,[R2+12]
000E6D 8C1F0E          2425         MOV.W   [R7+14],R1
000E70 8C0F0C          2426         MOV.W   [R7+12],R0
000E73 6910            2427         OR.W    R1,R0
000E75 F21F            2428         BNE     _86
                       2429 ; rtxc.c   1041          {
                       2430 ; rtxc.c   1042             if (*p2 != RTXC_START_TIMER)
000E77 86AC42          2431         MOV.B   ES,R5L
000E7A 924412          2432         CMP.B   [R4],#012H
000E7D F308            2433         BEQ     _85
                       2434 ; rtxc.c   1043             {
                       2435 ; rtxc.c   1044 #ifdef HAS_RESTART_TIMER /* { */
                       2436 ; rtxc.c   1045                /* no clkblk sent for RTXC_STOP_TIMER or RTXC_RESTART_TIMER */
                       2437 ; rtxc.c   1046 #else /* } HAS_RESTART_TIMER { */
                       2438 ; rtxc.c   1047                /* no clkblk sent for RTXC_STOP_TIMER */
                       2439 ; rtxc.c   1048 #endif /* } HAS_RESTART_TIMER */
                       2440 ; rtxc.c   1049                ((struct clkarg ks_stk *)p2)->ksrc = RC_TIMER_ILLEGAL;
000E7F 8C1716          2441         MOV.W   R1,[R7+22]
000E82 8C0714          2442         MOV.W   R0,[R7+20]
000E85 862C42          2443         MOV.B   ES,R1L
000E88 BC0402          2444         MOV.W   [R0+2],#04H
                       2445 ; rtxc.c   1050                break;
                       2446         BR      _428
000E8B D510B0         +2446         JMP.L   _428
000E8B D510B0         +2446         JMP.L   _428
                       2447 ; rtxc.c   1051             }
000E8E                 2448 _85:
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  45

ADDR   CODE            LINE SOURCELINE
                       2449 ; rtxc.c   1052             else /* is RTXC_START_TIMER */
                       2450 ; rtxc.c   1053             {
                       2451 ; rtxc.c   1054                if ( (pclkblk = get_clkblk()) == NULLCLK)
000E8E C5187F          2452         CALL    _get_clkblk
000E91 8C1F0E          2453         MOV.W   [R7+14],R1
000E94 8C0F0C          2454         MOV.W   [R7+12],R0
000E97 6910            2455         OR.W    R1,R0
                       2456         BEQ     _428
000E99 F202           +2456 ;       BNE     _LG_148
000E9B D510A8         +2456 ;       JMP.L   _428
000E9B D510A8         +2456 ;       JMP.L   _428
000E9E                +2456 _LG_148:
                       2457 ; rtxc.c   1055                   break; /* no timer available, NULLCLK returned */
                       2458 ; rtxc.c   1056                else
                       2459 ; rtxc.c   1057                   ((struct clkarg ks_stk *)p2)->pclkblk = pclkblk;
000E9E 8C1712          2460         MOV.W   R1,[R7+18]
000EA1 8C0710          2461         MOV.W   R0,[R7+16]
000EA4 8C370E          2462         MOV.W   R3,[R7+14]
000EA7 8C270C          2463         MOV.W   R2,[R7+12]
000EAA 862C42          2464         MOV.B   ES,R1L
000EAD 8A28            2465         MOV.W   [R0],R2
000EAF 8C3802          2466         MOV.W   [R0+2],R3
                       2467 ; rtxc.c   1058             }
                       2468 ; rtxc.c   1059          }
000EB2 FE19            2469         BR      _89
000EB2 FE19            2469         BR      _89
000EB4                 2470 _86:
                       2471 ; rtxc.c   1060          else /* clkblk was sent */
                       2472 ; rtxc.c   1061          {
                       2473 ; rtxc.c   1062             if (*p2 != RTXC_START_TIMER)
000EB4 86AC42          2474         MOV.B   ES,R5L
000EB7 924412          2475         CMP.B   [R4],#012H
000EBA F315            2476         BEQ     _89
                       2477 ; rtxc.c   1063             {
                       2478 ; rtxc.c   1064                if (pclkblk->task != hipritsk->task)
000EBC 8E1rrr          2479         MOV.W   R1,_hipritsk+2
000EBF 8E0rrr          2480         MOV.W   R0,_hipritsk
000EC2 862C42          2481         MOV.B   ES,R1L
000EC5 84000C          2482         MOV.B   R0L,[R0+12]
000EC8 8C370E          2483         MOV.W   R3,[R7+14]
000ECB 8C270C          2484         MOV.W   R2,[R7+12]
000ECE 866C42          2485         MOV.B   ES,R3L
000ED1 440A0C          2486         CMP.B   [R2+12],R0L
000ED4 F308            2487         BEQ     _89
                       2488 ; rtxc.c   1065                {
                       2489 ; rtxc.c   1066 #ifdef HAS_RESTART_TIMER /* { */
                       2490 ; rtxc.c   1067                   /* attempt to STOP or RESTART someone else's timer */
                       2491 ; rtxc.c   1068 #else /* } HAS_RESTART_TIMER { */
                       2492 ; rtxc.c   1069                   /* attempt to STOP someone else's timer */
                       2493 ; rtxc.c   1070 #endif /* } HAS_RESTART_TIMER */
                       2494 ; rtxc.c   1071                   ((struct clkarg ks_stk *)p2)->ksrc = RC_TIMER_ILLEGAL;
000ED6 8C1716          2495         MOV.W   R1,[R7+22]
000ED9 8C0714          2496         MOV.W   R0,[R7+20]
000EDC 862C42          2497         MOV.B   ES,R1L
000EDF BC0402          2498         MOV.W   [R0+2],#04H
                       2499 ; rtxc.c   1072                   break;
                       2500         BR      _428
000EE2 D51085         +2500         JMP.L   _428
000EE2 D5108500       +2500         JMP.L   _428
                       2501 ; rtxc.c   1073                }
                       2502 ; rtxc.c   1074             }
                       2503 ; rtxc.c   1075          }
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  46

ADDR   CODE            LINE SOURCELINE
000EE6                 2504 _89:
                       2505 ; rtxc.c   1076 
                       2506 ; rtxc.c   1077          if (pclkblk->state == TIMER_DONE)
000EE6 8C170E          2507         MOV.W   R1,[R7+14]
000EE9 8C070C          2508         MOV.W   R0,[R7+12]
000EEC 862C42          2509         MOV.B   ES,R1L
000EEF 84000D          2510         MOV.B   R0L,[R0+13]
000EF2 F20C            2511         BNE     _90
                       2512 ; rtxc.c   1078          {
                       2513 ; rtxc.c   1079             if (*p2 == RTXC_STOP_TIMER)
000EF4 86AC42          2514         MOV.B   ES,R5L
000EF7 924413          2515         CMP.B   [R4],#013H
000EFA F212            2516         BNE     _91
                       2517 ; rtxc.c   1080             {
                       2518 ; rtxc.c   1081                ((struct clkarg ks_stk *)p2)->ksrc = RC_TIMER_INACTIVE;
000EFC 8C1716          2519         MOV.W   R1,[R7+22]
000EFF 8C0714          2520         MOV.W   R0,[R7+20]
000F02 862C42          2521         MOV.B   ES,R1L
000F05 BC0302          2522         MOV.W   [R0+2],#03H
                       2523 ; rtxc.c   1082                break;
                       2524         BR      _428
000F08 D51072         +2524         JMP.L   _428
000F08 D5107200       +2524         JMP.L   _428
                       2525 ; rtxc.c   1083             }
                       2526 ; rtxc.c   1084          }
000F0C                 2527 _90:
000F0C 8C170E          2528         MOV.W   R1,[R7+14]
000F0F 8C070C          2529         MOV.W   R0,[R7+12]
                       2530 ; rtxc.c   1085          else   /* stop active timer */
                       2531 ; rtxc.c   1086          {
                       2532 ; rtxc.c   1087             unlink_timer(pclkblk);
000F12 C51947          2533         CALL    _unlink_timer
                       2534 ; rtxc.c   1088 
                       2535 ; rtxc.c   1089             if (*p2 == RTXC_STOP_TIMER)
000F15 86AC42          2536         MOV.B   ES,R5L
000F18 924413          2537         CMP.B   [R4],#013H
                       2538         BEQ     _428
000F1B F202           +2538 ;       BNE     _LG_158
000F1D D51067         +2538 ;       JMP.L   _428
000F1D D51067         +2538 ;       JMP.L   _428
000F20                +2538 _LG_158:
000F20                +2538 _LG_158:
                       2539 ; rtxc.c   1090                break;
                       2540 ; rtxc.c   1091          }
000F20                 2541 _91:
                       2542 ; rtxc.c   1092 
                       2543 ; rtxc.c   1093 #ifdef HAS_RESTART_TIMER /* { */
                       2544 ; rtxc.c   1094          /* at this point, the function is START_TIMER or RESTART_TIMER */
                       2545 ; rtxc.c   1095 #else /* } HAS_RESTART_TIMER { */
                       2546 ; rtxc.c   1096          /* at this point, the function should be START_TIMER */
                       2547 ; rtxc.c   1097 #endif /* } HAS_RESTART_TIMER */
                       2548 ; rtxc.c   1098 
                       2549 ; rtxc.c   1099          if (*p2 == RTXC_START_TIMER)
000F20 86AC42          2550         MOV.B   ES,R5L
000F23 924412          2551         CMP.B   [R4],#012H
000F26 F25A            2552         BNE     _94
                       2553 ; rtxc.c   1100          {
                       2554 ; rtxc.c   1101             /* if special case of zero initial and recycle times ... */
                       2555 ; rtxc.c   1102             /* signal semaphore and leave */
                       2556 ; rtxc.c   1103             if ( ((struct clkarg ks_stk *)p2)->ticks == (TICKS)0 &&
                       2557 ; rtxc.c   1104                  ((struct clkarg ks_stk *)p2)->period == (TICKS)0 )
000F28 8C3716          2558         MOV.W   R3,[R7+22]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  47

ADDR   CODE            LINE SOURCELINE
000F2B 8C2714          2559         MOV.W   R2,[R7+20]
000F2E 99200006        2560         ADD.W   R2,#06H
000F32 8C1716          2561         MOV.W   R1,[R7+22]
000F35 8C0714          2562         MOV.W   R0,[R7+20]
000F38 862C42          2563         MOV.B   ES,R1L
000F3B 8C0006          2564         MOV.W   R0,[R0+6]
000F3E F22B            2565         BNE     _93
000F40 8C5716          2566         MOV.W   R5,[R7+22]
000F43 8C4714          2567         MOV.W   R4,[R7+20]
000F46 86AC42          2568         MOV.B   ES,R5L
000F49 8C1408          2569         MOV.W   R1,[R4+8]
000F4C F224            2570         BNE     _93
                       2571 ; rtxc.c   1105             {
                       2572 ; rtxc.c   1106                pclkblk->task = hipritsk->task;
000F4E 8E1rrr          2573         MOV.W   R1,_hipritsk+2
000F51 8E0rrr          2574         MOV.W   R0,_hipritsk
000F54 862C42          2575         MOV.B   ES,R1L
000F57 84000C          2576         MOV.B   R0L,[R0+12]
000F5A 8C370E          2577         MOV.W   R3,[R7+14]
000F5D 8C270C          2578         MOV.W   R2,[R7+12]
000F60 866C42          2579         MOV.B   ES,R3L
000F63 840A0C          2580         MOV.B   [R2+12],R0L
                       2581 ; rtxc.c   1107                SIGNAL(((struct clkarg ks_stk *)p2)->sema);
000F66 860401          2582         MOV.B   R0L,0401H
000F69 9648018D        2583         MOV.B   0401H,#08DH
000F6D 8C3716          2584         MOV.W   R3,[R7+22]
000F70 8C2714          2585         MOV.W   R2,[R7+20]
000F73 866C42          2586         MOV.B   ES,R3L
000F76 841204          2587         MOV.B   R0H,[R2+4]
000F79 9Er0rr0001      2588         ADD.W   _semaput,#01H
000F7E 8E3rrr          2589         MOV.W   R3,_semaput+2
000F81 8E2rrr          2590         MOV.W   R2,_semaput
000F84 866C42          2591         MOV.B   ES,R3L
000F87 821A            2592         MOV.B   [R2],R0H
000F89 8E3rrr          2593         MOV.W   _semaput+2,R3
000F8C 8E2rrr          2594         MOV.W   _semaput,R2
000F8F 860C01          2595         MOV.B   0401H,R0L
                       2596 ; rtxc.c   1108                break;
                       2597         BR      _428
000F92 D5102D         +2597         JMP.L   _428
000F92 D5102D00       +2597         JMP.L   _428
                       2598 ; rtxc.c   1109             }
000F96                 2599 _93:
                       2600 ; rtxc.c   1110 
                       2601 ; rtxc.c   1111             /* if zero initial time and non-zero recycle time ... */
                       2602 ; rtxc.c   1112             /* start timer with recycle time & signal semaphore */
                       2603 ; rtxc.c   1113             if ( ((struct clkarg ks_stk *)p2)->ticks == (TICKS)0 &&
                       2604 ; rtxc.c   1114                  ((struct clkarg ks_stk *)p2)->period != (TICKS)0 )
000F96 6900            2605         OR.W    R0,R0
000F98 F22D            2606         BNE     _97
000F9A 8C1716          2607         MOV.W   R1,[R7+22]
000F9D 8C0714          2608         MOV.W   R0,[R7+20]
000FA0 862C42          2609         MOV.B   ES,R1L
000FA3 8C0008          2610         MOV.W   R0,[R0+8]
000FA6 F326            2611         BEQ     _97
                       2612 ; rtxc.c   1115             {
                       2613 ; rtxc.c   1116                ((struct clkarg ks_stk *)p2)->ticks =
                       2614 ; rtxc.c   1117                            ((struct clkarg ks_stk *)p2)->period;
000FA8 866C42          2615         MOV.B   ES,R3L
000FAB 8A0A            2616         MOV.W   [R2],R0
                       2617 ; rtxc.c   1118                SIGNAL(((struct clkarg ks_stk *)p2)->sema);
000FAD 864401          2618         MOV.B   R2L,0401H
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  48

ADDR   CODE            LINE SOURCELINE
000FB0 9648018D        2619         MOV.B   0401H,#08DH
000FB4 8C1716          2620         MOV.W   R1,[R7+22]
000FB7 8C0714          2621         MOV.W   R0,[R7+20]
000FBA 862C42          2622         MOV.B   ES,R1L
000FBD 840004          2623         MOV.B   R0L,[R0+4]
000FC0 9Er0rr0001      2624         ADD.W   _semaput,#01H
000FC5 8E5rrr          2625         MOV.W   R5,_semaput+2
000FC8 8E4rrr          2626         MOV.W   R4,_semaput
000FCB 86AC42          2627         MOV.B   ES,R5L
000FCE 820C            2628         MOV.B   [R4],R0L
000FD0 8E5rrr          2629         MOV.W   _semaput+2,R5
000FD3 8E4rrr          2630         MOV.W   _semaput,R4
000FD6 864C01          2631         MOV.B   0401H,R2L
                       2632 ; rtxc.c   1119             }
                       2633 ; rtxc.c   1120          }
000FD9 FE0D            2634         BR      _97
000FD9 FE0D00          2634         BR      _97
000FDC                 2635 _94:
                       2636 ; rtxc.c   1121 #ifdef HAS_RESTART_TIMER /* { */
                       2637 ; rtxc.c   1122          else  /* is RTXC_RESTART_TIMER */
                       2638 ; rtxc.c   1123          {
                       2639 ; rtxc.c   1124             /* get sema from clkblk & put in arg struct */
                       2640 ; rtxc.c   1125             ((struct clkarg ks_stk *)p2)->sema = pclkblk->objid;
000FDC 8C170E          2641         MOV.W   R1,[R7+14]
000FDF 8C070C          2642         MOV.W   R0,[R7+12]
000FE2 862C42          2643         MOV.B   ES,R1L
000FE5 840010          2644         MOV.B   R0L,[R0+16]
000FE8 8C3716          2645         MOV.W   R3,[R7+22]
000FEB 8C2714          2646         MOV.W   R2,[R7+20]
000FEE 866C42          2647         MOV.B   ES,R3L
000FF1 840A04          2648         MOV.B   [R2+4],R0L
000FF1 840A04          2648         MOV.B   [R2+4],R0L
                       2649 ; rtxc.c   1126          }
000FF4                 2650 _97:
                       2651 ; rtxc.c   1127 #endif /* } HAS_RESTART_TIMER */
                       2652 ; rtxc.c   1128 
                       2653 ; rtxc.c   1129          pclkblk->remain = ((struct clkarg ks_stk *)p2)->ticks;
000FF4 8C1716          2654         MOV.W   R1,[R7+22]
000FF7 8C0714          2655         MOV.W   R0,[R7+20]
000FFA 862C42          2656         MOV.B   ES,R1L
000FFD 8C0006          2657         MOV.W   R0,[R0+6]
001000 8C370E          2658         MOV.W   R3,[R7+14]
001003 8C270C          2659         MOV.W   R2,[R7+12]
001006 866C42          2660         MOV.B   ES,R3L
001009 8C0A08          2661         MOV.W   [R2+8],R0
                       2662 ; rtxc.c   1130          pclkblk->recycle = ((struct clkarg ks_stk *)p2)->period;
00100C 8C1716          2663         MOV.W   R1,[R7+22]
00100F 8C0714          2664         MOV.W   R0,[R7+20]
001012 862C42          2665         MOV.B   ES,R1L
001015 8C0008          2666         MOV.W   R0,[R0+8]
001018 866C42          2667         MOV.B   ES,R3L
00101B 8C0A0A          2668         MOV.W   [R2+10],R0
                       2669 ; rtxc.c   1131 
                       2670 ; rtxc.c   1132          /* mark object type */
                       2671 ; rtxc.c   1133          pclkblk->objtype = TIMER_OBJ;
00101E 8C370E          2672         MOV.W   R3,[R7+14]
001021 8C270C          2673         MOV.W   R2,[R7+12]
001024 866C42          2674         MOV.B   ES,R3L
001027 BC260E          2675         MOV.W   [R2+14],#06H
                       2676 ; rtxc.c   1134          pclkblk->task = hipritsk->task;
00102A 8E1rrr          2677         MOV.W   R1,_hipritsk+2
00102D 8E0rrr          2678         MOV.W   R0,_hipritsk
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  49

ADDR   CODE            LINE SOURCELINE
001030 862C42          2679         MOV.B   ES,R1L
001033 84000C          2680         MOV.B   R0L,[R0+12]
001036 866C42          2681         MOV.B   ES,R3L
001039 840A0C          2682         MOV.B   [R2+12],R0L
                       2683 ; rtxc.c   1135 
                       2684 ; rtxc.c   1136          /* force Sema pending in case it was already DONE */
                       2685 ; rtxc.c   1137          if ( (semat[pclkblk->objid = ((struct clkarg ks_stk *)p2)->sema]
                       2686 ; rtxc.c   1138                             == SEMA_DONE)
                       2687 ; rtxc.c   1139                                  &&
                       2688 ; rtxc.c   1140               ( ((struct clkarg ks_stk *)p2)->period == (TICKS)0) )
00103C 8C1716          2689         MOV.W   R1,[R7+22]
00103F 8C0714          2690         MOV.W   R0,[R7+20]
001042 862C42          2691         MOV.B   ES,R1L
001045 840004          2692         MOV.B   R0L,[R0+4]
001048 8C570E          2693         MOV.W   R5,[R7+14]
00104B 8C470C          2694         MOV.W   R4,[R7+12]
00104E 86AC42          2695         MOV.B   ES,R5L
001051 840C10          2696         MOV.B   [R4+16],R0L
001054 8140            2697         MOV.B   R2L,R0L
001056 B150            2698         MOVS.B  R2H,#00H
001058 B930            2699         MOVS.W  R3,#00H
00105A 964842rr        2700         MOV.B   ES,#SEG( _semat )
00105E 8512rrrr        2701         MOV.B   R0H,[R2+SOF( _semat )]
001062 F20E            2702         BNE     _99
001064 8C3716          2703         MOV.W   R3,[R7+22]
001067 8C2714          2704         MOV.W   R2,[R7+20]
00106A 866C42          2705         MOV.B   ES,R3L
00106D 8C1208          2706         MOV.W   R1,[R2+8]
001070 F207            2707         BNE     _99
                       2708 ; rtxc.c   1141             semat[pclkblk->objid] = SEMA_PENDING;
001072 B110            2709         MOVS.B  R0H,#00H
001074 B910            2710         MOVS.W  R1,#00H
001076 964842rr        2711         MOV.B   ES,#SEG( _semat )
00107A 9508rrrrFF      2712         MOV.B   [R0+SOF( _semat )],#0FFH
00107A 9508rrrrFF00    2712         MOV.B   [R0+SOF( _semat )],#0FFH
001080                 2713 _99:
                       2714 ; rtxc.c   1142 
                       2715 ; rtxc.c   1143          /* insert timer */
                       2716 ; rtxc.c   1144          insert_timer(pclkblk);
001080 8915            2717         MOV.W   R1,R5
001082 8904            2718         MOV.W   R0,R4
001084 C51812          2719         CALL    _insert_timer
                       2720 ; rtxc.c   1145 
                       2721 ; rtxc.c   1146          break;
                       2722         BR      _428
001087 D50FB2         +2722         JMP.L   _428
001087 D50FB2         +2722         JMP.L   _428
                       2723 ; rtxc.c   1147 #endif /* } HAS_START_TIMER */
                       2724 ; rtxc.c   1148 
                       2725 ; rtxc.c   1149 #ifdef HAS_DELAY /* { */
                       2726 ; rtxc.c   1150 /************************/
                       2727 ; rtxc.c   1151       case RTXC_DELAY:
00108A                 2728 _100:
                       2729 ; rtxc.c   1152 /************************/
                       2730 ; rtxc.c   1153          if ( ((task = ((struct delayarg ks_stk *)p2)->task) == SELFTASK)  ||
                       2731 ; rtxc.c   1154                 (task == hipritsk->task) )  /* delaying self */
00108A 8915            2732         MOV.W   R1,R5
00108C 8904            2733         MOV.W   R0,R4
00108E 8C1F16          2734         MOV.W   [R7+22],R1
001091 8C0F14          2735         MOV.W   [R7+20],R0
001094 862C42          2736         MOV.B   ES,R1L
001097 84C004          2737         MOV.B   R6L,[R0+4]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  50

ADDR   CODE            LINE SOURCELINE
00109A F30D            2738         BEQ     _101
00109C 8E3rrr          2739         MOV.W   R3,_hipritsk+2
00109F 8E2rrr          2740         MOV.W   R2,_hipritsk
0010A2 866C42          2741         MOV.B   ES,R3L
0010A5 84420C          2742         MOV.B   R2L,[R2+12]
0010A8 8C1716          2743         MOV.W   R1,[R7+22]
0010AB 8C0714          2744         MOV.W   R0,[R7+20]
0010AE 862C42          2745         MOV.B   ES,R1L
0010B1 444804          2746         CMP.B   [R0+4],R2L
0010B4 F221            2747         BNE     _102
0010B4 F221            2747         BNE     _102
0010B6                 2748 _101:
                       2749 ; rtxc.c   1155          {
                       2750 ; rtxc.c   1156             if ( ((struct delayarg ks_stk *)p2)->ticks == 0)
0010B6 8C1716          2751         MOV.W   R1,[R7+22]
0010B9 8C0714          2752         MOV.W   R0,[R7+20]
0010BC 862C42          2753         MOV.B   ES,R1L
0010BF 8C0006          2754         MOV.W   R0,[R0+6]
                       2755         BEQ     _428
0010C2 F202           +2755 ;       BNE     _LG_178
0010C4 D50F94         +2755 ;       JMP.L   _428
0010C4 D50F9400       +2755 ;       JMP.L   _428
0010C8                +2755 _LG_178:
                       2756 ; rtxc.c   1157                break;   /* zero time for self = NOP */
                       2757 ; rtxc.c   1158             ptcb = hipritsk;
0010C8 8E1rrr          2758         MOV.W   R1,_hipritsk+2
0010CB 8E0rrr          2759         MOV.W   R0,_hipritsk
0010CE 8C1F12          2760         MOV.W   [R7+18],R1
0010D1 8C0F10          2761         MOV.W   [R7+16],R0
                       2762 ; rtxc.c   1159             task = ptcb->task;
0010D4 8E1rrr          2763         MOV.W   R1,_hipritsk+2
0010D7 8E0rrr          2764         MOV.W   R0,_hipritsk
0010DA 862C42          2765         MOV.B   ES,R1L
0010DD 84C00C          2766         MOV.B   R6L,[R0+12]
                       2767 ; rtxc.c   1160             pclkblk = ((struct delayarg ks_stk *)p2)->pclkblk;
0010E0 8C1716          2768         MOV.W   R1,[R7+22]
0010E3 8C0714          2769         MOV.W   R0,[R7+20]
0010E6 862C42          2770         MOV.B   ES,R1L
0010E9 8C100A          2771         MOV.W   R1,[R0+10]
0010EC 8C0008          2772         MOV.W   R0,[R0+8]
0010EF 8C1F0E          2773         MOV.W   [R7+14],R1
0010F2 8C0F0C          2774         MOV.W   [R7+12],R0
                       2775 ; rtxc.c   1161          }
0010F5 FE58            2776         BR      _105
0010F5 FE5800          2776         BR      _105
0010F8                 2777 _102:
                       2778 ; rtxc.c   1162          else  /* current task is delaying another task */
                       2779 ; rtxc.c   1163          {
                       2780 ; rtxc.c   1164             ptcb = (TCB ks_tbl *)&rtxtcb[task];
0010F8 810C            2781         MOV.B   R0L,R6L
0010FA 9019            2782         SEXT.B  R0H
0010FC E9000024        2783         MULU.W  R0,#024H
001100 B910            2784         MOVS.W  R1,#00H
001102 9958rrrr        2785         MOV.W   R5,#SEG( _rtxtcb )
001106 9948rrrr        2786         MOV.W   R4,#SOF( _rtxtcb )
00110A 0940            2787         ADD.W   R4,R0
00110C 8C5F12          2788         MOV.W   [R7+18],R5
00110F 8C4F10          2789         MOV.W   [R7+16],R4
                       2790 ; rtxc.c   1165 
                       2791 ; rtxc.c   1166             if (ptcb->status & DELAY_WAIT)
001112 8915            2792         MOV.W   R1,R5
001114 8904            2793         MOV.W   R0,R4
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  51

ADDR   CODE            LINE SOURCELINE
001116 99000012        2794         ADD.W   R0,#012H
00111A 86AC42          2795         MOV.B   ES,R5L
00111D 8C2412          2796         MOV.W   R2,[R4+18]
001120 99250004        2797         AND.W   R2,#04H
001124 F328            2798         BEQ     _103
                       2799 ; rtxc.c   1167             {
                       2800 ; rtxc.c   1168                /* if task is already delayed ... */
                       2801 ; rtxc.c   1169                /* get current clkblk and unlink from active timers */
                       2802 ; rtxc.c   1170                pclkblk = ptcb->pclkblk;
001126 86AC42          2803         MOV.B   ES,R5L
001129 8C0408          2804         MOV.W   R0,[R4+8]
00112C 8C140A          2805         MOV.W   R1,[R4+10]
00112F 8C1F0E          2806         MOV.W   [R7+14],R1
001132 8C0F0C          2807         MOV.W   [R7+12],R0
                       2808 ; rtxc.c   1171                unlink_timer(pclkblk);
001135 C51835          2809         CALL    _unlink_timer
                       2810 ; rtxc.c   1172 
                       2811 ; rtxc.c   1173                if ( ((struct delayarg ks_stk *)p2)->ticks == 0)
001138 8C1716          2812         MOV.W   R1,[R7+22]
00113B 8C0714          2813         MOV.W   R0,[R7+20]
00113E 862C42          2814         MOV.B   ES,R1L
001141 8C0006          2815         MOV.W   R0,[R0+6]
001144 F230            2816         BNE     _105
                       2817 ; rtxc.c   1174                {
                       2818 ; rtxc.c   1175                   /* if 0 delay, clear DELAY_WAIT flag ... */
                       2819 ; rtxc.c   1176                   if ( (ptcb->status &= ~DELAY_WAIT) == READY)
001146 86AC42          2820         MOV.B   ES,R5L
001149 8C0412          2821         MOV.W   R0,[R4+18]
00114C 9905FFFB        2822         AND.W   R0,#0FFFBH
001150 86AC42          2823         MOV.B   ES,R5L
001153 8C0C12          2824         MOV.W   [R4+18],R0
001156 6900            2825         OR.W    R0,R0
                       2826         BNE     _428
001158 F302           +2826 ;       BEQ     _LG_184
00115A D50F49         +2826 ;       JMP.L   _428
00115A D50F4900       +2826 ;       JMP.L   _428
00115E                +2826 _LG_184:
                       2827 ; rtxc.c   1177                   {
                       2828 ; rtxc.c   1178                      /* ... if task is now READY, put in ready list */
                       2829 ; rtxc.c   1179                      ptcb->flink = nsrttcb;
00115E 8E1rrr          2830         MOV.W   R1,_nsrttcb+2
001161 8E0rrr          2831         MOV.W   R0,_nsrttcb
001164 86AC42          2832         MOV.B   ES,R5L
001167 8A0C            2833         MOV.W   [R4],R0
001169 8C1C02          2834         MOV.W   [R4+2],R1
                       2835 ; rtxc.c   1180                      nsrttcb = ptcb;
00116C 8E5rrr          2836         MOV.W   _nsrttcb+2,R5
00116F 8E4rrr          2837         MOV.W   _nsrttcb,R4
                       2838 ; rtxc.c   1181                   }
                       2839 ; rtxc.c   1182                   break;
                       2840         BR      _428
001172 D50F3D         +2840         JMP.L   _428
001172 D50F3D00       +2840         JMP.L   _428
                       2841 ; rtxc.c   1183                }
                       2842 ; rtxc.c   1184             }
001176                 2843 _103:
                       2844 ; rtxc.c   1185             else  /* task was not already delayed */
                       2845 ; rtxc.c   1186             {
                       2846 ; rtxc.c   1187                /* if 0 ticks (un-delay) or if task not READY, then NOP */
                       2847 ; rtxc.c   1188                if ( (((struct delayarg ks_stk *)p2)->ticks == 0) ||
                       2848 ; rtxc.c   1189                                        (ptcb->status != READY) )
001176 8C3716          2849         MOV.W   R3,[R7+22]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  52

ADDR   CODE            LINE SOURCELINE
001179 8C2714          2850         MOV.W   R2,[R7+20]
00117C 866C42          2851         MOV.B   ES,R3L
00117F 8C2206          2852         MOV.W   R2,[R2+6]
                       2853         BEQ     _428
001182 F202           +2853 ;       BNE     _LG_186
001184 D50F34         +2853 ;       JMP.L   _428
001184 D50F3400       +2853 ;       JMP.L   _428
001188                +2853 _LG_186:
001188 862C42          2854         MOV.B   ES,R1L
00118B 8A00            2855         MOV.W   R0,[R0]
                       2856         BNE     _428
00118D F302           +2856 ;       BEQ     _LG_188
00118F D50F2E         +2856 ;       JMP.L   _428
00118F D50F2E         +2856 ;       JMP.L   _428
001192                +2856 _LG_188:
                       2857 ; rtxc.c   1190                   break;
                       2858 ; rtxc.c   1191 
                       2859 ; rtxc.c   1192                /* allocate space on task's personal stack for clkblk */
                       2860 ; rtxc.c   1193                pclkblk = (CLKBLK ks_clk *)(ptcb->sp) - 1;
001192 86AC42          2861         MOV.B   ES,R5L
001195 8C5410          2862         MOV.W   R5,[R4+16]
001198 8C440E          2863         MOV.W   R4,[R4+14]
00119B 99420012        2864         SUB.W   R4,#012H
00119F 8C5F0E          2865         MOV.W   [R7+14],R5
0011A2 8C4F0C          2866         MOV.W   [R7+12],R4
0011A2 8C4F0C00        2866         MOV.W   [R7+12],R4
                       2867 ; rtxc.c   1194             }
                       2868 ; rtxc.c   1195          }
0011A6                 2869 _105:
                       2870 ; rtxc.c   1196 
                       2871 ; rtxc.c   1197          ptcb->pclkblk = pclkblk; /* put pointer to clkblk in tcb */
0011A6 8C3712          2872         MOV.W   R3,[R7+18]
0011A9 8C2710          2873         MOV.W   R2,[R7+16]
0011AC 8C170E          2874         MOV.W   R1,[R7+14]
0011AF 8C070C          2875         MOV.W   R0,[R7+12]
0011B2 866C42          2876         MOV.B   ES,R3L
0011B5 8C0A08          2877         MOV.W   [R2+8],R0
0011B8 8C1A0A          2878         MOV.W   [R2+10],R1
                       2879 ; rtxc.c   1198 
                       2880 ; rtxc.c   1199          if (ptcb->status == READY)
0011BB 99200012        2881         ADD.W   R2,#012H
0011BF 8C1712          2882         MOV.W   R1,[R7+18]
0011C2 8C0710          2883         MOV.W   R0,[R7+16]
0011C5 862C42          2884         MOV.B   ES,R1L
0011C8 8C0012          2885         MOV.W   R0,[R0+18]
0011CB 8C0F0A          2886         MOV.W   [R7+10],R0
0011CE 6900            2887         OR.W    R0,R0
0011D0 F226            2888         BNE     _106
                       2889 ; rtxc.c   1200          {
                       2890 ; rtxc.c   1201                /* general unlink from tcb READY list */
                       2891 ; rtxc.c   1202             ptcb->flink->blink = ptcb->blink;
0011D2 8C1712          2892         MOV.W   R1,[R7+18]
0011D5 8C0710          2893         MOV.W   R0,[R7+16]
0011D8 862C42          2894         MOV.B   ES,R1L
0011DB 8C4004          2895         MOV.W   R4,[R0+4]
0011DE 8C5006          2896         MOV.W   R5,[R0+6]
0011E1 8C1712          2897         MOV.W   R1,[R7+18]
0011E4 8C0710          2898         MOV.W   R0,[R7+16]
0011E7 862C42          2899         MOV.B   ES,R1L
0011EA 8C1002          2900         MOV.W   R1,[R0+2]
0011ED 8A00            2901         MOV.W   R0,[R0]
0011EF 862C42          2902         MOV.B   ES,R1L
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  53

ADDR   CODE            LINE SOURCELINE
0011F2 8C4804          2903         MOV.W   [R0+4],R4
0011F5 8C5806          2904         MOV.W   [R0+6],R5
                       2905 ; rtxc.c   1203             ptcb->blink->flink = ptcb->flink;
0011F8 8C1712          2906         MOV.W   R1,[R7+18]
0011FB 8C0710          2907         MOV.W   R0,[R7+16]
0011FE 862C42          2908         MOV.B   ES,R1L
001201 8A40            2909         MOV.W   R4,[R0]
001203 8C5002          2910         MOV.W   R5,[R0+2]
001206 8C1712          2911         MOV.W   R1,[R7+18]
001209 8C0710          2912         MOV.W   R0,[R7+16]
00120C 862C42          2913         MOV.B   ES,R1L
00120F 8C1006          2914         MOV.W   R1,[R0+6]
001212 8C0004          2915         MOV.W   R0,[R0+4]
001215 862C42          2916         MOV.B   ES,R1L
001218 8A48            2917         MOV.W   [R0],R4
00121A 8C5802          2918         MOV.W   [R0+2],R5
00121A 8C580200        2918         MOV.W   [R0+2],R5
                       2919 ; rtxc.c   1204          }
00121E                 2920 _106:
                       2921 ; rtxc.c   1205 
                       2922 ; rtxc.c   1206          ptcb->status |= DELAY_WAIT;
00121E 8C070A          2923         MOV.W   R0,[R7+10]
001221 99060004        2924         OR.W    R0,#04H
001225 866C42          2925         MOV.B   ES,R3L
001228 8A0A            2926         MOV.W   [R2],R0
                       2927 ; rtxc.c   1207 
                       2928 ; rtxc.c   1208          pclkblk->remain = ((struct delayarg ks_stk *)p2)->ticks;
00122A 8C1716          2929         MOV.W   R1,[R7+22]
00122D 8C0714          2930         MOV.W   R0,[R7+20]
001230 862C42          2931         MOV.B   ES,R1L
001233 8C0006          2932         MOV.W   R0,[R0+6]
001236 8C370E          2933         MOV.W   R3,[R7+14]
001239 8C270C          2934         MOV.W   R2,[R7+12]
00123C 866C42          2935         MOV.B   ES,R3L
00123F 8C0A08          2936         MOV.W   [R2+8],R0
                       2937 ; rtxc.c   1209          pclkblk->recycle = (TICKS)0;
001242 8913            2938         MOV.W   R1,R3
001244 8902            2939         MOV.W   R0,R2
001246 862C42          2940         MOV.B   ES,R1L
001249 BC000A          2941         MOV.W   [R0+10],#00H
                       2942 ; rtxc.c   1210 
                       2943 ; rtxc.c   1211          /* mark object type */
                       2944 ; rtxc.c   1212          pclkblk->objtype = DELAY_OBJ;
00124C 8C170E          2945         MOV.W   R1,[R7+14]
00124F 8C070C          2946         MOV.W   R0,[R7+12]
001252 862C42          2947         MOV.B   ES,R1L
001255 BC000E          2948         MOV.W   [R0+14],#00H
                       2949 ; rtxc.c   1213          pclkblk->objid = task;
001258 862C42          2950         MOV.B   ES,R1L
00125B 84C810          2951         MOV.B   [R0+16],R6L
                       2952 ; rtxc.c   1214          pclkblk->task = task;
00125E 8C170E          2953         MOV.W   R1,[R7+14]
001261 8C070C          2954         MOV.W   R0,[R7+12]
001264 862C42          2955         MOV.B   ES,R1L
001267 84C80C          2956         MOV.B   [R0+12],R6L
                       2957 ; rtxc.c   1215 
                       2958 ; rtxc.c   1216          /* insert timer */
                       2959 ; rtxc.c   1217          insert_timer(pclkblk);
00126A C5171F          2960         CALL    _insert_timer
                       2961 ; rtxc.c   1218          break;
                       2962         BR      _428
00126D D50EBF         +2962         JMP.L   _428
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  54

ADDR   CODE            LINE SOURCELINE
00126D D50EBF         +2962         JMP.L   _428
                       2963 ; rtxc.c   1219 #endif /* } HAS_DELAY */
                       2964 ; rtxc.c   1220 
                       2965 ; rtxc.c   1221 #ifdef HAS_ELAPSE /* { */
                       2966 ; rtxc.c   1222 /************************/
                       2967 ; rtxc.c   1223       case RTXC_ELAPSE:
001270                 2968 _107:
                       2969 ; rtxc.c   1224 /************************/
                       2970 ; rtxc.c   1225          PUSHPSWH; /* save current processor priority level */
001270 860401          2971         MOV.B   R0L,0401H
                       2972 ; rtxc.c   1226          DISABLE;
001273 9648018D        2973         MOV.B   0401H,#08DH
                       2974 ; rtxc.c   1227          tcnt = rtctick; /* snapshot rtctick */
001277 964842rr        2975         MOV.B   ES,#SEG( _rtctick )
00127B 9968rrrr        2976         MOV.W   R6,#SOF( _rtctick )
00127F 8A66            2977         MOV.W   R6,[R6]
                       2978 ; rtxc.c   1228          POPPSWH;  /* restore current PPL */
001281 860C01          2979         MOV.B   0401H,R0L
                       2980 ; rtxc.c   1229          ((struct etarg ks_stk *)p2)->val = tcnt -
                       2981 ; rtxc.c   1230                                 *(((struct etarg ks_stk *)p2)->stamp);
001284 8935            2982         MOV.W   R3,R5
001286 8924            2983         MOV.W   R2,R4
001288 866C42          2984         MOV.B   ES,R3L
00128B 8C0202          2985         MOV.W   R0,[R2+2]
00128E 8C1204          2986         MOV.W   R1,[R2+4]
001291 8946            2987         MOV.W   R4,R6
001293 862C42          2988         MOV.B   ES,R1L
001296 2A40            2989         SUB.W   R4,[R0]
001298 866C42          2990         MOV.B   ES,R3L
00129B 8C4A06          2991         MOV.W   [R2+6],R4
                       2992 ; rtxc.c   1231          *(((struct etarg ks_stk *)p2)->stamp) = tcnt;
00129E 862C42          2993         MOV.B   ES,R1L
0012A1 8A68            2994         MOV.W   [R0],R6
                       2995 ; rtxc.c   1232          break;
                       2996         BR      _428
0012A3 D50EA4         +2996         JMP.L   _428
0012A3 D50EA4         +2996         JMP.L   _428
                       2997 ; rtxc.c   1233 #endif /* } HAS_ELAPSE */
                       2998 ; rtxc.c   1234 
                       2999 ; rtxc.c   1235 #ifdef HAS_INQTIMER /* { */
                       3000 ; rtxc.c   1236 /************************/
                       3001 ; rtxc.c   1237       case RTXC_INQTIMER:
0012A6                 3002 _108:
                       3003 ; rtxc.c   1238 /************************/
                       3004 ; rtxc.c   1239          pclkblk = ((struct clkarg ks_stk *)p2)->pclkblk;
0012A6 86AC42          3005         MOV.B   ES,R5L
0012A9 8C040A          3006         MOV.W   R0,[R4+10]
0012AC 8C140C          3007         MOV.W   R1,[R4+12]
                       3008 ; rtxc.c   1240 
                       3009 ; rtxc.c   1241          if (pclkblk->state == TIMER_ACTIVE)
0012AF 862C42          3010         MOV.B   ES,R1L
0012B2 94040D01        3011         CMP.B   [R0+13],#01H
0012B6 F213            3012         BNE     _109
                       3013 ; rtxc.c   1242          {
                       3014 ; rtxc.c   1243             PUSHPSWH; /* save current processor priority level */
0012B8 864401          3015         MOV.B   R2L,0401H
                       3016 ; rtxc.c   1244             DISABLE; /* prevent changing rtctick while reading */
0012BB 9648018D        3017         MOV.B   0401H,#08DH
                       3018 ; rtxc.c   1245             ((struct clkarg ks_stk *)p2)->ticks = pclkblk->remain - rtctick;
0012BF 862C42          3019         MOV.B   ES,R1L
0012C2 8C0008          3020         MOV.W   R0,[R0+8]
0012C5 964842rr        3021         MOV.B   ES,#SEG( _rtctick )
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  55

ADDR   CODE            LINE SOURCELINE
0012C9 9918rrrr        3022         MOV.W   R1,#SOF( _rtctick )
0012CD 8A11            3023         MOV.W   R1,[R1]
0012CF 2901            3024         SUB.W   R0,R1
0012D1 86AC42          3025         MOV.B   ES,R5L
0012D4 8C0C06          3026         MOV.W   [R4+6],R0
                       3027 ; rtxc.c   1246             POPPSWH;
0012D7 864C01          3028         MOV.B   0401H,R2L
                       3029 ; rtxc.c   1247          }
                       3030         BR      _428
0012DA D50E89         +3030         JMP.L   _428
0012DA D50E8900       +3030         JMP.L   _428
0012DE                 3031 _109:
                       3032 ; rtxc.c   1248          else
                       3033 ; rtxc.c   1249             ((struct clkarg ks_stk *)p2)->ticks = (TICKS)0;
0012DE 86AC42          3034         MOV.B   ES,R5L
0012E1 BC4006          3035         MOV.W   [R4+6],#00H
                       3036 ; rtxc.c   1250          break;
                       3037         BR      _428
0012E4 D50E84         +3037         JMP.L   _428
0012E4 D50E8400       +3037         JMP.L   _428
                       3038 ; rtxc.c   1251 #endif /* } HAS_INQTIMER */
                       3039 ; rtxc.c   1252 
                       3040 ; rtxc.c   1253 #ifdef HAS_INQTIME /* { */
                       3041 ; rtxc.c   1254 /************************/
                       3042 ; rtxc.c   1255       case RTXC_INQTIME:
0012E8                 3043 _110:
                       3044 ; rtxc.c   1256 /************************/
                       3045 ; rtxc.c   1257          PUSHPSWH; /* save current processor priority level */
0012E8 860401          3046         MOV.B   R0L,0401H
                       3047 ; rtxc.c   1258          DISABLE; /* prevent changing while reading */
0012EB 9648018D        3048         MOV.B   0401H,#08DH
                       3049 ; rtxc.c   1259          ((struct timearg ks_stk *)p2)->time = rtctime;
0012EF 964842rr        3050         MOV.B   ES,#SEG( _rtctime )
0012F3 9938rrrr        3051         MOV.W   R3,#SOF( _rtctime )
0012F7 8B23            3052         MOV.W   R2,[R3+]
0012F9 8A33            3053         MOV.W   R3,[R3]
0012FB 86AC42          3054         MOV.B   ES,R5L
0012FE 8C2C02          3055         MOV.W   [R4+2],R2
001301 8C3C04          3056         MOV.W   [R4+4],R3
                       3057 ; rtxc.c   1260          rtctimetick=ratecnt;
001304 964842rr        3058         MOV.B   ES,#SEG( _ratecnt )
001308 9918rrrr        3059         MOV.W   R1,#SOF( _ratecnt )
00130C 8A11            3060         MOV.W   R1,[R1]
00130E 964842rr        3061         MOV.B   ES,#SEG( _rtctimetick )
001312 9928rrrr        3062         MOV.W   R2,#SOF( _rtctimetick )
001316 8A1A            3063         MOV.W   [R2],R1
                       3064 ; rtxc.c   1261          POPPSWH;
001318 860C01          3065         MOV.B   0401H,R0L
                       3066 ; rtxc.c   1262          break;
                       3067         BR      _428
00131B D50E68         +3067         JMP.L   _428
00131B D50E68         +3067         JMP.L   _428
                       3068 ; rtxc.c   1263 #endif /* } HAS_INQTIME */
                       3069 ; rtxc.c   1264 
                       3070 ; rtxc.c   1265 #ifdef HAS_DEFTIME /* { */
                       3071 ; rtxc.c   1266 /************************/
                       3072 ; rtxc.c   1267       case RTXC_DEFTIME:
00131E                 3073 _111:
                       3074 ; rtxc.c   1268 /************************/
                       3075 ; rtxc.c   1269          PUSHPSWH; /* save current processor priority level */
00131E 860401          3076         MOV.B   R0L,0401H
                       3077 ; rtxc.c   1270          DISABLE; /* prevent changing while writing */
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  56

ADDR   CODE            LINE SOURCELINE
001321 9648018D        3078         MOV.B   0401H,#08DH
                       3079 ; rtxc.c   1271          rtctime = ((struct timearg ks_stk *)p2)->time;
001325 86AC42          3080         MOV.B   ES,R5L
001328 8C5404          3081         MOV.W   R5,[R4+4]
00132B 8C4402          3082         MOV.W   R4,[R4+2]
00132E 964842rr        3083         MOV.B   ES,#SEG( _rtctime )
001332 9918rrrr        3084         MOV.W   R1,#SOF( _rtctime )
001336 8B49            3085         MOV.W   [R1+],R4
001338 8A59            3086         MOV.W   [R1],R5
                       3087 ; rtxc.c   1272          ratecnt=0;
00133A 964842rr        3088         MOV.B   ES,#SEG( _ratecnt )
00133E 9918rrrr        3089         MOV.W   R1,#SOF( _ratecnt )
001342 BA10            3090         MOV.W   [R1],#00H
                       3091 ; rtxc.c   1273          POPPSWH;
001344 860C01          3092         MOV.B   0401H,R0L
                       3093 ; rtxc.c   1274          break;
                       3094         BR      _428
001347 D50E52         +3094         JMP.L   _428
001347 D50E52         +3094         JMP.L   _428
                       3095 ; rtxc.c   1275 #endif /* } HAS_DEFTIME */
                       3096 ; rtxc.c   1276 
                       3097 ; rtxc.c   1277 #ifdef HAS_MAILBOXES /* { */
                       3098 ; rtxc.c   1278 #ifdef HAS_SEND /* { */
                       3099 ; rtxc.c   1279 /************************/
                       3100 ; rtxc.c   1280       case RTXC_SEND:
00134A                 3101 _112:
                       3102 ; rtxc.c   1281 /************************/
                       3103 ; rtxc.c   1282          if ( ((struct msgarg ks_stk *)p2)->priority == (PRIORITY)0)
00134A 8915            3104         MOV.W   R1,R5
00134C 8904            3105         MOV.W   R0,R4
00134E 8931            3106         MOV.W   R3,R1
001350 8920            3107         MOV.W   R2,R0
001352 99000007        3108         ADD.W   R0,#07H
001356 866C42          3109         MOV.B   ES,R3L
001359 848207          3110         MOV.B   R4L,[R2+7]
00135C F20F            3111         BNE     _113
                       3112 ; rtxc.c   1283          {
                       3113 ; rtxc.c   1284             /* priority = 0 yields sender's priority */
                       3114 ; rtxc.c   1285             ((struct msgarg ks_stk *)p2)->prtxcmsg->priority =
                       3115 ; rtxc.c   1286                hipritsk->priority;
00135E 8E1rrr          3116         MOV.W   R1,_hipritsk+2
001361 8E0rrr          3117         MOV.W   R0,_hipritsk
001364 862C42          3118         MOV.B   ES,R1L
001367 84000D          3119         MOV.B   R0L,[R0+13]
00136A 866C42          3120         MOV.B   ES,R3L
00136D 8C4208          3121         MOV.W   R4,[R2+8]
001370 8C520A          3122         MOV.W   R5,[R2+10]
001373 86AC42          3123         MOV.B   ES,R5L
001376 840C05          3124         MOV.B   [R4+5],R0L
                       3125 ; rtxc.c   1287          }
001379 FE0B            3126         BR      _114
001379 FE0B00          3126         BR      _114
00137C                 3127 _113:
                       3128 ; rtxc.c   1288          else
                       3129 ; rtxc.c   1289          {
                       3130 ; rtxc.c   1290             ((struct msgarg ks_stk *)p2)->prtxcmsg->priority =
                       3131 ; rtxc.c   1291                ((struct msgarg ks_stk *)p2)->priority;
00137C 862C42          3132         MOV.B   ES,R1L
00137F 8200            3133         MOV.B   R0L,[R0]
001381 866C42          3134         MOV.B   ES,R3L
001384 8C4208          3135         MOV.W   R4,[R2+8]
001387 8C520A          3136         MOV.W   R5,[R2+10]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  57

ADDR   CODE            LINE SOURCELINE
00138A 86AC42          3137         MOV.B   ES,R5L
00138D 840C05          3138         MOV.B   [R4+5],R0L
00138D 840C05          3138         MOV.B   [R4+5],R0L
                       3139 ; rtxc.c   1292          }
001390                 3140 _114:
                       3141 ; rtxc.c   1293 
                       3142 ; rtxc.c   1294          ((struct msgarg ks_stk *)p2)->prtxcmsg->sema =
                       3143 ; rtxc.c   1295             ((struct msgarg ks_stk *)p2)->sema;
001390 8913            3144         MOV.W   R1,R3
001392 8902            3145         MOV.W   R0,R2
001394 99000004        3146         ADD.W   R0,#04H
001398 8C1F12          3147         MOV.W   [R7+18],R1
00139B 8C0F10          3148         MOV.W   [R7+16],R0
00139E 866C42          3149         MOV.B   ES,R3L
0013A1 840204          3150         MOV.B   R0L,[R2+4]
0013A4 8953            3151         MOV.W   R5,R3
0013A6 8942            3152         MOV.W   R4,R2
0013A8 99400008        3153         ADD.W   R4,#08H
0013AC 8C3F16          3154         MOV.W   [R7+22],R3
0013AF 8C2F14          3155         MOV.W   [R7+20],R2
0013B2 866C42          3156         MOV.B   ES,R3L
0013B5 8C320A          3157         MOV.W   R3,[R2+10]
0013B8 8C2208          3158         MOV.W   R2,[R2+8]
0013BB 866C42          3159         MOV.B   ES,R3L
0013BE 840A06          3160         MOV.B   [R2+6],R0L
                       3161 ; rtxc.c   1296 
                       3162 ; rtxc.c   1297          ((struct msgarg ks_stk *)p2)->prtxcmsg->task = hipritsk->task;
0013C1 8E1rrr          3163         MOV.W   R1,_hipritsk+2
0013C4 8E0rrr          3164         MOV.W   R0,_hipritsk
0013C7 9900000C        3165         ADD.W   R0,#0CH
0013CB 8C1F0E          3166         MOV.W   [R7+14],R1
0013CE 8C0F0C          3167         MOV.W   [R7+12],R0
0013D1 8E1rrr          3168         MOV.W   R1,_hipritsk+2
0013D4 8E0rrr          3169         MOV.W   R0,_hipritsk
0013D7 862C42          3170         MOV.B   ES,R1L
0013DA 84000C          3171         MOV.B   R0L,[R0+12]
0013DD 8C3716          3172         MOV.W   R3,[R7+22]
0013E0 8C2714          3173         MOV.W   R2,[R7+20]
0013E3 866C42          3174         MOV.B   ES,R3L
0013E6 8C320A          3175         MOV.W   R3,[R2+10]
0013E9 8C2208          3176         MOV.W   R2,[R2+8]
0013EC 866C42          3177         MOV.B   ES,R3L
0013EF 840A04          3178         MOV.B   [R2+4],R0L
                       3179 ; rtxc.c   1298 
                       3180 ; rtxc.c   1299          pmh = (MHEADER ks_tbl *)&mheader[((struct msgarg ks_stk *)p2)->mbox];
0013F2 8C1716          3181         MOV.W   R1,[R7+22]
0013F5 8C0714          3182         MOV.W   R0,[R7+20]
0013F8 862C42          3183         MOV.B   ES,R1L
0013FB 840005          3184         MOV.B   R0L,[R0+5]
0013FE E8000E          3185         MULU.B  R0L,#0EH
001401 8920            3186         MOV.W   R2,R0
001403 B930            3187         MOVS.W  R3,#00H
001405 9918rrrr        3188         MOV.W   R1,#SEG( _mheader )
001409 9908rrrr        3189         MOV.W   R0,#SOF( _mheader )
00140D 0902            3190         ADD.W   R0,R2
00140F 8C1F0A          3191         MOV.W   [R7+10],R1
001412 8C0F08          3192         MOV.W   [R7+8],R0
                       3193 ; rtxc.c   1300 
                       3194 ; rtxc.c   1301 #ifdef MAILBOX_SEMAS /* { */
                       3195 ; rtxc.c   1302          /* if was empty and there is a not_empty semaphore defined */
                       3196 ; rtxc.c   1303          if (pmh->link == NULL)
001415 964842rr        3197         MOV.B   ES,#SEG( _mheader )
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  58

ADDR   CODE            LINE SOURCELINE
001419 8D32rrrr        3198         MOV.W   R3,[R2+SOF( _mheader+2 )]
00141D 8D22rrrr        3199         MOV.W   R2,[R2+SOF( _mheader )]
001421 6932            3200         OR.W    R3,R2
001423 F23B            3201         BNE     _119
                       3202 ; rtxc.c   1304          {
                       3203 ; rtxc.c   1305             UPDATE_SEMA(pmh->nesema);
001425 8C170A          3204         MOV.W   R1,[R7+10]
001428 8C0708          3205         MOV.W   R0,[R7+8]
00142B 9900000C        3206         ADD.W   R0,#0CH
00142F 8C1F06          3207         MOV.W   [R7+6],R1
001432 8C0F04          3208         MOV.W   [R7+4],R0
001435 8C170A          3209         MOV.W   R1,[R7+10]
001438 8C0708          3210         MOV.W   R0,[R7+8]
00143B 862C42          3211         MOV.B   ES,R1L
00143E 84400C          3212         MOV.B   R2L,[R0+12]
001441 F32C            3213         BEQ     _119
001443 B150            3214         MOVS.B  R2H,#00H
001445 B930            3215         MOVS.W  R3,#00H
001447 9918rrrr        3216         MOV.W   R1,#SEG( _semat )
00144B 9908rrrr        3217         MOV.W   R0,#SOF( _semat )
00144F 0902            3218         ADD.W   R0,R2
001451 964842rr        3219         MOV.B   ES,#SEG( _semat )
001455 85C2rrrr        3220         MOV.B   R6L,[R2+SOF( _semat )]
001459 91C4FF          3221         CMP.B   R6L,#0FFH
00145C F205            3222         BNE     _115
00145E 964842rr        3223         MOV.B   ES,#SEG( _semat )
001462 B520rrrr        3224         MOV.B   [R2+SOF( _semat )],#00H
001466 FE19            3225         BR      _119
001466 FE19            3225         BR      _119
001468                 3226 _115:
001468 862C42          3227         MOV.B   ES,R1L
00146B 8200            3228         MOV.B   R0L,[R0]
00146D F316            3229         BEQ     _119
00146F 860401          3230         MOV.B   R0L,0401H
001472 9648018D        3231         MOV.B   0401H,#08DH
001476 8C3706          3232         MOV.W   R3,[R7+6]
001479 8C2704          3233         MOV.W   R2,[R7+4]
00147C 866C42          3234         MOV.B   ES,R3L
00147F 8212            3235         MOV.B   R0H,[R2]
001481 9Er0rr0001      3236         ADD.W   _semaput,#01H
001486 8E3rrr          3237         MOV.W   R3,_semaput+2
001489 8E2rrr          3238         MOV.W   R2,_semaput
00148C 866C42          3239         MOV.B   ES,R3L
00148F 821A            3240         MOV.B   [R2],R0H
001491 8E3rrr          3241         MOV.W   _semaput+2,R3
001494 8E2rrr          3242         MOV.W   _semaput,R2
001497 860C01          3243         MOV.B   0401H,R0L
001497 860C01          3243         MOV.B   0401H,R0L
                       3244 ; rtxc.c   1306          }
00149A                 3245 _119:
                       3246 ; rtxc.c   1307 #endif /* } MAILBOX_SEMAS */
                       3247 ; rtxc.c   1308 
                       3248 ; rtxc.c   1309 #ifdef MAILBOX_WAITERS /* { */
                       3249 ; rtxc.c   1310          if ( (ptcb = pmh->waiters) != NULLTCB) /* if a task waiting */
00149A 8C170A          3250         MOV.W   R1,[R7+10]
00149D 8C0708          3251         MOV.W   R0,[R7+8]
0014A0 99000004        3252         ADD.W   R0,#04H
0014A4 8C1F06          3253         MOV.W   [R7+6],R1
0014A7 8C0F04          3254         MOV.W   [R7+4],R0
0014AA 8C170A          3255         MOV.W   R1,[R7+10]
0014AD 8C0708          3256         MOV.W   R0,[R7+8]
0014B0 862C42          3257         MOV.B   ES,R1L
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  59

ADDR   CODE            LINE SOURCELINE
0014B3 8C2004          3258         MOV.W   R2,[R0+4]
0014B6 8C3006          3259         MOV.W   R3,[R0+6]
0014B9 8913            3260         MOV.W   R1,R3
0014BB 8902            3261         MOV.W   R0,R2
0014BD 6910            3262         OR.W    R1,R0
0014BF F37E            3263         BEQ     _124
                       3264 ; rtxc.c   1311          {
                       3265 ; rtxc.c   1312             /* pass data directly from sender to receiver */
                       3266 ; rtxc.c   1313             p2a = ((FRAME ks_stk *)(ptcb->sp))->pksnum;
0014C1 8C3F02          3267         MOV.W   [R7+2],R3
0014C4 8A2F            3268         MOV.W   [R7],R2
0014C6 866C42          3269         MOV.B   ES,R3L
0014C9 8C3210          3270         MOV.W   R3,[R2+16]
0014CC 8C220E          3271         MOV.W   R2,[R2+14]
0014CF 866C42          3272         MOV.B   ES,R3L
0014D2 8C3206          3273         MOV.W   R3,[R2+6]
0014D5 8C2204          3274         MOV.W   R2,[R2+4]
                       3275 ; rtxc.c   1314 
                       3276 ; rtxc.c   1315             /* if receiving from anybody (0) or a specific task match */
                       3277 ; rtxc.c   1316             if ( (((struct msgarg ks_stk *)p2a)->task == (TASK)0) ||
                       3278 ; rtxc.c   1317                  (((struct msgarg ks_stk *)p2a)->task == hipritsk->task) )
0014D8 866C42          3279         MOV.B   ES,R3L
0014DB 840206          3280         MOV.B   R0L,[R2+6]
0014DE F30A            3281         BEQ     _120
0014E0 8C170E          3282         MOV.W   R1,[R7+14]
0014E3 8C070C          3283         MOV.W   R0,[R7+12]
0014E6 862C42          3284         MOV.B   ES,R1L
0014E9 8200            3285         MOV.B   R0L,[R0]
0014EB 866C42          3286         MOV.B   ES,R3L
0014EE 440A06          3287         CMP.B   [R2+6],R0L
0014F1 F25B            3288         BNE     _123
0014F1 F25B00          3288         BNE     _123
0014F4                 3289 _120:
                       3290 ; rtxc.c   1318             {
                       3291 ; rtxc.c   1319                /* pass &message directly to receiver */
                       3292 ; rtxc.c   1320                ((struct msgarg ks_stk *)p2a)->prtxcmsg =
                       3293 ; rtxc.c   1321                   ((struct msgarg ks_stk *)p2)->prtxcmsg;
0014F4 86AC42          3294         MOV.B   ES,R5L
0014F7 8C5402          3295         MOV.W   R5,[R4+2]
0014FA 8A44            3296         MOV.W   R4,[R4]
0014FC 866C42          3297         MOV.B   ES,R3L
0014FF 8C4A08          3298         MOV.W   [R2+8],R4
001502 8C5A0A          3299         MOV.W   [R2+10],R5
                       3300 ; rtxc.c   1322 
                       3301 ; rtxc.c   1323 #ifdef CBUG /* { */
                       3302 ; rtxc.c   1324                pmh->count++;
                       3303 ; rtxc.c   1325 #endif /* } CBUG */
                       3304 ; rtxc.c   1326 
                       3305 ; rtxc.c   1327                /* remove tcb from waiter's list */
                       3306 ; rtxc.c   1328                if ( (pmh->waiters = ptcb->flink) != NULLTCB)
001505 8C1702          3307         MOV.W   R1,[R7+2]
001508 8A07            3308         MOV.W   R0,[R7]
00150A 862C42          3309         MOV.B   ES,R1L
00150D 8A40            3310         MOV.W   R4,[R0]
00150F 8C5002          3311         MOV.W   R5,[R0+2]
001512 8C1706          3312         MOV.W   R1,[R7+6]
001515 8C0704          3313         MOV.W   R0,[R7+4]
001518 862C42          3314         MOV.B   ES,R1L
00151B 8A48            3315         MOV.W   [R0],R4
00151D 8C5802          3316         MOV.W   [R0+2],R5
001520 6954            3317         OR.W    R5,R4
001522 F30B            3318         BEQ     _121
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  60

ADDR   CODE            LINE SOURCELINE
                       3319 ; rtxc.c   1329                   ptcb->flink->blink = (TCB ks_tbl *)&pmh->waiters;
001524 8C5702          3320         MOV.W   R5,[R7+2]
001527 8A47            3321         MOV.W   R4,[R7]
001529 86AC42          3322         MOV.B   ES,R5L
00152C 8C5402          3323         MOV.W   R5,[R4+2]
00152F 8A44            3324         MOV.W   R4,[R4]
001531 86AC42          3325         MOV.B   ES,R5L
001534 8C0C04          3326         MOV.W   [R4+4],R0
001537 8C1C06          3327         MOV.W   [R4+6],R1
001537 8C1C06          3327         MOV.W   [R4+6],R1
00153A                 3328 _121:
                       3329 ; rtxc.c   1330 
                       3330 ; rtxc.c   1331                /* clear MSG WAIT in receiving task and check if runnable */
                       3331 ; rtxc.c   1332                if ( (ptcb->status &= ~MSG_WAIT) == READY)
00153A 8C1702          3332         MOV.W   R1,[R7+2]
00153D 8A07            3333         MOV.W   R0,[R7]
00153F 862C42          3334         MOV.B   ES,R1L
001542 8C0012          3335         MOV.W   R0,[R0+18]
001545 9905FFDF        3336         AND.W   R0,#0FFDFH
001549 8C5702          3337         MOV.W   R5,[R7+2]
00154C 8A47            3338         MOV.W   R4,[R7]
00154E 86AC42          3339         MOV.B   ES,R5L
001551 9C4512FFDF      3340         AND.W   [R4+18],#0FFDFH
001556 6900            3341         OR.W    R0,R0
001558 F20F            3342         BNE     _122
                       3343 ; rtxc.c   1333                {
                       3344 ; rtxc.c   1334                   /* insert waiter into READY list */
                       3345 ; rtxc.c   1335                   ptcb->flink = nsrttcb;
00155A 8E1rrr          3346         MOV.W   R1,_nsrttcb+2
00155D 8E0rrr          3347         MOV.W   R0,_nsrttcb
001560 8C5702          3348         MOV.W   R5,[R7+2]
001563 8A47            3349         MOV.W   R4,[R7]
001565 86AC42          3350         MOV.B   ES,R5L
001568 8A0C            3351         MOV.W   [R4],R0
00156A 8C1C02          3352         MOV.W   [R4+2],R1
                       3353 ; rtxc.c   1336                   nsrttcb = ptcb;
00156D 8915            3354         MOV.W   R1,R5
00156F 8904            3355         MOV.W   R0,R4
001571 8E1rrr          3356         MOV.W   _nsrttcb+2,R1
001574 8E0rrr          3357         MOV.W   _nsrttcb,R0
001574 8E0rrr00        3357         MOV.W   _nsrttcb,R0
                       3358 ; rtxc.c   1337                }
001578                 3359 _122:
                       3360 ; rtxc.c   1338 
                       3361 ; rtxc.c   1339 #ifdef MAILBOX_TIMEOUTS /* { */
                       3362 ; rtxc.c   1340                /* cleanup any pending timeout */
                       3363 ; rtxc.c   1341                if ( (pclkblk = ptcb->pclkblk) != NULLCLK)
001578 8C1702          3364         MOV.W   R1,[R7+2]
00157B 8A07            3365         MOV.W   R0,[R7]
00157D 862C42          3366         MOV.B   ES,R1L
001580 8C100A          3367         MOV.W   R1,[R0+10]
001583 8C0008          3368         MOV.W   R0,[R0+8]
001586 8951            3369         MOV.W   R5,R1
001588 8940            3370         MOV.W   R4,R0
00158A 6954            3371         OR.W    R5,R4
00158C F320            3372         BEQ     _127
                       3373 ; rtxc.c   1342                {
                       3374 ; rtxc.c   1343                   /* mark waiter GOOD */
                       3375 ; rtxc.c   1344                   ((struct msgarg ks_stk *)p2a)->ksrc = RC_GOOD;
00158E 866C42          3376         MOV.B   ES,R3L
001591 BC2002          3377         MOV.W   [R2+2],#00H
                       3378 ; rtxc.c   1345 
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  61

ADDR   CODE            LINE SOURCELINE
                       3379 ; rtxc.c   1346                   unlink_timer(pclkblk);
001594 C51606          3380         CALL    _unlink_timer
                       3381 ; rtxc.c   1347                   ptcb->pclkblk = NULLCLK;
001597 8C1702          3382         MOV.W   R1,[R7+2]
00159A 8A07            3383         MOV.W   R0,[R7]
00159C 862C42          3384         MOV.B   ES,R1L
00159F BC0008          3385         MOV.W   [R0+8],#00H
0015A2 BC000A          3386         MOV.W   [R0+10],#00H
                       3387 ; rtxc.c   1348                }
                       3388 ; rtxc.c   1349 #endif /* } MAILBOX_TIMEOUTS */
                       3389 ; rtxc.c   1350             }
0015A5 FE14            3390         BR      _127
0015A5 FE1400          3390         BR      _127
0015A8                 3391 _123:
                       3392 ; rtxc.c   1351             else
                       3393 ; rtxc.c   1352             {
                       3394 ; rtxc.c   1353                insert_message(pmh, ((struct msgarg ks_stk *)p2)->prtxcmsg);
0015A8 86AC42          3395         MOV.B   ES,R5L
0015AB 8A24            3396         MOV.W   R2,[R4]
0015AD 8C3402          3397         MOV.W   R3,[R4+2]
0015B0 8C170A          3398         MOV.W   R1,[R7+10]
0015B3 8C0708          3399         MOV.W   R0,[R7+8]
0015B6 C50D42          3400         CALL    _insert_message
                       3401 ; rtxc.c   1354             }
                       3402 ; rtxc.c   1355          }
0015B9 FE0A            3403         BR      _127
0015B9 FE0A00          3403         BR      _127
0015BC                 3404 _124:
                       3405 ; rtxc.c   1356          else
                       3406 ; rtxc.c   1357 #endif /* } MAILBOX_WAITERS */
                       3407 ; rtxc.c   1358          {
                       3408 ; rtxc.c   1359             insert_message(pmh, ((struct msgarg ks_stk *)p2)->prtxcmsg);
0015BC 86AC42          3409         MOV.B   ES,R5L
0015BF 8A24            3410         MOV.W   R2,[R4]
0015C1 8C3402          3411         MOV.W   R3,[R4+2]
0015C4 8C170A          3412         MOV.W   R1,[R7+10]
0015C7 8C0708          3413         MOV.W   R0,[R7+8]
0015CA C50D38          3414         CALL    _insert_message
0015CA C50D3800        3414         CALL    _insert_message
                       3415 ; rtxc.c   1360          }
0015CE                 3416 _127:
                       3417 ; rtxc.c   1361 
                       3418 ; rtxc.c   1362          sema = ((struct msgarg ks_stk *)p2)->sema;
0015CE 8C3712          3419         MOV.W   R3,[R7+18]
0015D1 8C2710          3420         MOV.W   R2,[R7+16]
0015D4 866C42          3421         MOV.B   ES,R3L
0015D7 8262            3422         MOV.B   R3L,[R2]
                       3423 ; rtxc.c   1363 
                       3424 ; rtxc.c   1364 #ifdef MAILBOX_WAITERS /* { */
                       3425 ; rtxc.c   1365          /* if need to wait on response (sema) */
                       3426 ; rtxc.c   1366          if ( ((struct msgarg ks_stk *)p2)->wait)
0015D9 8C1716          3427         MOV.W   R1,[R7+22]
0015DC 8C0714          3428         MOV.W   R0,[R7+20]
0015DF 862C42          3429         MOV.B   ES,R1L
0015E2 84000C          3430         MOV.B   R0L,[R0+12]
0015E5 F365            3431         BEQ     _128
                       3432 ; rtxc.c   1367          {
                       3433 ; rtxc.c   1368             ptcb = hipritsk; /* save for later */
0015E7 8E5rrr          3434         MOV.W   R5,_hipritsk+2
0015EA 8E4rrr          3435         MOV.W   R4,_hipritsk
                       3436 ; rtxc.c   1369 
                       3437 ; rtxc.c   1370             semat[sema] = (SSTATE)ptcb->task;
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  62

ADDR   CODE            LINE SOURCELINE
0015ED 8C5F12          3438         MOV.W   [R7+18],R5
0015F0 8C4F10          3439         MOV.W   [R7+16],R4
0015F3 86AC42          3440         MOV.B   ES,R5L
0015F6 84040C          3441         MOV.B   R0L,[R4+12]
0015F9 8186            3442         MOV.B   R4L,R3L
0015FB B190            3443         MOVS.B  R4H,#00H
0015FD B950            3444         MOVS.W  R5,#00H
0015FF 964842rr        3445         MOV.B   ES,#SEG( _semat )
001603 850Crrrr        3446         MOV.B   [R4+SOF( _semat )],R0L
                       3447 ; rtxc.c   1371 
                       3448 ; rtxc.c   1372             ptcb->status = SEMAPHORE_WAIT;
001607 8C1712          3449         MOV.W   R1,[R7+18]
00160A 8C0710          3450         MOV.W   R0,[R7+16]
00160D 862C42          3451         MOV.B   ES,R1L
001610 9C08120040      3452         MOV.W   [R0+18],#040H
001615 8E1rrr          3453         MOV.W   R1,_hipritsk+2
001618 8E0rrr          3454         MOV.W   R0,_hipritsk
                       3455 ; rtxc.c   1373 
                       3456 ; rtxc.c   1374             UNLINK_HIPRITSK(); /* unlink first tcb */
00161B 862C42          3457         MOV.B   ES,R1L
00161E 8C1002          3458         MOV.W   R1,[R0+2]
001621 8A00            3459         MOV.W   R0,[R0]
001623 8E1rrr          3460         MOV.W   _hipritsk+2,R1
001626 8E0rrr          3461         MOV.W   _hipritsk,R0
001629 9928rrrr        3462         MOV.W   R2,#SOF( _hipritsk )
00162D 8942            3463         MOV.W   R4,R2
00162F B950            3464         MOVS.W  R5,#00H
001631 862C42          3465         MOV.B   ES,R1L
001634 8C4804          3466         MOV.W   [R0+4],R4
001637 8C5806          3467         MOV.W   [R0+6],R5
                       3468 ; rtxc.c   1375 
                       3469 ; rtxc.c   1376 #ifdef SEMAPHORE_TIMEOUTS /* { */
                       3470 ; rtxc.c   1377             if ( ((struct msgarg ks_stk *)p2)->ticks) /* if timeout active */
00163A 8C1716          3471         MOV.W   R1,[R7+22]
00163D 8C0714          3472         MOV.W   R0,[R7+20]
001640 862C42          3473         MOV.B   ES,R1L
001643 8C200E          3474         MOV.W   R2,[R0+14]
                       3475         BEQ     _428
001646 F202           +3475 ;       BNE     _LG_218
001648 D50CD2         +3475 ;       JMP.L   _428
001648 D50CD200       +3475 ;       JMP.L   _428
00164C                +3475 _LG_218:
                       3476 ; rtxc.c   1378             {
                       3477 ; rtxc.c   1379                ptcb->pclkblk = ((struct msgarg ks_stk *)p2)->pclkblk;
00164C 8C1716          3478         MOV.W   R1,[R7+22]
00164F 8C0714          3479         MOV.W   R0,[R7+20]
001652 862C42          3480         MOV.B   ES,R1L
001655 8C1012          3481         MOV.W   R1,[R0+18]
001658 8C0010          3482         MOV.W   R0,[R0+16]
00165B 8C5712          3483         MOV.W   R5,[R7+18]
00165E 8C4710          3484         MOV.W   R4,[R7+16]
001661 86AC42          3485         MOV.B   ES,R5L
001664 8C0C08          3486         MOV.W   [R4+8],R0
001667 8C1C0A          3487         MOV.W   [R4+10],R1
                       3488 ; rtxc.c   1380                pclkblk = ptcb->pclkblk;
00166A 86AC42          3489         MOV.B   ES,R5L
00166D 8C0408          3490         MOV.W   R0,[R4+8]
001670 8C140A          3491         MOV.W   R1,[R4+10]
                       3492 ; rtxc.c   1381                pclkblk->remain = ((struct msgarg ks_stk *)p2)->ticks;
001673 862C42          3493         MOV.B   ES,R1L
001676 8C2808          3494         MOV.W   [R0+8],R2
                       3495 ; rtxc.c   1382                pclkblk->recycle = (TICKS)0;
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  63

ADDR   CODE            LINE SOURCELINE
001679 862C42          3496         MOV.B   ES,R1L
00167C BC000A          3497         MOV.W   [R0+10],#00H
                       3498 ; rtxc.c   1383 
                       3499 ; rtxc.c   1384                /* mark object type */
                       3500 ; rtxc.c   1385                pclkblk->objtype = SEMAPHORE_OBJ;
00167F 862C42          3501         MOV.B   ES,R1L
001682 BC010E          3502         MOV.W   [R0+14],#01H
                       3503 ; rtxc.c   1386                pclkblk->objid = sema;
001685 862C42          3504         MOV.B   ES,R1L
001688 846810          3505         MOV.B   [R0+16],R3L
                       3506 ; rtxc.c   1387                pclkblk->task = ptcb->task;
00168B 8C5712          3507         MOV.W   R5,[R7+18]
00168E 8C4710          3508         MOV.W   R4,[R7+16]
001691 86AC42          3509         MOV.B   ES,R5L
001694 84440C          3510         MOV.B   R2L,[R4+12]
001697 862C42          3511         MOV.B   ES,R1L
00169A 84480C          3512         MOV.B   [R0+12],R2L
                       3513 ; rtxc.c   1388 
                       3514 ; rtxc.c   1389                /* insert timer */
                       3515 ; rtxc.c   1390                insert_timer(pclkblk);
00169D C51505          3516         CALL    _insert_timer
                       3517 ; rtxc.c   1391 
                       3518 ; rtxc.c   1392                ((struct msgarg ks_stk *)p2)->ksrc = RC_TIMEOUT;
0016A0 8C1716          3519         MOV.W   R1,[R7+22]
0016A3 8C0714          3520         MOV.W   R0,[R7+20]
0016A6 862C42          3521         MOV.B   ES,R1L
0016A9 BC0502          3522         MOV.W   [R0+2],#05H
                       3523 ; rtxc.c   1393             }
                       3524 ; rtxc.c   1394 #endif /* } SEMAPHORE_TIMEOUTS */
                       3525 ; rtxc.c   1395          }
                       3526         BR      _428
0016AC D50CA0         +3526         JMP.L   _428
0016AC D50CA000       +3526         JMP.L   _428
0016B0                 3527 _128:
                       3528 ; rtxc.c   1396          else
                       3529 ; rtxc.c   1397 #endif /* } MAILBOX_WAITERS */
                       3530 ; rtxc.c   1398          {
                       3531 ; rtxc.c   1399             if (sema != NULLSEMA)
0016B0 6166            3532         OR.B    R3L,R3L
                       3533         BEQ     _428
0016B2 F202           +3533 ;       BNE     _LG_220
0016B4 D50C9C         +3533 ;       JMP.L   _428
0016B4 D50C9C00       +3533 ;       JMP.L   _428
0016B8                +3533 _LG_220:
                       3534 ; rtxc.c   1400                semat[sema] = SEMA_PENDING;
0016B8 8146            3535         MOV.B   R2L,R3L
0016BA B150            3536         MOVS.B  R2H,#00H
0016BC B930            3537         MOVS.W  R3,#00H
0016BE 964842rr        3538         MOV.B   ES,#SEG( _semat )
0016C2 9528rrrrFF      3539         MOV.B   [R2+SOF( _semat )],#0FFH
                       3540 ; rtxc.c   1401          }
                       3541 ; rtxc.c   1402          break;
                       3542         BR      _428
0016C7 D50C92         +3542         JMP.L   _428
0016C7 D50C92         +3542         JMP.L   _428
                       3543 ; rtxc.c   1403 #endif /* } HAS_SEND */
                       3544 ; rtxc.c   1404 
                       3545 ; rtxc.c   1405 #ifdef HAS_RECEIVE /* { */
                       3546 ; rtxc.c   1406 /************************/
                       3547 ; rtxc.c   1407       case RTXC_RECEIVE:
0016CA                 3548 _129:
                       3549 ; rtxc.c   1408 /************************/
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  64

ADDR   CODE            LINE SOURCELINE
                       3550 ; rtxc.c   1409          pmh = (MHEADER ks_tbl *)&mheader[((struct msgarg ks_stk *)p2)->mbox];
0016CA 8915            3551         MOV.W   R1,R5
0016CC 8904            3552         MOV.W   R0,R4
0016CE 862C42          3553         MOV.B   ES,R1L
0016D1 844005          3554         MOV.B   R2L,[R0+5]
0016D4 E8400E          3555         MULU.B  R2L,#0EH
0016D7 B930            3556         MOVS.W  R3,#00H
0016D9 9958rrrr        3557         MOV.W   R5,#SEG( _mheader )
0016DD 9948rrrr        3558         MOV.W   R4,#SOF( _mheader )
0016E1 0942            3559         ADD.W   R4,R2
                       3560 ; rtxc.c   1410 
                       3561 ; rtxc.c   1411          /* if no messages are available */
                       3562 ; rtxc.c   1412          if ( (prtxcmsg = remove_message(pmh,
                       3563 ; rtxc.c   1413                             ((struct msgarg ks_stk *)p2)->task)) == NULL)
0016E3 8C1F16          3564         MOV.W   [R7+22],R1
0016E6 8C0F14          3565         MOV.W   [R7+20],R0
0016E9 862C42          3566         MOV.B   ES,R1L
0016EC 844006          3567         MOV.B   R2L,[R0+6]
0016EF 8915            3568         MOV.W   R1,R5
0016F1 8904            3569         MOV.W   R0,R4
0016F3 C50CF3          3570         CALL    _remove_message
0016F6 8C1F12          3571         MOV.W   [R7+18],R1
0016F9 8C0F10          3572         MOV.W   [R7+16],R0
0016FC 6910            3573         OR.W    R1,R0
0016FE F257            3574         BNE     _130
                       3575 ; rtxc.c   1414          {
                       3576 ; rtxc.c   1415 #ifdef MAILBOX_WAITERS /* { */
                       3577 ; rtxc.c   1416             if ( ((struct msgarg ks_stk *)p2)->wait)
001700 8C1716          3578         MOV.W   R1,[R7+22]
001703 8C0714          3579         MOV.W   R0,[R7+20]
001706 862C42          3580         MOV.B   ES,R1L
001709 84000C          3581         MOV.B   R0L,[R0+12]
00170C F36F            3582         BEQ     _136
                       3583 ; rtxc.c   1417             {
                       3584 ; rtxc.c   1418                ptcb = hipritsk; /* save for later */
00170E 8E1rrr          3585         MOV.W   R1,_hipritsk+2
001711 8E0rrr          3586         MOV.W   R0,_hipritsk
                       3587 ; rtxc.c   1419 
                       3588 ; rtxc.c   1420                ptcb->status = MSG_WAIT; /* set MSG_WAIT in status word */
001714 862C42          3589         MOV.B   ES,R1L
001717 9C08120020      3590         MOV.W   [R0+18],#020H
00171C 8C1F0E          3591         MOV.W   [R7+14],R1
00171F 8C0F0C          3592         MOV.W   [R7+12],R0
                       3593 ; rtxc.c   1421 
                       3594 ; rtxc.c   1422                /* thread waiting task in priority order */
                       3595 ; rtxc.c   1423                porder((TCB ks_tbl *)&pmh->waiters);
001722 99400004        3596         ADD.W   R4,#04H
001726 8915            3597         MOV.W   R1,R5
001728 8904            3598         MOV.W   R0,R4
00172A C51577          3599         CALL    _porder
                       3600 ; rtxc.c   1424 
                       3601 ; rtxc.c   1425 #ifdef MAILBOX_TIMEOUTS /* { */
                       3602 ; rtxc.c   1426                if ( ((struct msgarg ks_stk *)p2)->ticks) /* if timeout active*/
00172D 8C1716          3603         MOV.W   R1,[R7+22]
001730 8C0714          3604         MOV.W   R0,[R7+20]
001733 862C42          3605         MOV.B   ES,R1L
001736 8C200E          3606         MOV.W   R2,[R0+14]
001739 F359            3607         BEQ     _136
                       3608 ; rtxc.c   1427                {
                       3609 ; rtxc.c   1428                   ptcb->pclkblk = ((struct msgarg ks_stk *)p2)->pclkblk;
00173B 8C1716          3610         MOV.W   R1,[R7+22]
00173E 8C0714          3611         MOV.W   R0,[R7+20]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  65

ADDR   CODE            LINE SOURCELINE
001741 862C42          3612         MOV.B   ES,R1L
001744 8C1012          3613         MOV.W   R1,[R0+18]
001747 8C0010          3614         MOV.W   R0,[R0+16]
00174A 8C570E          3615         MOV.W   R5,[R7+14]
00174D 8C470C          3616         MOV.W   R4,[R7+12]
001750 86AC42          3617         MOV.B   ES,R5L
001753 8C0C08          3618         MOV.W   [R4+8],R0
001756 8C1C0A          3619         MOV.W   [R4+10],R1
                       3620 ; rtxc.c   1429                   pclkblk = ptcb->pclkblk;
001759 8915            3621         MOV.W   R1,R5
00175B 8904            3622         MOV.W   R0,R4
00175D 862C42          3623         MOV.B   ES,R1L
001760 8C100A          3624         MOV.W   R1,[R0+10]
001763 8C0008          3625         MOV.W   R0,[R0+8]
                       3626 ; rtxc.c   1430                   pclkblk->remain = ((struct msgarg ks_stk *)p2)->ticks;
001766 862C42          3627         MOV.B   ES,R1L
001769 8C2808          3628         MOV.W   [R0+8],R2
                       3629 ; rtxc.c   1431                   pclkblk->recycle = (TICKS)0;
00176C 862C42          3630         MOV.B   ES,R1L
00176F BC000A          3631         MOV.W   [R0+10],#00H
                       3632 ; rtxc.c   1432 
                       3633 ; rtxc.c   1433                   /* mark object type */
                       3634 ; rtxc.c   1434                   pclkblk->objtype = MAILBOX_OBJ;
001772 862C42          3635         MOV.B   ES,R1L
001775 BC050E          3636         MOV.W   [R0+14],#05H
                       3637 ; rtxc.c   1435                   pclkblk->objid = ((struct msgarg ks_stk *)p2)->mbox;
001778 8C3716          3638         MOV.W   R3,[R7+22]
00177B 8C2714          3639         MOV.W   R2,[R7+20]
00177E 866C42          3640         MOV.B   ES,R3L
001781 844205          3641         MOV.B   R2L,[R2+5]
001784 862C42          3642         MOV.B   ES,R1L
001787 844810          3643         MOV.B   [R0+16],R2L
                       3644 ; rtxc.c   1436                   pclkblk->task = ptcb->task;
00178A 8C370E          3645         MOV.W   R3,[R7+14]
00178D 8C270C          3646         MOV.W   R2,[R7+12]
001790 866C42          3647         MOV.B   ES,R3L
001793 84420C          3648         MOV.B   R2L,[R2+12]
001796 862C42          3649         MOV.B   ES,R1L
001799 84480C          3650         MOV.B   [R0+12],R2L
                       3651 ; rtxc.c   1437 
                       3652 ; rtxc.c   1438                   /* insert timer */
                       3653 ; rtxc.c   1439                   insert_timer(pclkblk);
00179C C51486          3654         CALL    _insert_timer
                       3655 ; rtxc.c   1440 
                       3656 ; rtxc.c   1441                   ((struct msgarg ks_stk *)p2)->ksrc = RC_TIMEOUT;
00179F 8C1716          3657         MOV.W   R1,[R7+22]
0017A2 8C0714          3658         MOV.W   R0,[R7+20]
0017A5 862C42          3659         MOV.B   ES,R1L
0017A8 BC0502          3660         MOV.W   [R0+2],#05H
                       3661 ; rtxc.c   1442                }
                       3662 ; rtxc.c   1443 #endif /* } MAILBOX_TIMEOUTS */
                       3663 ; rtxc.c   1444             }
                       3664 ; rtxc.c   1445 #endif /* } MAILBOX_WAITERS */
                       3665 ; rtxc.c   1446          }
0017AB FE20            3666         BR      _136
0017AB FE2000          3666         BR      _136
0017AE                 3667 _130:
                       3668 ; rtxc.c   1447          else /* message returned to caller */
                       3669 ; rtxc.c   1448          {
                       3670 ; rtxc.c   1449 #ifdef CBUG /* { */
                       3671 ; rtxc.c   1450             pmh->count++;
                       3672 ; rtxc.c   1451 #endif /* } CBUG */
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  66

ADDR   CODE            LINE SOURCELINE
                       3673 ; rtxc.c   1452 
                       3674 ; rtxc.c   1453 #ifdef MAILBOX_SEMAS /* { */
                       3675 ; rtxc.c   1454             if (pmh->nesema != NULLSEMA)
0017AE 8935            3676         MOV.W   R3,R5
0017B0 8924            3677         MOV.W   R2,R4
0017B2 9920000C        3678         ADD.W   R2,#0CH
0017B6 86AC42          3679         MOV.B   ES,R5L
0017B9 84040C          3680         MOV.B   R0L,[R4+12]
0017BC F317            3681         BEQ     _136
                       3682 ; rtxc.c   1455             {
                       3683 ; rtxc.c   1456                /* if now empty */
                       3684 ; rtxc.c   1457                if (pmh->link == NULL)
0017BE 86AC42          3685         MOV.B   ES,R5L
0017C1 8C5402          3686         MOV.W   R5,[R4+2]
0017C4 8A44            3687         MOV.W   R4,[R4]
0017C6 6954            3688         OR.W    R5,R4
0017C8 F208            3689         BNE     _131
                       3690 ; rtxc.c   1458                   semat[pmh->nesema] = SEMA_PENDING; /* reset */
0017CA B110            3691         MOVS.B  R0H,#00H
0017CC B910            3692         MOVS.W  R1,#00H
0017CE 964842rr        3693         MOV.B   ES,#SEG( _semat )
0017D2 9508rrrrFF      3694         MOV.B   [R0+SOF( _semat )],#0FFH
0017D7 FE0A            3695         BR      _136
0017D7 FE0A00          3695         BR      _136
0017DA                 3696 _131:
                       3697 ; rtxc.c   1459                else
                       3698 ; rtxc.c   1460                   semat[pmh->nesema] = SEMA_DONE; /* force not empty */
0017DA 866C42          3699         MOV.B   ES,R3L
0017DD 8202            3700         MOV.B   R0L,[R2]
0017DF B110            3701         MOVS.B  R0H,#00H
0017E1 B910            3702         MOVS.W  R1,#00H
0017E3 964842rr        3703         MOV.B   ES,#SEG( _semat )
0017E7 B500rrrr        3704         MOV.B   [R0+SOF( _semat )],#00H
0017E7 B500rrrr00      3704         MOV.B   [R0+SOF( _semat )],#00H
                       3705 ; rtxc.c   1461             }
                       3706 ; rtxc.c   1462 #endif /* } MAILBOX_SEMAS */
                       3707 ; rtxc.c   1463          }
0017EC                 3708 _136:
                       3709 ; rtxc.c   1464 
                       3710 ; rtxc.c   1465          /* return msg to caller */
                       3711 ; rtxc.c   1466          ((struct msgarg ks_stk *)p2)->prtxcmsg = prtxcmsg;
0017EC 8C3716          3712         MOV.W   R3,[R7+22]
0017EF 8C2714          3713         MOV.W   R2,[R7+20]
0017F2 8C1712          3714         MOV.W   R1,[R7+18]
0017F5 8C0710          3715         MOV.W   R0,[R7+16]
0017F8 866C42          3716         MOV.B   ES,R3L
0017FB 8C0A08          3717         MOV.W   [R2+8],R0
0017FE 8C1A0A          3718         MOV.W   [R2+10],R1
                       3719 ; rtxc.c   1467          break;
                       3720         BR      _428
001801 D50BF5         +3720         JMP.L   _428
001801 D50BF5         +3720         JMP.L   _428
                       3721 ; rtxc.c   1468 #endif /* } HAS_RECEIVE */
                       3722 ; rtxc.c   1469 #endif /* } HAS_MAILBOXES */
                       3723 ; rtxc.c   1470 
                       3724 ; rtxc.c   1471 #ifdef HAS_QUEUES /* { */
                       3725 ; rtxc.c   1472 #ifdef HAS_ENQUEUE /* { */
                       3726 ; rtxc.c   1473 /************************/
                       3727 ; rtxc.c   1474       case RTXC_ENQUEUE:
001804                 3728 _137:
                       3729 ; rtxc.c   1475 /************************/
                       3730 ; rtxc.c   1476          pqh = (QHEADER ks_tbl *)&qheader[((struct qarg ks_stk *)p2)->queue];
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  67

ADDR   CODE            LINE SOURCELINE
001804 8915            3731         MOV.W   R1,R5
001806 8904            3732         MOV.W   R0,R4
001808 8C1F16          3733         MOV.W   [R7+22],R1
00180B 8C0F14          3734         MOV.W   [R7+20],R0
00180E 862C42          3735         MOV.B   ES,R1L
001811 840005          3736         MOV.B   R0L,[R0+5]
001814 E80018          3737         MULU.B  R0L,#018H
001817 B910            3738         MOVS.W  R1,#00H
001819 9938rrrr        3739         MOV.W   R3,#SEG( _qheader )
00181D 9928rrrr        3740         MOV.W   R2,#SOF( _qheader )
001821 0920            3741         ADD.W   R2,R0
                       3742 ; rtxc.c   1477 
                       3743 ; rtxc.c   1478          if ( (depth = pqh->depth) == pqh->curndx) /* queue was already full */
001823 866C42          3744         MOV.B   ES,R3L
001826 8C0206          3745         MOV.W   R0,[R2+6]
001829 8C0F0E          3746         MOV.W   [R7+14],R0
00182C 8940            3747         MOV.W   R4,R0
00182E 8913            3748         MOV.W   R1,R3
001830 8902            3749         MOV.W   R0,R2
001832 9900000A        3750         ADD.W   R0,#0AH
001836 8C1F0C          3751         MOV.W   [R7+12],R1
001839 8C0F0A          3752         MOV.W   [R7+10],R0
00183C 866C42          3753         MOV.B   ES,R3L
00183F 4C4A0A          3754         CMP.W   [R2+10],R4
001842 F24A            3755         BNE     _138
                       3756 ; rtxc.c   1479          {
                       3757 ; rtxc.c   1480 #ifdef ENQUEUE_WAITERS /* { */
                       3758 ; rtxc.c   1481             if ( ((struct qarg ks_stk *)p2)->wait)
001844 8C1716          3759         MOV.W   R1,[R7+22]
001847 8C0714          3760         MOV.W   R0,[R7+20]
00184A 862C42          3761         MOV.B   ES,R1L
00184D 84000A          3762         MOV.B   R0L,[R0+10]
                       3763         BEQ     _428
001850 F202           +3763 ;       BNE     _LG_234
001852 D50BCD         +3763 ;       JMP.L   _428
001852 D50BCD00       +3763 ;       JMP.L   _428
001856                +3763 _LG_234:
                       3764 ; rtxc.c   1482             {
                       3765 ; rtxc.c   1483                ptcb = hipritsk; /* save hipritsk for later */
001856 8E5rrr          3766         MOV.W   R5,_hipritsk+2
001859 8E4rrr          3767         MOV.W   R4,_hipritsk
                       3768 ; rtxc.c   1484 
                       3769 ; rtxc.c   1485                ptcb->status = QUEUE_WAIT; /* set QUEUE_WAIT in status */
00185C 86AC42          3770         MOV.B   ES,R5L
00185F 9C48120080      3771         MOV.W   [R4+18],#080H
                       3772 ; rtxc.c   1486 
                       3773 ; rtxc.c   1487                /* thread waiting task in priority order */
                       3774 ; rtxc.c   1488                porder((TCB ks_tbl *)&pqh->waiters);
001864 8913            3775         MOV.W   R1,R3
001866 8902            3776         MOV.W   R0,R2
001868 9900000C        3777         ADD.W   R0,#0CH
00186C C514D6          3778         CALL    _porder
                       3779 ; rtxc.c   1489 
                       3780 ; rtxc.c   1490 #ifdef ENQUEUE_TIMEOUTS /* { */
                       3781 ; rtxc.c   1491                if ( ((struct qarg ks_stk *)p2)->ticks) /* if timeout active */
00186F 8C1716          3782         MOV.W   R1,[R7+22]
001872 8C0714          3783         MOV.W   R0,[R7+20]
001875 862C42          3784         MOV.B   ES,R1L
001878 8C200C          3785         MOV.W   R2,[R0+12]
                       3786         BEQ     _428
00187B F202           +3786 ;       BNE     _LG_236
00187D D50BB7         +3786 ;       JMP.L   _428
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  68

ADDR   CODE            LINE SOURCELINE
00187D D50BB7         +3786 ;       JMP.L   _428
001880                +3786 _LG_236:
                       3787 ; rtxc.c   1492                {
                       3788 ; rtxc.c   1493                   ptcb->pclkblk = ((struct qarg ks_stk *)p2)->pclkblk;
001880 8C1716          3789         MOV.W   R1,[R7+22]
001883 8C0714          3790         MOV.W   R0,[R7+20]
001886 862C42          3791         MOV.B   ES,R1L
001889 8C1010          3792         MOV.W   R1,[R0+16]
00188C 8C000E          3793         MOV.W   R0,[R0+14]
00188F 86AC42          3794         MOV.B   ES,R5L
001892 8C0C08          3795         MOV.W   [R4+8],R0
001895 8C1C0A          3796         MOV.W   [R4+10],R1
                       3797 ; rtxc.c   1494                   pclkblk = ptcb->pclkblk;
001898 86AC42          3798         MOV.B   ES,R5L
00189B 8C0408          3799         MOV.W   R0,[R4+8]
00189E 8C140A          3800         MOV.W   R1,[R4+10]
                       3801 ; rtxc.c   1495                   pclkblk->remain = ((struct qarg ks_stk *)p2)->ticks;
0018A1 862C42          3802         MOV.B   ES,R1L
0018A4 8C2808          3803         MOV.W   [R0+8],R2
                       3804 ; rtxc.c   1496                   pclkblk->recycle = (TICKS)0;
0018A7 862C42          3805         MOV.B   ES,R1L
0018AA BC000A          3806         MOV.W   [R0+10],#00H
                       3807 ; rtxc.c   1497 
                       3808 ; rtxc.c   1498                   /* mark object type */
                       3809 ; rtxc.c   1499                   pclkblk->objtype = QUEUE_OBJ;
0018AD 862C42          3810         MOV.B   ES,R1L
0018B0 BC030E          3811         MOV.W   [R0+14],#03H
                       3812 ; rtxc.c   1500                   pclkblk->objid = ((struct qarg ks_stk *)p2)->queue;
0018B3 8C3716          3813         MOV.W   R3,[R7+22]
0018B6 8C2714          3814         MOV.W   R2,[R7+20]
0018B9 866C42          3815         MOV.B   ES,R3L
0018BC 844205          3816         MOV.B   R2L,[R2+5]
0018BF 862C42          3817         MOV.B   ES,R1L
0018C2 844810          3818         MOV.B   [R0+16],R2L
                       3819 ; rtxc.c   1501                   pclkblk->task = ptcb->task;
0018C5 86AC42          3820         MOV.B   ES,R5L
0018C8 84440C          3821         MOV.B   R2L,[R4+12]
0018CB 862C42          3822         MOV.B   ES,R1L
0018CE 84480C          3823         MOV.B   [R0+12],R2L
                       3824 ; rtxc.c   1502 
                       3825 ; rtxc.c   1503                   /* insert timer */
                       3826 ; rtxc.c   1504                   insert_timer(pclkblk);
0018D1 C513EB          3827         CALL    _insert_timer
                       3828 ; rtxc.c   1505                }
                       3829 ; rtxc.c   1506 #endif /* } ENQUEUE_TIMEOUTS */
                       3830 ; rtxc.c   1507             }
                       3831 ; rtxc.c   1508 #endif /* } ENQUEUE_WAITERS */
                       3832 ; rtxc.c   1509             break;
                       3833         BR      _428
0018D4 D50B8C         +3833         JMP.L   _428
0018D4 D50B8C00       +3833         JMP.L   _428
                       3834 ; rtxc.c   1510          }
0018D8                 3835 _138:
                       3836 ; rtxc.c   1511 
                       3837 ; rtxc.c   1512          ((struct qarg ks_stk *)p2)->ksrc = RC_GOOD;
0018D8 8C1716          3838         MOV.W   R1,[R7+22]
0018DB 8C0714          3839         MOV.W   R0,[R7+20]
0018DE 862C42          3840         MOV.B   ES,R1L
0018E1 BC0002          3841         MOV.W   [R0+2],#00H
                       3842 ; rtxc.c   1513 
                       3843 ; rtxc.c   1514          width = pqh->width;
0018E4 8C3F12          3844         MOV.W   [R7+18],R3
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  69

ADDR   CODE            LINE SOURCELINE
0018E7 8C2F10          3845         MOV.W   [R7+16],R2
0018EA 866C42          3846         MOV.B   ES,R3L
0018ED 8C6204          3847         MOV.W   R6,[R2+4]
                       3848 ; rtxc.c   1515 
                       3849 ; rtxc.c   1516 #ifdef DEQUEUE_WAITERS /* { */
                       3850 ; rtxc.c   1517          /* if queue is empty && if there are waiters */
                       3851 ; rtxc.c   1518          if ( (pqh->curndx == 0) && ((ptcb = pqh->waiters) != NULLTCB) )
0018F0 8C170C          3852         MOV.W   R1,[R7+12]
0018F3 8C070A          3853         MOV.W   R0,[R7+10]
0018F6 862C42          3854         MOV.B   ES,R1L
0018F9 8A00            3855         MOV.W   R0,[R0]
                       3856         BNE     _155
0018FB F302           +3856 ;       BEQ     _LG_238
0018FD D500FE         +3856 ;       JMP.L   _155
0018FD D500FE         +3856 ;       JMP.L   _155
001900                +3856 _LG_238:
001900 8C1712          3857         MOV.W   R1,[R7+18]
001903 8C0710          3858         MOV.W   R0,[R7+16]
001906 9900000C        3859         ADD.W   R0,#0CH
00190A 8C3712          3860         MOV.W   R3,[R7+18]
00190D 8C2710          3861         MOV.W   R2,[R7+16]
001910 866C42          3862         MOV.B   ES,R3L
001913 8C420C          3863         MOV.W   R4,[R2+12]
001916 8C520E          3864         MOV.W   R5,[R2+14]
001919 8935            3865         MOV.W   R3,R5
00191B 8924            3866         MOV.W   R2,R4
00191D 6932            3867         OR.W    R3,R2
                       3868         BEQ     _155
00191F F202           +3868 ;       BNE     _LG_240
001921 D500EC         +3868 ;       JMP.L   _155
001921 D500EC         +3868 ;       JMP.L   _155
001924                +3868 _LG_240:
                       3869 ; rtxc.c   1519          {
                       3870 ; rtxc.c   1520             /* move data directly to first waiter */
                       3871 ; rtxc.c   1521 
                       3872 ; rtxc.c   1522             /* remove highest priority waiter (1st) */
                       3873 ; rtxc.c   1523             if ( (pqh->waiters = ptcb->flink) != NULLTCB)
001924 8C5F08          3874         MOV.W   [R7+8],R5
001927 8C4F06          3875         MOV.W   [R7+6],R4
00192A 86AC42          3876         MOV.B   ES,R5L
00192D 8A24            3877         MOV.W   R2,[R4]
00192F 8C3402          3878         MOV.W   R3,[R4+2]
001932 8C5712          3879         MOV.W   R5,[R7+18]
001935 8C4710          3880         MOV.W   R4,[R7+16]
001938 86AC42          3881         MOV.B   ES,R5L
00193B 8C2C0C          3882         MOV.W   [R4+12],R2
00193E 8C3C0E          3883         MOV.W   [R4+14],R3
001941 6932            3884         OR.W    R3,R2
001943 F30C            3885         BEQ     _139
                       3886 ; rtxc.c   1524                  ptcb->flink->blink = (TCB ks_tbl *)&pqh->waiters;
001945 8C3708          3887         MOV.W   R3,[R7+8]
001948 8C2706          3888         MOV.W   R2,[R7+6]
00194B 866C42          3889         MOV.B   ES,R3L
00194E 8C3202          3890         MOV.W   R3,[R2+2]
001951 8A22            3891         MOV.W   R2,[R2]
001953 866C42          3892         MOV.B   ES,R3L
001956 8C0A04          3893         MOV.W   [R2+4],R0
001959 8C1A06          3894         MOV.W   [R2+6],R1
001959 8C1A06          3894         MOV.W   [R2+6],R1
00195C                 3895 _139:
                       3896 ; rtxc.c   1525 
                       3897 ; rtxc.c   1526             if ( (ptcb->status &= ~QUEUE_WAIT) == READY)
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  70

ADDR   CODE            LINE SOURCELINE
00195C 8C1708          3898         MOV.W   R1,[R7+8]
00195F 8C0706          3899         MOV.W   R0,[R7+6]
001962 862C42          3900         MOV.B   ES,R1L
001965 8C0012          3901         MOV.W   R0,[R0+18]
001968 9905FF7F        3902         AND.W   R0,#0FF7FH
00196C 8C5708          3903         MOV.W   R5,[R7+8]
00196F 8C4706          3904         MOV.W   R4,[R7+6]
001972 86AC42          3905         MOV.B   ES,R5L
001975 9C4512FF7F      3906         AND.W   [R4+18],#0FF7FH
00197A 6900            3907         OR.W    R0,R0
00197C F20A            3908         BNE     _140
                       3909 ; rtxc.c   1527             {
                       3910 ; rtxc.c   1528                ptcb->flink = nsrttcb;
00197E 8E1rrr          3911         MOV.W   R1,_nsrttcb+2
001981 8E0rrr          3912         MOV.W   R0,_nsrttcb
001984 86AC42          3913         MOV.B   ES,R5L
001987 8A0C            3914         MOV.W   [R4],R0
001989 8C1C02          3915         MOV.W   [R4+2],R1
                       3916 ; rtxc.c   1529                nsrttcb = ptcb;
00198C 8E5rrr          3917         MOV.W   _nsrttcb+2,R5
00198F 8E4rrr          3918         MOV.W   _nsrttcb,R4
00198F 8E4rrr          3918         MOV.W   _nsrttcb,R4
                       3919 ; rtxc.c   1530             }
001992                 3920 _140:
                       3921 ; rtxc.c   1531 
                       3922 ; rtxc.c   1532 #ifdef DEQUEUE_TIMEOUTS /* { */
                       3923 ; rtxc.c   1533             /* cleanup any pending timeout */
                       3924 ; rtxc.c   1534             if ( (pclkblk = ptcb->pclkblk) != NULLCLK)
001992 86AC42          3925         MOV.B   ES,R5L
001995 8C0408          3926         MOV.W   R0,[R4+8]
001998 8C140A          3927         MOV.W   R1,[R4+10]
00199B 8931            3928         MOV.W   R3,R1
00199D 8920            3929         MOV.W   R2,R0
00199F 6932            3930         OR.W    R3,R2
0019A1 F307            3931         BEQ     _141
                       3932 ; rtxc.c   1535             {
                       3933 ; rtxc.c   1536                unlink_timer(pclkblk);
0019A3 C513FE          3934         CALL    _unlink_timer
                       3935 ; rtxc.c   1537                ptcb->pclkblk = NULLCLK;
0019A6 86AC42          3936         MOV.B   ES,R5L
0019A9 BC4008          3937         MOV.W   [R4+8],#00H
0019AC BC400A          3938         MOV.W   [R4+10],#00H
0019AC BC400A00        3938         MOV.W   [R4+10],#00H
                       3939 ; rtxc.c   1538             }
0019B0                 3940 _141:
                       3941 ; rtxc.c   1539 #endif /* } DEQUEUE_TIMEOUTS */
                       3942 ; rtxc.c   1540 
                       3943 ; rtxc.c   1541             p2a = ((FRAME ks_stk *)(ptcb->sp))->pksnum;
0019B0 86AC42          3944         MOV.B   ES,R5L
0019B3 8C040E          3945         MOV.W   R0,[R4+14]
0019B6 8C1410          3946         MOV.W   R1,[R4+16]
0019B9 862C42          3947         MOV.B   ES,R1L
0019BC 8C1006          3948         MOV.W   R1,[R0+6]
0019BF 8C0004          3949         MOV.W   R0,[R0+4]
                       3950 ; rtxc.c   1542 
                       3951 ; rtxc.c   1543             ((struct qarg ks_stk *)p2a)->ksrc = RC_GOOD;
0019C2 862C42          3952         MOV.B   ES,R1L
0019C5 BC0002          3953         MOV.W   [R0+2],#00H
                       3954 ; rtxc.c   1544 
                       3955 ; rtxc.c   1545 #ifdef QUEUE_MEMCPY /* { */
                       3956 ; rtxc.c   1546             if (width)
                       3957 ; rtxc.c   1547                memcpy( ((struct qarg ks_stk *)p2a)->data,
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  71

ADDR   CODE            LINE SOURCELINE
                       3958 ; rtxc.c   1548                        ((struct qarg ks_stk *)p2)->data,
                       3959 ; rtxc.c   1549                        width);
                       3960 ; rtxc.c   1550 #else /* } QUEUE_MEMCPY { */
                       3961 ; rtxc.c   1551             switch(width)
0019C8 99640000        3962         CMP.W   R6,#00H
0019CC F351            3963         BEQ     _149
0019CE 99640001        3964         CMP.W   R6,#01H
0019D2 F307            3965         BEQ     _142
0019D4 99640002        3966         CMP.W   R6,#02H
0019D8 F316            3967         BEQ     _143
0019DA 99640004        3968         CMP.W   R6,#04H
0019DE F325            3969         BEQ     _144
0019E0 FE39            3970         BR      _145
0019E0 FE39            3970         BR      _145
                       3971 ; rtxc.c   1552             {
                       3972 ; rtxc.c   1553                case 0:
                       3973 ; rtxc.c   1554                   break;
                       3974 ; rtxc.c   1555 
                       3975 ; rtxc.c   1556                case sizeof(char):
0019E2                 3976 _142:
                       3977 ; rtxc.c   1557                   *(char *)(((struct qarg ks_stk *)p2a)->data) =
                       3978 ; rtxc.c   1558                               *(char *)(((struct qarg ks_stk *)p2)->data);
0019E2 8C3716          3979         MOV.W   R3,[R7+22]
0019E5 8C2714          3980         MOV.W   R2,[R7+20]
0019E8 866C42          3981         MOV.B   ES,R3L
0019EB 8C3208          3982         MOV.W   R3,[R2+8]
0019EE 8C2206          3983         MOV.W   R2,[R2+6]
0019F1 866C42          3984         MOV.B   ES,R3L
0019F4 8242            3985         MOV.B   R2L,[R2]
0019F6 862C42          3986         MOV.B   ES,R1L
0019F9 8C1008          3987         MOV.W   R1,[R0+8]
0019FC 8C0006          3988         MOV.W   R0,[R0+6]
0019FF 862C42          3989         MOV.B   ES,R1L
001A02 8248            3990         MOV.B   [R0],R2L
                       3991 ; rtxc.c   1559                   break;
001A04 FE35            3992         BR      _149
001A04 FE35            3992         BR      _149
                       3993 ; rtxc.c   1560 
                       3994 ; rtxc.c   1561                case sizeof(short):
001A06                 3995 _143:
                       3996 ; rtxc.c   1562                   *(short *)(((struct qarg ks_stk *)p2a)->data) =
                       3997 ; rtxc.c   1563                               *(short *)(((struct qarg ks_stk *)p2)->data);
001A06 8C3716          3998         MOV.W   R3,[R7+22]
001A09 8C2714          3999         MOV.W   R2,[R7+20]
001A0C 866C42          4000         MOV.B   ES,R3L
001A0F 8C3208          4001         MOV.W   R3,[R2+8]
001A12 8C2206          4002         MOV.W   R2,[R2+6]
001A15 866C42          4003         MOV.B   ES,R3L
001A18 8A22            4004         MOV.W   R2,[R2]
001A1A 862C42          4005         MOV.B   ES,R1L
001A1D 8C1008          4006         MOV.W   R1,[R0+8]
001A20 8C0006          4007         MOV.W   R0,[R0+6]
001A23 862C42          4008         MOV.B   ES,R1L
001A26 8A28            4009         MOV.W   [R0],R2
                       4010 ; rtxc.c   1564                   break;
001A28 FE23            4011         BR      _149
001A28 FE23            4011         BR      _149
                       4012 ; rtxc.c   1565 
                       4013 ; rtxc.c   1566                case sizeof(long):
001A2A                 4014 _144:
                       4015 ; rtxc.c   1567                   *(long *)(((struct qarg ks_stk *)p2a)->data) =
                       4016 ; rtxc.c   1568                               *(long *)(((struct qarg ks_stk *)p2)->data);
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  72

ADDR   CODE            LINE SOURCELINE
001A2A 8C3716          4017         MOV.W   R3,[R7+22]
001A2D 8C2714          4018         MOV.W   R2,[R7+20]
001A30 866C42          4019         MOV.B   ES,R3L
001A33 8C3208          4020         MOV.W   R3,[R2+8]
001A36 8C2206          4021         MOV.W   R2,[R2+6]
001A39 866C42          4022         MOV.B   ES,R3L
001A3C 8C3202          4023         MOV.W   R3,[R2+2]
001A3F 8A22            4024         MOV.W   R2,[R2]
001A41 862C42          4025         MOV.B   ES,R1L
001A44 8C1008          4026         MOV.W   R1,[R0+8]
001A47 8C0006          4027         MOV.W   R0,[R0+6]
001A4A 862C42          4028         MOV.B   ES,R1L
001A4D 8A28            4029         MOV.W   [R0],R2
001A4F 8C3802          4030         MOV.W   [R0+2],R3
                       4031 ; rtxc.c   1569                   break;
001A52 FE0E            4032         BR      _149
001A52 FE0E            4032         BR      _149
                       4033 ; rtxc.c   1570 
                       4034 ; rtxc.c   1571                default:
001A54                 4035 _145:
                       4036 ; rtxc.c   1572                   memcpy( ((struct qarg ks_stk *)p2a)->data,
                       4037 ; rtxc.c   1573                           ((struct qarg ks_stk *)p2)->data,
                       4038 ; rtxc.c   1574                           width);
001A54 862C42          4039         MOV.B   ES,R1L
001A57 8C1008          4040         MOV.W   R1,[R0+8]
001A5A 8C0006          4041         MOV.W   R0,[R0+6]
001A5D 8C3716          4042         MOV.W   R3,[R7+22]
001A60 8C2714          4043         MOV.W   R2,[R7+20]
001A63 866C42          4044         MOV.B   ES,R3L
001A66 8C3208          4045         MOV.W   R3,[R2+8]
001A69 8C2206          4046         MOV.W   R2,[R2+6]
                       4047         CALL    _memcpy
001A6C C4rrrrrr       +4047 ;       FCALL   _memcpy
001A6C C4rrrrrr       +4047 ;       FCALL   _memcpy
                       4048 ; rtxc.c   1575                   break;
                       4049 ; rtxc.c   1576             }
001A70                 4050 _149:
                       4051 ; rtxc.c   1577 #endif /* } QUEUE_MEMCPY */
                       4052 ; rtxc.c   1578 
                       4053 ; rtxc.c   1579 #ifdef CBUG /* { */
                       4054 ; rtxc.c   1580             pqh->count++; /* increment total no. of enqueues to date */
                       4055 ; rtxc.c   1581 #endif /* } CBUG */
                       4056 ; rtxc.c   1582 
                       4057 ; rtxc.c   1583 #ifdef QUEUE_SEMAS /* { */
                       4058 ; rtxc.c   1584             /* queue was empty - process not empty sema for consumer */
                       4059 ; rtxc.c   1585             UPDATE_SEMA(pqh->nesema);
001A70 8C3712          4060         MOV.W   R3,[R7+18]
001A73 8C2710          4061         MOV.W   R2,[R7+16]
001A76 99200015        4062         ADD.W   R2,#015H
001A7A 8C1712          4063         MOV.W   R1,[R7+18]
001A7D 8C0710          4064         MOV.W   R0,[R7+16]
001A80 862C42          4065         MOV.B   ES,R1L
001A83 840015          4066         MOV.B   R0L,[R0+21]
001A86 F329            4067         BEQ     _153
001A88 B110            4068         MOVS.B  R0H,#00H
001A8A B910            4069         MOVS.W  R1,#00H
001A8C 9958rrrr        4070         MOV.W   R5,#SEG( _semat )
001A90 9948rrrr        4071         MOV.W   R4,#SOF( _semat )
001A94 0940            4072         ADD.W   R4,R0
001A96 964842rr        4073         MOV.B   ES,#SEG( _semat )
001A9A 85C0rrrr        4074         MOV.B   R6L,[R0+SOF( _semat )]
001A9E 91C4FF          4075         CMP.B   R6L,#0FFH
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  73

ADDR   CODE            LINE SOURCELINE
001AA1 F206            4076         BNE     _150
001AA3 964842rr        4077         MOV.B   ES,#SEG( _semat )
001AA7 B500rrrr        4078         MOV.B   [R0+SOF( _semat )],#00H
001AAB FE17            4079         BR      _153
001AAB FE1700          4079         BR      _153
001AAE                 4080 _150:
001AAE 86AC42          4081         MOV.B   ES,R5L
001AB1 8204            4082         MOV.B   R0L,[R4]
001AB3 F313            4083         BEQ     _153
001AB5 860401          4084         MOV.B   R0L,0401H
001AB8 9648018D        4085         MOV.B   0401H,#08DH
001ABC 866C42          4086         MOV.B   ES,R3L
001ABF 8212            4087         MOV.B   R0H,[R2]
001AC1 9Er0rr0001      4088         ADD.W   _semaput,#01H
001AC6 8E3rrr          4089         MOV.W   R3,_semaput+2
001AC9 8E2rrr          4090         MOV.W   R2,_semaput
001ACC 866C42          4091         MOV.B   ES,R3L
001ACF 821A            4092         MOV.B   [R2],R0H
001AD1 8E3rrr          4093         MOV.W   _semaput+2,R3
001AD4 8E2rrr          4094         MOV.W   _semaput,R2
001AD7 860C01          4095         MOV.B   0401H,R0L
001AD7 860C01          4095         MOV.B   0401H,R0L
001ADA                 4096 _153:
                       4097 ; rtxc.c   1586 
                       4098 ; rtxc.c   1587             /* queue was empty - process not full sema for producer */
                       4099 ; rtxc.c   1588             if (pqh->nfsema != NULLSEMA)
001ADA 8C1712          4100         MOV.W   R1,[R7+18]
001ADD 8C0710          4101         MOV.W   R0,[R7+16]
001AE0 862C42          4102         MOV.B   ES,R1L
001AE3 840017          4103         MOV.B   R0L,[R0+23]
                       4104         BEQ     _428
001AE6 F202           +4104 ;       BNE     _LG_262
001AE8 D50A82         +4104 ;       JMP.L   _428
001AE8 D50A8200       +4104 ;       JMP.L   _428
001AEC                +4104 _LG_262:
                       4105 ; rtxc.c   1589                   semat[pqh->nfsema] = SEMA_DONE;
001AEC B110            4106         MOVS.B  R0H,#00H
001AEE B910            4107         MOVS.W  R1,#00H
001AF0 964842rr        4108         MOV.B   ES,#SEG( _semat )
001AF4 B500rrrr        4109         MOV.B   [R0+SOF( _semat )],#00H
                       4110 ; rtxc.c   1590 #endif /* } QUEUE_SEMAS */
                       4111 ; rtxc.c   1591             break;
                       4112         BR      _428
001AF8 D50A7A         +4112         JMP.L   _428
001AF8 D50A7A00       +4112         JMP.L   _428
                       4113 ; rtxc.c   1592          }
001AFC                 4114 _155:
                       4115 ; rtxc.c   1593 #endif /* } DEQUEUE_WAITERS */
                       4116 ; rtxc.c   1594 
                       4117 ; rtxc.c   1595          /* move data into queue */
                       4118 ; rtxc.c   1596          pqh->curndx++;
001AFC 8C170C          4119         MOV.W   R1,[R7+12]
001AFF 8C070A          4120         MOV.W   R0,[R7+10]
001B02 862C42          4121         MOV.B   ES,R1L
001B05 AA01            4122         ADDS.W  [R0],#01H
                       4123 ; rtxc.c   1597          if (++pqh->putndx == depth)
001B07 8C1712          4124         MOV.W   R1,[R7+18]
001B0A 8C0710          4125         MOV.W   R0,[R7+16]
001B0D 99000008        4126         ADD.W   R0,#08H
001B11 8C3712          4127         MOV.W   R3,[R7+18]
001B14 8C2710          4128         MOV.W   R2,[R7+16]
001B17 866C42          4129         MOV.B   ES,R3L
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  74

ADDR   CODE            LINE SOURCELINE
001B1A 8C2208          4130         MOV.W   R2,[R2+8]
001B1D A921            4131         ADDS.W  R2,#01H
001B1F 8C5712          4132         MOV.W   R5,[R7+18]
001B22 8C4710          4133         MOV.W   R4,[R7+16]
001B25 86AC42          4134         MOV.B   ES,R5L
001B28 AC4108          4135         ADDS.W  [R4+8],#01H
001B2B 4C270E          4136         CMP.W   R2,[R7+14]
001B2E F206            4137         BNE     _156
                       4138 ; rtxc.c   1598             pqh->putndx = 0;  /* recycle index */
001B30 8C3712          4139         MOV.W   R3,[R7+18]
001B33 8C2710          4140         MOV.W   R2,[R7+16]
001B36 866C42          4141         MOV.B   ES,R3L
001B39 BC2008          4142         MOV.W   [R2+8],#00H
001B39 BC2008          4142         MOV.W   [R2+8],#00H
001B3C                 4143 _156:
                       4144 ; rtxc.c   1599 
                       4145 ; rtxc.c   1600          qindex = pqh->putndx; /* local for speed */
001B3C 862C42          4146         MOV.B   ES,R1L
001B3F 8A00            4147         MOV.W   R0,[R0]
                       4148 ; rtxc.c   1601 
                       4149 ; rtxc.c   1602 #ifdef QUEUE_MEMCPY /* { */
                       4150 ; rtxc.c   1603          if (width)
                       4151 ; rtxc.c   1604             ks_memcpyFN(pqh->base + (qindex * width),
                       4152 ; rtxc.c   1605                    ((struct qarg ks_stk *)p2)->data, width);
                       4153 ; rtxc.c   1606 #else /* } QUEUE_MEMCPY { */
                       4154 ; rtxc.c   1607          switch(width)
001B41 99640000        4155         CMP.W   R6,#00H
001B45 F369            4156         BEQ     _164
001B47 99640001        4157         CMP.W   R6,#01H
001B4B F308            4158         BEQ     _157
001B4D 99640002        4159         CMP.W   R6,#02H
001B51 F31C            4160         BEQ     _158
001B53 99640004        4161         CMP.W   R6,#04H
001B57 F331            4162         BEQ     _159
001B59 FE4A            4163         BR      _160
001B59 FE4A00          4163         BR      _160
                       4164 ; rtxc.c   1608          {
                       4165 ; rtxc.c   1609             case 0:
                       4166 ; rtxc.c   1610                break;
                       4167 ; rtxc.c   1611 
                       4168 ; rtxc.c   1612             case sizeof(char):
001B5C                 4169 _157:
                       4170 ; rtxc.c   1613                *(char ks_queue *)(pqh->base + qindex) =
                       4171 ; rtxc.c   1614                                   *(char *)(((struct qarg ks_stk *)p2)->data);
001B5C 8C3716          4172         MOV.W   R3,[R7+22]
001B5F 8C2714          4173         MOV.W   R2,[R7+20]
001B62 866C42          4174         MOV.B   ES,R3L
001B65 8C3208          4175         MOV.W   R3,[R2+8]
001B68 8C2206          4176         MOV.W   R2,[R2+6]
001B6B 866C42          4177         MOV.B   ES,R3L
001B6E 8222            4178         MOV.B   R1L,[R2]
001B70 8920            4179         MOV.W   R2,R0
001B72 9839            4180         SEXT.W  R3
001B74 8C5712          4181         MOV.W   R5,[R7+18]
001B77 8C4710          4182         MOV.W   R4,[R7+16]
001B7A 86AC42          4183         MOV.B   ES,R5L
001B7D 0A24            4184         ADD.W   R2,[R4]
001B7F 1C3402          4185         ADDC.W  R3,[R4+2]
001B82 866C42          4186         MOV.B   ES,R3L
001B85 822A            4187         MOV.B   [R2],R1L
                       4188 ; rtxc.c   1615                break;
001B87 FE48            4189         BR      _164
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  75

ADDR   CODE            LINE SOURCELINE
001B87 FE4800          4189         BR      _164
                       4190 ; rtxc.c   1616 
                       4191 ; rtxc.c   1617             case sizeof(short):
001B8A                 4192 _158:
                       4193 ; rtxc.c   1618                *(short ks_queue *)(pqh->base + (qindex << 1)) =
                       4194 ; rtxc.c   1619                                   *(short *)(((struct qarg ks_stk *)p2)->data);
001B8A 8C3716          4195         MOV.W   R3,[R7+22]
001B8D 8C2714          4196         MOV.W   R2,[R7+20]
001B90 866C42          4197         MOV.B   ES,R3L
001B93 8C3208          4198         MOV.W   R3,[R2+8]
001B96 8C2206          4199         MOV.W   R2,[R2+6]
001B99 866C42          4200         MOV.B   ES,R3L
001B9C 8A12            4201         MOV.W   R1,[R2]
001B9E D901            4202         ASL.W   R0,#01H
001BA0 8920            4203         MOV.W   R2,R0
001BA2 B930            4204         MOVS.W  R3,#00H
001BA4 8C5712          4205         MOV.W   R5,[R7+18]
001BA7 8C4710          4206         MOV.W   R4,[R7+16]
001BAA 86AC42          4207         MOV.B   ES,R5L
001BAD 0A24            4208         ADD.W   R2,[R4]
001BAF 1C3402          4209         ADDC.W  R3,[R4+2]
001BB2 866C42          4210         MOV.B   ES,R3L
001BB5 8A1A            4211         MOV.W   [R2],R1
                       4212 ; rtxc.c   1620                break;
001BB7 FE30            4213         BR      _164
001BB7 FE3000          4213         BR      _164
                       4214 ; rtxc.c   1621             case sizeof(long):
001BBA                 4215 _159:
                       4216 ; rtxc.c   1622                *(long ks_queue *)(pqh->base + (qindex << 2)) =
                       4217 ; rtxc.c   1623                                   *(long *)(((struct qarg ks_stk *)p2)->data);
001BBA 8C3716          4218         MOV.W   R3,[R7+22]
001BBD 8C2714          4219         MOV.W   R2,[R7+20]
001BC0 866C42          4220         MOV.B   ES,R3L
001BC3 8C3208          4221         MOV.W   R3,[R2+8]
001BC6 8C2206          4222         MOV.W   R2,[R2+6]
001BC9 866C42          4223         MOV.B   ES,R3L
001BCC 8C3202          4224         MOV.W   R3,[R2+2]
001BCF 8A22            4225         MOV.W   R2,[R2]
001BD1 D902            4226         ASL.W   R0,#02H
001BD3 B910            4227         MOVS.W  R1,#00H
001BD5 8C5712          4228         MOV.W   R5,[R7+18]
001BD8 8C4710          4229         MOV.W   R4,[R7+16]
001BDB 86AC42          4230         MOV.B   ES,R5L
001BDE 0A04            4231         ADD.W   R0,[R4]
001BE0 1C1402          4232         ADDC.W  R1,[R4+2]
001BE3 862C42          4233         MOV.B   ES,R1L
001BE6 8A28            4234         MOV.W   [R0],R2
001BE8 8C3802          4235         MOV.W   [R0+2],R3
                       4236 ; rtxc.c   1624                break;
001BEB FE16            4237         BR      _164
001BEB FE1600          4237         BR      _164
                       4238 ; rtxc.c   1625 
                       4239 ; rtxc.c   1626             default:
001BEE                 4240 _160:
                       4241 ; rtxc.c   1627                ks_memcpyFN(pqh->base + (qindex * width),
                       4242 ; rtxc.c   1628                        ((struct qarg ks_stk *)p2)->data,
                       4243 ; rtxc.c   1629                        width);
001BEE E406            4244         MULU.W  R0,R6
001BF0 8940            4245         MOV.W   R4,R0
001BF2 B950            4246         MOVS.W  R5,#00H
001BF4 8C1712          4247         MOV.W   R1,[R7+18]
001BF7 8C0710          4248         MOV.W   R0,[R7+16]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  76

ADDR   CODE            LINE SOURCELINE
001BFA 862C42          4249         MOV.B   ES,R1L
001BFD 0A40            4250         ADD.W   R4,[R0]
001BFF 1C5002          4251         ADDC.W  R5,[R0+2]
001C02 8C3716          4252         MOV.W   R3,[R7+22]
001C05 8C2714          4253         MOV.W   R2,[R7+20]
001C08 866C42          4254         MOV.B   ES,R3L
001C0B 8C3208          4255         MOV.W   R3,[R2+8]
001C0E 8C2206          4256         MOV.W   R2,[R2+6]
001C11 8915            4257         MOV.W   R1,R5
001C13 8904            4258         MOV.W   R0,R4
001C15 C515BF          4259         CALL    _ks_memcpyFN
001C15 C515BF          4259         CALL    _ks_memcpyFN
                       4260 ; rtxc.c   1630                break;
                       4261 ; rtxc.c   1631          }
001C18                 4262 _164:
                       4263 ; rtxc.c   1632 #endif /* } QUEUE_MEMCPY */
                       4264 ; rtxc.c   1633 
                       4265 ; rtxc.c   1634 #ifdef CBUG /* { */
                       4266 ; rtxc.c   1635          pqh->count++; /* increment total no. of enqueues to date */
                       4267 ; rtxc.c   1636          if (pqh->curndx > pqh->worst) /* check for new worst case full condition
                             */
                       4268 ; rtxc.c   1637             pqh->worst = pqh->curndx;
                       4269 ; rtxc.c   1638 #endif /* } CBUG */
                       4270 ; rtxc.c   1639 
                       4271 ; rtxc.c   1640 #ifdef QUEUE_SEMAS /* { */
                       4272 ; rtxc.c   1641          if (pqh->curndx == depth)               /* queue is now full */
001C18 8C170C          4273         MOV.W   R1,[R7+12]
001C1B 8C070A          4274         MOV.W   R0,[R7+10]
001C1E 862C42          4275         MOV.B   ES,R1L
001C21 8A60            4276         MOV.W   R6,[R0]
001C23 8C270E          4277         MOV.W   R2,[R7+14]
001C26 8C170C          4278         MOV.W   R1,[R7+12]
001C29 8C070A          4279         MOV.W   R0,[R7+10]
001C2C 862C42          4280         MOV.B   ES,R1L
001C2F 4A28            4281         CMP.W   [R0],R2
001C31 F24A            4282         BNE     _167
                       4283 ; rtxc.c   1642          {
                       4284 ; rtxc.c   1643             if (pqh->nfsema != NULLSEMA)
001C33 8C1712          4285         MOV.W   R1,[R7+18]
001C36 8C0710          4286         MOV.W   R0,[R7+16]
001C39 862C42          4287         MOV.B   ES,R1L
001C3C 840017          4288         MOV.B   R0L,[R0+23]
001C3F F307            4289         BEQ     _165
                       4290 ; rtxc.c   1644                semat[pqh->nfsema] = SEMA_PENDING; /*set not full sema pending*/
001C41 B110            4291         MOVS.B  R0H,#00H
001C43 B910            4292         MOVS.W  R1,#00H
001C45 964842rr        4293         MOV.B   ES,#SEG( _semat )
001C49 9508rrrrFF      4294         MOV.B   [R0+SOF( _semat )],#0FFH
001C49 9508rrrrFF      4294         MOV.B   [R0+SOF( _semat )],#0FFH
001C4E                 4295 _165:
                       4296 ; rtxc.c   1645 
                       4297 ; rtxc.c   1646             UPDATE_SEMA(pqh->fsema);
001C4E 8C1712          4298         MOV.W   R1,[R7+18]
001C51 8C0710          4299         MOV.W   R0,[R7+16]
001C54 99000014        4300         ADD.W   R0,#014H
001C58 8C1F16          4301         MOV.W   [R7+22],R1
001C5B 8C0F14          4302         MOV.W   [R7+20],R0
001C5E 8C1712          4303         MOV.W   R1,[R7+18]
001C61 8C0710          4304         MOV.W   R0,[R7+16]
001C64 862C42          4305         MOV.B   ES,R1L
001C67 840014          4306         MOV.B   R0L,[R0+20]
001C6A F33A            4307         BEQ     _172
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  77

ADDR   CODE            LINE SOURCELINE
001C6C B110            4308         MOVS.B  R0H,#00H
001C6E B910            4309         MOVS.W  R1,#00H
001C70 9958rrrr        4310         MOV.W   R5,#SEG( _semat )
001C74 9948rrrr        4311         MOV.W   R4,#SOF( _semat )
001C78 0940            4312         ADD.W   R4,R0
001C7A 964842rr        4313         MOV.B   ES,#SEG( _semat )
001C7E 8540rrrr        4314         MOV.B   R2L,[R0+SOF( _semat )]
001C82 9144FF          4315         CMP.B   R2L,#0FFH
001C85 F206            4316         BNE     _166
001C87 964842rr        4317         MOV.B   ES,#SEG( _semat )
001C8B B500rrrr        4318         MOV.B   [R0+SOF( _semat )],#00H
001C8F FE28            4319         BR      _172
001C8F FE2800          4319         BR      _172
001C92                 4320 _166:
001C92 86AC42          4321         MOV.B   ES,R5L
001C95 8204            4322         MOV.B   R0L,[R4]
001C97 F324            4323         BEQ     _172
001C99 860401          4324         MOV.B   R0L,0401H
001C9C 9648018D        4325         MOV.B   0401H,#08DH
001CA0 8C3716          4326         MOV.W   R3,[R7+22]
001CA3 8C2714          4327         MOV.W   R2,[R7+20]
001CA6 866C42          4328         MOV.B   ES,R3L
001CA9 8212            4329         MOV.B   R0H,[R2]
001CAB 9Er0rr0001      4330         ADD.W   _semaput,#01H
001CB0 8E3rrr          4331         MOV.W   R3,_semaput+2
001CB3 8E2rrr          4332         MOV.W   R2,_semaput
001CB6 866C42          4333         MOV.B   ES,R3L
001CB9 821A            4334         MOV.B   [R2],R0H
001CBB 8E3rrr          4335         MOV.W   _semaput+2,R3
001CBE 8E2rrr          4336         MOV.W   _semaput,R2
001CC1 860C01          4337         MOV.B   0401H,R0L
                       4338 ; rtxc.c   1647          }
001CC4 FE0D            4339         BR      _172
001CC4 FE0D            4339         BR      _172
001CC6                 4340 _167:
                       4341 ; rtxc.c   1648          else                               /* still room in queue */
                       4342 ; rtxc.c   1649          {
                       4343 ; rtxc.c   1650             if (pqh->nfsema != NULLSEMA)
001CC6 8C1712          4344         MOV.W   R1,[R7+18]
001CC9 8C0710          4345         MOV.W   R0,[R7+16]
001CCC 862C42          4346         MOV.B   ES,R1L
001CCF 840017          4347         MOV.B   R0L,[R0+23]
001CD2 F306            4348         BEQ     _172
                       4349 ; rtxc.c   1651                semat[pqh->nfsema] = SEMA_DONE;
001CD4 B110            4350         MOVS.B  R0H,#00H
001CD6 B910            4351         MOVS.W  R1,#00H
001CD8 964842rr        4352         MOV.B   ES,#SEG( _semat )
001CDC B500rrrr        4353         MOV.B   [R0+SOF( _semat )],#00H
001CDC B500rrrr        4353         MOV.B   [R0+SOF( _semat )],#00H
                       4354 ; rtxc.c   1652          }
001CE0                 4355 _172:
                       4356 ; rtxc.c   1653 
                       4357 ; rtxc.c   1654          if (pqh->curndx == 1) /* if was empty */
001CE0 99640001        4358         CMP.W   R6,#01H
                       4359         BNE     _428
001CE4 F302           +4359 ;       BEQ     _LG_286
001CE6 D50983         +4359 ;       JMP.L   _428
001CE6 D5098300       +4359 ;       JMP.L   _428
001CEA                +4359 _LG_286:
                       4360 ; rtxc.c   1655          {
                       4361 ; rtxc.c   1656             if (pqh->esema != NULLSEMA)
001CEA 8C1712          4362         MOV.W   R1,[R7+18]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  78

ADDR   CODE            LINE SOURCELINE
001CED 8C0710          4363         MOV.W   R0,[R7+16]
001CF0 862C42          4364         MOV.B   ES,R1L
001CF3 840016          4365         MOV.B   R0L,[R0+22]
001CF6 F307            4366         BEQ     _173
                       4367 ; rtxc.c   1657                semat[pqh->esema] = SEMA_PENDING;
001CF8 B110            4368         MOVS.B  R0H,#00H
001CFA B910            4369         MOVS.W  R1,#00H
001CFC 964842rr        4370         MOV.B   ES,#SEG( _semat )
001D00 9508rrrrFF      4371         MOV.B   [R0+SOF( _semat )],#0FFH
001D00 9508rrrrFF00    4371         MOV.B   [R0+SOF( _semat )],#0FFH
001D06                 4372 _173:
                       4373 ; rtxc.c   1658 
                       4374 ; rtxc.c   1659             UPDATE_SEMA(pqh->nesema);
001D06 8C3712          4375         MOV.W   R3,[R7+18]
001D09 8C2710          4376         MOV.W   R2,[R7+16]
001D0C 99200015        4377         ADD.W   R2,#015H
001D10 8C1712          4378         MOV.W   R1,[R7+18]
001D13 8C0710          4379         MOV.W   R0,[R7+16]
001D16 862C42          4380         MOV.B   ES,R1L
001D19 840015          4381         MOV.B   R0L,[R0+21]
                       4382         BEQ     _428
001D1C F202           +4382 ;       BNE     _LG_290
001D1E D50967         +4382 ;       JMP.L   _428
001D1E D5096700       +4382 ;       JMP.L   _428
001D22                +4382 _LG_290:
001D22 B110            4383         MOVS.B  R0H,#00H
001D24 B910            4384         MOVS.W  R1,#00H
001D26 9958rrrr        4385         MOV.W   R5,#SEG( _semat )
001D2A 9948rrrr        4386         MOV.W   R4,#SOF( _semat )
001D2E 0940            4387         ADD.W   R4,R0
001D30 964842rr        4388         MOV.B   ES,#SEG( _semat )
001D34 85C0rrrr        4389         MOV.B   R6L,[R0+SOF( _semat )]
001D38 91C4FF          4390         CMP.B   R6L,#0FFH
001D3B F206            4391         BNE     _174
001D3D 964842rr        4392         MOV.B   ES,#SEG( _semat )
001D41 B500rrrr        4393         MOV.B   [R0+SOF( _semat )],#00H
                       4394         BR      _428
001D45 D50953         +4394         JMP.L   _428
001D45 D50953         +4394         JMP.L   _428
001D48                 4395 _174:
001D48 86AC42          4396         MOV.B   ES,R5L
001D4B 8204            4397         MOV.B   R0L,[R4]
                       4398         BEQ     _428
001D4D F202           +4398 ;       BNE     _LG_294
001D4F D5094E         +4398 ;       JMP.L   _428
001D4F D5094E         +4398 ;       JMP.L   _428
001D52                +4398 _LG_294:
001D52 860401          4399         MOV.B   R0L,0401H
001D55 9648018D        4400         MOV.B   0401H,#08DH
001D59 866C42          4401         MOV.B   ES,R3L
001D5C 8212            4402         MOV.B   R0H,[R2]
001D5E 9Er0rr0001      4403         ADD.W   _semaput,#01H
001D63 8E3rrr          4404         MOV.W   R3,_semaput+2
001D66 8E2rrr          4405         MOV.W   R2,_semaput
001D69 866C42          4406         MOV.B   ES,R3L
001D6C 821A            4407         MOV.B   [R2],R0H
001D6E 8E3rrr          4408         MOV.W   _semaput+2,R3
001D71 8E2rrr          4409         MOV.W   _semaput,R2
001D74 860C01          4410         MOV.B   0401H,R0L
                       4411 ; rtxc.c   1660          }
                       4412 ; rtxc.c   1661 #endif /* } QUEUE_SEMAS */
                       4413 ; rtxc.c   1662          break;
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  79

ADDR   CODE            LINE SOURCELINE
                       4414         BR      _428
001D77 D5093A         +4414         JMP.L   _428
001D77 D5093A         +4414         JMP.L   _428
                       4415 ; rtxc.c   1663 #endif /* } HAS_ENQUEUE */
                       4416 ; rtxc.c   1664 
                       4417 ; rtxc.c   1665 #ifdef HAS_DEQUEUE /* { */
                       4418 ; rtxc.c   1666 /************************/
                       4419 ; rtxc.c   1667       case RTXC_DEQUEUE:
001D7A                 4420 _175:
                       4421 ; rtxc.c   1668 /************************/
                       4422 ; rtxc.c   1669          pqh = (QHEADER ks_tbl *)&qheader[((struct qarg ks_stk *)p2)->queue];
001D7A 8915            4423         MOV.W   R1,R5
001D7C 8904            4424         MOV.W   R0,R4
001D7E 8C1F16          4425         MOV.W   [R7+22],R1
001D81 8C0F14          4426         MOV.W   [R7+20],R0
001D84 862C42          4427         MOV.B   ES,R1L
001D87 840005          4428         MOV.B   R0L,[R0+5]
001D8A E80018          4429         MULU.B  R0L,#018H
001D8D B910            4430         MOVS.W  R1,#00H
001D8F 9938rrrr        4431         MOV.W   R3,#SEG( _qheader )
001D93 9928rrrr        4432         MOV.W   R2,#SOF( _qheader )
001D97 0920            4433         ADD.W   R2,R0
                       4434 ; rtxc.c   1670 
                       4435 ; rtxc.c   1671          if (pqh->curndx == 0)  /* empty queue */
001D99 8953            4436         MOV.W   R5,R3
001D9B 8942            4437         MOV.W   R4,R2
001D9D 9940000A        4438         ADD.W   R4,#0AH
001DA1 866C42          4439         MOV.B   ES,R3L
001DA4 8C020A          4440         MOV.W   R0,[R2+10]
001DA7 F24A            4441         BNE     _176
                       4442 ; rtxc.c   1672          {
                       4443 ; rtxc.c   1673 #ifdef DEQUEUE_WAITERS /* { */
                       4444 ; rtxc.c   1674             if ( ((struct qarg ks_stk *)p2)->wait)
001DA9 8C1716          4445         MOV.W   R1,[R7+22]
001DAC 8C0714          4446         MOV.W   R0,[R7+20]
001DAF 862C42          4447         MOV.B   ES,R1L
001DB2 84000A          4448         MOV.B   R0L,[R0+10]
                       4449         BEQ     _428
001DB5 F202           +4449 ;       BNE     _LG_298
001DB7 D5091A         +4449 ;       JMP.L   _428
001DB7 D5091A         +4449 ;       JMP.L   _428
001DBA                +4449 _LG_298:
                       4450 ; rtxc.c   1675             {
                       4451 ; rtxc.c   1676                ptcb = hipritsk; /* save copy of hipritsk */
001DBA 8E5rrr          4452         MOV.W   R5,_hipritsk+2
001DBD 8E4rrr          4453         MOV.W   R4,_hipritsk
                       4454 ; rtxc.c   1677 
                       4455 ; rtxc.c   1678                ptcb->status = QUEUE_WAIT; /* set QUEUE_WAIT in status */
001DC0 86AC42          4456         MOV.B   ES,R5L
001DC3 9C48120080      4457         MOV.W   [R4+18],#080H
                       4458 ; rtxc.c   1679 
                       4459 ; rtxc.c   1680                /* thread waiting task in priority order */
                       4460 ; rtxc.c   1681                porder((TCB ks_tbl *)&pqh->waiters);
001DC8 8913            4461         MOV.W   R1,R3
001DCA 8902            4462         MOV.W   R0,R2
001DCC 9900000C        4463         ADD.W   R0,#0CH
001DD0 C51224          4464         CALL    _porder
                       4465 ; rtxc.c   1682 
                       4466 ; rtxc.c   1683 #ifdef DEQUEUE_TIMEOUTS /* { */
                       4467 ; rtxc.c   1684                if ( ((struct qarg ks_stk *)p2)->ticks) /* if timeout active */
001DD3 8C1716          4468         MOV.W   R1,[R7+22]
001DD6 8C0714          4469         MOV.W   R0,[R7+20]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  80

ADDR   CODE            LINE SOURCELINE
001DD9 862C42          4470         MOV.B   ES,R1L
001DDC 8C200C          4471         MOV.W   R2,[R0+12]
                       4472         BEQ     _428
001DDF F202           +4472 ;       BNE     _LG_300
001DE1 D50905         +4472 ;       JMP.L   _428
001DE1 D50905         +4472 ;       JMP.L   _428
001DE4                +4472 _LG_300:
                       4473 ; rtxc.c   1685                {
                       4474 ; rtxc.c   1686                   ptcb->pclkblk = ((struct qarg ks_stk *)p2)->pclkblk;
001DE4 8C1716          4475         MOV.W   R1,[R7+22]
001DE7 8C0714          4476         MOV.W   R0,[R7+20]
001DEA 862C42          4477         MOV.B   ES,R1L
001DED 8C1010          4478         MOV.W   R1,[R0+16]
001DF0 8C000E          4479         MOV.W   R0,[R0+14]
001DF3 86AC42          4480         MOV.B   ES,R5L
001DF6 8C0C08          4481         MOV.W   [R4+8],R0
001DF9 8C1C0A          4482         MOV.W   [R4+10],R1
                       4483 ; rtxc.c   1687                   pclkblk = ptcb->pclkblk;
001DFC 86AC42          4484         MOV.B   ES,R5L
001DFF 8C0408          4485         MOV.W   R0,[R4+8]
001E02 8C140A          4486         MOV.W   R1,[R4+10]
                       4487 ; rtxc.c   1688                   pclkblk->remain = ((struct qarg ks_stk *)p2)->ticks;
001E05 862C42          4488         MOV.B   ES,R1L
001E08 8C2808          4489         MOV.W   [R0+8],R2
                       4490 ; rtxc.c   1689                   pclkblk->recycle = (TICKS)0;
001E0B 862C42          4491         MOV.B   ES,R1L
001E0E BC000A          4492         MOV.W   [R0+10],#00H
                       4493 ; rtxc.c   1690 
                       4494 ; rtxc.c   1691                   /* mark object type */
                       4495 ; rtxc.c   1692                   pclkblk->objtype = QUEUE_OBJ;
001E11 862C42          4496         MOV.B   ES,R1L
001E14 BC030E          4497         MOV.W   [R0+14],#03H
                       4498 ; rtxc.c   1693                   pclkblk->objid = ((struct qarg ks_stk *)p2)->queue;
001E17 8C3716          4499         MOV.W   R3,[R7+22]
001E1A 8C2714          4500         MOV.W   R2,[R7+20]
001E1D 866C42          4501         MOV.B   ES,R3L
001E20 844205          4502         MOV.B   R2L,[R2+5]
001E23 862C42          4503         MOV.B   ES,R1L
001E26 844810          4504         MOV.B   [R0+16],R2L
                       4505 ; rtxc.c   1694                   pclkblk->task = ptcb->task;
001E29 86AC42          4506         MOV.B   ES,R5L
001E2C 84440C          4507         MOV.B   R2L,[R4+12]
001E2F 862C42          4508         MOV.B   ES,R1L
001E32 84480C          4509         MOV.B   [R0+12],R2L
                       4510 ; rtxc.c   1695 
                       4511 ; rtxc.c   1696                   /* insert timer */
                       4512 ; rtxc.c   1697                   insert_timer(pclkblk);
001E35 C51139          4513         CALL    _insert_timer
                       4514 ; rtxc.c   1698                }
                       4515 ; rtxc.c   1699 
                       4516 ; rtxc.c   1700 #endif /* } DEQUEUE_TIMEOUTS */
                       4517 ; rtxc.c   1701             }
                       4518 ; rtxc.c   1702 
                       4519 ; rtxc.c   1703 #endif /* } DEQUEUE_WAITERS */
                       4520 ; rtxc.c   1704             break;
                       4521         BR      _428
001E38 D508DA         +4521         JMP.L   _428
001E38 D508DA00       +4521         JMP.L   _428
                       4522 ; rtxc.c   1705          }
001E3C                 4523 _176:
                       4524 ; rtxc.c   1706 
                       4525 ; rtxc.c   1707          /* queue not empty, get entry */
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  81

ADDR   CODE            LINE SOURCELINE
                       4526 ; rtxc.c   1708 
                       4527 ; rtxc.c   1709          ((struct qarg ks_stk *)p2)->ksrc = RC_GOOD;
001E3C 8C1716          4528         MOV.W   R1,[R7+22]
001E3F 8C0714          4529         MOV.W   R0,[R7+20]
001E42 862C42          4530         MOV.B   ES,R1L
001E45 BC0002          4531         MOV.W   [R0+2],#00H
                       4532 ; rtxc.c   1710 
                       4533 ; rtxc.c   1711          qindex = pqh->putndx - --pqh->curndx;
001E48 8C3F12          4534         MOV.W   [R7+18],R3
001E4B 8C2F10          4535         MOV.W   [R7+16],R2
001E4E 99200008        4536         ADD.W   R2,#08H
001E52 8C3F0A          4537         MOV.W   [R7+10],R3
001E55 8C2F08          4538         MOV.W   [R7+8],R2
001E58 8C1712          4539         MOV.W   R1,[R7+18]
001E5B 8C0710          4540         MOV.W   R0,[R7+16]
001E5E 862C42          4541         MOV.B   ES,R1L
001E61 8C0008          4542         MOV.W   R0,[R0+8]
001E64 86AC42          4543         MOV.B   ES,R5L
001E67 8A14            4544         MOV.W   R1,[R4]
001E69 A91F            4545         ADDS.W  R1,#0FH
001E6B 86AC42          4546         MOV.B   ES,R5L
001E6E AA4F            4547         ADDS.W  [R4],#0FH
001E70 8C5F0E          4548         MOV.W   [R7+14],R5
001E73 8C4F0C          4549         MOV.W   [R7+12],R4
001E76 2901            4550         SUB.W   R0,R1
001E78 8920            4551         MOV.W   R2,R0
                       4552 ; rtxc.c   1712          if (qindex < 0)
001E7A 99040000        4553         CMP.W   R0,#00H
001E7E FA08            4554         BGE     _177
                       4555 ; rtxc.c   1713             qindex += pqh->depth;  /* wrap around */
001E80 8C3712          4556         MOV.W   R3,[R7+18]
001E83 8C2710          4557         MOV.W   R2,[R7+16]
001E86 866C42          4558         MOV.B   ES,R3L
001E89 8C1206          4559         MOV.W   R1,[R2+6]
001E8C 0901            4560         ADD.W   R0,R1
001E8E 8920            4561         MOV.W   R2,R0
001E8E 8920            4561         MOV.W   R2,R0
001E90                 4562 _177:
                       4563 ; rtxc.c   1714 
                       4564 ; rtxc.c   1715 #ifdef QUEUE_MEMCPY /* { */
                       4565 ; rtxc.c   1716          if ( (width = pqh->width) != 0)
                       4566 ; rtxc.c   1717             ks_memcpyNF( ((struct qarg ks_stk *)p2)->data,
                       4567 ; rtxc.c   1718                     pqh->base + (qindex * width),
                       4568 ; rtxc.c   1719                     width);
                       4569 ; rtxc.c   1720 #else /* } QUEUE_MEMCPY { */
                       4570 ; rtxc.c   1721          switch(width = pqh->width)
001E90 8C1712          4571         MOV.W   R1,[R7+18]
001E93 8C0710          4572         MOV.W   R0,[R7+16]
001E96 862C42          4573         MOV.B   ES,R1L
001E99 8C6004          4574         MOV.W   R6,[R0+4]
001E9C 8906            4575         MOV.W   R0,R6
001E9E 99040000        4576         CMP.W   R0,#00H
001EA2 F367            4577         BEQ     _185
001EA4 99040001        4578         CMP.W   R0,#01H
001EA8 F307            4579         BEQ     _178
001EAA 99040002        4580         CMP.W   R0,#02H
001EAE F31B            4581         BEQ     _179
001EB0 99040004        4582         CMP.W   R0,#04H
001EB4 F32F            4583         BEQ     _180
001EB6 FE48            4584         BR      _181
001EB6 FE48            4584         BR      _181
                       4585 ; rtxc.c   1722          {
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  82

ADDR   CODE            LINE SOURCELINE
                       4586 ; rtxc.c   1723             case 0:
                       4587 ; rtxc.c   1724                break;
                       4588 ; rtxc.c   1725 
                       4589 ; rtxc.c   1726             case sizeof(char):
001EB8                 4590 _178:
                       4591 ; rtxc.c   1727                *(char *)(((struct qarg ks_stk *)p2)->data) =
                       4592 ; rtxc.c   1728                                *(char ks_queue *)(pqh->base + qindex);
001EB8 8922            4593         MOV.W   R2,R2
001EBA 9839            4594         SEXT.W  R3
001EBC 8C1712          4595         MOV.W   R1,[R7+18]
001EBF 8C0710          4596         MOV.W   R0,[R7+16]
001EC2 862C42          4597         MOV.B   ES,R1L
001EC5 0A20            4598         ADD.W   R2,[R0]
001EC7 1C3002          4599         ADDC.W  R3,[R0+2]
001ECA 866C42          4600         MOV.B   ES,R3L
001ECD 8202            4601         MOV.B   R0L,[R2]
001ECF 8C3716          4602         MOV.W   R3,[R7+22]
001ED2 8C2714          4603         MOV.W   R2,[R7+20]
001ED5 866C42          4604         MOV.B   ES,R3L
001ED8 8C3208          4605         MOV.W   R3,[R2+8]
001EDB 8C2206          4606         MOV.W   R2,[R2+6]
001EDE 866C42          4607         MOV.B   ES,R3L
001EE1 820A            4608         MOV.B   [R2],R0L
                       4609 ; rtxc.c   1729                break;
001EE3 FE47            4610         BR      _185
001EE3 FE4700          4610         BR      _185
                       4611 ; rtxc.c   1730 
                       4612 ; rtxc.c   1731             case sizeof(short):
001EE6                 4613 _179:
                       4614 ; rtxc.c   1732                *(short *)(((struct qarg ks_stk *)p2)->data) =
                       4615 ; rtxc.c   1733                                *(short ks_queue *)(pqh->base + (qindex << 1));
001EE6 D921            4616         ASL.W   R2,#01H
001EE8 B930            4617         MOVS.W  R3,#00H
001EEA 8C1712          4618         MOV.W   R1,[R7+18]
001EED 8C0710          4619         MOV.W   R0,[R7+16]
001EF0 862C42          4620         MOV.B   ES,R1L
001EF3 0A20            4621         ADD.W   R2,[R0]
001EF5 1C3002          4622         ADDC.W  R3,[R0+2]
001EF8 866C42          4623         MOV.B   ES,R3L
001EFB 8A02            4624         MOV.W   R0,[R2]
001EFD 8C3716          4625         MOV.W   R3,[R7+22]
001F00 8C2714          4626         MOV.W   R2,[R7+20]
001F03 866C42          4627         MOV.B   ES,R3L
001F06 8C3208          4628         MOV.W   R3,[R2+8]
001F09 8C2206          4629         MOV.W   R2,[R2+6]
001F0C 866C42          4630         MOV.B   ES,R3L
001F0F 8A0A            4631         MOV.W   [R2],R0
                       4632 ; rtxc.c   1734                break;
001F11 FE30            4633         BR      _185
001F11 FE3000          4633         BR      _185
                       4634 ; rtxc.c   1735 
                       4635 ; rtxc.c   1736             case sizeof(long):
001F14                 4636 _180:
                       4637 ; rtxc.c   1737                *(long *)(((struct qarg ks_stk *)p2)->data) =
                       4638 ; rtxc.c   1738                                *(long ks_queue *)(pqh->base + (qindex << 2));
001F14 D922            4639         ASL.W   R2,#02H
001F16 B930            4640         MOVS.W  R3,#00H
001F18 8C1712          4641         MOV.W   R1,[R7+18]
001F1B 8C0710          4642         MOV.W   R0,[R7+16]
001F1E 862C42          4643         MOV.B   ES,R1L
001F21 0A20            4644         ADD.W   R2,[R0]
001F23 1C3002          4645         ADDC.W  R3,[R0+2]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  83

ADDR   CODE            LINE SOURCELINE
001F26 866C42          4646         MOV.B   ES,R3L
001F29 8C3202          4647         MOV.W   R3,[R2+2]
001F2C 8A22            4648         MOV.W   R2,[R2]
001F2E 8C1716          4649         MOV.W   R1,[R7+22]
001F31 8C0714          4650         MOV.W   R0,[R7+20]
001F34 862C42          4651         MOV.B   ES,R1L
001F37 8C1008          4652         MOV.W   R1,[R0+8]
001F3A 8C0006          4653         MOV.W   R0,[R0+6]
001F3D 862C42          4654         MOV.B   ES,R1L
001F40 8A28            4655         MOV.W   [R0],R2
001F42 8C3802          4656         MOV.W   [R0+2],R3
                       4657 ; rtxc.c   1739                break;
001F45 FE16            4658         BR      _185
001F45 FE1600          4658         BR      _185
                       4659 ; rtxc.c   1740 
                       4660 ; rtxc.c   1741             default:
001F48                 4661 _181:
                       4662 ; rtxc.c   1742                ks_memcpyNF( ((struct qarg ks_stk *)p2)->data,
                       4663 ; rtxc.c   1743                        pqh->base + (qindex * width),
                       4664 ; rtxc.c   1744                        width);
001F48 8C1716          4665         MOV.W   R1,[R7+22]
001F4B 8C0714          4666         MOV.W   R0,[R7+20]
001F4E 862C42          4667         MOV.B   ES,R1L
001F51 8C1008          4668         MOV.W   R1,[R0+8]
001F54 8C0006          4669         MOV.W   R0,[R0+6]
001F57 E426            4670         MULU.W  R2,R6
001F59 8942            4671         MOV.W   R4,R2
001F5B B950            4672         MOVS.W  R5,#00H
001F5D 8C3712          4673         MOV.W   R3,[R7+18]
001F60 8C2710          4674         MOV.W   R2,[R7+16]
001F63 866C42          4675         MOV.B   ES,R3L
001F66 0A42            4676         ADD.W   R4,[R2]
001F68 1C5202          4677         ADDC.W  R5,[R2+2]
001F6B 8935            4678         MOV.W   R3,R5
001F6D 8924            4679         MOV.W   R2,R4
001F6F C51426          4680         CALL    _ks_memcpyNF
001F6F C51426          4680         CALL    _ks_memcpyNF
                       4681 ; rtxc.c   1745                break;
                       4682 ; rtxc.c   1746          }
001F72                 4683 _185:
                       4684 ; rtxc.c   1747 #endif /* } QUEUE_MEMCPY */
                       4685 ; rtxc.c   1748 
                       4686 ; rtxc.c   1749 #ifdef QUEUE_SEMAS /* { */
                       4687 ; rtxc.c   1750          if (pqh->curndx == 0)  /* just dequeued last item (now empty) */
001F72 8C170E          4688         MOV.W   R1,[R7+14]
001F75 8C070C          4689         MOV.W   R0,[R7+12]
001F78 862C42          4690         MOV.B   ES,R1L
001F7B 8A00            4691         MOV.W   R0,[R0]
001F7D 8C0F16          4692         MOV.W   [R7+22],R0
001F80 6900            4693         OR.W    R0,R0
001F82 F24A            4694         BNE     _188
                       4695 ; rtxc.c   1751          {
                       4696 ; rtxc.c   1752             if (pqh->nesema != NULLSEMA)
001F84 8C1712          4697         MOV.W   R1,[R7+18]
001F87 8C0710          4698         MOV.W   R0,[R7+16]
001F8A 862C42          4699         MOV.B   ES,R1L
001F8D 840015          4700         MOV.B   R0L,[R0+21]
001F90 F307            4701         BEQ     _186
                       4702 ; rtxc.c   1753                semat[pqh->nesema] = SEMA_PENDING; /* pend not empty sema */
001F92 B110            4703         MOVS.B  R0H,#00H
001F94 B910            4704         MOVS.W  R1,#00H
001F96 964842rr        4705         MOV.B   ES,#SEG( _semat )
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  84

ADDR   CODE            LINE SOURCELINE
001F9A 9508rrrrFF      4706         MOV.B   [R0+SOF( _semat )],#0FFH
001F9A 9508rrrrFF00    4706         MOV.B   [R0+SOF( _semat )],#0FFH
001FA0                 4707 _186:
                       4708 ; rtxc.c   1754 
                       4709 ; rtxc.c   1755             UPDATE_SEMA(pqh->esema);
001FA0 8C5712          4710         MOV.W   R5,[R7+18]
001FA3 8C4710          4711         MOV.W   R4,[R7+16]
001FA6 99400016        4712         ADD.W   R4,#016H
001FAA 8C1712          4713         MOV.W   R1,[R7+18]
001FAD 8C0710          4714         MOV.W   R0,[R7+16]
001FB0 862C42          4715         MOV.B   ES,R1L
001FB3 840016          4716         MOV.B   R0L,[R0+22]
001FB6 F33D            4717         BEQ     _193
001FB8 B110            4718         MOVS.B  R0H,#00H
001FBA B910            4719         MOVS.W  R1,#00H
001FBC 9938rrrr        4720         MOV.W   R3,#SEG( _semat )
001FC0 9928rrrr        4721         MOV.W   R2,#SOF( _semat )
001FC4 0920            4722         ADD.W   R2,R0
001FC6 8C3F06          4723         MOV.W   [R7+6],R3
001FC9 8C2F04          4724         MOV.W   [R7+4],R2
001FCC 964842rr        4725         MOV.B   ES,#SEG( _semat )
001FD0 8540rrrr        4726         MOV.B   R2L,[R0+SOF( _semat )]
001FD4 9144FF          4727         CMP.B   R2L,#0FFH
001FD7 F206            4728         BNE     _187
001FD9 964842rr        4729         MOV.B   ES,#SEG( _semat )
001FDD B500rrrr        4730         MOV.B   [R0+SOF( _semat )],#00H
001FE1 FE28            4731         BR      _193
001FE1 FE2800          4731         BR      _193
001FE4                 4732 _187:
001FE4 8C3706          4733         MOV.W   R3,[R7+6]
001FE7 8C2704          4734         MOV.W   R2,[R7+4]
001FEA 866C42          4735         MOV.B   ES,R3L
001FED 8202            4736         MOV.B   R0L,[R2]
001FEF F321            4737         BEQ     _193
001FF1 860401          4738         MOV.B   R0L,0401H
001FF4 9648018D        4739         MOV.B   0401H,#08DH
001FF8 86AC42          4740         MOV.B   ES,R5L
001FFB 8214            4741         MOV.B   R0H,[R4]
001FFD 9Er0rr0001      4742         ADD.W   _semaput,#01H
002002 8E3rrr          4743         MOV.W   R3,_semaput+2
002005 8E2rrr          4744         MOV.W   R2,_semaput
002008 866C42          4745         MOV.B   ES,R3L
00200B 821A            4746         MOV.B   [R2],R0H
00200D 8E3rrr          4747         MOV.W   _semaput+2,R3
002010 8E2rrr          4748         MOV.W   _semaput,R2
002013 860C01          4749         MOV.B   0401H,R0L
                       4750 ; rtxc.c   1756          }
002016 FE0D            4751         BR      _193
002016 FE0D            4751         BR      _193
002018                 4752 _188:
                       4753 ; rtxc.c   1757          else /* there are still more entries in queue */
                       4754 ; rtxc.c   1758          {
                       4755 ; rtxc.c   1759             if (pqh->nesema != NULLSEMA)
002018 8C1712          4756         MOV.W   R1,[R7+18]
00201B 8C0710          4757         MOV.W   R0,[R7+16]
00201E 862C42          4758         MOV.B   ES,R1L
002021 840015          4759         MOV.B   R0L,[R0+21]
002024 F306            4760         BEQ     _193
                       4761 ; rtxc.c   1760                semat[pqh->nesema] = SEMA_DONE; /* set not empty sema done */
002026 B110            4762         MOVS.B  R0H,#00H
002028 B910            4763         MOVS.W  R1,#00H
00202A 964842rr        4764         MOV.B   ES,#SEG( _semat )
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  85

ADDR   CODE            LINE SOURCELINE
00202E B500rrrr        4765         MOV.B   [R0+SOF( _semat )],#00H
00202E B500rrrr        4765         MOV.B   [R0+SOF( _semat )],#00H
                       4766 ; rtxc.c   1761          }
002032                 4767 _193:
                       4768 ; rtxc.c   1762 #endif /* } QUEUE_SEMAS */
                       4769 ; rtxc.c   1763 
                       4770 ; rtxc.c   1764 #ifdef ENQUEUE_WAITERS /* { */
                       4771 ; rtxc.c   1765          if (pqh->curndx == pqh->depth - 1)  /* queue was full before deq */
002032 8C1712          4772         MOV.W   R1,[R7+18]
002035 8C0710          4773         MOV.W   R0,[R7+16]
002038 99000006        4774         ADD.W   R0,#06H
00203C 8C1F06          4775         MOV.W   [R7+6],R1
00203F 8C0F04          4776         MOV.W   [R7+4],R0
002042 8C1712          4777         MOV.W   R1,[R7+18]
002045 8C0710          4778         MOV.W   R0,[R7+16]
002048 862C42          4779         MOV.B   ES,R1L
00204B 8C0006          4780         MOV.W   R0,[R0+6]
00204E A90F            4781         ADDS.W  R0,#0FH
002050 8C1716          4782         MOV.W   R1,[R7+22]
002053 4910            4783         CMP.W   R1,R0
                       4784         BNE     _218
002055 F302           +4784 ;       BEQ     _LG_324
002057 D501D7         +4784 ;       JMP.L   _218
002057 D501D7         +4784 ;       JMP.L   _218
00205A                +4784 _LG_324:
                       4785 ; rtxc.c   1766          {
                       4786 ; rtxc.c   1767             /* insert first waiter into insert list */
                       4787 ; rtxc.c   1768             if ( (ptcb = pqh->waiters) != NULLTCB)
00205A 8C1712          4788         MOV.W   R1,[R7+18]
00205D 8C0710          4789         MOV.W   R0,[R7+16]
002060 9900000C        4790         ADD.W   R0,#0CH
002064 8C3712          4791         MOV.W   R3,[R7+18]
002067 8C2710          4792         MOV.W   R2,[R7+16]
00206A 866C42          4793         MOV.B   ES,R3L
00206D 8C420C          4794         MOV.W   R4,[R2+12]
002070 8C520E          4795         MOV.W   R5,[R2+14]
002073 8935            4796         MOV.W   R3,R5
002075 8924            4797         MOV.W   R2,R4
002077 6932            4798         OR.W    R3,R2
                       4799         BEQ     _215
002079 F202           +4799 ;       BNE     _LG_326
00207B D5017D         +4799 ;       JMP.L   _215
00207B D5017D         +4799 ;       JMP.L   _215
00207E                +4799 _LG_326:
                       4800 ; rtxc.c   1769             {
                       4801 ; rtxc.c   1770                /* remove highest priority waiter */
                       4802 ; rtxc.c   1771                if ( (pqh->waiters = ptcb->flink) != NULLTCB)
00207E 8C5F16          4803         MOV.W   [R7+22],R5
002081 8C4F14          4804         MOV.W   [R7+20],R4
002084 86AC42          4805         MOV.B   ES,R5L
002087 8A24            4806         MOV.W   R2,[R4]
002089 8C3402          4807         MOV.W   R3,[R4+2]
00208C 8C5712          4808         MOV.W   R5,[R7+18]
00208F 8C4710          4809         MOV.W   R4,[R7+16]
002092 86AC42          4810         MOV.B   ES,R5L
002095 8C2C0C          4811         MOV.W   [R4+12],R2
002098 8C3C0E          4812         MOV.W   [R4+14],R3
00209B 6932            4813         OR.W    R3,R2
00209D F30C            4814         BEQ     _194
                       4815 ; rtxc.c   1772                   ptcb->flink->blink = (TCB ks_tbl *)&pqh->waiters;
00209F 8C3716          4816         MOV.W   R3,[R7+22]
0020A2 8C2714          4817         MOV.W   R2,[R7+20]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  86

ADDR   CODE            LINE SOURCELINE
0020A5 866C42          4818         MOV.B   ES,R3L
0020A8 8C3202          4819         MOV.W   R3,[R2+2]
0020AB 8A22            4820         MOV.W   R2,[R2]
0020AD 866C42          4821         MOV.B   ES,R3L
0020B0 8C0A04          4822         MOV.W   [R2+4],R0
0020B3 8C1A06          4823         MOV.W   [R2+6],R1
0020B3 8C1A06          4823         MOV.W   [R2+6],R1
0020B6                 4824 _194:
                       4825 ; rtxc.c   1773 
                       4826 ; rtxc.c   1774                if ( (ptcb->status &= ~QUEUE_WAIT) == READY)
0020B6 8C1716          4827         MOV.W   R1,[R7+22]
0020B9 8C0714          4828         MOV.W   R0,[R7+20]
0020BC 862C42          4829         MOV.B   ES,R1L
0020BF 8C0012          4830         MOV.W   R0,[R0+18]
0020C2 9905FF7F        4831         AND.W   R0,#0FF7FH
0020C6 8C5716          4832         MOV.W   R5,[R7+22]
0020C9 8C4714          4833         MOV.W   R4,[R7+20]
0020CC 86AC42          4834         MOV.B   ES,R5L
0020CF 9C4512FF7F      4835         AND.W   [R4+18],#0FF7FH
0020D4 6900            4836         OR.W    R0,R0
0020D6 F20A            4837         BNE     _195
                       4838 ; rtxc.c   1775                {
                       4839 ; rtxc.c   1776                   ptcb->flink = nsrttcb;
0020D8 8E1rrr          4840         MOV.W   R1,_nsrttcb+2
0020DB 8E0rrr          4841         MOV.W   R0,_nsrttcb
0020DE 86AC42          4842         MOV.B   ES,R5L
0020E1 8A0C            4843         MOV.W   [R4],R0
0020E3 8C1C02          4844         MOV.W   [R4+2],R1
                       4845 ; rtxc.c   1777                   nsrttcb = ptcb;
0020E6 8E5rrr          4846         MOV.W   _nsrttcb+2,R5
0020E9 8E4rrr          4847         MOV.W   _nsrttcb,R4
0020E9 8E4rrr          4847         MOV.W   _nsrttcb,R4
                       4848 ; rtxc.c   1778                }
0020EC                 4849 _195:
                       4850 ; rtxc.c   1779 
                       4851 ; rtxc.c   1780 #ifdef ENQUEUE_TIMEOUTS /* { */
                       4852 ; rtxc.c   1781                /* cleanup any pending timeout */
                       4853 ; rtxc.c   1782                if ( (pclkblk = ptcb->pclkblk) != NULLCLK)
0020EC 86AC42          4854         MOV.B   ES,R5L
0020EF 8C0408          4855         MOV.W   R0,[R4+8]
0020F2 8C140A          4856         MOV.W   R1,[R4+10]
0020F5 8931            4857         MOV.W   R3,R1
0020F7 8920            4858         MOV.W   R2,R0
0020F9 6932            4859         OR.W    R3,R2
0020FB F307            4860         BEQ     _196
                       4861 ; rtxc.c   1783                {
                       4862 ; rtxc.c   1784                   unlink_timer(pclkblk);
0020FD C51051          4863         CALL    _unlink_timer
                       4864 ; rtxc.c   1785                   ptcb->pclkblk = NULLCLK;
002100 86AC42          4865         MOV.B   ES,R5L
002103 BC4008          4866         MOV.W   [R4+8],#00H
002106 BC400A          4867         MOV.W   [R4+10],#00H
002106 BC400A00        4867         MOV.W   [R4+10],#00H
                       4868 ; rtxc.c   1786                }
00210A                 4869 _196:
                       4870 ; rtxc.c   1787 #endif /* } ENQUEUE_TIMEOUTS */
                       4871 ; rtxc.c   1788 
                       4872 ; rtxc.c   1789                /* perform enqueue for waiter */
                       4873 ; rtxc.c   1790 
                       4874 ; rtxc.c   1791                pqh->curndx++;
00210A 8C170E          4875         MOV.W   R1,[R7+14]
00210D 8C070C          4876         MOV.W   R0,[R7+12]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  87

ADDR   CODE            LINE SOURCELINE
002110 862C42          4877         MOV.B   ES,R1L
002113 AA01            4878         ADDS.W  [R0],#01H
                       4879 ; rtxc.c   1792                if (++pqh->putndx == pqh->depth)
002115 8C170A          4880         MOV.W   R1,[R7+10]
002118 8C0708          4881         MOV.W   R0,[R7+8]
00211B 862C42          4882         MOV.B   ES,R1L
00211E 8A00            4883         MOV.W   R0,[R0]
002120 A901            4884         ADDS.W  R0,#01H
002122 8C370A          4885         MOV.W   R3,[R7+10]
002125 8C2708          4886         MOV.W   R2,[R7+8]
002128 866C42          4887         MOV.B   ES,R3L
00212B AA21            4888         ADDS.W  [R2],#01H
00212D 8C3706          4889         MOV.W   R3,[R7+6]
002130 8C2704          4890         MOV.W   R2,[R7+4]
002133 866C42          4891         MOV.B   ES,R3L
002136 8A12            4892         MOV.W   R1,[R2]
002138 4901            4893         CMP.W   R0,R1
00213A F206            4894         BNE     _197
                       4895 ; rtxc.c   1793                   pqh->putndx = 0;  /* recycle index */
00213C 8C170A          4896         MOV.W   R1,[R7+10]
00213F 8C0708          4897         MOV.W   R0,[R7+8]
002142 862C42          4898         MOV.B   ES,R1L
002145 BA00            4899         MOV.W   [R0],#00H
002145 BA0000          4899         MOV.W   [R0],#00H
002148                 4900 _197:
                       4901 ; rtxc.c   1794 
                       4902 ; rtxc.c   1795                qindex = pqh->putndx; /* local for speed */
002148 8C170A          4903         MOV.W   R1,[R7+10]
00214B 8C0708          4904         MOV.W   R0,[R7+8]
00214E 862C42          4905         MOV.B   ES,R1L
002151 8A00            4906         MOV.W   R0,[R0]
                       4907 ; rtxc.c   1796 
                       4908 ; rtxc.c   1797                p2a = ((FRAME ks_stk *)(ptcb->sp))->pksnum;
002153 86AC42          4909         MOV.B   ES,R5L
002156 8C240E          4910         MOV.W   R2,[R4+14]
002159 8C3410          4911         MOV.W   R3,[R4+16]
00215C 866C42          4912         MOV.B   ES,R3L
00215F 8C3206          4913         MOV.W   R3,[R2+6]
002162 8C2204          4914         MOV.W   R2,[R2+4]
                       4915 ; rtxc.c   1798 
                       4916 ; rtxc.c   1799                ((struct qarg ks_stk *)p2a)->ksrc = RC_GOOD;
002165 866C42          4917         MOV.B   ES,R3L
002168 BC2002          4918         MOV.W   [R2+2],#00H
                       4919 ; rtxc.c   1800 
                       4920 ; rtxc.c   1801 #ifdef QUEUE_MEMCPY /* { */
                       4921 ; rtxc.c   1802                if (width)
                       4922 ; rtxc.c   1803                   ks_memcpyFN(pqh->base + (qindex * width),
                       4923 ; rtxc.c   1804                          ((struct qarg ks_stk *)p2a)->data,
                       4924 ; rtxc.c   1805                          width);
                       4925 ; rtxc.c   1806 #else /* } QUEUE_MEMCPY { */
                       4926 ; rtxc.c   1807                switch(width)
00216B 99640000        4927         CMP.W   R6,#00H
00216F F35D            4928         BEQ     _205
002171 99640001        4929         CMP.W   R6,#01H
002175 F308            4930         BEQ     _198
002177 99640002        4931         CMP.W   R6,#02H
00217B F319            4932         BEQ     _199
00217D 99640004        4933         CMP.W   R6,#04H
002181 F32B            4934         BEQ     _200
002183 FE41            4935         BR      _201
002183 FE4100          4935         BR      _201
                       4936 ; rtxc.c   1808                {
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  88

ADDR   CODE            LINE SOURCELINE
                       4937 ; rtxc.c   1809                   case 0:
                       4938 ; rtxc.c   1810                      break;
                       4939 ; rtxc.c   1811 
                       4940 ; rtxc.c   1812                   case sizeof(char):
002186                 4941 _198:
                       4942 ; rtxc.c   1813                      *(char  ks_queue *)(pqh->base + qindex) =
                       4943 ; rtxc.c   1814                                  *(char *)(((struct qarg ks_stk *)p2a)->data);
002186 866C42          4944         MOV.B   ES,R3L
002189 8C3208          4945         MOV.W   R3,[R2+8]
00218C 8C2206          4946         MOV.W   R2,[R2+6]
00218F 866C42          4947         MOV.B   ES,R3L
002192 8222            4948         MOV.B   R1L,[R2]
002194 8920            4949         MOV.W   R2,R0
002196 9839            4950         SEXT.W  R3
002198 8C5712          4951         MOV.W   R5,[R7+18]
00219B 8C4710          4952         MOV.W   R4,[R7+16]
00219E 86AC42          4953         MOV.B   ES,R5L
0021A1 0A24            4954         ADD.W   R2,[R4]
0021A3 1C3402          4955         ADDC.W  R3,[R4+2]
0021A6 866C42          4956         MOV.B   ES,R3L
0021A9 822A            4957         MOV.B   [R2],R1L
                       4958 ; rtxc.c   1815                      break;
0021AB FE3F            4959         BR      _205
0021AB FE3F00          4959         BR      _205
                       4960 ; rtxc.c   1816 
                       4961 ; rtxc.c   1817                   case sizeof(short):
0021AE                 4962 _199:
                       4963 ; rtxc.c   1818                      *(short  ks_queue *)(pqh->base + (qindex << 1)) =
                       4964 ; rtxc.c   1819                                  *(short *)(((struct qarg ks_stk *)p2a)->data);
0021AE 866C42          4965         MOV.B   ES,R3L
0021B1 8C3208          4966         MOV.W   R3,[R2+8]
0021B4 8C2206          4967         MOV.W   R2,[R2+6]
0021B7 866C42          4968         MOV.B   ES,R3L
0021BA 8A12            4969         MOV.W   R1,[R2]
0021BC D901            4970         ASL.W   R0,#01H
0021BE 8920            4971         MOV.W   R2,R0
0021C0 B930            4972         MOVS.W  R3,#00H
0021C2 8C5712          4973         MOV.W   R5,[R7+18]
0021C5 8C4710          4974         MOV.W   R4,[R7+16]
0021C8 86AC42          4975         MOV.B   ES,R5L
0021CB 0A24            4976         ADD.W   R2,[R4]
0021CD 1C3402          4977         ADDC.W  R3,[R4+2]
0021D0 866C42          4978         MOV.B   ES,R3L
0021D3 8A1A            4979         MOV.W   [R2],R1
                       4980 ; rtxc.c   1820                      break;
0021D5 FE2A            4981         BR      _205
0021D5 FE2A00          4981         BR      _205
                       4982 ; rtxc.c   1821 
                       4983 ; rtxc.c   1822                   case sizeof(long):
0021D8                 4984 _200:
                       4985 ; rtxc.c   1823                      *(long  ks_queue *)(pqh->base + (qindex << 2)) =
                       4986 ; rtxc.c   1824                                  *(long *)(((struct qarg ks_stk *)p2a)->data);
0021D8 866C42          4987         MOV.B   ES,R3L
0021DB 8C3208          4988         MOV.W   R3,[R2+8]
0021DE 8C2206          4989         MOV.W   R2,[R2+6]
0021E1 866C42          4990         MOV.B   ES,R3L
0021E4 8C3202          4991         MOV.W   R3,[R2+2]
0021E7 8A22            4992         MOV.W   R2,[R2]
0021E9 D902            4993         ASL.W   R0,#02H
0021EB B910            4994         MOVS.W  R1,#00H
0021ED 8C5712          4995         MOV.W   R5,[R7+18]
0021F0 8C4710          4996         MOV.W   R4,[R7+16]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  89

ADDR   CODE            LINE SOURCELINE
0021F3 86AC42          4997         MOV.B   ES,R5L
0021F6 0A04            4998         ADD.W   R0,[R4]
0021F8 1C1402          4999         ADDC.W  R1,[R4+2]
0021FB 862C42          5000         MOV.B   ES,R1L
0021FE 8A28            5001         MOV.W   [R0],R2
002200 8C3802          5002         MOV.W   [R0+2],R3
                       5003 ; rtxc.c   1825                      break;
002203 FE13            5004         BR      _205
002203 FE1300          5004         BR      _205
                       5005 ; rtxc.c   1826 
                       5006 ; rtxc.c   1827                   default:
002206                 5007 _201:
                       5008 ; rtxc.c   1828                      ks_memcpyFN(pqh->base + (qindex * width),
                       5009 ; rtxc.c   1829                              ((struct qarg ks_stk *)p2a)->data,
                       5010 ; rtxc.c   1830                              width);
002206 E406            5011         MULU.W  R0,R6
002208 8940            5012         MOV.W   R4,R0
00220A B950            5013         MOVS.W  R5,#00H
00220C 8C1712          5014         MOV.W   R1,[R7+18]
00220F 8C0710          5015         MOV.W   R0,[R7+16]
002212 862C42          5016         MOV.B   ES,R1L
002215 0A40            5017         ADD.W   R4,[R0]
002217 1C5002          5018         ADDC.W  R5,[R0+2]
00221A 866C42          5019         MOV.B   ES,R3L
00221D 8C3208          5020         MOV.W   R3,[R2+8]
002220 8C2206          5021         MOV.W   R2,[R2+6]
002223 8915            5022         MOV.W   R1,R5
002225 8904            5023         MOV.W   R0,R4
002227 C512B6          5024         CALL    _ks_memcpyFN
002227 C512B6          5024         CALL    _ks_memcpyFN
                       5025 ; rtxc.c   1831                     break;
                       5026 ; rtxc.c   1832                }
00222A                 5027 _205:
                       5028 ; rtxc.c   1833 #endif /* } QUEUE_MEMCPY */
                       5029 ; rtxc.c   1834 
                       5030 ; rtxc.c   1835 #ifdef CBUG /* { */
                       5031 ; rtxc.c   1836                pqh->count++; /* increment total no. of enqueues to date */
                       5032 ; rtxc.c   1837                /* already past worst case */
                       5033 ; rtxc.c   1838 #endif /* } CBUG */
                       5034 ; rtxc.c   1839 
                       5035 ; rtxc.c   1840 #ifdef QUEUE_SEMAS /* { */
                       5036 ; rtxc.c   1841                if (pqh->curndx == pqh->depth) /* queue is now full */
00222A 8C170E          5037         MOV.W   R1,[R7+14]
00222D 8C070C          5038         MOV.W   R0,[R7+12]
002230 862C42          5039         MOV.B   ES,R1L
002233 8A60            5040         MOV.W   R6,[R0]
002235 8C1706          5041         MOV.W   R1,[R7+6]
002238 8C0704          5042         MOV.W   R0,[R7+4]
00223B 862C42          5043         MOV.B   ES,R1L
00223E 8A00            5044         MOV.W   R0,[R0]
002240 8C370E          5045         MOV.W   R3,[R7+14]
002243 8C270C          5046         MOV.W   R2,[R7+12]
002246 866C42          5047         MOV.B   ES,R3L
002249 4A0A            5048         CMP.W   [R2],R0
00224B F24A            5049         BNE     _208
                       5050 ; rtxc.c   1842                {
                       5051 ; rtxc.c   1843                  if (pqh->nfsema != NULLSEMA)
00224D 8C1712          5052         MOV.W   R1,[R7+18]
002250 8C0710          5053         MOV.W   R0,[R7+16]
002253 862C42          5054         MOV.B   ES,R1L
002256 840017          5055         MOV.B   R0L,[R0+23]
002259 F307            5056         BEQ     _206
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  90

ADDR   CODE            LINE SOURCELINE
                       5057 ; rtxc.c   1844                     semat[pqh->nfsema] = SEMA_PENDING; /*pend not full sema*/
00225B B110            5058         MOVS.B  R0H,#00H
00225D B910            5059         MOVS.W  R1,#00H
00225F 964842rr        5060         MOV.B   ES,#SEG( _semat )
002263 9508rrrrFF      5061         MOV.B   [R0+SOF( _semat )],#0FFH
002263 9508rrrrFF      5061         MOV.B   [R0+SOF( _semat )],#0FFH
002268                 5062 _206:
                       5063 ; rtxc.c   1845 
                       5064 ; rtxc.c   1846                  UPDATE_SEMA(pqh->fsema);
002268 8C1712          5065         MOV.W   R1,[R7+18]
00226B 8C0710          5066         MOV.W   R0,[R7+16]
00226E 99000014        5067         ADD.W   R0,#014H
002272 8C1F16          5068         MOV.W   [R7+22],R1
002275 8C0F14          5069         MOV.W   [R7+20],R0
002278 8C1712          5070         MOV.W   R1,[R7+18]
00227B 8C0710          5071         MOV.W   R0,[R7+16]
00227E 862C42          5072         MOV.B   ES,R1L
002281 840014          5073         MOV.B   R0L,[R0+20]
002284 F33A            5074         BEQ     _213
002286 B110            5075         MOVS.B  R0H,#00H
002288 B910            5076         MOVS.W  R1,#00H
00228A 9958rrrr        5077         MOV.W   R5,#SEG( _semat )
00228E 9948rrrr        5078         MOV.W   R4,#SOF( _semat )
002292 0940            5079         ADD.W   R4,R0
002294 964842rr        5080         MOV.B   ES,#SEG( _semat )
002298 8540rrrr        5081         MOV.B   R2L,[R0+SOF( _semat )]
00229C 9144FF          5082         CMP.B   R2L,#0FFH
00229F F206            5083         BNE     _207
0022A1 964842rr        5084         MOV.B   ES,#SEG( _semat )
0022A5 B500rrrr        5085         MOV.B   [R0+SOF( _semat )],#00H
0022A9 FE28            5086         BR      _213
0022A9 FE2800          5086         BR      _213
0022AC                 5087 _207:
0022AC 86AC42          5088         MOV.B   ES,R5L
0022AF 8204            5089         MOV.B   R0L,[R4]
0022B1 F324            5090         BEQ     _213
0022B3 860401          5091         MOV.B   R0L,0401H
0022B6 9648018D        5092         MOV.B   0401H,#08DH
0022BA 8C3716          5093         MOV.W   R3,[R7+22]
0022BD 8C2714          5094         MOV.W   R2,[R7+20]
0022C0 866C42          5095         MOV.B   ES,R3L
0022C3 8212            5096         MOV.B   R0H,[R2]
0022C5 9Er0rr0001      5097         ADD.W   _semaput,#01H
0022CA 8E3rrr          5098         MOV.W   R3,_semaput+2
0022CD 8E2rrr          5099         MOV.W   R2,_semaput
0022D0 866C42          5100         MOV.B   ES,R3L
0022D3 821A            5101         MOV.B   [R2],R0H
0022D5 8E3rrr          5102         MOV.W   _semaput+2,R3
0022D8 8E2rrr          5103         MOV.W   _semaput,R2
0022DB 860C01          5104         MOV.B   0401H,R0L
                       5105 ; rtxc.c   1847                }
0022DE FE0D            5106         BR      _213
0022DE FE0D            5106         BR      _213
0022E0                 5107 _208:
                       5108 ; rtxc.c   1848                else                               /* still room in queue */
                       5109 ; rtxc.c   1849                {
                       5110 ; rtxc.c   1850                   if (pqh->nfsema != NULLSEMA)
0022E0 8C1712          5111         MOV.W   R1,[R7+18]
0022E3 8C0710          5112         MOV.W   R0,[R7+16]
0022E6 862C42          5113         MOV.B   ES,R1L
0022E9 840017          5114         MOV.B   R0L,[R0+23]
0022EC F306            5115         BEQ     _213
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  91

ADDR   CODE            LINE SOURCELINE
                       5116 ; rtxc.c   1851                      semat[pqh->nfsema] = SEMA_DONE;
0022EE B110            5117         MOVS.B  R0H,#00H
0022F0 B910            5118         MOVS.W  R1,#00H
0022F2 964842rr        5119         MOV.B   ES,#SEG( _semat )
0022F6 B500rrrr        5120         MOV.B   [R0+SOF( _semat )],#00H
0022F6 B500rrrr        5120         MOV.B   [R0+SOF( _semat )],#00H
                       5121 ; rtxc.c   1852                }
0022FA                 5122 _213:
                       5123 ; rtxc.c   1853 #endif /* } QUEUE_SEMAS */
                       5124 ; rtxc.c   1854 
                       5125 ; rtxc.c   1855 #ifdef QUEUE_SEMAS /* { */
                       5126 ; rtxc.c   1856                if (pqh->curndx == 1) /* if was empty */
0022FA 99640001        5127         CMP.W   R6,#01H
                       5128         BNE     _428
0022FE F302           +5128 ;       BEQ     _LG_356
002300 D50676         +5128 ;       JMP.L   _428
002300 D5067600       +5128 ;       JMP.L   _428
002304                +5128 _LG_356:
                       5129 ; rtxc.c   1857                {
                       5130 ; rtxc.c   1858                   UPDATE_SEMA(pqh->nesema);
002304 8C3712          5131         MOV.W   R3,[R7+18]
002307 8C2710          5132         MOV.W   R2,[R7+16]
00230A 99200015        5133         ADD.W   R2,#015H
00230E 8C1712          5134         MOV.W   R1,[R7+18]
002311 8C0710          5135         MOV.W   R0,[R7+16]
002314 862C42          5136         MOV.B   ES,R1L
002317 840015          5137         MOV.B   R0L,[R0+21]
                       5138         BEQ     _428
00231A F202           +5138 ;       BNE     _LG_358
00231C D50668         +5138 ;       JMP.L   _428
00231C D5066800       +5138 ;       JMP.L   _428
002320                +5138 _LG_358:
002320 B110            5139         MOVS.B  R0H,#00H
002322 B910            5140         MOVS.W  R1,#00H
002324 9958rrrr        5141         MOV.W   R5,#SEG( _semat )
002328 9948rrrr        5142         MOV.W   R4,#SOF( _semat )
00232C 0940            5143         ADD.W   R4,R0
00232E 964842rr        5144         MOV.B   ES,#SEG( _semat )
002332 85C0rrrr        5145         MOV.B   R6L,[R0+SOF( _semat )]
002336 91C4FF          5146         CMP.B   R6L,#0FFH
002339 F206            5147         BNE     _214
00233B 964842rr        5148         MOV.B   ES,#SEG( _semat )
00233F B500rrrr        5149         MOV.B   [R0+SOF( _semat )],#00H
                       5150         BR      _428
002343 D50654         +5150         JMP.L   _428
002343 D50654         +5150         JMP.L   _428
002346                 5151 _214:
002346 86AC42          5152         MOV.B   ES,R5L
002349 8204            5153         MOV.B   R0L,[R4]
                       5154         BEQ     _428
00234B F202           +5154 ;       BNE     _LG_362
00234D D5064F         +5154 ;       JMP.L   _428
00234D D5064F         +5154 ;       JMP.L   _428
002350                +5154 _LG_362:
002350 860401          5155         MOV.B   R0L,0401H
002353 9648018D        5156         MOV.B   0401H,#08DH
002357 866C42          5157         MOV.B   ES,R3L
00235A 8212            5158         MOV.B   R0H,[R2]
00235C 9Er0rr0001      5159         ADD.W   _semaput,#01H
002361 8E3rrr          5160         MOV.W   R3,_semaput+2
002364 8E2rrr          5161         MOV.W   R2,_semaput
002367 866C42          5162         MOV.B   ES,R3L
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  92

ADDR   CODE            LINE SOURCELINE
00236A 821A            5163         MOV.B   [R2],R0H
00236C 8E3rrr          5164         MOV.W   _semaput+2,R3
00236F 8E2rrr          5165         MOV.W   _semaput,R2
002372 860C01          5166         MOV.B   0401H,R0L
                       5167 ; rtxc.c   1859                }
                       5168 ; rtxc.c   1860 #endif /* } QUEUE_SEMAS */
                       5169 ; rtxc.c   1861             }
                       5170         BR      _428
002375 D5063B         +5170         JMP.L   _428
002375 D5063B         +5170         JMP.L   _428
002378                 5171 _215:
                       5172 ; rtxc.c   1862             else
                       5173 ; rtxc.c   1863             {
                       5174 ; rtxc.c   1864 #ifdef QUEUE_SEMAS /* { */
                       5175 ; rtxc.c   1865                if (pqh->fsema != NULLSEMA)
002378 8C1712          5176         MOV.W   R1,[R7+18]
00237B 8C0710          5177         MOV.W   R0,[R7+16]
00237E 862C42          5178         MOV.B   ES,R1L
002381 840014          5179         MOV.B   R0L,[R0+20]
002384 F307            5180         BEQ     _216
                       5181 ; rtxc.c   1866                   semat[pqh->fsema] = SEMA_PENDING;
002386 B110            5182         MOVS.B  R0H,#00H
002388 B910            5183         MOVS.W  R1,#00H
00238A 964842rr        5184         MOV.B   ES,#SEG( _semat )
00238E 9508rrrrFF      5185         MOV.B   [R0+SOF( _semat )],#0FFH
00238E 9508rrrrFF00    5185         MOV.B   [R0+SOF( _semat )],#0FFH
002394                 5186 _216:
                       5187 ; rtxc.c   1867 
                       5188 ; rtxc.c   1868                UPDATE_SEMA(pqh->nfsema);
002394 8C3712          5189         MOV.W   R3,[R7+18]
002397 8C2710          5190         MOV.W   R2,[R7+16]
00239A 99200017        5191         ADD.W   R2,#017H
00239E 8C1712          5192         MOV.W   R1,[R7+18]
0023A1 8C0710          5193         MOV.W   R0,[R7+16]
0023A4 862C42          5194         MOV.B   ES,R1L
0023A7 840017          5195         MOV.B   R0L,[R0+23]
                       5196         BEQ     _428
0023AA F202           +5196 ;       BNE     _LG_366
0023AC D50620         +5196 ;       JMP.L   _428
0023AC D5062000       +5196 ;       JMP.L   _428
0023B0                +5196 _LG_366:
0023B0 B110            5197         MOVS.B  R0H,#00H
0023B2 B910            5198         MOVS.W  R1,#00H
0023B4 9958rrrr        5199         MOV.W   R5,#SEG( _semat )
0023B8 9948rrrr        5200         MOV.W   R4,#SOF( _semat )
0023BC 0940            5201         ADD.W   R4,R0
0023BE 964842rr        5202         MOV.B   ES,#SEG( _semat )
0023C2 85C0rrrr        5203         MOV.B   R6L,[R0+SOF( _semat )]
0023C6 91C4FF          5204         CMP.B   R6L,#0FFH
0023C9 F206            5205         BNE     _217
0023CB 964842rr        5206         MOV.B   ES,#SEG( _semat )
0023CF B500rrrr        5207         MOV.B   [R0+SOF( _semat )],#00H
                       5208         BR      _428
0023D3 D5060C         +5208         JMP.L   _428
0023D3 D5060C         +5208         JMP.L   _428
0023D6                 5209 _217:
0023D6 86AC42          5210         MOV.B   ES,R5L
0023D9 8204            5211         MOV.B   R0L,[R4]
                       5212         BEQ     _428
0023DB F202           +5212 ;       BNE     _LG_370
0023DD D50607         +5212 ;       JMP.L   _428
0023DD D50607         +5212 ;       JMP.L   _428
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  93

ADDR   CODE            LINE SOURCELINE
0023E0                +5212 _LG_370:
0023E0 860401          5213         MOV.B   R0L,0401H
0023E3 9648018D        5214         MOV.B   0401H,#08DH
0023E7 866C42          5215         MOV.B   ES,R3L
0023EA 8212            5216         MOV.B   R0H,[R2]
0023EC 9Er0rr0001      5217         ADD.W   _semaput,#01H
0023F1 8E3rrr          5218         MOV.W   R3,_semaput+2
0023F4 8E2rrr          5219         MOV.W   R2,_semaput
0023F7 866C42          5220         MOV.B   ES,R3L
0023FA 821A            5221         MOV.B   [R2],R0H
0023FC 8E3rrr          5222         MOV.W   _semaput+2,R3
0023FF 8E2rrr          5223         MOV.W   _semaput,R2
002402 860C01          5224         MOV.B   0401H,R0L
                       5225 ; rtxc.c   1869 
                       5226 ; rtxc.c   1870 #endif /* } QUEUE_SEMAS */
                       5227 ; rtxc.c   1871             }
                       5228 ; rtxc.c   1872          }
                       5229         BR      _428
002405 D505F3         +5229         JMP.L   _428
002405 D505F3         +5229         JMP.L   _428
002408                 5230 _218:
                       5231 ; rtxc.c   1873          else
                       5232 ; rtxc.c   1874 #endif /* } ENQUEUE_WAITERS */
                       5233 ; rtxc.c   1875          {
                       5234 ; rtxc.c   1876 #ifdef QUEUE_SEMAS /* { */
                       5235 ; rtxc.c   1877 
                       5236 ; rtxc.c   1878             UPDATE_SEMA(pqh->nfsema);
002408 8C3712          5237         MOV.W   R3,[R7+18]
00240B 8C2710          5238         MOV.W   R2,[R7+16]
00240E 99200017        5239         ADD.W   R2,#017H
002412 8C1712          5240         MOV.W   R1,[R7+18]
002415 8C0710          5241         MOV.W   R0,[R7+16]
002418 862C42          5242         MOV.B   ES,R1L
00241B 840017          5243         MOV.B   R0L,[R0+23]
                       5244         BEQ     _428
00241E F202           +5244 ;       BNE     _LG_372
002420 D505E6         +5244 ;       JMP.L   _428
002420 D505E600       +5244 ;       JMP.L   _428
002424                +5244 _LG_372:
002424 B110            5245         MOVS.B  R0H,#00H
002426 B910            5246         MOVS.W  R1,#00H
002428 9958rrrr        5247         MOV.W   R5,#SEG( _semat )
00242C 9948rrrr        5248         MOV.W   R4,#SOF( _semat )
002430 0940            5249         ADD.W   R4,R0
002432 964842rr        5250         MOV.B   ES,#SEG( _semat )
002436 85C0rrrr        5251         MOV.B   R6L,[R0+SOF( _semat )]
00243A 91C4FF          5252         CMP.B   R6L,#0FFH
00243D F206            5253         BNE     _219
00243F 964842rr        5254         MOV.B   ES,#SEG( _semat )
002443 B500rrrr        5255         MOV.B   [R0+SOF( _semat )],#00H
                       5256         BR      _428
002447 D505D2         +5256         JMP.L   _428
002447 D505D2         +5256         JMP.L   _428
00244A                 5257 _219:
00244A 86AC42          5258         MOV.B   ES,R5L
00244D 8204            5259         MOV.B   R0L,[R4]
                       5260         BEQ     _428
00244F F202           +5260 ;       BNE     _LG_376
002451 D505CD         +5260 ;       JMP.L   _428
002451 D505CD         +5260 ;       JMP.L   _428
002454                +5260 _LG_376:
002454 860401          5261         MOV.B   R0L,0401H
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  94

ADDR   CODE            LINE SOURCELINE
002457 9648018D        5262         MOV.B   0401H,#08DH
00245B 866C42          5263         MOV.B   ES,R3L
00245E 8212            5264         MOV.B   R0H,[R2]
002460 9Er0rr0001      5265         ADD.W   _semaput,#01H
002465 8E3rrr          5266         MOV.W   R3,_semaput+2
002468 8E2rrr          5267         MOV.W   R2,_semaput
00246B 866C42          5268         MOV.B   ES,R3L
00246E 821A            5269         MOV.B   [R2],R0H
002470 8E3rrr          5270         MOV.W   _semaput+2,R3
002473 8E2rrr          5271         MOV.W   _semaput,R2
002476 860C01          5272         MOV.B   0401H,R0L
                       5273 ; rtxc.c   1879 
                       5274 ; rtxc.c   1880 #endif /* } QUEUE_SEMAS */
                       5275 ; rtxc.c   1881          }
                       5276 ; rtxc.c   1882          break;
                       5277         BR      _428
002479 D505B9         +5277         JMP.L   _428
002479 D505B9         +5277         JMP.L   _428
                       5278 ; rtxc.c   1883 #endif /* } HAS_DEQUEUE */
                       5279 ; rtxc.c   1884 #endif /* } HAS_QUEUES */
                       5280 ; rtxc.c   1885 
                       5281 ; rtxc.c   1886 #ifdef HAS_DEFQUEUE /* { */
                       5282 ; rtxc.c   1887 /************************/
                       5283 ; rtxc.c   1888       case RTXC_DEFQUEUE:
00247C                 5284 _220:
                       5285 ; rtxc.c   1889 /************************/
                       5286 ; rtxc.c   1890          pqh = (QHEADER ks_tbl *)&qheader[((struct qdefarg ks_stk *)p2)->queue];
00247C 8935            5287         MOV.W   R3,R5
00247E 8924            5288         MOV.W   R2,R4
002480 866C42          5289         MOV.B   ES,R3L
002483 840204          5290         MOV.B   R0L,[R2+4]
002486 E80018          5291         MULU.B  R0L,#018H
002489 B910            5292         MOVS.W  R1,#00H
00248B 9958rrrr        5293         MOV.W   R5,#SEG( _qheader )
00248F 9948rrrr        5294         MOV.W   R4,#SOF( _qheader )
002493 8C1F12          5295         MOV.W   [R7+18],R1
002496 8C0F10          5296         MOV.W   [R7+16],R0
002499 0940            5297         ADD.W   R4,R0
                       5298 ; rtxc.c   1891 
                       5299 ; rtxc.c   1892          pqh->base   = ((struct qdefarg ks_stk *)p2)->base;
00249B 8C3F16          5300         MOV.W   [R7+22],R3
00249E 8C2F14          5301         MOV.W   [R7+20],R2
0024A1 866C42          5302         MOV.B   ES,R3L
0024A4 8C0206          5303         MOV.W   R0,[R2+6]
0024A7 8C1208          5304         MOV.W   R1,[R2+8]
0024AA 8C3712          5305         MOV.W   R3,[R7+18]
0024AD 8C2710          5306         MOV.W   R2,[R7+16]
0024B0 964842rr        5307         MOV.B   ES,#SEG( _qheader )
0024B4 8D0Arrrr        5308         MOV.W   [R2+SOF( _qheader )],R0
0024B8 8D1Arrrr        5309         MOV.W   [R2+SOF( _qheader+2 )],R1
                       5310 ; rtxc.c   1893          pqh->width  = ((struct qdefarg ks_stk *)p2)->width;
0024BC 8C1716          5311         MOV.W   R1,[R7+22]
0024BF 8C0714          5312         MOV.W   R0,[R7+20]
0024C2 862C42          5313         MOV.B   ES,R1L
0024C5 8C000A          5314         MOV.W   R0,[R0+10]
0024C8 86AC42          5315         MOV.B   ES,R5L
0024CB 8C0C04          5316         MOV.W   [R4+4],R0
                       5317 ; rtxc.c   1894          pqh->depth  = ((struct qdefarg ks_stk *)p2)->depth;
0024CE 8C1716          5318         MOV.W   R1,[R7+22]
0024D1 8C0714          5319         MOV.W   R0,[R7+20]
0024D4 862C42          5320         MOV.B   ES,R1L
0024D7 8C000C          5321         MOV.W   R0,[R0+12]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  95

ADDR   CODE            LINE SOURCELINE
0024DA 8935            5322         MOV.W   R3,R5
0024DC 8924            5323         MOV.W   R2,R4
0024DE 99200006        5324         ADD.W   R2,#06H
0024E2 8C3F12          5325         MOV.W   [R7+18],R3
0024E5 8C2F10          5326         MOV.W   [R7+16],R2
0024E8 86AC42          5327         MOV.B   ES,R5L
0024EB 8C0C06          5328         MOV.W   [R4+6],R0
                       5329 ; rtxc.c   1895          cursz = ((struct qdefarg ks_stk *)p2)->current_size;
0024EE 8C3716          5330         MOV.W   R3,[R7+22]
0024F1 8C2714          5331         MOV.W   R2,[R7+20]
0024F4 866C42          5332         MOV.B   ES,R3L
0024F7 8C120E          5333         MOV.W   R1,[R2+14]
                       5334 ; rtxc.c   1896 
                       5335 ; rtxc.c   1897          if ( (cursz < 0) || (cursz > pqh->depth) )
0024FA 8C3716          5336         MOV.W   R3,[R7+22]
0024FD 8C2714          5337         MOV.W   R2,[R7+20]
002500 866C42          5338         MOV.B   ES,R3L
002503 9C240E0000      5339         CMP.W   [R2+14],#00H
002508 FB07            5340         BLT     _221
00250A 8C3716          5341         MOV.W   R3,[R7+22]
00250D 8C2714          5342         MOV.W   R2,[R7+20]
002510 866C42          5343         MOV.B   ES,R3L
002513 4C0A0E          5344         CMP.W   [R2+14],R0
002516 FD09            5345         BLE     _222
002516 FD09            5345         BLE     _222
002518                 5346 _221:
                       5347 ; rtxc.c   1898             ((struct qdefarg ks_stk *)p2)->ksrc = RC_ILLEGAL_QUEUE_SIZE;
002518 8C3716          5348         MOV.W   R3,[R7+22]
00251B 8C2714          5349         MOV.W   R2,[R7+20]
00251E 866C42          5350         MOV.B   ES,R3L
002521 9C28020008      5351         MOV.W   [R2+2],#08H
                       5352         BR      _428
002526 D50563         +5352         JMP.L   _428
002526 D5056300       +5352         JMP.L   _428
00252A                 5353 _222:
                       5354 ; rtxc.c   1899 
                       5355 ; rtxc.c   1900          else if (cursz == 0)
00252A 6911            5356         OR.W    R1,R1
00252C F210            5357         BNE     _223
                       5358 ; rtxc.c   1901          {
                       5359 ; rtxc.c   1902             pqh->putndx = pqh->depth - 1; /* purge queue */
00252E 8C3712          5360         MOV.W   R3,[R7+18]
002531 8C2710          5361         MOV.W   R2,[R7+16]
002534 866C42          5362         MOV.B   ES,R3L
002537 8A02            5363         MOV.W   R0,[R2]
002539 A90F            5364         ADDS.W  R0,#0FH
00253B 86AC42          5365         MOV.B   ES,R5L
00253E 8C0C08          5366         MOV.W   [R4+8],R0
                       5367 ; rtxc.c   1903             pqh->curndx = 0;
002541 9940000A        5368         ADD.W   R4,#0AH
002545 86AC42          5369         MOV.B   ES,R5L
002548 BA40            5370         MOV.W   [R4],#00H
                       5371 ; rtxc.c   1904          }
                       5372         BR      _428
00254A D50551         +5372         JMP.L   _428
00254A D5055100       +5372         JMP.L   _428
00254E                 5373 _223:
                       5374 ; rtxc.c   1905 
                       5375 ; rtxc.c   1906          else
                       5376 ; rtxc.c   1907          {
                       5377 ; rtxc.c   1908             pqh->curndx = cursz;
00254E 86AC42          5378         MOV.B   ES,R5L
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  96

ADDR   CODE            LINE SOURCELINE
002551 8C1C0A          5379         MOV.W   [R4+10],R1
                       5380 ; rtxc.c   1909             pqh->putndx = cursz - 1;
002554 A91F            5381         ADDS.W  R1,#0FH
002556 86AC42          5382         MOV.B   ES,R5L
002559 8C1C08          5383         MOV.W   [R4+8],R1
                       5384 ; rtxc.c   1910          }
                       5385 ; rtxc.c   1911          break;
                       5386         BR      _428
00255C D50548         +5386         JMP.L   _428
00255C D5054800       +5386         JMP.L   _428
                       5387 ; rtxc.c   1912 #endif /* } HAS_DEFQUEUE */
                       5388 ; rtxc.c   1913 
                       5389 ; rtxc.c   1914 #ifdef QUEUE_SEMAS /* { */
                       5390 ; rtxc.c   1915 #ifdef HAS_DEFQSEMA /* { */
                       5391 ; rtxc.c   1916 /************************/
                       5392 ; rtxc.c   1917       case RTXC_DEFQSEMA:
002560                 5393 _224:
                       5394 ; rtxc.c   1918 /************************/
                       5395 ; rtxc.c   1919          pqh = (QHEADER ks_tbl *)&qheader[((struct qdefarg ks_stk *)p2)->queue];
002560 8935            5396         MOV.W   R3,R5
002562 8924            5397         MOV.W   R2,R4
002564 866C42          5398         MOV.B   ES,R3L
002567 840204          5399         MOV.B   R0L,[R2+4]
00256A E80018          5400         MULU.B  R0L,#018H
00256D B910            5401         MOVS.W  R1,#00H
00256F 9958rrrr        5402         MOV.W   R5,#SEG( _qheader )
002573 9948rrrr        5403         MOV.W   R4,#SOF( _qheader )
002577 0940            5404         ADD.W   R4,R0
                       5405 ; rtxc.c   1920 
                       5406 ; rtxc.c   1921          switch(((struct qdefarg ks_stk *)p2)->qcond)
002579 866C42          5407         MOV.B   ES,R3L
00257C 8C0212          5408         MOV.W   R0,[R2+18]
00257F 99040000        5409         CMP.W   R0,#00H
002583 F30B            5410         BEQ     _225
002585 99040001        5411         CMP.W   R0,#01H
002589 F329            5412         BEQ     _227
00258B 99040003        5413         CMP.W   R0,#03H
00258F F34A            5414         BEQ     _229
002591 99040002        5415         CMP.W   R0,#02H
002595 F368            5416         BEQ     _231
                       5417         BR      _428
002597 D5052A         +5417         JMP.L   _428
002597 D5052A         +5417         JMP.L   _428
                       5418 ; rtxc.c   1922          {
                       5419 ; rtxc.c   1923             /* note: semaphore is 0 == undefqsema() and harmless */
                       5420 ; rtxc.c   1924             case QNE:
00259A                 5421 _225:
                       5422 ; rtxc.c   1925                pqh->nesema = ((struct qdefarg ks_stk *)p2)->sema;
00259A 866C42          5423         MOV.B   ES,R3L
00259D 844210          5424         MOV.B   R2L,[R2+16]
0025A0 8915            5425         MOV.W   R1,R5
0025A2 8904            5426         MOV.W   R0,R4
0025A4 99000015        5427         ADD.W   R0,#015H
0025A8 86AC42          5428         MOV.B   ES,R5L
0025AB 844C15          5429         MOV.B   [R4+21],R2L
                       5430 ; rtxc.c   1926                if (pqh->curndx != 0) /* if not empty */
0025AE 86AC42          5431         MOV.B   ES,R5L
0025B1 8C340A          5432         MOV.W   R3,[R4+10]
0025B4 F308            5433         BEQ     _226
                       5434 ; rtxc.c   1927                   semat[pqh->nesema] = SEMA_DONE;
0025B6 B150            5435         MOVS.B  R2H,#00H
0025B8 B930            5436         MOVS.W  R3,#00H
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  97

ADDR   CODE            LINE SOURCELINE
0025BA 964842rr        5437         MOV.B   ES,#SEG( _semat )
0025BE B520rrrr        5438         MOV.B   [R2+SOF( _semat )],#00H
                       5439         BR      _428
0025C2 D50515         +5439         JMP.L   _428
0025C2 D5051500       +5439         JMP.L   _428
0025C6                 5440 _226:
                       5441 ; rtxc.c   1928                else
                       5442 ; rtxc.c   1929                   semat[pqh->nesema] = SEMA_PENDING;
0025C6 862C42          5443         MOV.B   ES,R1L
0025C9 8200            5444         MOV.B   R0L,[R0]
0025CB B110            5445         MOVS.B  R0H,#00H
0025CD B910            5446         MOVS.W  R1,#00H
0025CF 964842rr        5447         MOV.B   ES,#SEG( _semat )
0025D3 9508rrrrFF      5448         MOV.B   [R0+SOF( _semat )],#0FFH
                       5449 ; rtxc.c   1930                break;
                       5450         BR      _428
0025D8 D5050A         +5450         JMP.L   _428
0025D8 D5050A00       +5450         JMP.L   _428
                       5451 ; rtxc.c   1931 
                       5452 ; rtxc.c   1932             case QNF:
0025DC                 5453 _227:
                       5454 ; rtxc.c   1933                pqh->nfsema = ((struct qdefarg ks_stk *)p2)->sema;
0025DC 866C42          5455         MOV.B   ES,R3L
0025DF 844210          5456         MOV.B   R2L,[R2+16]
0025E2 8915            5457         MOV.W   R1,R5
0025E4 8904            5458         MOV.W   R0,R4
0025E6 99000017        5459         ADD.W   R0,#017H
0025EA 86AC42          5460         MOV.B   ES,R5L
0025ED 844C17          5461         MOV.B   [R4+23],R2L
                       5462 ; rtxc.c   1934                if (pqh->curndx != pqh->depth) /* if not full */
0025F0 86AC42          5463         MOV.B   ES,R5L
0025F3 8C3406          5464         MOV.W   R3,[R4+6]
0025F6 86AC42          5465         MOV.B   ES,R5L
0025F9 4C3C0A          5466         CMP.W   [R4+10],R3
0025FC F308            5467         BEQ     _228
                       5468 ; rtxc.c   1935                   semat[pqh->nfsema] = SEMA_DONE;
0025FE B150            5469         MOVS.B  R2H,#00H
002600 B930            5470         MOVS.W  R3,#00H
002602 964842rr        5471         MOV.B   ES,#SEG( _semat )
002606 B520rrrr        5472         MOV.B   [R2+SOF( _semat )],#00H
                       5473         BR      _428
00260A D504F1         +5473         JMP.L   _428
00260A D504F100       +5473         JMP.L   _428
00260E                 5474 _228:
                       5475 ; rtxc.c   1936                else
                       5476 ; rtxc.c   1937                   semat[pqh->nfsema] = SEMA_PENDING;
00260E 862C42          5477         MOV.B   ES,R1L
002611 8200            5478         MOV.B   R0L,[R0]
002613 B110            5479         MOVS.B  R0H,#00H
002615 B910            5480         MOVS.W  R1,#00H
002617 964842rr        5481         MOV.B   ES,#SEG( _semat )
00261B 9508rrrrFF      5482         MOV.B   [R0+SOF( _semat )],#0FFH
                       5483 ; rtxc.c   1938                break;
                       5484         BR      _428
002620 D504E6         +5484         JMP.L   _428
002620 D504E600       +5484         JMP.L   _428
                       5485 ; rtxc.c   1939 
                       5486 ; rtxc.c   1940             case QE:
002624                 5487 _229:
                       5488 ; rtxc.c   1941                pqh->esema = ((struct qdefarg ks_stk *)p2)->sema;
002624 866C42          5489         MOV.B   ES,R3L
002627 844210          5490         MOV.B   R2L,[R2+16]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  98

ADDR   CODE            LINE SOURCELINE
00262A 8915            5491         MOV.W   R1,R5
00262C 8904            5492         MOV.W   R0,R4
00262E 99000016        5493         ADD.W   R0,#016H
002632 86AC42          5494         MOV.B   ES,R5L
002635 844C16          5495         MOV.B   [R4+22],R2L
                       5496 ; rtxc.c   1942                if (pqh->curndx == 0) /* if empty */
002638 86AC42          5497         MOV.B   ES,R5L
00263B 8C340A          5498         MOV.W   R3,[R4+10]
00263E F208            5499         BNE     _230
                       5500 ; rtxc.c   1943                   semat[pqh->esema] = SEMA_DONE;
002640 B150            5501         MOVS.B  R2H,#00H
002642 B930            5502         MOVS.W  R3,#00H
002644 964842rr        5503         MOV.B   ES,#SEG( _semat )
002648 B520rrrr        5504         MOV.B   [R2+SOF( _semat )],#00H
                       5505         BR      _428
00264C D504D0         +5505         JMP.L   _428
00264C D504D000       +5505         JMP.L   _428
002650                 5506 _230:
                       5507 ; rtxc.c   1944                else
                       5508 ; rtxc.c   1945                   semat[pqh->esema] = SEMA_PENDING;
002650 862C42          5509         MOV.B   ES,R1L
002653 8200            5510         MOV.B   R0L,[R0]
002655 B110            5511         MOVS.B  R0H,#00H
002657 B910            5512         MOVS.W  R1,#00H
002659 964842rr        5513         MOV.B   ES,#SEG( _semat )
00265D 9508rrrrFF      5514         MOV.B   [R0+SOF( _semat )],#0FFH
                       5515 ; rtxc.c   1946                break;
                       5516         BR      _428
002662 D504C5         +5516         JMP.L   _428
002662 D504C500       +5516         JMP.L   _428
                       5517 ; rtxc.c   1947 
                       5518 ; rtxc.c   1948             case QF:
002666                 5519 _231:
                       5520 ; rtxc.c   1949                pqh->fsema = ((struct qdefarg ks_stk *)p2)->sema;
002666 866C42          5521         MOV.B   ES,R3L
002669 844210          5522         MOV.B   R2L,[R2+16]
00266C 8915            5523         MOV.W   R1,R5
00266E 8904            5524         MOV.W   R0,R4
002670 99000014        5525         ADD.W   R0,#014H
002674 86AC42          5526         MOV.B   ES,R5L
002677 844C14          5527         MOV.B   [R4+20],R2L
                       5528 ; rtxc.c   1950                if (pqh->curndx == pqh->depth) /* if full */
00267A 86AC42          5529         MOV.B   ES,R5L
00267D 8C3406          5530         MOV.W   R3,[R4+6]
002680 86AC42          5531         MOV.B   ES,R5L
002683 4C3C0A          5532         CMP.W   [R4+10],R3
002686 F208            5533         BNE     _232
                       5534 ; rtxc.c   1951                   semat[pqh->fsema] = SEMA_DONE;
002688 B150            5535         MOVS.B  R2H,#00H
00268A B930            5536         MOVS.W  R3,#00H
00268C 964842rr        5537         MOV.B   ES,#SEG( _semat )
002690 B520rrrr        5538         MOV.B   [R2+SOF( _semat )],#00H
                       5539         BR      _428
002694 D504AC         +5539         JMP.L   _428
002694 D504AC00       +5539         JMP.L   _428
002698                 5540 _232:
                       5541 ; rtxc.c   1952                else
                       5542 ; rtxc.c   1953                   semat[pqh->fsema] = SEMA_PENDING;
002698 862C42          5543         MOV.B   ES,R1L
00269B 8200            5544         MOV.B   R0L,[R0]
00269D B110            5545         MOVS.B  R0H,#00H
00269F B910            5546         MOVS.W  R1,#00H
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page  99

ADDR   CODE            LINE SOURCELINE
0026A1 964842rr        5547         MOV.B   ES,#SEG( _semat )
0026A5 9508rrrrFF      5548         MOV.B   [R0+SOF( _semat )],#0FFH
                       5549 ; rtxc.c   1954                break;
                       5550 ; rtxc.c   1955          }
                       5551 ; rtxc.c   1956          break;
                       5552         BR      _428
0026AA D504A1         +5552         JMP.L   _428
0026AA D504A100       +5552         JMP.L   _428
                       5553 ; rtxc.c   1957 #endif /* } HAS_DEFQSEMA */
                       5554 ; rtxc.c   1958 #endif /* } QUEUE_SEMAS */
                       5555 ; rtxc.c   1959 
                       5556 ; rtxc.c   1960 #ifdef MAILBOX_SEMAS /* { */
                       5557 ; rtxc.c   1961 #ifdef HAS_DEFMBOXSEMA /* { */
                       5558 ; rtxc.c   1962 /************************/
                       5559 ; rtxc.c   1963       case RTXC_DEFMBOXSEMA:
0026AE                 5560 _233:
                       5561 ; rtxc.c   1964 /************************/
                       5562 ; rtxc.c   1965          pmh = (MHEADER ks_tbl *)&mheader[((struct msgarg ks_stk *)p2)->mbox];
0026AE 86AC42          5563         MOV.B   ES,R5L
0026B1 840405          5564         MOV.B   R0L,[R4+5]
0026B4 E8000E          5565         MULU.B  R0L,#0EH
0026B7 B910            5566         MOVS.W  R1,#00H
0026B9 9938rrrr        5567         MOV.W   R3,#SEG( _mheader )
0026BD 9928rrrr        5568         MOV.W   R2,#SOF( _mheader )
0026C1 0920            5569         ADD.W   R2,R0
0026C3 8913            5570         MOV.W   R1,R3
0026C5 8902            5571         MOV.W   R0,R2
                       5572 ; rtxc.c   1966 
                       5573 ; rtxc.c   1967          /* note: semaphore is 0 == undefmboxsema() and harmless */
                       5574 ; rtxc.c   1968          pmh->nesema = ((struct msgarg ks_stk *)p2)->sema;
0026C7 86AC42          5575         MOV.B   ES,R5L
0026CA 844404          5576         MOV.B   R2L,[R4+4]
0026CD 8951            5577         MOV.W   R5,R1
0026CF 8940            5578         MOV.W   R4,R0
0026D1 9940000C        5579         ADD.W   R4,#0CH
0026D5 862C42          5580         MOV.B   ES,R1L
0026D8 84480C          5581         MOV.B   [R0+12],R2L
                       5582 ; rtxc.c   1969 
                       5583 ; rtxc.c   1970          if (pmh->link == NULL)
0026DB 862C42          5584         MOV.B   ES,R1L
0026DE 8C1002          5585         MOV.W   R1,[R0+2]
0026E1 8A00            5586         MOV.W   R0,[R0]
0026E3 6910            5587         OR.W    R1,R0
0026E5 F209            5588         BNE     _234
                       5589 ; rtxc.c   1971              semat[pmh->nesema] = SEMA_PENDING;
0026E7 B150            5590         MOVS.B  R2H,#00H
0026E9 B930            5591         MOVS.W  R3,#00H
0026EB 964842rr        5592         MOV.B   ES,#SEG( _semat )
0026EF 9528rrrrFF      5593         MOV.B   [R2+SOF( _semat )],#0FFH
                       5594         BR      _428
0026F4 D5047C         +5594         JMP.L   _428
0026F4 D5047C00       +5594         JMP.L   _428
0026F8                 5595 _234:
                       5596 ; rtxc.c   1972          else
                       5597 ; rtxc.c   1973              semat[pmh->nesema] = SEMA_DONE;
0026F8 86AC42          5598         MOV.B   ES,R5L
0026FB 8204            5599         MOV.B   R0L,[R4]
0026FD B110            5600         MOVS.B  R0H,#00H
0026FF B910            5601         MOVS.W  R1,#00H
002701 964842rr        5602         MOV.B   ES,#SEG( _semat )
002705 B500rrrr        5603         MOV.B   [R0+SOF( _semat )],#00H
                       5604 ; rtxc.c   1974          break;
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 100

ADDR   CODE            LINE SOURCELINE
                       5605         BR      _428
002709 D50471         +5605         JMP.L   _428
002709 D50471         +5605         JMP.L   _428
                       5606 ; rtxc.c   1975 #endif /* } HAS_DEFMBOXSEMA */
                       5607 ; rtxc.c   1976 #endif /* } MAILBOX_SEMAS */
                       5608 ; rtxc.c   1977 
                       5609 ; rtxc.c   1978 #ifdef HAS_PURGEQUEUE /* { */
                       5610 ; rtxc.c   1979 /************************/
                       5611 ; rtxc.c   1980       case RTXC_PURGEQUEUE:
00270C                 5612 _235:
                       5613 ; rtxc.c   1981 /************************/
                       5614 ; rtxc.c   1982          pqh = (QHEADER ks_tbl *)&qheader[((struct qarg ks_stk *)p2)->queue];
00270C 8915            5615         MOV.W   R1,R5
00270E 8904            5616         MOV.W   R0,R4
002710 862C42          5617         MOV.B   ES,R1L
002713 840005          5618         MOV.B   R0L,[R0+5]
002716 E80018          5619         MULU.B  R0L,#018H
002719 B910            5620         MOVS.W  R1,#00H
00271B 9958rrrr        5621         MOV.W   R5,#SEG( _qheader )
00271F 9948rrrr        5622         MOV.W   R4,#SOF( _qheader )
002723 0940            5623         ADD.W   R4,R0
                       5624 ; rtxc.c   1983 
                       5625 ; rtxc.c   1984          pqh->putndx = pqh->depth - 1;
002725 8915            5626         MOV.W   R1,R5
002727 8904            5627         MOV.W   R0,R4
002729 99000006        5628         ADD.W   R0,#06H
00272D 8C1F12          5629         MOV.W   [R7+18],R1
002730 8C0F10          5630         MOV.W   [R7+16],R0
002733 86AC42          5631         MOV.B   ES,R5L
002736 8C0406          5632         MOV.W   R0,[R4+6]
002739 A90F            5633         ADDS.W  R0,#0FH
00273B 8935            5634         MOV.W   R3,R5
00273D 8924            5635         MOV.W   R2,R4
00273F 99200008        5636         ADD.W   R2,#08H
002743 8C3F0E          5637         MOV.W   [R7+14],R3
002746 8C2F0C          5638         MOV.W   [R7+12],R2
002749 86AC42          5639         MOV.B   ES,R5L
00274C 8C0C08          5640         MOV.W   [R4+8],R0
                       5641 ; rtxc.c   1985          qindex = pqh->curndx; /* save original size for later use */
00274F 8915            5642         MOV.W   R1,R5
002751 8904            5643         MOV.W   R0,R4
002753 9900000A        5644         ADD.W   R0,#0AH
002757 8C1F0A          5645         MOV.W   [R7+10],R1
00275A 8C0F08          5646         MOV.W   [R7+8],R0
00275D 86AC42          5647         MOV.B   ES,R5L
002760 8C640A          5648         MOV.W   R6,[R4+10]
                       5649 ; rtxc.c   1986          pqh->curndx = 0;
002763 86AC42          5650         MOV.B   ES,R5L
002766 BC400A          5651         MOV.W   [R4+10],#00H
                       5652 ; rtxc.c   1987 
                       5653 ; rtxc.c   1988 #ifdef QUEUE_SEMAS /* { */
                       5654 ; rtxc.c   1989          UPDATE_SEMA(pqh->esema);
002769 8C5F16          5655         MOV.W   [R7+22],R5
00276C 8C4F14          5656         MOV.W   [R7+20],R4
00276F 99400016        5657         ADD.W   R4,#016H
002773 8C1716          5658         MOV.W   R1,[R7+22]
002776 8C0714          5659         MOV.W   R0,[R7+20]
002779 862C42          5660         MOV.B   ES,R1L
00277C 840016          5661         MOV.B   R0L,[R0+22]
00277F F32F            5662         BEQ     _239
002781 B110            5663         MOVS.B  R0H,#00H
002783 B910            5664         MOVS.W  R1,#00H
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 101

ADDR   CODE            LINE SOURCELINE
002785 9938rrrr        5665         MOV.W   R3,#SEG( _semat )
002789 9928rrrr        5666         MOV.W   R2,#SOF( _semat )
00278D 0920            5667         ADD.W   R2,R0
00278F 8C3F06          5668         MOV.W   [R7+6],R3
002792 8C2F04          5669         MOV.W   [R7+4],R2
002795 964842rr        5670         MOV.B   ES,#SEG( _semat )
002799 8540rrrr        5671         MOV.B   R2L,[R0+SOF( _semat )]
00279D 9144FF          5672         CMP.B   R2L,#0FFH
0027A0 F205            5673         BNE     _236
0027A2 964842rr        5674         MOV.B   ES,#SEG( _semat )
0027A6 B500rrrr        5675         MOV.B   [R0+SOF( _semat )],#00H
0027AA FE19            5676         BR      _239
0027AA FE19            5676         BR      _239
0027AC                 5677 _236:
0027AC 8C3706          5678         MOV.W   R3,[R7+6]
0027AF 8C2704          5679         MOV.W   R2,[R7+4]
0027B2 866C42          5680         MOV.B   ES,R3L
0027B5 8202            5681         MOV.B   R0L,[R2]
0027B7 F313            5682         BEQ     _239
0027B9 860401          5683         MOV.B   R0L,0401H
0027BC 9648018D        5684         MOV.B   0401H,#08DH
0027C0 86AC42          5685         MOV.B   ES,R5L
0027C3 8214            5686         MOV.B   R0H,[R4]
0027C5 9Er0rr0001      5687         ADD.W   _semaput,#01H
0027CA 8E3rrr          5688         MOV.W   R3,_semaput+2
0027CD 8E2rrr          5689         MOV.W   R2,_semaput
0027D0 866C42          5690         MOV.B   ES,R3L
0027D3 821A            5691         MOV.B   [R2],R0H
0027D5 8E3rrr          5692         MOV.W   _semaput+2,R3
0027D8 8E2rrr          5693         MOV.W   _semaput,R2
0027DB 860C01          5694         MOV.B   0401H,R0L
0027DB 860C01          5694         MOV.B   0401H,R0L
0027DE                 5695 _239:
                       5696 ; rtxc.c   1990 
                       5697 ; rtxc.c   1991 #endif /* } QUEUE_SEMAS */
                       5698 ; rtxc.c   1992 
                       5699 ; rtxc.c   1993          depth = pqh->depth;
0027DE 8C1712          5700         MOV.W   R1,[R7+18]
0027E1 8C0710          5701         MOV.W   R0,[R7+16]
0027E4 862C42          5702         MOV.B   ES,R1L
0027E7 8A00            5703         MOV.W   R0,[R0]
0027E9 8C0F06          5704         MOV.W   [R7+6],R0
                       5705 ; rtxc.c   1994 
                       5706 ; rtxc.c   1995          /* if queue was full */
                       5707 ; rtxc.c   1996          if (qindex == depth)
0027EC 8C1712          5708         MOV.W   R1,[R7+18]
0027EF 8C0710          5709         MOV.W   R0,[R7+16]
0027F2 862C42          5710         MOV.B   ES,R1L
0027F5 4A68            5711         CMP.W   [R0],R6
                       5712         BNE     _428
0027F7 F302           +5712 ;       BEQ     _LG_408
0027F9 D503F9         +5712 ;       JMP.L   _428
0027F9 D503F9         +5712 ;       JMP.L   _428
0027FC                +5712 _LG_408:
                       5713 ; rtxc.c   1997          {
                       5714 ; rtxc.c   1998 #ifdef QUEUE_SEMAS /* { */
                       5715 ; rtxc.c   1999             UPDATE_SEMA(pqh->nfsema);
0027FC 8C3716          5716         MOV.W   R3,[R7+22]
0027FF 8C2714          5717         MOV.W   R2,[R7+20]
002802 99200017        5718         ADD.W   R2,#017H
002806 8C1716          5719         MOV.W   R1,[R7+22]
002809 8C0714          5720         MOV.W   R0,[R7+20]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 102

ADDR   CODE            LINE SOURCELINE
00280C 862C42          5721         MOV.B   ES,R1L
00280F 840017          5722         MOV.B   R0L,[R0+23]
002812 F329            5723         BEQ     _243
002814 B110            5724         MOVS.B  R0H,#00H
002816 B910            5725         MOVS.W  R1,#00H
002818 9958rrrr        5726         MOV.W   R5,#SEG( _semat )
00281C 9948rrrr        5727         MOV.W   R4,#SOF( _semat )
002820 0940            5728         ADD.W   R4,R0
002822 964842rr        5729         MOV.B   ES,#SEG( _semat )
002826 85C0rrrr        5730         MOV.B   R6L,[R0+SOF( _semat )]
00282A 91C4FF          5731         CMP.B   R6L,#0FFH
00282D F206            5732         BNE     _240
00282F 964842rr        5733         MOV.B   ES,#SEG( _semat )
002833 B500rrrr        5734         MOV.B   [R0+SOF( _semat )],#00H
002837 FE17            5735         BR      _243
002837 FE1700          5735         BR      _243
00283A                 5736 _240:
00283A 86AC42          5737         MOV.B   ES,R5L
00283D 8204            5738         MOV.B   R0L,[R4]
00283F F313            5739         BEQ     _243
002841 860401          5740         MOV.B   R0L,0401H
002844 9648018D        5741         MOV.B   0401H,#08DH
002848 866C42          5742         MOV.B   ES,R3L
00284B 8212            5743         MOV.B   R0H,[R2]
00284D 9Er0rr0001      5744         ADD.W   _semaput,#01H
002852 8E3rrr          5745         MOV.W   R3,_semaput+2
002855 8E2rrr          5746         MOV.W   R2,_semaput
002858 866C42          5747         MOV.B   ES,R3L
00285B 821A            5748         MOV.B   [R2],R0H
00285D 8E3rrr          5749         MOV.W   _semaput+2,R3
002860 8E2rrr          5750         MOV.W   _semaput,R2
002863 860C01          5751         MOV.B   0401H,R0L
002863 860C01          5751         MOV.B   0401H,R0L
002866                 5752 _243:
                       5753 ; rtxc.c   2000 
                       5754 ; rtxc.c   2001 #endif /* } QUEUE_SEMAS */
                       5755 ; rtxc.c   2002 
                       5756 ; rtxc.c   2003             width = pqh->width;
002866 8C1716          5757         MOV.W   R1,[R7+22]
002869 8C0714          5758         MOV.W   R0,[R7+20]
00286C 862C42          5759         MOV.B   ES,R1L
00286F 8C6004          5760         MOV.W   R6,[R0+4]
                       5761 ; rtxc.c   2004 
                       5762 ; rtxc.c   2005 #ifdef QUEUE_WAITERS /* { */
                       5763 ; rtxc.c   2006             /* might have enq or deq waiters to process */
                       5764 ; rtxc.c   2007             while ( (ptcb = pqh->waiters) != NULLTCB)
002872 8C1716          5765         MOV.W   R1,[R7+22]
002875 8C0714          5766         MOV.W   R0,[R7+20]
002878 9900000C        5767         ADD.W   R0,#0CH
00287C 8C1F12          5768         MOV.W   [R7+18],R1
00287F 8C0F10          5769         MOV.W   [R7+16],R0
002882 8C1716          5770         MOV.W   R1,[R7+22]
002885 8C0714          5771         MOV.W   R0,[R7+20]
002888 862C42          5772         MOV.B   ES,R1L
00288B 8C100E          5773         MOV.W   R1,[R0+14]
00288E 8C000C          5774         MOV.W   R0,[R0+12]
002891 8951            5775         MOV.W   R5,R1
002893 8940            5776         MOV.W   R4,R0
002895 6910            5777         OR.W    R1,R0
                       5778         BEQ     _428
002897 F202           +5778 ;       BNE     _LG_416
002899 D503A9         +5778 ;       JMP.L   _428
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 103

ADDR   CODE            LINE SOURCELINE
002899 D503A9         +5778 ;       JMP.L   _428
00289C                +5778 _LG_416:
00289C 8C1716          5779         MOV.W   R1,[R7+22]
00289F 8C0714          5780         MOV.W   R0,[R7+20]
0028A2 99000015        5781         ADD.W   R0,#015H
0028A6 8C1F04          5782         MOV.W   [R7+4],R1
0028A9 8C0F02          5783         MOV.W   [R7+2],R0
0028A9 8C0F02          5783         MOV.W   [R7+2],R0
0028AC                 5784 _244:
                       5785 ; rtxc.c   2008             {
                       5786 ; rtxc.c   2009                /* remove highest priority waiter (1st) */
                       5787 ; rtxc.c   2010                if ( (pqh->waiters = ptcb->flink) != NULLTCB)
0028AC 86AC42          5788         MOV.B   ES,R5L
0028AF 8A04            5789         MOV.W   R0,[R4]
0028B1 8C1402          5790         MOV.W   R1,[R4+2]
0028B4 8C3712          5791         MOV.W   R3,[R7+18]
0028B7 8C2710          5792         MOV.W   R2,[R7+16]
0028BA 866C42          5793         MOV.B   ES,R3L
0028BD 8A0A            5794         MOV.W   [R2],R0
0028BF 8C1A02          5795         MOV.W   [R2+2],R1
0028C2 6910            5796         OR.W    R1,R0
0028C4 F30C            5797         BEQ     _245
                       5798 ; rtxc.c   2011                   ptcb->flink->blink = (TCB ks_tbl *)&pqh->waiters;
0028C6 8C1712          5799         MOV.W   R1,[R7+18]
0028C9 8C0710          5800         MOV.W   R0,[R7+16]
0028CC 86AC42          5801         MOV.B   ES,R5L
0028CF 8A24            5802         MOV.W   R2,[R4]
0028D1 8C3402          5803         MOV.W   R3,[R4+2]
0028D4 866C42          5804         MOV.B   ES,R3L
0028D7 8C0A04          5805         MOV.W   [R2+4],R0
0028DA 8C1A06          5806         MOV.W   [R2+6],R1
0028DA 8C1A0600        5806         MOV.W   [R2+6],R1
0028DE                 5807 _245:
                       5808 ; rtxc.c   2012 
                       5809 ; rtxc.c   2013                if ( (ptcb->status &= ~QUEUE_WAIT) == READY)
0028DE 86AC42          5810         MOV.B   ES,R5L
0028E1 8C0412          5811         MOV.W   R0,[R4+18]
0028E4 9905FF7F        5812         AND.W   R0,#0FF7FH
0028E8 86AC42          5813         MOV.B   ES,R5L
0028EB 9C4512FF7F      5814         AND.W   [R4+18],#0FF7FH
0028F0 6900            5815         OR.W    R0,R0
0028F2 F20A            5816         BNE     _246
                       5817 ; rtxc.c   2014                {
                       5818 ; rtxc.c   2015                   ptcb->flink = nsrttcb;
0028F4 8E1rrr          5819         MOV.W   R1,_nsrttcb+2
0028F7 8E0rrr          5820         MOV.W   R0,_nsrttcb
0028FA 86AC42          5821         MOV.B   ES,R5L
0028FD 8A0C            5822         MOV.W   [R4],R0
0028FF 8C1C02          5823         MOV.W   [R4+2],R1
                       5824 ; rtxc.c   2016                   nsrttcb = ptcb;
002902 8E5rrr          5825         MOV.W   _nsrttcb+2,R5
002905 8E4rrr          5826         MOV.W   _nsrttcb,R4
002905 8E4rrr          5826         MOV.W   _nsrttcb,R4
                       5827 ; rtxc.c   2017                }
002908                 5828 _246:
                       5829 ; rtxc.c   2018 
                       5830 ; rtxc.c   2019 #ifdef QUEUE_TIMEOUTS /* { */
                       5831 ; rtxc.c   2020                /* cleanup any pending timeout */
                       5832 ; rtxc.c   2021                if ( (pclkblk = ptcb->pclkblk) != NULLCLK)
002908 86AC42          5833         MOV.B   ES,R5L
00290B 8C0408          5834         MOV.W   R0,[R4+8]
00290E 8C140A          5835         MOV.W   R1,[R4+10]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 104

ADDR   CODE            LINE SOURCELINE
002911 8931            5836         MOV.W   R3,R1
002913 8920            5837         MOV.W   R2,R0
002915 6932            5838         OR.W    R3,R2
002917 F307            5839         BEQ     _247
                       5840 ; rtxc.c   2022                {
                       5841 ; rtxc.c   2023                   unlink_timer(pclkblk);
002919 C50C43          5842         CALL    _unlink_timer
                       5843 ; rtxc.c   2024                   ptcb->pclkblk = NULLCLK;
00291C 86AC42          5844         MOV.B   ES,R5L
00291F BC4008          5845         MOV.W   [R4+8],#00H
002922 BC400A          5846         MOV.W   [R4+10],#00H
002922 BC400A00        5846         MOV.W   [R4+10],#00H
                       5847 ; rtxc.c   2025                }
002926                 5848 _247:
                       5849 ; rtxc.c   2026 #endif /* } QUEUE_TIMEOUTS */
                       5850 ; rtxc.c   2027 
                       5851 ; rtxc.c   2028                p2a = ((FRAME ks_stk *)(ptcb->sp))->pksnum;
002926 86AC42          5852         MOV.B   ES,R5L
002929 8C240E          5853         MOV.W   R2,[R4+14]
00292C 8C3410          5854         MOV.W   R3,[R4+16]
00292F 866C42          5855         MOV.B   ES,R3L
002932 8C3206          5856         MOV.W   R3,[R2+6]
002935 8C2204          5857         MOV.W   R2,[R2+4]
                       5858 ; rtxc.c   2029 
                       5859 ; rtxc.c   2030                ((struct qarg ks_stk *)p2a)->ksrc = RC_GOOD;
002938 866C42          5860         MOV.B   ES,R3L
00293B BC2002          5861         MOV.W   [R2+2],#00H
                       5862 ; rtxc.c   2031 
                       5863 ; rtxc.c   2032                /* move data into queue */
                       5864 ; rtxc.c   2033                pqh->curndx++;
00293E 8C170A          5865         MOV.W   R1,[R7+10]
002941 8C0708          5866         MOV.W   R0,[R7+8]
002944 862C42          5867         MOV.B   ES,R1L
002947 AA01            5868         ADDS.W  [R0],#01H
                       5869 ; rtxc.c   2034                if (++pqh->putndx == depth)
002949 8C170E          5870         MOV.W   R1,[R7+14]
00294C 8C070C          5871         MOV.W   R0,[R7+12]
00294F 862C42          5872         MOV.B   ES,R1L
002952 8A40            5873         MOV.W   R4,[R0]
002954 A941            5874         ADDS.W  R4,#01H
002956 8C170E          5875         MOV.W   R1,[R7+14]
002959 8C070C          5876         MOV.W   R0,[R7+12]
00295C 862C42          5877         MOV.B   ES,R1L
00295F AA01            5878         ADDS.W  [R0],#01H
002961 4C4706          5879         CMP.W   R4,[R7+6]
002964 F206            5880         BNE     _248
                       5881 ; rtxc.c   2035                   pqh->putndx = 0;  /* recycle index */
002966 8C170E          5882         MOV.W   R1,[R7+14]
002969 8C070C          5883         MOV.W   R0,[R7+12]
00296C 862C42          5884         MOV.B   ES,R1L
00296F BA00            5885         MOV.W   [R0],#00H
00296F BA0000          5885         MOV.W   [R0],#00H
002972                 5886 _248:
                       5887 ; rtxc.c   2036 
                       5888 ; rtxc.c   2037                qindex = pqh->putndx;
002972 8C170E          5889         MOV.W   R1,[R7+14]
002975 8C070C          5890         MOV.W   R0,[R7+12]
002978 862C42          5891         MOV.B   ES,R1L
00297B 8A00            5892         MOV.W   R0,[R0]
                       5893 ; rtxc.c   2038 
                       5894 ; rtxc.c   2039 #ifdef QUEUE_MEMCPY /* { */
                       5895 ; rtxc.c   2040                if (width)
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 105

ADDR   CODE            LINE SOURCELINE
                       5896 ; rtxc.c   2041                   ks_memcpyFN(pqh->base + (qindex * width),
                       5897 ; rtxc.c   2042                          ((struct qarg ks_stk *)p2a)->data,
                       5898 ; rtxc.c   2043                          width);
                       5899 ; rtxc.c   2044 #else /* } QUEUE_MEMCPY { */
                       5900 ; rtxc.c   2045                switch(width)
00297D 99640000        5901         CMP.W   R6,#00H
002981 F35D            5902         BEQ     _256
002983 99640001        5903         CMP.W   R6,#01H
002987 F308            5904         BEQ     _249
002989 99640002        5905         CMP.W   R6,#02H
00298D F319            5906         BEQ     _250
00298F 99640004        5907         CMP.W   R6,#04H
002993 F32B            5908         BEQ     _251
002995 FE41            5909         BR      _252
002995 FE4100          5909         BR      _252
                       5910 ; rtxc.c   2046                {
                       5911 ; rtxc.c   2047                   case 0:
                       5912 ; rtxc.c   2048                      break;
                       5913 ; rtxc.c   2049 
                       5914 ; rtxc.c   2050                   case sizeof(char):
002998                 5915 _249:
                       5916 ; rtxc.c   2051                      *(char ks_queue *)(pqh->base + qindex) =
                       5917 ; rtxc.c   2052                                *(char *)(((struct qarg ks_stk *)p2a)->data);
002998 866C42          5918         MOV.B   ES,R3L
00299B 8C3208          5919         MOV.W   R3,[R2+8]
00299E 8C2206          5920         MOV.W   R2,[R2+6]
0029A1 866C42          5921         MOV.B   ES,R3L
0029A4 8222            5922         MOV.B   R1L,[R2]
0029A6 8920            5923         MOV.W   R2,R0
0029A8 9839            5924         SEXT.W  R3
0029AA 8C5716          5925         MOV.W   R5,[R7+22]
0029AD 8C4714          5926         MOV.W   R4,[R7+20]
0029B0 86AC42          5927         MOV.B   ES,R5L
0029B3 0A24            5928         ADD.W   R2,[R4]
0029B5 1C3402          5929         ADDC.W  R3,[R4+2]
0029B8 866C42          5930         MOV.B   ES,R3L
0029BB 822A            5931         MOV.B   [R2],R1L
                       5932 ; rtxc.c   2053                      break;
0029BD FE3F            5933         BR      _256
0029BD FE3F00          5933         BR      _256
                       5934 ; rtxc.c   2054 
                       5935 ; rtxc.c   2055                   case sizeof(short):
0029C0                 5936 _250:
                       5937 ; rtxc.c   2056                      *(short ks_queue *)(pqh->base + (qindex << 1)) =
                       5938 ; rtxc.c   2057                                *(short *)(((struct qarg ks_stk *)p2a)->data);
0029C0 866C42          5939         MOV.B   ES,R3L
0029C3 8C3208          5940         MOV.W   R3,[R2+8]
0029C6 8C2206          5941         MOV.W   R2,[R2+6]
0029C9 866C42          5942         MOV.B   ES,R3L
0029CC 8A12            5943         MOV.W   R1,[R2]
0029CE D901            5944         ASL.W   R0,#01H
0029D0 8920            5945         MOV.W   R2,R0
0029D2 B930            5946         MOVS.W  R3,#00H
0029D4 8C5716          5947         MOV.W   R5,[R7+22]
0029D7 8C4714          5948         MOV.W   R4,[R7+20]
0029DA 86AC42          5949         MOV.B   ES,R5L
0029DD 0A24            5950         ADD.W   R2,[R4]
0029DF 1C3402          5951         ADDC.W  R3,[R4+2]
0029E2 866C42          5952         MOV.B   ES,R3L
0029E5 8A1A            5953         MOV.W   [R2],R1
                       5954 ; rtxc.c   2058                      break;
0029E7 FE2A            5955         BR      _256
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 106

ADDR   CODE            LINE SOURCELINE
0029E7 FE2A00          5955         BR      _256
                       5956 ; rtxc.c   2059 
                       5957 ; rtxc.c   2060                   case sizeof(long):
0029EA                 5958 _251:
                       5959 ; rtxc.c   2061                      *(long ks_queue *)(pqh->base + (qindex << 2)) =
                       5960 ; rtxc.c   2062                                *(long *)(((struct qarg ks_stk *)p2a)->data);
0029EA 866C42          5961         MOV.B   ES,R3L
0029ED 8C3208          5962         MOV.W   R3,[R2+8]
0029F0 8C2206          5963         MOV.W   R2,[R2+6]
0029F3 866C42          5964         MOV.B   ES,R3L
0029F6 8C3202          5965         MOV.W   R3,[R2+2]
0029F9 8A22            5966         MOV.W   R2,[R2]
0029FB D902            5967         ASL.W   R0,#02H
0029FD B910            5968         MOVS.W  R1,#00H
0029FF 8C5716          5969         MOV.W   R5,[R7+22]
002A02 8C4714          5970         MOV.W   R4,[R7+20]
002A05 86AC42          5971         MOV.B   ES,R5L
002A08 0A04            5972         ADD.W   R0,[R4]
002A0A 1C1402          5973         ADDC.W  R1,[R4+2]
002A0D 862C42          5974         MOV.B   ES,R1L
002A10 8A28            5975         MOV.W   [R0],R2
002A12 8C3802          5976         MOV.W   [R0+2],R3
                       5977 ; rtxc.c   2063                      break;
002A15 FE13            5978         BR      _256
002A15 FE1300          5978         BR      _256
                       5979 ; rtxc.c   2064 
                       5980 ; rtxc.c   2065                   default:
002A18                 5981 _252:
                       5982 ; rtxc.c   2066                      ks_memcpyFN(pqh->base + (qindex * width),
                       5983 ; rtxc.c   2067                            ((struct qarg ks_stk *)p2a)->data,
                       5984 ; rtxc.c   2068                            width);
002A18 E406            5985         MULU.W  R0,R6
002A1A 8940            5986         MOV.W   R4,R0
002A1C B950            5987         MOVS.W  R5,#00H
002A1E 8C1716          5988         MOV.W   R1,[R7+22]
002A21 8C0714          5989         MOV.W   R0,[R7+20]
002A24 862C42          5990         MOV.B   ES,R1L
002A27 0A40            5991         ADD.W   R4,[R0]
002A29 1C5002          5992         ADDC.W  R5,[R0+2]
002A2C 866C42          5993         MOV.B   ES,R3L
002A2F 8C3208          5994         MOV.W   R3,[R2+8]
002A32 8C2206          5995         MOV.W   R2,[R2+6]
002A35 8915            5996         MOV.W   R1,R5
002A37 8904            5997         MOV.W   R0,R4
002A39 C50EAD          5998         CALL    _ks_memcpyFN
002A39 C50EAD          5998         CALL    _ks_memcpyFN
                       5999 ; rtxc.c   2069                      break;
                       6000 ; rtxc.c   2070                }
002A3C                 6001 _256:
                       6002 ; rtxc.c   2071 #endif /* } QUEUE_MEMCPY */
                       6003 ; rtxc.c   2072 
                       6004 ; rtxc.c   2073 #ifdef CBUG /* { */
                       6005 ; rtxc.c   2074                pqh->count++; /* increment total no. of enqueues to date */
                       6006 ; rtxc.c   2075                if (pqh->curndx > pqh->worst) /* check for new worst case */
                       6007 ; rtxc.c   2076                   pqh->worst = pqh->curndx;
                       6008 ; rtxc.c   2077 #endif /* } CBUG */
                       6009 ; rtxc.c   2078 
                       6010 ; rtxc.c   2079 #ifdef QUEUE_SEMAS /* { */
                       6011 ; rtxc.c   2080                /* queue was empty - process not empty sema for consumer */
                       6012 ; rtxc.c   2081                if ( pqh->curndx == 1)
002A3C 8C170A          6013         MOV.W   R1,[R7+10]
002A3F 8C0708          6014         MOV.W   R0,[R7+8]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 107

ADDR   CODE            LINE SOURCELINE
002A42 862C42          6015         MOV.B   ES,R1L
002A45 9A040001        6016         CMP.W   [R0],#01H
002A49 F233            6017         BNE     _261
                       6018 ; rtxc.c   2082                {
                       6019 ; rtxc.c   2083                   UPDATE_SEMA(pqh->nesema);
002A4B 8C1704          6020         MOV.W   R1,[R7+4]
002A4E 8C0702          6021         MOV.W   R0,[R7+2]
002A51 862C42          6022         MOV.B   ES,R1L
002A54 8200            6023         MOV.B   R0L,[R0]
002A56 F32C            6024         BEQ     _261
002A58 B110            6025         MOVS.B  R0H,#00H
002A5A B910            6026         MOVS.W  R1,#00H
002A5C 9938rrrr        6027         MOV.W   R3,#SEG( _semat )
002A60 9928rrrr        6028         MOV.W   R2,#SOF( _semat )
002A64 0920            6029         ADD.W   R2,R0
002A66 964842rr        6030         MOV.B   ES,#SEG( _semat )
002A6A 8580rrrr        6031         MOV.B   R4L,[R0+SOF( _semat )]
002A6E 9184FF          6032         CMP.B   R4L,#0FFH
002A71 F206            6033         BNE     _257
002A73 964842rr        6034         MOV.B   ES,#SEG( _semat )
002A77 B500rrrr        6035         MOV.B   [R0+SOF( _semat )],#00H
002A7B FE1A            6036         BR      _261
002A7B FE1A00          6036         BR      _261
002A7E                 6037 _257:
002A7E 866C42          6038         MOV.B   ES,R3L
002A81 8202            6039         MOV.B   R0L,[R2]
002A83 F316            6040         BEQ     _261
002A85 860401          6041         MOV.B   R0L,0401H
002A88 9648018D        6042         MOV.B   0401H,#08DH
002A8C 8C3704          6043         MOV.W   R3,[R7+4]
002A8F 8C2702          6044         MOV.W   R2,[R7+2]
002A92 866C42          6045         MOV.B   ES,R3L
002A95 8212            6046         MOV.B   R0H,[R2]
002A97 9Er0rr0001      6047         ADD.W   _semaput,#01H
002A9C 8E3rrr          6048         MOV.W   R3,_semaput+2
002A9F 8E2rrr          6049         MOV.W   R2,_semaput
002AA2 866C42          6050         MOV.B   ES,R3L
002AA5 821A            6051         MOV.B   [R2],R0H
002AA7 8E3rrr          6052         MOV.W   _semaput+2,R3
002AAA 8E2rrr          6053         MOV.W   _semaput,R2
002AAD 860C01          6054         MOV.B   0401H,R0L
002AAD 860C01          6054         MOV.B   0401H,R0L
                       6055 ; rtxc.c   2084                }
002AB0                 6056 _261:
002AB0 8C1712          6057         MOV.W   R1,[R7+18]
002AB3 8C0710          6058         MOV.W   R0,[R7+16]
002AB6 862C42          6059         MOV.B   ES,R1L
002AB9 8C1002          6060         MOV.W   R1,[R0+2]
002ABC 8A00            6061         MOV.W   R0,[R0]
002ABE 8951            6062         MOV.W   R5,R1
002AC0 8940            6063         MOV.W   R4,R0
002AC2 6910            6064         OR.W    R1,R0
                       6065         BNE     _244
002AC4 F302           +6065 ;       BEQ     _LG_442
002AC6 D5FEF2         +6065 ;       JMP.L   _244
002AC6 D5FEF200       +6065 ;       JMP.L   _244
002ACA                +6065 _LG_442:
                       6066 ; rtxc.c   2085 
                       6067 ; rtxc.c   2086 #endif /* } QUEUE_SEMAS */
                       6068 ; rtxc.c   2087 
                       6069 ; rtxc.c   2088             } /* end of while */
                       6070 ; rtxc.c   2089 #endif /* } QUEUE_WAITERS */
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 108

ADDR   CODE            LINE SOURCELINE
                       6071 ; rtxc.c   2090 
                       6072 ; rtxc.c   2091          }
                       6073 ; rtxc.c   2092          break;
                       6074         BR      _428
002ACA D50291         +6074         JMP.L   _428
002ACA D5029100       +6074         JMP.L   _428
                       6075 ; rtxc.c   2093 #endif /* } HAS_PURGEQUEUE */
                       6076 ; rtxc.c   2094 
                       6077 ; rtxc.c   2095 /************************/
                       6078 ; rtxc.c   2096       case RTXC_EXECUTE:
002ACE                 6079 _262:
                       6080 ; rtxc.c   2097 /************************/
                       6081 ; rtxc.c   2098          ptcb = (TCB ks_tbl *)&rtxtcb[task = ((struct targ ks_stk *)p2)->task];
002ACE 86AC42          6082         MOV.B   ES,R5L
002AD1 840404          6083         MOV.B   R0L,[R4+4]
002AD4 9019            6084         SEXT.B  R0H
002AD6 E9000024        6085         MULU.W  R0,#024H
002ADA B910            6086         MOVS.W  R1,#00H
002ADC 9938rrrr        6087         MOV.W   R3,#SEG( _rtxtcb )
002AE0 9928rrrr        6088         MOV.W   R2,#SOF( _rtxtcb )
002AE4 0920            6089         ADD.W   R2,R0
                       6090 ; rtxc.c   2099 
                       6091 ; rtxc.c   2100          /* if task is already executing, then stop and restart */
                       6092 ; rtxc.c   2101          if (ptcb->status == READY)
002AE6 8953            6093         MOV.W   R5,R3
002AE8 8942            6094         MOV.W   R4,R2
002AEA 99400012        6095         ADD.W   R4,#012H
002AEE 8C5F12          6096         MOV.W   [R7+18],R5
002AF1 8C4F10          6097         MOV.W   [R7+16],R4
002AF4 8C3F16          6098         MOV.W   [R7+22],R3
002AF7 8C2F14          6099         MOV.W   [R7+20],R2
002AFA 866C42          6100         MOV.B   ES,R3L
002AFD 8C4212          6101         MOV.W   R4,[R2+18]
002B00 F224            6102         BNE     _263
                       6103 ; rtxc.c   2102          {
                       6104 ; rtxc.c   2103             ptcb->flink->blink = ptcb->blink; /* general unlink */
002B02 8C3716          6105         MOV.W   R3,[R7+22]
002B05 8C2714          6106         MOV.W   R2,[R7+20]
002B08 866C42          6107         MOV.B   ES,R3L
002B0B 8C4204          6108         MOV.W   R4,[R2+4]
002B0E 8C5206          6109         MOV.W   R5,[R2+6]
002B11 964842rr        6110         MOV.B   ES,#SEG( _rtxtcb )
002B15 8D20rrrr        6111         MOV.W   R2,[R0+SOF( _rtxtcb )]
002B19 8D30rrrr        6112         MOV.W   R3,[R0+SOF( _rtxtcb+2 )]
002B1D 866C42          6113         MOV.B   ES,R3L
002B20 8C4A04          6114         MOV.W   [R2+4],R4
002B23 8C5A06          6115         MOV.W   [R2+6],R5
                       6116 ; rtxc.c   2104             ptcb->blink->flink = ptcb->flink;
002B26 964842rr        6117         MOV.B   ES,#SEG( _rtxtcb )
002B2A 8D10rrrr        6118         MOV.W   R1,[R0+SOF( _rtxtcb+2 )]
002B2E 8D00rrrr        6119         MOV.W   R0,[R0+SOF( _rtxtcb )]
002B32 8C3716          6120         MOV.W   R3,[R7+22]
002B35 8C2714          6121         MOV.W   R2,[R7+20]
002B38 866C42          6122         MOV.B   ES,R3L
002B3B 8C3206          6123         MOV.W   R3,[R2+6]
002B3E 8C2204          6124         MOV.W   R2,[R2+4]
002B41 866C42          6125         MOV.B   ES,R3L
002B44 8A0A            6126         MOV.W   [R2],R0
002B46 8C1A02          6127         MOV.W   [R2+2],R1
002B46 8C1A0200        6127         MOV.W   [R2+2],R1
                       6128 ; rtxc.c   2105          }
002B4A                 6129 _263:
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 109

ADDR   CODE            LINE SOURCELINE
                       6130 ; rtxc.c   2106 
                       6131 ; rtxc.c   2107          /* initialize task stack pointer */
                       6132 ; rtxc.c   2108          frame = ptcb->sp = (FRAME ks_stk *)(ptcb->stackbase +
                       6133 ; rtxc.c   2109                                    ptcb->stacksize - sizeof(FRAME));
002B4A 8C1716          6134         MOV.W   R1,[R7+22]
002B4D 8C0714          6135         MOV.W   R0,[R7+20]
002B50 862C42          6136         MOV.B   ES,R1L
002B53 8C001C          6137         MOV.W   R0,[R0+28]
002B56 B910            6138         MOVS.W  R1,#00H
002B58 8C3716          6139         MOV.W   R3,[R7+22]
002B5B 8C2714          6140         MOV.W   R2,[R7+20]
002B5E 866C42          6141         MOV.B   ES,R3L
002B61 0C0218          6142         ADD.W   R0,[R2+24]
002B64 1C121A          6143         ADDC.W  R1,[R2+26]
002B67 99020018        6144         SUB.W   R0,#018H
002B6B 8951            6145         MOV.W   R5,R1
002B6D 8940            6146         MOV.W   R4,R0
002B6F 8C3716          6147         MOV.W   R3,[R7+22]
002B72 8C2714          6148         MOV.W   R2,[R7+20]
002B75 866C42          6149         MOV.B   ES,R3L
002B78 8C4A0E          6150         MOV.W   [R2+14],R4
002B7B 8C5A10          6151         MOV.W   [R2+16],R5
                       6152 ; rtxc.c   2110 
                       6153 ; rtxc.c   2111          frame->pc = ptcb->pc_t0; /* initialize program counter */
002B7E 866C42          6154         MOV.B   ES,R3L
002B81 8C4214          6155         MOV.W   R4,[R2+20]
002B84 8C5216          6156         MOV.W   R5,[R2+22]
002B87 862C42          6157         MOV.B   ES,R1L
002B8A 8C4814          6158         MOV.W   [R0+20],R4
002B8D 8C5816          6159         MOV.W   [R0+22],R5
                       6160 ; rtxc.c   2112 
                       6161 ; rtxc.c   2113          frame->psw = 0x8000; /* init status register at task startup */
002B90 862C42          6162         MOV.B   ES,R1L
002B93 9C08128000      6163         MOV.W   [R0+18],#08000H
                       6164 ; rtxc.c   2114 
                       6165 ; rtxc.c   2115 #if _MODEL == 'l'
                       6166 ; rtxc.c   2116          frame->ssel = 0x7f;
002B98 862C42          6167         MOV.B   ES,R1L
002B9B 9408027F        6168         MOV.B   [R0+2],#07FH
                       6169 ; rtxc.c   2117 #else
                       6170 ; rtxc.c   2118          frame->ssel = 0x00;
                       6171 ; rtxc.c   2119 #endif /* } _MODEL */
                       6172 ; rtxc.c   2120 
                       6173 ; rtxc.c   2121          frame->ds = 0x00;
002B9F 862C42          6174         MOV.B   ES,R1L
002BA2 B40003          6175         MOV.B   [R0+3],#00H
                       6176 ; rtxc.c   2122          frame->es = 0x00;
002BA5 862C42          6177         MOV.B   ES,R1L
002BA8 B200            6178         MOV.B   [R0],#00H
                       6179 ; rtxc.c   2123          frame->cs = 0x00;
002BAA 862C42          6180         MOV.B   ES,R1L
002BAD B40001          6181         MOV.B   [R0+1],#00H
                       6182 ; rtxc.c   2124 
                       6183 ; rtxc.c   2125 #ifdef TIME_SLICE /* { */
                       6184 ; rtxc.c   2126          ptcb->tslice = (TSLICE)0;
002BB0 8C1716          6185         MOV.W   R1,[R7+22]
002BB3 8C0714          6186         MOV.W   R0,[R7+20]
002BB6 862C42          6187         MOV.B   ES,R1L
002BB9 B4001E          6188         MOV.B   [R0+30],#00H
                       6189 ; rtxc.c   2127          ptcb->newslice = (TSLICE)0;
002BBC 8931            6190         MOV.W   R3,R1
002BBE 8920            6191         MOV.W   R2,R0
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 110

ADDR   CODE            LINE SOURCELINE
002BC0 866C42          6192         MOV.B   ES,R3L
002BC3 B4201F          6193         MOV.B   [R2+31],#00H
                       6194 ; rtxc.c   2128 #endif /* } TIME_SLICE */
                       6195 ; rtxc.c   2129 
                       6196 ; rtxc.c   2130 #ifdef SYNC_START /* { */
                       6197 ; rtxc.c   2131          if (hipritsk->task == 0)
                       6198 ; rtxc.c   2132             ptcb->status = BLOCK_WAIT; /* mark task blocked */
                       6199 ; rtxc.c   2133          else
                       6200 ; rtxc.c   2134             ptcb->status = READY; /* mark task runnable */
                       6201 ; rtxc.c   2135 #else /* } SYNC_START { */
                       6202 ; rtxc.c   2136          ptcb->status = READY; /* mark task runnable */
002BC6 8C1712          6203         MOV.W   R1,[R7+18]
002BC9 8C0710          6204         MOV.W   R0,[R7+16]
002BCC 862C42          6205         MOV.B   ES,R1L
002BCF BA00            6206         MOV.W   [R0],#00H
                       6207 ; rtxc.c   2137 #endif /* } SYNC_START */
                       6208 ; rtxc.c   2138 
                       6209 ; rtxc.c   2139 #ifdef FPU /* { */
                       6210 ; rtxc.c   2140           /* if fpregs area allocated */
                       6211 ; rtxc.c   2141          if ( (fpregs = rtxtcb[task].fpregs) != NULLFPREGS)
                       6212 ; rtxc.c   2142          {
                       6213 ; rtxc.c   2143                   /* init fpu to known state */
                       6214 ; rtxc.c   2144 
                       6215 ; rtxc.c   2145             /* processor dependent fpu initialization goes here */
                       6216 ; rtxc.c   2146                        /* fpregs->? = ?; */
                       6217 ; rtxc.c   2147 
                       6218 ; rtxc.c   2148             ptcb->fpumode = 1;         /* mark task as fpu user */
                       6219 ; rtxc.c   2149          }
                       6220 ; rtxc.c   2150 #ifdef BSS_NOT_ZERO /* { */
                       6221 ; rtxc.c   2151          else
                       6222 ; rtxc.c   2152          {
                       6223 ; rtxc.c   2153             ptcb->fpumode = 0;         /* mark task as non fpu user */
                       6224 ; rtxc.c   2154          }
                       6225 ; rtxc.c   2155 #endif /* } BSS_NOT_ZERO */
                       6226 ; rtxc.c   2156 #endif /* } FPU */
                       6227 ; rtxc.c   2157 
                       6228 ; rtxc.c   2158 #ifdef SYNC_START /* { */
                       6229 ; rtxc.c   2159          if (ptcb->status == READY)
                       6230 ; rtxc.c   2160          {
                       6231 ; rtxc.c   2161             /* insert new task into list for later */
                       6232 ; rtxc.c   2162             ptcb->flink = nsrttcb;
                       6233 ; rtxc.c   2163             nsrttcb = ptcb;
                       6234 ; rtxc.c   2164          }
                       6235 ; rtxc.c   2165 #else /* } SYNC_START { */
                       6236 ; rtxc.c   2166          /* insert new task into list for later */
                       6237 ; rtxc.c   2167          ptcb->flink = nsrttcb;
002BD1 8E1rrr          6238         MOV.W   R1,_nsrttcb+2
002BD4 8E0rrr          6239         MOV.W   R0,_nsrttcb
002BD7 8C3716          6240         MOV.W   R3,[R7+22]
002BDA 8C2714          6241         MOV.W   R2,[R7+20]
002BDD 866C42          6242         MOV.B   ES,R3L
002BE0 8A0A            6243         MOV.W   [R2],R0
002BE2 8C1A02          6244         MOV.W   [R2+2],R1
                       6245 ; rtxc.c   2168          nsrttcb = ptcb;
002BE5 8E3rrr          6246         MOV.W   _nsrttcb+2,R3
002BE8 8E2rrr          6247         MOV.W   _nsrttcb,R2
                       6248 ; rtxc.c   2169 #endif /* } SYNC_START */
                       6249 ; rtxc.c   2170 
                       6250 ; rtxc.c   2171          break;
                       6251         BR      _428
002BEB D50200         +6251         JMP.L   _428
002BEB D50200         +6251         JMP.L   _428
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 111

ADDR   CODE            LINE SOURCELINE
                       6252 ; rtxc.c   2172 
                       6253 ; rtxc.c   2173 #ifdef HAS_DEFTASK /* { */
                       6254 ; rtxc.c   2174 /************************/
                       6255 ; rtxc.c   2175       case RTXC_DEFTASK:
002BEE                 6256 _264:
                       6257 ; rtxc.c   2176 /************************/
                       6258 ; rtxc.c   2177          if ( (task = ((struct deftaskarg ks_stk *)p2)->task) == SELFTASK)
002BEE 8935            6259         MOV.W   R3,R5
002BF0 8924            6260         MOV.W   R2,R4
002BF2 866C42          6261         MOV.B   ES,R3L
002BF5 840204          6262         MOV.B   R0L,[R2+4]
002BF8 8110            6263         MOV.B   R0H,R0L
002BFA F206            6264         BNE     _265
                       6265 ; rtxc.c   2178          {
                       6266 ; rtxc.c   2179             ((struct deftaskarg ks_stk *)p2)->ksrc = RC_ILLEGAL_TASK;
002BFC 866C42          6267         MOV.B   ES,R3L
002BFF 9C2802000B      6268         MOV.W   [R2+2],#0BH
                       6269 ; rtxc.c   2180             break;
                       6270         BR      _428
002C04 D501F4         +6270         JMP.L   _428
002C04 D501F400       +6270         JMP.L   _428
                       6271 ; rtxc.c   2181          }
002C08                 6272 _265:
                       6273 ; rtxc.c   2182 
                       6274 ; rtxc.c   2183          ptcb = (TCB ks_tbl *)&rtxtcb[task];
002C08 8100            6275         MOV.B   R0L,R0L
002C0A 9019            6276         SEXT.B  R0H
002C0C E9000024        6277         MULU.W  R0,#024H
002C10 B910            6278         MOVS.W  R1,#00H
002C12 9958rrrr        6279         MOV.W   R5,#SEG( _rtxtcb )
002C16 9948rrrr        6280         MOV.W   R4,#SOF( _rtxtcb )
002C1A 0940            6281         ADD.W   R4,R0
                       6282 ; rtxc.c   2184 
                       6283 ; rtxc.c   2185          /* if task is "active", then abort deftask operation */
                       6284 ; rtxc.c   2186          if ( (ptcb->status & INACTIVE) != INACTIVE)
002C1C 86AC42          6285         MOV.B   ES,R5L
002C1F 8C0412          6286         MOV.W   R0,[R4+18]
002C22 99050100        6287         AND.W   R0,#0100H
002C26 99040100        6288         CMP.W   R0,#0100H
002C2A F306            6289         BEQ     _266
                       6290 ; rtxc.c   2187          {
                       6291 ; rtxc.c   2188             ((struct deftaskarg ks_stk *)p2)->ksrc = RC_ACTIVE_TASK;
002C2C 866C42          6292         MOV.B   ES,R3L
002C2F 9C2802000C      6293         MOV.W   [R2+2],#0CH
                       6294 ; rtxc.c   2189             break;
                       6295         BR      _428
002C34 D501DC         +6295         JMP.L   _428
002C34 D501DC00       +6295         JMP.L   _428
                       6296 ; rtxc.c   2190          }
002C38                 6297 _266:
                       6298 ; rtxc.c   2191 
                       6299 ; rtxc.c   2192          ptcb->priority =  ((struct deftaskarg ks_stk *)p2)->priority;
002C38 866C42          6300         MOV.B   ES,R3L
002C3B 840205          6301         MOV.B   R0L,[R2+5]
002C3E 86AC42          6302         MOV.B   ES,R5L
002C41 840C0D          6303         MOV.B   [R4+13],R0L
                       6304 ; rtxc.c   2193 
                       6305 ; rtxc.c   2194          if ( ((struct deftaskarg ks_stk *)p2)->stackbase) /* new stack */
002C44 866C42          6306         MOV.B   ES,R3L
002C47 8C0206          6307         MOV.W   R0,[R2+6]
002C4A 8C1208          6308         MOV.W   R1,[R2+8]
002C4D 8C1F16          6309         MOV.W   [R7+22],R1
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 112

ADDR   CODE            LINE SOURCELINE
002C50 8C0F14          6310         MOV.W   [R7+20],R0
002C53 6910            6311         OR.W    R1,R0
002C55 F30E            6312         BEQ     _267
                       6313 ; rtxc.c   2195          {
                       6314 ; rtxc.c   2196             ptcb->stackbase = ((struct deftaskarg ks_stk *)p2)->stackbase;
002C57 8C1716          6315         MOV.W   R1,[R7+22]
002C5A 8C0714          6316         MOV.W   R0,[R7+20]
002C5D 86AC42          6317         MOV.B   ES,R5L
002C60 8C0C18          6318         MOV.W   [R4+24],R0
002C63 8C1C1A          6319         MOV.W   [R4+26],R1
                       6320 ; rtxc.c   2197             ptcb->stacksize = ((struct deftaskarg ks_stk *)p2)->stacksize;
002C66 866C42          6321         MOV.B   ES,R3L
002C69 8C020A          6322         MOV.W   R0,[R2+10]
002C6C 86AC42          6323         MOV.B   ES,R5L
002C6F 8C0C1C          6324         MOV.W   [R4+28],R0
002C6F 8C0C1C          6324         MOV.W   [R4+28],R0
                       6325 ; rtxc.c   2198          }
002C72                 6326 _267:
                       6327 ; rtxc.c   2199 
                       6328 ; rtxc.c   2200 #if _MODEL == 'm' || _MODEL == 'l'
                       6329 ; rtxc.c   2201          pc1 = (unsigned long)((struct deftaskarg ks_stk *)p2)->entry;
002C72 866C42          6330         MOV.B   ES,R3L
002C75 8C020C          6331         MOV.W   R0,[R2+12]
002C78 8C120E          6332         MOV.W   R1,[R2+14]
                       6333 ; rtxc.c   2202          ptcb->pc_t0 = (void (*)(void))swap_pc_t0(pc1);
002C7B C5028A          6334         CALL    _swap_pc_t0
002C7E 86AC42          6335         MOV.B   ES,R5L
002C81 8C0C14          6336         MOV.W   [R4+20],R0
002C84 8C1C16          6337         MOV.W   [R4+22],R1
                       6338 ; rtxc.c   2203 #else
                       6339 ; rtxc.c   2204          ptcb->pc_t0 = ((struct deftaskarg ks_stk *)p2)->entry;
                       6340 ; rtxc.c   2205 #endif /* } _MODEL */
                       6341 ; rtxc.c   2206 
                       6342 ; rtxc.c   2207          ptcb->pclkblk = NULLCLK;
002C87 86AC42          6343         MOV.B   ES,R5L
002C8A BC4008          6344         MOV.W   [R4+8],#00H
002C8D BC400A          6345         MOV.W   [R4+10],#00H
                       6346 ; rtxc.c   2208 
                       6347 ; rtxc.c   2209 #ifdef HAS_INQTASK_ARG /* { */
                       6348 ; rtxc.c   2210          ptcb->arg = NULLARG;
002C90 86AC42          6349         MOV.B   ES,R5L
002C93 BC4020          6350         MOV.W   [R4+32],#00H
002C96 BC4022          6351         MOV.W   [R4+34],#00H
                       6352 ; rtxc.c   2211 #endif /* } HAS_INQTASK_ARG */
                       6353 ; rtxc.c   2212 
                       6354 ; rtxc.c   2213 #ifdef TIME_SLICE /* { */
                       6355 ; rtxc.c   2214          ptcb->tslice = (TSLICE)0;
002C99 86AC42          6356         MOV.B   ES,R5L
002C9C B4401E          6357         MOV.B   [R4+30],#00H
                       6358 ; rtxc.c   2215          ptcb->newslice = (TSLICE)0;
002C9F 86AC42          6359         MOV.B   ES,R5L
002CA2 B4401F          6360         MOV.B   [R4+31],#00H
                       6361 ; rtxc.c   2216 #endif /* } TIME_SLICE */
                       6362 ; rtxc.c   2217 
                       6363 ; rtxc.c   2218          break;
                       6364         BR      _428
002CA5 D501A3         +6364         JMP.L   _428
002CA5 D501A3         +6364         JMP.L   _428
                       6365 ; rtxc.c   2219 #endif /* } HAS_DEFTASK */
                       6366 ; rtxc.c   2220 
                       6367 ; rtxc.c   2221 #ifdef HAS_INQTASK_ARG /* { */
                       6368 ; rtxc.c   2222 /************************/
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 113

ADDR   CODE            LINE SOURCELINE
                       6369 ; rtxc.c   2223       case RTXC_INQTASK_ARG:
002CA8                 6370 _268:
                       6371 ; rtxc.c   2224 /************************/
                       6372 ; rtxc.c   2225          if ( (task = ((struct deftaskarg ks_stk *)p2)->task) == SELFTASK)
002CA8 86AC42          6373         MOV.B   ES,R5L
002CAB 840404          6374         MOV.B   R0L,[R4+4]
002CAE F206            6375         BNE     _269
                       6376 ; rtxc.c   2226             task = hipritsk->task;
002CB0 8E1rrr          6377         MOV.W   R1,_hipritsk+2
002CB3 8E0rrr          6378         MOV.W   R0,_hipritsk
002CB6 862C42          6379         MOV.B   ES,R1L
002CB9 84000C          6380         MOV.B   R0L,[R0+12]
002CB9 84000C          6380         MOV.B   R0L,[R0+12]
002CBC                 6381 _269:
                       6382 ; rtxc.c   2227          ((struct deftaskarg ks_stk *)p2)->arg = rtxtcb[task].arg;
002CBC 8100            6383         MOV.B   R0L,R0L
002CBE 9019            6384         SEXT.B  R0H
002CC0 E9000024        6385         MULU.W  R0,#024H
002CC4 B910            6386         MOVS.W  R1,#00H
002CC6 964842rr        6387         MOV.B   ES,#SEG( _rtxtcb+32 )
002CCA 8D10rrrr        6388         MOV.W   R1,[R0+SOF( _rtxtcb+34 )]
002CCE 8D00rrrr        6389         MOV.W   R0,[R0+SOF( _rtxtcb+32 )]
002CD2 86AC42          6390         MOV.B   ES,R5L
002CD5 8C0C10          6391         MOV.W   [R4+16],R0
002CD8 8C1C12          6392         MOV.W   [R4+18],R1
                       6393 ; rtxc.c   2228          break;
                       6394         BR      _428
002CDB D50188         +6394         JMP.L   _428
002CDB D50188         +6394         JMP.L   _428
                       6395 ; rtxc.c   2229 #endif /* } HAS_INQTASK_ARG */
                       6396 ; rtxc.c   2230 
                       6397 ; rtxc.c   2231 #ifdef HAS_DEFTASK_ARG /* { */
                       6398 ; rtxc.c   2232 /************************/
                       6399 ; rtxc.c   2233       case RTXC_DEFTASK_ARG:
002CDE                 6400 _270:
                       6401 ; rtxc.c   2234 /************************/
                       6402 ; rtxc.c   2235          if ( (task = ((struct deftaskarg ks_stk *)p2)->task) == SELFTASK)
002CDE 86AC42          6403         MOV.B   ES,R5L
002CE1 840404          6404         MOV.B   R0L,[R4+4]
002CE4 F206            6405         BNE     _271
                       6406 ; rtxc.c   2236             task = hipritsk->task;
002CE6 8E1rrr          6407         MOV.W   R1,_hipritsk+2
002CE9 8E0rrr          6408         MOV.W   R0,_hipritsk
002CEC 862C42          6409         MOV.B   ES,R1L
002CEF 84000C          6410         MOV.B   R0L,[R0+12]
002CEF 84000C          6410         MOV.B   R0L,[R0+12]
002CF2                 6411 _271:
                       6412 ; rtxc.c   2237          rtxtcb[task].arg = ((struct deftaskarg ks_stk *)p2)->arg;
002CF2 86AC42          6413         MOV.B   ES,R5L
002CF5 8C5412          6414         MOV.W   R5,[R4+18]
002CF8 8C4410          6415         MOV.W   R4,[R4+16]
002CFB 8100            6416         MOV.B   R0L,R0L
002CFD 9019            6417         SEXT.B  R0H
002CFF E9000024        6418         MULU.W  R0,#024H
002D03 B910            6419         MOVS.W  R1,#00H
002D05 964842rr        6420         MOV.B   ES,#SEG( _rtxtcb+32 )
002D09 8D48rrrr        6421         MOV.W   [R0+SOF( _rtxtcb+32 )],R4
002D0D 8D58rrrr        6422         MOV.W   [R0+SOF( _rtxtcb+34 )],R5
                       6423 ; rtxc.c   2238          break;
                       6424         BR      _428
002D11 D5016D         +6424         JMP.L   _428
002D11 D5016D         +6424         JMP.L   _428
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 114

ADDR   CODE            LINE SOURCELINE
                       6425 ; rtxc.c   2239 #endif /* } HAS_DEFTASK_ARG */
                       6426 ; rtxc.c   2240 
                       6427 ; rtxc.c   2241 #ifdef HAS_ALLOC_TASK /* { */
                       6428 ; rtxc.c   2242 /************************/
                       6429 ; rtxc.c   2243       case RTXC_ALLOC_TASK:
002D14                 6430 _272:
                       6431 ; rtxc.c   2244 /************************/
                       6432 ; rtxc.c   2245          if ( (ptcb = dtcbfl) != NULLTCB) /* allocate tcb */
002D14 964842rr        6433         MOV.B   ES,#SEG( _dtcbfl )
002D18 9918rrrr        6434         MOV.W   R1,#SOF( _dtcbfl )
002D1C 8B01            6435         MOV.W   R0,[R1+]
002D1E 8A11            6436         MOV.W   R1,[R1]
002D20 8931            6437         MOV.W   R3,R1
002D22 8920            6438         MOV.W   R2,R0
002D24 6932            6439         OR.W    R3,R2
002D26 F312            6440         BEQ     _273
                       6441 ; rtxc.c   2246          {
                       6442 ; rtxc.c   2247             dtcbfl = ptcb->flink; /* by removing 1st from free list */
002D28 862C42          6443         MOV.B   ES,R1L
002D2B 8A20            6444         MOV.W   R2,[R0]
002D2D 8C3002          6445         MOV.W   R3,[R0+2]
002D30 964842rr        6446         MOV.B   ES,#SEG( _dtcbfl )
002D34 9968rrrr        6447         MOV.W   R6,#SOF( _dtcbfl )
002D38 8B2E            6448         MOV.W   [R6+],R2
002D3A 8A3E            6449         MOV.W   [R6],R3
                       6450 ; rtxc.c   2248             ((struct targ ks_stk *)p2)->task = ptcb->task;
002D3C 862C42          6451         MOV.B   ES,R1L
002D3F 84000C          6452         MOV.B   R0L,[R0+12]
002D42 86AC42          6453         MOV.B   ES,R5L
002D45 840C04          6454         MOV.B   [R4+4],R0L
                       6455 ; rtxc.c   2249          }
                       6456         BR      _428
002D48 D50152         +6456         JMP.L   _428
002D48 D5015200       +6456         JMP.L   _428
002D4C                 6457 _273:
                       6458 ; rtxc.c   2250          else
                       6459 ; rtxc.c   2251             ((struct targ ks_stk *)p2)->task = (TASK)0;
002D4C 86AC42          6460         MOV.B   ES,R5L
002D4F B44004          6461         MOV.B   [R4+4],#00H
                       6462 ; rtxc.c   2252          break;
                       6463         BR      _428
002D52 D5014D         +6463         JMP.L   _428
002D52 D5014D00       +6463         JMP.L   _428
                       6464 ; rtxc.c   2253 #endif /* } HAS_ALLOC_TASK */
                       6465 ; rtxc.c   2254 
                       6466 ; rtxc.c   2255 #ifdef HAS_TERMINATE /* { */
                       6467 ; rtxc.c   2256 /************************/
                       6468 ; rtxc.c   2257       case RTXC_TERMINATE:
002D56                 6469 _274:
                       6470 ; rtxc.c   2258 /************************/
                       6471 ; rtxc.c   2259          if ( (task = ((struct targ ks_stk *)p2)->task) == SELFTASK)
002D56 8915            6472         MOV.W   R1,R5
002D58 8904            6473         MOV.W   R0,R4
002D5A 862C42          6474         MOV.B   ES,R1L
002D5D 840004          6475         MOV.B   R0L,[R0+4]
002D60 840F16          6476         MOV.B   [R7+22],R0L
002D63 6100            6477         OR.B    R0L,R0L
002D65 F20C            6478         BNE     _275
                       6479 ; rtxc.c   2260          {
                       6480 ; rtxc.c   2261             ptcb = hipritsk;
002D67 8E5rrr          6481         MOV.W   R5,_hipritsk+2
002D6A 8E4rrr          6482         MOV.W   R4,_hipritsk
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 115

ADDR   CODE            LINE SOURCELINE
                       6483 ; rtxc.c   2262             task = hipritsk->task;
002D6D 8E1rrr          6484         MOV.W   R1,_hipritsk+2
002D70 8E0rrr          6485         MOV.W   R0,_hipritsk
002D73 862C42          6486         MOV.B   ES,R1L
002D76 84000C          6487         MOV.B   R0L,[R0+12]
002D79 840F16          6488         MOV.B   [R7+22],R0L
                       6489 ; rtxc.c   2263          }
002D7C FE0B            6490         BR      _276
002D7C FE0B            6490         BR      _276
002D7E                 6491 _275:
                       6492 ; rtxc.c   2264          else
                       6493 ; rtxc.c   2265             ptcb = (TCB ks_tbl *)&rtxtcb[task];
002D7E 840716          6494         MOV.B   R0L,[R7+22]
002D81 9019            6495         SEXT.B  R0H
002D83 E9000024        6496         MULU.W  R0,#024H
002D87 B910            6497         MOVS.W  R1,#00H
002D89 9958rrrr        6498         MOV.W   R5,#SEG( _rtxtcb )
002D8D 9948rrrr        6499         MOV.W   R4,#SOF( _rtxtcb )
002D91 0940            6500         ADD.W   R4,R0
002D91 094000          6500         ADD.W   R4,R0
002D94                 6501 _276:
                       6502 ; rtxc.c   2266 
                       6503 ; rtxc.c   2267 #ifdef TIME_SLICE /* { */
                       6504 ; rtxc.c   2268          ptcb->tslice = (TSLICE)0;
002D94 86AC42          6505         MOV.B   ES,R5L
002D97 B4401E          6506         MOV.B   [R4+30],#00H
                       6507 ; rtxc.c   2269          ptcb->newslice = (TSLICE)0;
002D9A 86AC42          6508         MOV.B   ES,R5L
002D9D B4401F          6509         MOV.B   [R4+31],#00H
                       6510 ; rtxc.c   2270 #endif /* } TIME_SLICE */
                       6511 ; rtxc.c   2271 
                       6512 ; rtxc.c   2272          /* if task has a timeout timer */
                       6513 ; rtxc.c   2273          if ( (pclkblk = ptcb->pclkblk) != NULLCLK)
002DA0 8915            6514         MOV.W   R1,R5
002DA2 8904            6515         MOV.W   R0,R4
002DA4 99000008        6516         ADD.W   R0,#08H
002DA8 8C1F14          6517         MOV.W   [R7+20],R1
002DAB 8C0F12          6518         MOV.W   [R7+18],R0
002DAE 86AC42          6519         MOV.B   ES,R5L
002DB1 8C0408          6520         MOV.W   R0,[R4+8]
002DB4 8C140A          6521         MOV.W   R1,[R4+10]
002DB7 8931            6522         MOV.W   R3,R1
002DB9 8920            6523         MOV.W   R2,R0
002DBB 6932            6524         OR.W    R3,R2
002DBD F30E            6525         BEQ     _278
                       6526 ; rtxc.c   2274          {
                       6527 ; rtxc.c   2275             /* if timeout is still active */
                       6528 ; rtxc.c   2276             if (pclkblk->state == TIMER_ACTIVE)
002DBF 862C42          6529         MOV.B   ES,R1L
002DC2 94040D01        6530         CMP.B   [R0+13],#01H
002DC6 F202            6531         BNE     _277
                       6532 ; rtxc.c   2277             {
                       6533 ; rtxc.c   2278                unlink_timer(pclkblk);
002DC8 C509EC          6534         CALL    _unlink_timer
002DC8 C509EC00        6534         CALL    _unlink_timer
                       6535 ; rtxc.c   2279             }
002DCC                 6536 _277:
                       6537 ; rtxc.c   2280             ptcb->pclkblk = NULLCLK;
002DCC 8C1714          6538         MOV.W   R1,[R7+20]
002DCF 8C0712          6539         MOV.W   R0,[R7+18]
002DD2 862C42          6540         MOV.B   ES,R1L
002DD5 BA00            6541         MOV.W   [R0],#00H
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 116

ADDR   CODE            LINE SOURCELINE
002DD7 BC0002          6542         MOV.W   [R0+2],#00H
002DD7 BC0002          6542         MOV.W   [R0+2],#00H
                       6543 ; rtxc.c   2281          }
002DDA                 6544 _278:
                       6545 ; rtxc.c   2282 
                       6546 ; rtxc.c   2283          if (ptcb->status & SEMAPHORE_WAIT)
002DDA 8915            6547         MOV.W   R1,R5
002DDC 8904            6548         MOV.W   R0,R4
002DDE 99000012        6549         ADD.W   R0,#012H
002DE2 8C1F14          6550         MOV.W   [R7+20],R1
002DE5 8C0F12          6551         MOV.W   [R7+18],R0
002DE8 86AC42          6552         MOV.B   ES,R5L
002DEB 8C6412          6553         MOV.W   R6,[R4+18]
002DEE 99080040        6554         MOV.W   R0,#040H
002DF2 5906            6555         AND.W   R0,R6
002DF4 F332            6556         BEQ     _284
                       6557 ; rtxc.c   2284          {
                       6558 ; rtxc.c   2285             p2a = ptcb->sp->pksnum;
002DF6 86AC42          6559         MOV.B   ES,R5L
002DF9 8C040E          6560         MOV.W   R0,[R4+14]
002DFC 8C1410          6561         MOV.W   R1,[R4+16]
002DFF 862C42          6562         MOV.B   ES,R1L
002E02 8C1006          6563         MOV.W   R1,[R0+6]
002E05 8C0004          6564         MOV.W   R0,[R0+4]
                       6565 ; rtxc.c   2286 
                       6566 ; rtxc.c   2287             if ( (*p2a == RTXC_WAIT)
                       6567 ; rtxc.c   2288 #ifdef HAS_MAILBOXES /* { */
                       6568 ; rtxc.c   2289                                      || (*p2a == RTXC_SEND)
                       6569 ; rtxc.c   2290 #endif /* } HAS_MAILBOXES */
                       6570 ; rtxc.c   2291                                                             )
002E08 862C42          6571         MOV.B   ES,R1L
002E0B 920401          6572         CMP.B   [R0],#01H
002E0E F304            6573         BEQ     _279
002E10 862C42          6574         MOV.B   ES,R1L
002E13 920404          6575         CMP.B   [R0],#04H
002E16 F20B            6576         BNE     _280
002E16 F20B            6576         BNE     _280
002E18                 6577 _279:
                       6578 ; rtxc.c   2292             {
                       6579 ; rtxc.c   2293                sema = ((struct sarg ks_stk *)p2a)->sema;
002E18 862C42          6580         MOV.B   ES,R1L
002E1B 840004          6581         MOV.B   R0L,[R0+4]
                       6582 ; rtxc.c   2294                semat[sema] = SEMA_PENDING;
002E1E B110            6583         MOVS.B  R0H,#00H
002E20 B910            6584         MOVS.W  R1,#00H
002E22 964842rr        6585         MOV.B   ES,#SEG( _semat )
002E26 9508rrrrFF      6586         MOV.B   [R0+SOF( _semat )],#0FFH
                       6587 ; rtxc.c   2295             }
002E2B FE17            6588         BR      _284
002E2B FE1700          6588         BR      _284
002E2E                 6589 _280:
                       6590 ; rtxc.c   2296             else /* must be RTXC_WAITM - set all semas PENDing */
                       6591 ; rtxc.c   2297             {
                       6592 ; rtxc.c   2298                for (semalist = ((struct sargm ks_stk *)p2a)->list;
002E2E 862C42          6593         MOV.B   ES,R1L
002E31 8C1008          6594         MOV.W   R1,[R0+8]
002E34 8C0006          6595         MOV.W   R0,[R0+6]
002E37 8931            6596         MOV.W   R3,R1
002E39 8920            6597         MOV.W   R2,R0
002E3B 862C42          6598         MOV.B   ES,R1L
002E3E 8200            6599         MOV.B   R0L,[R0]
002E40 F30C            6600         BEQ     _284
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 117

ADDR   CODE            LINE SOURCELINE
002E40 F30C            6600         BEQ     _284
002E42                 6601 _281:
                       6602 ; rtxc.c   2299                   (sema = *semalist) != NULLSEMA; semalist++)
                       6603 ; rtxc.c   2300                {
                       6604 ; rtxc.c   2301                   semat[sema] = SEMA_PENDING;
002E42 B110            6605         MOVS.B  R0H,#00H
002E44 B910            6606         MOVS.W  R1,#00H
002E46 964842rr        6607         MOV.B   ES,#SEG( _semat )
002E4A 9508rrrrFF      6608         MOV.B   [R0+SOF( _semat )],#0FFH
002E4F 99200001        6609         ADD.W   R2,#01H
002E53 866C42          6610         MOV.B   ES,R3L
002E56 8202            6611         MOV.B   R0L,[R2]
002E58 F2F4            6612         BNE     _281
002E58 F2F4            6612         BNE     _281
                       6613 ; rtxc.c   2302                }
                       6614 ; rtxc.c   2303             }
                       6615 ; rtxc.c   2304          }
002E5A                 6616 _284:
                       6617 ; rtxc.c   2305 
                       6618 ; rtxc.c   2306          if ( (ptcb->status == READY)
                       6619 ; rtxc.c   2307 #if defined(MAILBOX_WAITERS)   || \ 
                       6620 ; rtxc.c   2308     defined(PARTITION_WAITERS) || \ 
                       6621 ; rtxc.c   2309     defined(RESOURCE_WAITERS)  || \ 
                       6622 ; rtxc.c   2310     defined(QUEUE_WAITERS) /* { */
                       6623 ; rtxc.c   2311            || (ptcb->status & COMBO_WAIT)
                       6624 ; rtxc.c   2312 #endif /* } - MAILBOX_ || PARTITION_ || QUEUE_ || RESOURCE_WAITERS */
                       6625 ; rtxc.c   2313                                       )
002E5A 6966            6626         OR.W    R6,R6
002E5C F303            6627         BEQ     _285
002E5E 996500AA        6628         AND.W   R6,#0AAH
002E62 F31C            6629         BEQ     _287
002E62 F31C            6629         BEQ     _287
002E64                 6630 _285:
                       6631 ; rtxc.c   2314          {
                       6632 ; rtxc.c   2315             /* unlink task from a WAITER or the READY list */
                       6633 ; rtxc.c   2316                   /* (all cases have same format) */
                       6634 ; rtxc.c   2317             if((ptcb->blink->flink = ptcb->flink) != NULLTCB)
002E64 86AC42          6635         MOV.B   ES,R5L
002E67 8A04            6636         MOV.W   R0,[R4]
002E69 8C1402          6637         MOV.W   R1,[R4+2]
002E6C 86AC42          6638         MOV.B   ES,R5L
002E6F 8C2404          6639         MOV.W   R2,[R4+4]
002E72 8C3406          6640         MOV.W   R3,[R4+6]
002E75 866C42          6641         MOV.B   ES,R3L
002E78 8A0A            6642         MOV.W   [R2],R0
002E7A 8C1A02          6643         MOV.W   [R2+2],R1
002E7D 6910            6644         OR.W    R1,R0
002E7F F30E            6645         BEQ     _287
                       6646 ; rtxc.c   2318                ptcb->flink->blink = ptcb->blink;
002E81 86AC42          6647         MOV.B   ES,R5L
002E84 8C0404          6648         MOV.W   R0,[R4+4]
002E87 8C1406          6649         MOV.W   R1,[R4+6]
002E8A 86AC42          6650         MOV.B   ES,R5L
002E8D 8A24            6651         MOV.W   R2,[R4]
002E8F 8C3402          6652         MOV.W   R3,[R4+2]
002E92 866C42          6653         MOV.B   ES,R3L
002E95 8C0A04          6654         MOV.W   [R2+4],R0
002E98 8C1A06          6655         MOV.W   [R2+6],R1
002E98 8C1A0600        6655         MOV.W   [R2+6],R1
                       6656 ; rtxc.c   2319          }
002E9C                 6657 _287:
                       6658 ; rtxc.c   2320 
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 118

ADDR   CODE            LINE SOURCELINE
                       6659 ; rtxc.c   2321          if (task <= ntasks)
002E9C 964842rr        6660         MOV.B   ES,#SEG( _ntasks )
002EA0 9908rrrr        6661         MOV.W   R0,#SOF( _ntasks )
002EA4 8200            6662         MOV.B   R0L,[R0]
002EA6 440F16          6663         CMP.B   [R7+22],R0L
002EA9 FC0E            6664         BGT     _288
                       6665 ; rtxc.c   2322             ptcb->priority = rtxktcb[task].priority; /* reset priority */
002EAB 840716          6666         MOV.B   R0L,[R7+22]
002EAE 9019            6667         SEXT.B  R0H
002EB0 E900000C        6668         MULU.W  R0,#0CH
002EB4 B910            6669         MOVS.W  R1,#00H
002EB6 964842rr        6670         MOV.B   ES,#SEG( _rtxktcb+10 )
002EBA 8500rrrr        6671         MOV.B   R0L,[R0+SOF( _rtxktcb+10 )]
002EBE 86AC42          6672         MOV.B   ES,R5L
002EC1 840C0D          6673         MOV.B   [R4+13],R0L
002EC4 FE14            6674         BR      _289
002EC4 FE14            6674         BR      _289
002EC6                 6675 _288:
                       6676 ; rtxc.c   2323 #ifdef DYNAMIC_TASKS /* { */
                       6677 ; rtxc.c   2324          else
                       6678 ; rtxc.c   2325          {
                       6679 ; rtxc.c   2326             ptcb->priority = NULLTASK_PRIORITY - 1; /* reset priority */
002EC6 86AC42          6680         MOV.B   ES,R5L
002EC9 94480D7E        6681         MOV.B   [R4+13],#07EH
                       6682 ; rtxc.c   2327 
                       6683 ; rtxc.c   2328             /* re-insert tcb into tcb free list for dynamic tasks */
                       6684 ; rtxc.c   2329                         /* unless already inactive */
                       6685 ; rtxc.c   2330 #if 0 /* NOT IMPLEMENTED - since no way to free a never started task */
                       6686 ; rtxc.c   2331             if ( (ptcb->status & INACTIVE) != INACTIVE)
                       6687 ; rtxc.c   2332 #endif
                       6688 ; rtxc.c   2333             {
                       6689 ; rtxc.c   2334                ptcb->flink = dtcbfl;
002ECD 964842rr        6690         MOV.B   ES,#SEG( _dtcbfl )
002ED1 9918rrrr        6691         MOV.W   R1,#SOF( _dtcbfl )
002ED5 8B01            6692         MOV.W   R0,[R1+]
002ED7 8A11            6693         MOV.W   R1,[R1]
002ED9 86AC42          6694         MOV.B   ES,R5L
002EDC 8A0C            6695         MOV.W   [R4],R0
002EDE 8C1C02          6696         MOV.W   [R4+2],R1
                       6697 ; rtxc.c   2335                dtcbfl = ptcb;
002EE1 964842rr        6698         MOV.B   ES,#SEG( _dtcbfl )
002EE5 9908rrrr        6699         MOV.W   R0,#SOF( _dtcbfl )
002EE9 8B48            6700         MOV.W   [R0+],R4
002EEB 8A58            6701         MOV.W   [R0],R5
002EEB 8A5800          6701         MOV.W   [R0],R5
                       6702 ; rtxc.c   2336             }
                       6703 ; rtxc.c   2337          }
002EEE                 6704 _289:
                       6705 ; rtxc.c   2338 #endif /* } DYNAMIC_TASKS */
                       6706 ; rtxc.c   2339 
                       6707 ; rtxc.c   2340 #ifdef FPU /* { */
                       6708 ; rtxc.c   2341          if ( (ptcb->fpumode == 1) && (ptcb == fputask) )
                       6709 ; rtxc.c   2342          {
                       6710 ; rtxc.c   2343             fputask = &rtxtcb[0]; /* release ownership of fpu */
                       6711 ; rtxc.c   2344          }
                       6712 ; rtxc.c   2345 #endif /* } FPU */
                       6713 ; rtxc.c   2346 
                       6714 ; rtxc.c   2347          ptcb->status = INACTIVE;
002EEE 8C1714          6715         MOV.W   R1,[R7+20]
002EF1 8C0712          6716         MOV.W   R0,[R7+18]
002EF4 862C42          6717         MOV.B   ES,R1L
002EF7 9A080100        6718         MOV.W   [R0],#0100H
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 119

ADDR   CODE            LINE SOURCELINE
                       6719 ; rtxc.c   2348 
                       6720 ; rtxc.c   2349          break;
002EFB FE79            6721         BR      _428
002EFB FE7900          6721         BR      _428
                       6722 ; rtxc.c   2350 #endif /* } HAS_TERMINATE */
                       6723 ; rtxc.c   2351 
                       6724 ; rtxc.c   2352 #ifdef HAS_YIELD /* { */
                       6725 ; rtxc.c   2353 /************************/
                       6726 ; rtxc.c   2354       case RTXC_YIELD:
002EFE                 6727 _290:
                       6728 ; rtxc.c   2355 /************************/
                       6729 ; rtxc.c   2356          /* yield is NOP unless next READY task at same priority */
                       6730 ; rtxc.c   2357          if (hipritsk->flink->priority != hipritsk->priority)
002EFE 8E1rrr          6731         MOV.W   R1,_hipritsk+2
002F01 8E0rrr          6732         MOV.W   R0,_hipritsk
002F04 862C42          6733         MOV.B   ES,R1L
002F07 8A20            6734         MOV.W   R2,[R0]
002F09 8C3002          6735         MOV.W   R3,[R0+2]
002F0C 862C42          6736         MOV.B   ES,R1L
002F0F 84C00D          6737         MOV.B   R6L,[R0+13]
002F12 866C42          6738         MOV.B   ES,R3L
002F15 44CA0D          6739         CMP.B   [R2+13],R6L
002F18 F26A            6740         BNE     _428
                       6741 ; rtxc.c   2358             break;
                       6742 ; rtxc.c   2359 
                       6743 ; rtxc.c   2360          ((struct targ ks_stk *)p2)->ksrc = RC_GOOD;
002F1A 86AC42          6744         MOV.B   ES,R5L
002F1D BC4002          6745         MOV.W   [R4+2],#00H
                       6746 ; rtxc.c   2361 
                       6747 ; rtxc.c   2362          ptcb = hipritsk; /* save */
                       6748 ; rtxc.c   2363 
                       6749 ; rtxc.c   2364 #ifdef TIME_SLICE /* { */
                       6750 ; rtxc.c   2365          ptcb->tslice = ptcb->newslice; /* reset time allotment */
002F20 862C42          6751         MOV.B   ES,R1L
002F23 84401F          6752         MOV.B   R2L,[R0+31]
002F26 862C42          6753         MOV.B   ES,R1L
002F29 84481E          6754         MOV.B   [R0+30],R2L
                       6755 ; rtxc.c   2366 #endif /* } TIME_SLICE */
                       6756 ; rtxc.c   2367 
                       6757 ; rtxc.c   2368          UNLINK_HIPRITSK(); /* unlink first tcb */
002F2C 862C42          6758         MOV.B   ES,R1L
002F2F 8A20            6759         MOV.W   R2,[R0]
002F31 8C3002          6760         MOV.W   R3,[R0+2]
002F34 8E3rrr          6761         MOV.W   _hipritsk+2,R3
002F37 8E2rrr          6762         MOV.W   _hipritsk,R2
002F3A 9948rrrr        6763         MOV.W   R4,#SOF( _hipritsk )
002F3E B950            6764         MOVS.W  R5,#00H
002F40 866C42          6765         MOV.B   ES,R3L
002F43 8C4A04          6766         MOV.W   [R2+4],R4
002F46 8C5A06          6767         MOV.W   [R2+6],R5
                       6768 ; rtxc.c   2369 
                       6769 ; rtxc.c   2370          /* re-insert task */
                       6770 ; rtxc.c   2371          ptcb->flink = nsrttcb;
002F49 8E3rrr          6771         MOV.W   R3,_nsrttcb+2
002F4C 8E2rrr          6772         MOV.W   R2,_nsrttcb
002F4F 862C42          6773         MOV.B   ES,R1L
002F52 8A28            6774         MOV.W   [R0],R2
002F54 8C3802          6775         MOV.W   [R0+2],R3
                       6776 ; rtxc.c   2372          nsrttcb = ptcb;
002F57 8E1rrr          6777         MOV.W   _nsrttcb+2,R1
002F5A 8E0rrr          6778         MOV.W   _nsrttcb,R0
                       6779 ; rtxc.c   2373 
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 120

ADDR   CODE            LINE SOURCELINE
                       6780 ; rtxc.c   2374          break;
002F5D FE48            6781         BR      _428
002F5D FE4800          6781         BR      _428
                       6782 ; rtxc.c   2375 #endif /* } HAS_YIELD */
                       6783 ; rtxc.c   2376 
                       6784 ; rtxc.c   2377 #ifdef HAS_DEFPRIORITY /* { */
                       6785 ; rtxc.c   2378 /************************/
                       6786 ; rtxc.c   2379       case RTXC_DEFPRIORITY:
002F60                 6787 _291:
                       6788 ; rtxc.c   2380 /************************/
                       6789 ; rtxc.c   2381          /* limit priority to reasonable value, else real low priority */
                       6790 ; rtxc.c   2382          if ( (((struct targ ks_stk *)p2)->priority < 1) ||
                       6791 ; rtxc.c   2383               (((struct targ ks_stk *)p2)->priority >= NULLTASK_PRIORITY) )
002F60 8935            6792         MOV.W   R3,R5
002F62 8924            6793         MOV.W   R2,R4
002F64 99200005        6794         ADD.W   R2,#05H
002F68 86AC42          6795         MOV.B   ES,R5L
002F6B 94440501        6796         CMP.B   [R4+5],#01H
002F6F FB05            6797         BLT     _292
002F71 86AC42          6798         MOV.B   ES,R5L
002F74 9444057F        6799         CMP.B   [R4+5],#07FH
002F78 FB03            6800         BLT     _293
002F78 FB03            6800         BLT     _293
002F7A                 6801 _292:
                       6802 ; rtxc.c   2384                  ((struct targ ks_stk *)p2)->priority = NULLTASK_PRIORITY - 1;
002F7A 866C42          6803         MOV.B   ES,R3L
002F7D 92287E          6804         MOV.B   [R2],#07EH
002F7D 92287E          6804         MOV.B   [R2],#07EH
002F80                 6805 _293:
                       6806 ; rtxc.c   2385 
                       6807 ; rtxc.c   2386          if ( (task = ((struct targ ks_stk *)p2)->task) == SELFTASK)
002F80 86AC42          6808         MOV.B   ES,R5L
002F83 840404          6809         MOV.B   R0L,[R4+4]
002F86 8110            6810         MOV.B   R0H,R0L
002F88 F204            6811         BNE     _294
                       6812 ; rtxc.c   2387             ptcb = hipritsk;
002F8A 8E1rrr          6813         MOV.W   R1,_hipritsk+2
002F8D 8E0rrr          6814         MOV.W   R0,_hipritsk
002F90 FE0B            6815         BR      _295
002F90 FE0B            6815         BR      _295
002F92                 6816 _294:
                       6817 ; rtxc.c   2388          else
                       6818 ; rtxc.c   2389             ptcb = (TCB ks_tbl *)&rtxtcb[task];
002F92 8100            6819         MOV.B   R0L,R0L
002F94 9019            6820         SEXT.B  R0H
002F96 E9000024        6821         MULU.W  R0,#024H
002F9A 8940            6822         MOV.W   R4,R0
002F9C B950            6823         MOVS.W  R5,#00H
002F9E 9918rrrr        6824         MOV.W   R1,#SEG( _rtxtcb )
002FA2 9908rrrr        6825         MOV.W   R0,#SOF( _rtxtcb )
002FA6 0904            6826         ADD.W   R0,R4
002FA6 0904            6826         ADD.W   R0,R4
002FA8                 6827 _295:
                       6828 ; rtxc.c   2390 
                       6829 ; rtxc.c   2391          chgpriority(ptcb, ((struct targ ks_stk *)p2)->priority);
002FA8 866C42          6830         MOV.B   ES,R3L
002FAB 8242            6831         MOV.B   R2L,[R2]
002FAD C50B15          6832         CALL    _chgpriority
                       6833 ; rtxc.c   2392          break;
002FB0 FE1E            6834         BR      _428
002FB0 FE1E            6834         BR      _428
                       6835 ; rtxc.c   2393 #endif /* } HAS_DEFPRIORITY */
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 121

ADDR   CODE            LINE SOURCELINE
                       6836 ; rtxc.c   2394 
                       6837 ; rtxc.c   2395 #ifdef HAS_USER /* { */
                       6838 ; rtxc.c   2396 /************************/
                       6839 ; rtxc.c   2397       case RTXC_USER:
002FB2                 6840 _296:
                       6841 ; rtxc.c   2398 /************************/
                       6842 ; rtxc.c   2399          /* call function passing &arg packet */
                       6843 ; rtxc.c   2400          ((struct userarg ks_stk *)p2)->val =
                       6844 ; rtxc.c   2401             (*((struct userarg ks_stk *)p2)->fun)
                       6845 ; rtxc.c   2402             (((struct userarg ks_stk *)p2)->arg);
002FB2 8915            6846         MOV.W   R1,R5
002FB4 8904            6847         MOV.W   R0,R4
002FB6 862C42          6848         MOV.B   ES,R1L
002FB9 8C4006          6849         MOV.W   R4,[R0+6]
002FBC 8C5008          6850         MOV.W   R5,[R0+8]
002FBF 8C1F16          6851         MOV.W   [R7+22],R1
002FC2 8C0F14          6852         MOV.W   [R7+20],R0
002FC5 862C42          6853         MOV.B   ES,R1L
002FC8 8C1004          6854         MOV.W   R1,[R0+4]
002FCB 8C0002          6855         MOV.W   R0,[R0+2]
002FCE C4rrrrrr        6856         FCALL   __ICALL
002FD2 8C3716          6857         MOV.W   R3,[R7+22]
002FD5 8C2714          6858         MOV.W   R2,[R7+20]
002FD8 866C42          6859         MOV.B   ES,R3L
002FDB 8C0A0A          6860         MOV.W   [R2+10],R0
                       6861 ; rtxc.c   2403          break;
002FDE FE07            6862         BR      _428
002FDE FE07            6862         BR      _428
002FE0                 6863 _297:
002FE0 8C571A          6864         MOV.W   R5,[R7+26]
002FE3 8C4718          6865         MOV.W   R4,[R7+24]
002FE6 86AC42          6866         MOV.B   ES,R5L
002FE9 9C4802000E      6867         MOV.W   [R4+2],#0EH
002FE9 9C4802000E      6867         MOV.W   [R4+2],#0EH
                       6868 ; rtxc.c   2404 #endif /* } HAS_USER */
                       6869 ; rtxc.c   2405 
                       6870 ; rtxc.c   2406 #ifdef HAS_NOP /* { */
                       6871 ; rtxc.c   2407 /************************/
                       6872 ; rtxc.c   2408       case RTXC_NOP:
                       6873 ; rtxc.c   2409 /************************/
                       6874 ; rtxc.c   2410          break;
                       6875 ; rtxc.c   2411 #endif /* } HAS_NOP */
                       6876 ; rtxc.c   2412 
                       6877 ; rtxc.c   2413 /************************/
                       6878 ; rtxc.c   2414       default:
                       6879 ; rtxc.c   2415 /************************/
                       6880 ; rtxc.c   2416          break;
                       6881 ; rtxc.c   2417    }
002FEE                 6882 _428:
                       6883 ; rtxc.c   2418 
                       6884 ; rtxc.c   2419 /* end if forcing the compiler to generate a JUMP TABLE - deterministic */
                       6885 ; rtxc.c   2420 #pragma endoptimize
                       6886 ; rtxc.c   2421 
                       6887 ; rtxc.c   2422    PUSHPSWH; /* save current processor priority level */
002FEE 860401          6888         MOV.B   R0L,0401H
                       6889 ; rtxc.c   2423    DISABLE;
002FF1 9648018D        6890         MOV.B   0401H,#08DH
                       6891 ; rtxc.c   2424    if ( (semaput == semaget) && (nsrttcb == NULLTCB) && (t_expired == 0) )
002FF5 8E3rrr          6892         MOV.W   R3,_semaput+2
002FF8 8E2rrr          6893         MOV.W   R2,_semaput
002FFB 4E3rrr          6894         CMP.W   R3,_semaget+2
002FFE F202            6895         BNE     _497
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 122

ADDR   CODE            LINE SOURCELINE
003000 4E2rrr          6896         CMP.W   R2,_semaget
003000 4E2rrr00        6896         CMP.W   R2,_semaget
003004                 6897 _497:
003004 F214            6898         BNE     _431
003006 8E3rrr          6899         MOV.W   R3,_nsrttcb+2
003009 8E2rrr          6900         MOV.W   R2,_nsrttcb
00300C 6932            6901         OR.W    R3,R2
00300E F20F            6902         BNE     _431
003010 964842rr        6903         MOV.B   ES,#SEG( _t_expired )
003014 9918rrrr        6904         MOV.W   R1,#SOF( _t_expired )
003018 8211            6905         MOV.B   R0H,[R1]
00301A F209            6906         BNE     _431
                       6907 ; rtxc.c   2425    {
                       6908 ; rtxc.c   2426 #ifdef FPU /* { */
                       6909 ; rtxc.c   2427         if ( (hipritsk->fpumode == 1) && (fputask != hipritsk) )
                       6910 ; rtxc.c   2428         {
                       6911 ; rtxc.c   2429              /* swap fpu regs */
                       6912 ; rtxc.c   2430              fpuswap(fputask->fpregs, hipritsk->fpregs);
                       6913 ; rtxc.c   2431              fputask = hipritsk; /* update new user of fpu */
                       6914 ; rtxc.c   2432         }
                       6915 ; rtxc.c   2433 #endif /* } FPU */
                       6916 ; rtxc.c   2434         return(hipritsk->sp);
00301C 8E1rrr          6917         MOV.W   R1,_hipritsk+2
00301F 8E0rrr          6918         MOV.W   R0,_hipritsk
003022 862C42          6919         MOV.B   ES,R1L
003025 8C1010          6920         MOV.W   R1,[R0+16]
003028 8C000E          6921         MOV.W   R0,[R0+14]
00302B FE04            6922         BR      _432
00302B FE0400          6922         BR      _432
                       6923 ; rtxc.c   2435    }
00302E                 6924 _431:
                       6925 ; rtxc.c   2436    else
                       6926 ; rtxc.c   2437    {
                       6927 ; rtxc.c   2438        POPPSWH;
00302E 860C01          6928         MOV.B   0401H,R0L
                       6929 ; rtxc.c   2439        return(postem());
003031 C5046F          6930         CALL    _postem
003031 C5046F          6930         CALL    _postem
                       6931 ; rtxc.c   2440    }
                       6932 ; rtxc.c   2441 }
003034                 6933 _432:
003034 99700020        6934         ADD.W   R7,#020H
003038 2F70            6935         POP.W   R4, R5, R6
00303A D680            6936         RET
00303A D680            6936         RET
                       6937 ; rtxc.c   2442 
                       6938 ; rtxc.c   2443 #ifdef HAS_MAILBOXES /* { */
                       6939 ; rtxc.c   2444 /* thread message into mailbox chain in priority as specified by sender */
                       6940 ; rtxc.c   2445 /************************/
                       6941 ; rtxc.c   2446 static void insert_message(MHEADER ks_tbl *pmh, RTXCMSG *prtxcmsg)
                       6942 ; rtxc.c   2447 /************************/
                       6943 ; rtxc.c   2448 {
00303C                 6944 _insert_message:
00303C 0F70            6945         PUSH.W  R4, R5, R6
00303E A978            6946         ADDS.W  R7,#08H
003040 8C3F06          6947         MOV.W   [R7+6],R3
003043 8C2F04          6948         MOV.W   [R7+4],R2
                       6949 ; rtxc.c   2449    RTXCMSG *prev, *next;
                       6950 ; rtxc.c   2450    PRIORITY priority;
                       6951 ; rtxc.c   2451 
                       6952 ; rtxc.c   2452    /* see if the degenerate case exists, i.e., the mailbox is empty */
                       6953 ; rtxc.c   2453    if ( (next = pmh->link) == NULL)
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 123

ADDR   CODE            LINE SOURCELINE
003046 862C42          6954         MOV.B   ES,R1L
003049 8A20            6955         MOV.W   R2,[R0]
00304B 8C3002          6956         MOV.W   R3,[R0+2]
00304E 8953            6957         MOV.W   R5,R3
003050 8942            6958         MOV.W   R4,R2
003052 6932            6959         OR.W    R3,R2
003054 F208            6960         BNE     _498
                       6961 ; rtxc.c   2454       pmh->link = prtxcmsg;
003056 8C3706          6962         MOV.W   R3,[R7+6]
003059 8C2704          6963         MOV.W   R2,[R7+4]
00305C 862C42          6964         MOV.B   ES,R1L
00305F 8A28            6965         MOV.W   [R0],R2
003061 8C3802          6966         MOV.W   [R0+2],R3
003064 FE30            6967         BR      _503
003064 FE30            6967         BR      _503
003066                 6968 _498:
                       6969 ; rtxc.c   2455    else /* mailbox is not empty, search for insertion point */
                       6970 ; rtxc.c   2456    {
                       6971 ; rtxc.c   2457       priority = prtxcmsg->priority;
003066 8C3706          6972         MOV.W   R3,[R7+6]
003069 8C2704          6973         MOV.W   R2,[R7+4]
00306C 866C42          6974         MOV.B   ES,R3L
00306F 84C205          6975         MOV.B   R6L,[R2+5]
                       6976 ; rtxc.c   2458 
                       6977 ; rtxc.c   2459       prev = (RTXCMSG *)pmh;
003072 8C1F02          6978         MOV.W   [R7+2],R1
003075 8A0F            6979         MOV.W   [R7],R0
                       6980 ; rtxc.c   2460 
                       6981 ; rtxc.c   2461       while ( ((next = prev->link) != NULL) && (next->priority <= priority) )
003077 862C42          6982         MOV.B   ES,R1L
00307A 8C1002          6983         MOV.W   R1,[R0+2]
00307D 8A00            6984         MOV.W   R0,[R0]
00307F 8951            6985         MOV.W   R5,R1
003081 8940            6986         MOV.W   R4,R0
003083 6910            6987         OR.W    R1,R0
003085 F316            6988         BEQ     _502
003087 86AC42          6989         MOV.B   ES,R5L
00308A 44CC05          6990         CMP.B   [R4+5],R6L
00308D FC12            6991         BGT     _502
00308D FC1200          6991         BGT     _502
003090                 6992 _499:
                       6993 ; rtxc.c   2462          prev = next;
003090 8C5F02          6994         MOV.W   [R7+2],R5
003093 8A4F            6995         MOV.W   [R7],R4
003095 86AC42          6996         MOV.B   ES,R5L
003098 8A04            6997         MOV.W   R0,[R4]
00309A 8C1402          6998         MOV.W   R1,[R4+2]
00309D 8931            6999         MOV.W   R3,R1
00309F 8920            7000         MOV.W   R2,R0
0030A1 8953            7001         MOV.W   R5,R3
0030A3 8942            7002         MOV.W   R4,R2
0030A5 6932            7003         OR.W    R3,R2
0030A7 F305            7004         BEQ     _502
0030A9 862C42          7005         MOV.B   ES,R1L
0030AC 44C805          7006         CMP.B   [R0+5],R6L
0030AF FDF0            7007         BLE     _499
0030AF FDF000          7007         BLE     _499
0030B2                 7008 _502:
                       7009 ; rtxc.c   2463 
                       7010 ; rtxc.c   2464       prev->link = prtxcmsg;
0030B2 8C3706          7011         MOV.W   R3,[R7+6]
0030B5 8C2704          7012         MOV.W   R2,[R7+4]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 124

ADDR   CODE            LINE SOURCELINE
0030B8 8C1702          7013         MOV.W   R1,[R7+2]
0030BB 8A07            7014         MOV.W   R0,[R7]
0030BD 862C42          7015         MOV.B   ES,R1L
0030C0 8A28            7016         MOV.W   [R0],R2
0030C2 8C3802          7017         MOV.W   [R0+2],R3
0030C2 8C380200        7017         MOV.W   [R0+2],R3
                       7018 ; rtxc.c   2465    }
0030C6                 7019 _503:
                       7020 ; rtxc.c   2466 
                       7021 ; rtxc.c   2467    prtxcmsg->link = next;
0030C6 8C3706          7022         MOV.W   R3,[R7+6]
0030C9 8C2704          7023         MOV.W   R2,[R7+4]
0030CC 866C42          7024         MOV.B   ES,R3L
0030CF 8A4A            7025         MOV.W   [R2],R4
0030D1 8C5A02          7026         MOV.W   [R2+2],R5
                       7027 ; rtxc.c   2468 }
0030D4 99700008        7028         ADD.W   R7,#08H
0030D8 2F70            7029         POP.W   R4, R5, R6
0030DA D680            7030         RET
0030DA D680            7030         RET
                       7031 ; rtxc.c   2469 
                       7032 ; rtxc.c   2470 /* remove message from task's mailbox */
                       7033 ; rtxc.c   2471 /************************/
                       7034 ; rtxc.c   2472 static RTXCMSG *remove_message(MHEADER ks_tbl *pmh, TASK task)
                       7035 ; rtxc.c   2473 /************************/
                       7036 ; rtxc.c   2474 {
0030DC                 7037 _remove_message:
0030DC 0F30            7038         PUSH.W  R4, R5
0030DE A978            7039         ADDS.W  R7,#08H
                       7040 ; rtxc.c   2475    RTXCMSG *lptr, *nptr;
                       7041 ; rtxc.c   2476 
                       7042 ; rtxc.c   2477    if ( (nptr = pmh->link) == NULL)
0030E0 8C1F06          7043         MOV.W   [R7+6],R1
0030E3 8C0F04          7044         MOV.W   [R7+4],R0
0030E6 862C42          7045         MOV.B   ES,R1L
0030E9 8C1002          7046         MOV.W   R1,[R0+2]
0030EC 8A00            7047         MOV.W   R0,[R0]
0030EE 8C1F02          7048         MOV.W   [R7+2],R1
0030F1 8A0F            7049         MOV.W   [R7],R0
0030F3 8951            7050         MOV.W   R5,R1
0030F5 8940            7051         MOV.W   R4,R0
0030F7 6910            7052         OR.W    R1,R0
0030F9 F204            7053         BNE     _506
                       7054 ; rtxc.c   2478       return(NULL);
0030FB B910            7055         MOV.W   R1,#00H
0030FD B900            7056         MOV.W   R0,#00H
0030FF FE45            7057         BR      _514
0030FF FE4500          7057         BR      _514
003102                 7058 _506:
                       7059 ; rtxc.c   2479 
                       7060 ; rtxc.c   2480    if ( (task == (TASK)0) || (nptr->task == task) )
003102 6144            7061         OR.B    R2L,R2L
003104 F307            7062         BEQ     _507
003106 8C1702          7063         MOV.W   R1,[R7+2]
003109 8A07            7064         MOV.W   R0,[R7]
00310B 862C42          7065         MOV.B   ES,R1L
00310E 444804          7066         CMP.B   [R0+4],R2L
003111 F212            7067         BNE     _508
003111 F21200          7067         BNE     _508
003114                 7068 _507:
                       7069 ; rtxc.c   2481    {
                       7070 ; rtxc.c   2482       pmh->link = nptr->link;
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 125

ADDR   CODE            LINE SOURCELINE
003114 8C1702          7071         MOV.W   R1,[R7+2]
003117 8A07            7072         MOV.W   R0,[R7]
003119 862C42          7073         MOV.B   ES,R1L
00311C 8C1002          7074         MOV.W   R1,[R0+2]
00311F 8A00            7075         MOV.W   R0,[R0]
003121 8C3706          7076         MOV.W   R3,[R7+6]
003124 8C2704          7077         MOV.W   R2,[R7+4]
003127 866C42          7078         MOV.B   ES,R3L
00312A 8A0A            7079         MOV.W   [R2],R0
00312C 8C1A02          7080         MOV.W   [R2+2],R1
                       7081 ; rtxc.c   2483       return(nptr);
00312F 8C1702          7082         MOV.W   R1,[R7+2]
003132 8A07            7083         MOV.W   R0,[R7]
003134 FE2A            7084         BR      _514
003134 FE2A            7084         BR      _514
                       7085 ; rtxc.c   2484    }
003136                 7086 _508:
                       7087 ; rtxc.c   2485 
                       7088 ; rtxc.c   2486    while (nptr->link != NULL)
003136 8C1702          7089         MOV.W   R1,[R7+2]
003139 8A07            7090         MOV.W   R0,[R7]
00313B 862C42          7091         MOV.B   ES,R1L
00313E 8C1002          7092         MOV.W   R1,[R0+2]
003141 8A00            7093         MOV.W   R0,[R0]
003143 6910            7094         OR.W    R1,R0
003145 F320            7095         BEQ     _511
003145 F32000          7095         BEQ     _511
003148                 7096 _509:
                       7097 ; rtxc.c   2487    {
                       7098 ; rtxc.c   2488       lptr = nptr;
                       7099 ; rtxc.c   2489       nptr = lptr->link;
003148 86AC42          7100         MOV.B   ES,R5L
00314B 8A04            7101         MOV.W   R0,[R4]
00314D 8C1402          7102         MOV.W   R1,[R4+2]
003150 8C5F06          7103         MOV.W   [R7+6],R5
003153 8C4F04          7104         MOV.W   [R7+4],R4
003156 8951            7105         MOV.W   R5,R1
003158 8940            7106         MOV.W   R4,R0
                       7107 ; rtxc.c   2490       if (nptr->task == task)
00315A 862C42          7108         MOV.B   ES,R1L
00315D 444804          7109         CMP.B   [R0+4],R2L
003160 F20C            7110         BNE     _510
                       7111 ; rtxc.c   2491       {
                       7112 ; rtxc.c   2492          lptr->link = nptr->link;
003162 862C42          7113         MOV.B   ES,R1L
003165 8A20            7114         MOV.W   R2,[R0]
003167 8C3002          7115         MOV.W   R3,[R0+2]
00316A 8C5706          7116         MOV.W   R5,[R7+6]
00316D 8C4704          7117         MOV.W   R4,[R7+4]
003170 86AC42          7118         MOV.B   ES,R5L
003173 8A2C            7119         MOV.W   [R4],R2
003175 8C3C02          7120         MOV.W   [R4+2],R3
                       7121 ; rtxc.c   2493          return(nptr);
003178 FE08            7122         BR      _514
003178 FE08            7122         BR      _514
                       7123 ; rtxc.c   2494       }
00317A                 7124 _510:
00317A 862C42          7125         MOV.B   ES,R1L
00317D 8C1002          7126         MOV.W   R1,[R0+2]
003180 8A00            7127         MOV.W   R0,[R0]
003182 6910            7128         OR.W    R1,R0
003184 F2E1            7129         BNE     _509
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 126

ADDR   CODE            LINE SOURCELINE
003184 F2E1            7129         BNE     _509
                       7130 ; rtxc.c   2495    }
003186                 7131 _511:
                       7132 ; rtxc.c   2496 
                       7133 ; rtxc.c   2497    return(NULL);
003186 B910            7134         MOV.W   R1,#00H
003188 B900            7135         MOV.W   R0,#00H
003188 B900            7135         MOV.W   R0,#00H
                       7136 ; rtxc.c   2498 }
00318A                 7137 _514:
00318A 99700008        7138         ADD.W   R7,#08H
00318E 2F30            7139         POP.W   R4, R5
003190 D680            7140         RET
003190 D680            7140         RET
                       7141 ; rtxc.c   2499 #endif /* } HAS_MAILBOXES */
                       7142 ; rtxc.c   2500 
                       7143 ; rtxc.c   2501 #if _MODEL == 'm' || _MODEL == 'l'
                       7144 ; rtxc.c   2502 unsigned long swap_pc_t0(unsigned long temppc)
                       7145 ; rtxc.c   2503 {
                       7146         PUBLIC  _swap_pc_t0
003192                 7147 _swap_pc_t0:
003192 0F30            7148         PUSH.W  R4, R5
                       7149 ; rtxc.c   2504     unsigned long low, high;
                       7150 ; rtxc.c   2505 
                       7151 ; rtxc.c   2506     low = temppc & 0x00ffff;         /* low to go high */
003194 8951            7152         MOV.W   R5,R1
003196 8940            7153         MOV.W   R4,R0
003198 99550000        7154         AND.W   R5,#00H
                       7155 ; rtxc.c   2507     high =  temppc & 0x0ffff0000;    /* high to go low */
00319C 99050000        7156         AND.W   R0,#00H
                       7157 ; rtxc.c   2508     temppc = (low << 16) + (high >> 16);
0031A0 DD50            7158         ASL.D   R4,#010H
0031A2 DC10            7159         LSR.D   R0,#010H
0031A4 8931            7160         MOV.W   R3,R1
0031A6 8920            7161         MOV.W   R2,R0
0031A8 8915            7162         MOV.W   R1,R5
0031AA 8904            7163         MOV.W   R0,R4
0031AC 0902            7164         ADD.W   R0,R2
0031AE 1913            7165         ADDC.W  R1,R3
                       7166 ; rtxc.c   2509     return(temppc);
                       7167 ; rtxc.c   2510 }
0031B0 2F30            7168         POP.W   R4, R5
0031B2 D680            7169         RET
0031B2 D680            7169         RET
                       7170 ; rtxc.c   2511 #endif /* } _MODEL */
                       7171 ; rtxc.c   2512 
                       7172 ; rtxc.c   2513 /* clear TCB critical info and initialize task status list */
                       7173 ; rtxc.c   2514 /************************/
                       7174 ; rtxc.c   2515 void taskinit(void)
                       7175 ; rtxc.c   2516 /************************/
                       7176 ; rtxc.c   2517 {
                       7177         PUBLIC  _taskinit
0031B4                 7178 _taskinit:
0031B4 0F70            7179         PUSH.W  R4, R5, R6
                       7180 ; rtxc.c   2518    register TASK i;
                       7181 ; rtxc.c   2519    register TCB ks_tbl *ptcb;
                       7182 ; rtxc.c   2520 
                       7183 ; rtxc.c   2521 #if _MODEL == 'm' || _MODEL == 'l'
                       7184 ; rtxc.c   2522    unsigned long pc1;
                       7185 ; rtxc.c   2523 #endif /* } _MODEL */
                       7186 ; rtxc.c   2524 
                       7187 ; rtxc.c   2525 #ifdef BSS_NOT_ZERO /* { */
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 127

ADDR   CODE            LINE SOURCELINE
                       7188 ; rtxc.c   2526 #ifdef CBUG /* { */
                       7189 ; rtxc.c   2527    cbugflag = 0;
                       7190 ; rtxc.c   2528 #endif /* } CBUG */
                       7191 ; rtxc.c   2529 #endif /* } BSS_NOT_ZERO */
                       7192 ; rtxc.c   2530 
                       7193 ; rtxc.c   2531 #ifdef FPU /* { */
                       7194 ; rtxc.c   2532    fputask =
                       7195 ; rtxc.c   2533 #endif /* } FPU */
                       7196 ; rtxc.c   2534    hipritsk = (TCB ks_tbl *)&rtxtcb[0];
0031B6 9Er8rrrrrr      7197         MOV.W   _hipritsk+2,#SEG( _rtxtcb )
0031BB 9Er8rrrrrr      7198         MOV.W   _hipritsk,#SOF( _rtxtcb )
                       7199 ; rtxc.c   2535 
                       7200 ; rtxc.c   2536    hipritsk->blink = (TCB ks_tbl *)&hipritsk;
0031C0 9908rrrr        7201         MOV.W   R0,#SOF( _hipritsk )
0031C4 B910            7202         MOVS.W  R1,#00H
0031C6 964842rr        7203         MOV.B   ES,#SEG( _rtxtcb+4 )
0031CA 9928rrrr        7204         MOV.W   R2,#SOF( _rtxtcb+4 )
0031CE 8B0A            7205         MOV.W   [R2+],R0
0031D0 8A1A            7206         MOV.W   [R2],R1
                       7207 ; rtxc.c   2537 
                       7208 ; rtxc.c   2538    hipritsk->priority = NULLTASK_PRIORITY;
0031D2 8E1rrr          7209         MOV.W   R1,_hipritsk+2
0031D5 8E0rrr          7210         MOV.W   R0,_hipritsk
0031D8 862C42          7211         MOV.B   ES,R1L
0031DB 94080D7F        7212         MOV.B   [R0+13],#07FH
                       7213 ; rtxc.c   2539 
                       7214 ; rtxc.c   2540 #ifdef BSS_NOT_ZERO /* { */
                       7215 ; rtxc.c   2541    hipritsk->task = 0;
0031DF 862C42          7216         MOV.B   ES,R1L
0031E2 B4000C          7217         MOV.B   [R0+12],#00H
                       7218 ; rtxc.c   2542    hipritsk->flink = NULLTCB;
0031E5 862C42          7219         MOV.B   ES,R1L
0031E8 BA00            7220         MOV.W   [R0],#00H
0031EA BC0002          7221         MOV.W   [R0+2],#00H
                       7222 ; rtxc.c   2543    hipritsk->status = READY; /* mark null task READY */
0031ED 8E1rrr          7223         MOV.W   R1,_hipritsk+2
0031F0 8E0rrr          7224         MOV.W   R0,_hipritsk
0031F3 862C42          7225         MOV.B   ES,R1L
0031F6 BC0012          7226         MOV.W   [R0+18],#00H
                       7227 ; rtxc.c   2544    nsrttcb = NULLTCB;
0031F9 BEr0rr          7228         MOV.W   _nsrttcb+2,#00H
0031FC BEr0rr          7229         MOV.W   _nsrttcb,#00H
                       7230 ; rtxc.c   2545 #ifdef FPU /* { */
                       7231 ; rtxc.c   2546    hipritsk->fpregs = NULLFPREGS;
                       7232 ; rtxc.c   2547    hipritsk->fpumode = 0;  /* all other tasks set in execute */
                       7233 ; rtxc.c   2548 #endif /* } FPU */
                       7234 ; rtxc.c   2549 #endif /* } BSS_NOT_ZERO */
                       7235 ; rtxc.c   2550 
                       7236 ; rtxc.c   2551    for (i = 1, ptcb = (TCB ks_tbl *)&rtxtcb[1]; i <= ntasks; i++, ptcb++)
0031FF 91C801          7237         MOV.B   R6L,#01H
003202 9958rrrr        7238         MOV.W   R5,#SEG( _rtxtcb+36 )
003206 9948rrrr        7239         MOV.W   R4,#SOF( _rtxtcb+36 )
00320A 964842rr        7240         MOV.B   ES,#SEG( _ntasks )
00320E 9908rrrr        7241         MOV.W   R0,#SOF( _ntasks )
003212 8200            7242         MOV.B   R0L,[R0]
003214 910401          7243         CMP.B   R0L,#01H
003217 FB51            7244         BLT     _518
003217 FB5100          7244         BLT     _518
00321A                 7245 _517:
                       7246 ; rtxc.c   2552    {
                       7247 ; rtxc.c   2553       ptcb->status = INACTIVE; /* mark each task inactive */
00321A 86AC42          7248         MOV.B   ES,R5L
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 128

ADDR   CODE            LINE SOURCELINE
00321D 9C48120100      7249         MOV.W   [R4+18],#0100H
                       7250 ; rtxc.c   2554       ptcb->task = i; /* set each task no. */
003222 86AC42          7251         MOV.B   ES,R5L
003225 84CC0C          7252         MOV.B   [R4+12],R6L
                       7253 ; rtxc.c   2555 
                       7254 ; rtxc.c   2556 #ifdef BSS_NOT_ZERO /* { */
                       7255 ; rtxc.c   2557       ptcb->pclkblk = NULLCLK;
003228 86AC42          7256         MOV.B   ES,R5L
00322B BC4008          7257         MOV.W   [R4+8],#00H
00322E BC400A          7258         MOV.W   [R4+10],#00H
                       7259 ; rtxc.c   2558 #endif /* } BSS_NOT_ZERO */
                       7260 ; rtxc.c   2559 
                       7261 ; rtxc.c   2560       ptcb->priority = rtxktcb[i].priority; /* initial priority */
003231 810C            7262         MOV.B   R0L,R6L
003233 9019            7263         SEXT.B  R0H
003235 E900000C        7264         MULU.W  R0,#0CH
003239 8920            7265         MOV.W   R2,R0
00323B B930            7266         MOVS.W  R3,#00H
00323D 964842rr        7267         MOV.B   ES,#SEG( _rtxktcb+10 )
003241 8522rrrr        7268         MOV.B   R1L,[R2+SOF( _rtxktcb+10 )]
003245 86AC42          7269         MOV.B   ES,R5L
003248 842C0D          7270         MOV.B   [R4+13],R1L
                       7271 ; rtxc.c   2561 
                       7272 ; rtxc.c   2562 #ifdef FPU /* { */
                       7273 ; rtxc.c   2563       ptcb->fpregs = rtxktcb[i].fpregs;
                       7274 ; rtxc.c   2564 #ifdef BSS_NOT_ZERO /* { */
                       7275 ; rtxc.c   2565       ptcb->fpumode = 0;
                       7276 ; rtxc.c   2566 #endif /* } BSS_NOT_ZERO */
                       7277 ; rtxc.c   2567 #endif /* } FPU */
                       7278 ; rtxc.c   2568 
                       7279 ; rtxc.c   2569 #ifdef TIME_SLICE /* { */
                       7280 ; rtxc.c   2570 #ifdef BSS_NOT_ZERO /* { */
                       7281 ; rtxc.c   2571       ptcb->tslice = (TSLICE)0;
00324B 86AC42          7282         MOV.B   ES,R5L
00324E B4401E          7283         MOV.B   [R4+30],#00H
                       7284 ; rtxc.c   2572       ptcb->newslice = (TSLICE)0;
003251 86AC42          7285         MOV.B   ES,R5L
003254 B4401F          7286         MOV.B   [R4+31],#00H
                       7287 ; rtxc.c   2573 #endif /* } BSS_NOT_ZERO */
                       7288 ; rtxc.c   2574 #endif /* } TIME_SLICE */
                       7289 ; rtxc.c   2575 
                       7290 ; rtxc.c   2576       /* copy stackbase, stacksize and entry point from KTCB to TCB */
                       7291 ; rtxc.c   2577       ptcb->stackbase = (char ks_stk *)rtxktcb[i].stackbase;
003257 8920            7292         MOV.W   R2,R0
003259 B930            7293         MOVS.W  R3,#00H
00325B 964842rr        7294         MOV.B   ES,#SEG( _rtxktcb+4 )
00325F 8D32rrrr        7295         MOV.W   R3,[R2+SOF( _rtxktcb+6 )]
003263 8D22rrrr        7296         MOV.W   R2,[R2+SOF( _rtxktcb+4 )]
003267 86AC42          7297         MOV.B   ES,R5L
00326A 8C2C18          7298         MOV.W   [R4+24],R2
00326D 8C3C1A          7299         MOV.W   [R4+26],R3
                       7300 ; rtxc.c   2578       ptcb->stacksize = rtxktcb[i].stacksize;
003270 8920            7301         MOV.W   R2,R0
003272 B930            7302         MOVS.W  R3,#00H
003274 964842rr        7303         MOV.B   ES,#SEG( _rtxktcb+8 )
003278 8D12rrrr        7304         MOV.W   R1,[R2+SOF( _rtxktcb+8 )]
00327C 86AC42          7305         MOV.B   ES,R5L
00327F 8C1C1C          7306         MOV.W   [R4+28],R1
                       7307 ; rtxc.c   2579 #ifdef CBUG
                       7308 ; rtxc.c   2580       stkinit((short ks_stk *)ptcb->stackbase, ptcb->stacksize);
                       7309 ; rtxc.c   2581 #endif /* } CBUG */
                       7310 ; rtxc.c   2582 
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 129

ADDR   CODE            LINE SOURCELINE
                       7311 ; rtxc.c   2583 #if _MODEL == 'm' || _MODEL == 'l'
                       7312 ; rtxc.c   2584       pc1 = (unsigned long)rtxktcb[i].pc_t0;
003282 B910            7313         MOVS.W  R1,#00H
003284 964842rr        7314         MOV.B   ES,#SEG( _rtxktcb )
003288 8D10rrrr        7315         MOV.W   R1,[R0+SOF( _rtxktcb+2 )]
00328C 8D00rrrr        7316         MOV.W   R0,[R0+SOF( _rtxktcb )]
                       7317 ; rtxc.c   2585       ptcb->pc_t0 = (void (*)(void))swap_pc_t0(pc1);
003290 C5FF80          7318         CALL    _swap_pc_t0
003293 86AC42          7319         MOV.B   ES,R5L
003296 8C0C14          7320         MOV.W   [R4+20],R0
003299 8C1C16          7321         MOV.W   [R4+22],R1
                       7322 ; rtxc.c   2586 #else
                       7323 ; rtxc.c   2587       ptcb->pc_t0 = rtxktcb[i].pc_t0;
                       7324 ; rtxc.c   2588 #endif /* } _MODEL */
                       7325 ; rtxc.c   2589 
                       7326 ; rtxc.c   2590 #ifdef HAS_INQTASK_ARG /* { */
                       7327 ; rtxc.c   2591 #ifdef BSS_NOT_ZERO /* { */
                       7328 ; rtxc.c   2592       ptcb->arg = NULLARG;
00329C 86AC42          7329         MOV.B   ES,R5L
00329F BC4020          7330         MOV.W   [R4+32],#00H
0032A2 BC4022          7331         MOV.W   [R4+34],#00H
0032A5 A1C1            7332         ADDS.B  R6L,#01H
0032A7 99400024        7333         ADD.W   R4,#024H
0032AB 964842rr        7334         MOV.B   ES,#SEG( _ntasks )
0032AF 9908rrrr        7335         MOV.W   R0,#SOF( _ntasks )
0032B3 8200            7336         MOV.B   R0L,[R0]
0032B5 41C0            7337         CMP.B   R6L,R0L
0032B7 FDB1            7338         BLE     _517
0032B7 FDB100          7338         BLE     _517
                       7339 ; rtxc.c   2593 #endif /* } BSS_NOT_ZERO */
                       7340 ; rtxc.c   2594 #endif /* } HAS_INQTASK_ARG */
                       7341 ; rtxc.c   2595    }
0032BA                 7342 _518:
                       7343 ; rtxc.c   2596 
                       7344 ; rtxc.c   2597 #ifdef DYNAMIC_TASKS /* { */
                       7345 ; rtxc.c   2598    /* thread dynamic task TCB free pool - possibly dntasks == 0 */
                       7346 ; rtxc.c   2599    if (dntasks)
0032BA 964842rr        7347         MOV.B   ES,#SEG( _dntasks )
0032BE 9908rrrr        7348         MOV.W   R0,#SOF( _dntasks )
0032C2 8250            7349         MOV.B   R2H,[R0]
0032C4 F315            7350         BEQ     _519
                       7351 ; rtxc.c   2600      dtcbfl = (TCB ks_tbl *)&rtxtcb[ntasks + 1];
0032C6 964842rr        7352         MOV.B   ES,#SEG( _ntasks )
0032CA 9908rrrr        7353         MOV.W   R0,#SOF( _ntasks )
0032CE 8200            7354         MOV.B   R0L,[R0]
0032D0 9019            7355         SEXT.B  R0H
0032D2 E9000024        7356         MULU.W  R0,#024H
0032D6 B910            7357         MOVS.W  R1,#00H
0032D8 9958rrrr        7358         MOV.W   R5,#SEG( _rtxtcb+36 )
0032DC 9948rrrr        7359         MOV.W   R4,#SOF( _rtxtcb+36 )
0032E0 0940            7360         ADD.W   R4,R0
0032E2 964842rr        7361         MOV.B   ES,#SEG( _dtcbfl )
0032E6 9908rrrr        7362         MOV.W   R0,#SOF( _dtcbfl )
0032EA 8B48            7363         MOV.W   [R0+],R4
0032EC 8A58            7364         MOV.W   [R0],R5
0032EE FE06            7365         BR      _520
0032EE FE06            7365         BR      _520
0032F0                 7366 _519:
                       7367 ; rtxc.c   2601    else
                       7368 ; rtxc.c   2602      dtcbfl = NULLTCB;
0032F0 964842rr        7369         MOV.B   ES,#SEG( _dtcbfl )
0032F4 9908rrrr        7370         MOV.W   R0,#SOF( _dtcbfl )
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 130

ADDR   CODE            LINE SOURCELINE
0032F8 BB00            7371         MOV.W   [R0+],#00H
0032FA BA00            7372         MOV.W   [R0],#00H
0032FA BA00            7372         MOV.W   [R0],#00H
0032FC                 7373 _520:
                       7374 ; rtxc.c   2603 
                       7375 ; rtxc.c   2604    for (i = 1, ptcb = dtcbfl; i <= dntasks; i++, ptcb++)
0032FC 914801          7376         MOV.B   R2L,#01H
0032FF 964842rr        7377         MOV.B   ES,#SEG( _dtcbfl )
003303 9918rrrr        7378         MOV.W   R1,#SOF( _dtcbfl )
003307 8B01            7379         MOV.W   R0,[R1+]
003309 8A11            7380         MOV.W   R1,[R1]
00330B 915401          7381         CMP.B   R2H,#01H
00330E FB32            7382         BLT     _522
00330E FB32            7382         BLT     _522
003310                 7383 _521:
                       7384 ; rtxc.c   2605    {
                       7385 ; rtxc.c   2606       ptcb->flink = ptcb + 1; /* insert tcb into linked list */
003310 8951            7386         MOV.W   R5,R1
003312 8940            7387         MOV.W   R4,R0
003314 99400024        7388         ADD.W   R4,#024H
003318 862C42          7389         MOV.B   ES,R1L
00331B 8A48            7390         MOV.W   [R0],R4
00331D 8C5802          7391         MOV.W   [R0+2],R5
                       7392 ; rtxc.c   2607 
                       7393 ; rtxc.c   2608       ptcb->status = INACTIVE; /* mark each task inactive */
003320 862C42          7394         MOV.B   ES,R1L
003323 9C08120100      7395         MOV.W   [R0+18],#0100H
                       7396 ; rtxc.c   2609       ptcb->task = ntasks + i; /* set each task no. */
003328 964842rr        7397         MOV.B   ES,#SEG( _ntasks )
00332C 9938rrrr        7398         MOV.W   R3,#SOF( _ntasks )
003330 8253            7399         MOV.B   R2H,[R3]
003332 0154            7400         ADD.B   R2H,R2L
003334 862C42          7401         MOV.B   ES,R1L
003337 84580C          7402         MOV.B   [R0+12],R2H
                       7403 ; rtxc.c   2610 
                       7404 ; rtxc.c   2611 #ifdef BSS_NOT_ZERO /* { */
                       7405 ; rtxc.c   2612       ptcb->pclkblk = NULLCLK;
00333A 862C42          7406         MOV.B   ES,R1L
00333D BC0008          7407         MOV.W   [R0+8],#00H
003340 BC000A          7408         MOV.W   [R0+10],#00H
                       7409 ; rtxc.c   2613 #endif /* } BSS_NOT_ZERO */
                       7410 ; rtxc.c   2614 
                       7411 ; rtxc.c   2615       ptcb->priority = NULLTASK_PRIORITY - 1; /* initial priority (low) */
003343 862C42          7412         MOV.B   ES,R1L
003346 94080D7E        7413         MOV.B   [R0+13],#07EH
                       7414 ; rtxc.c   2616 
                       7415 ; rtxc.c   2617 #ifdef FPU /* { */
                       7416 ; rtxc.c   2618 #ifdef BSS_NOT_ZERO /* { */
                       7417 ; rtxc.c   2619       ptcb->fpregs = NULLFPREGS;
                       7418 ; rtxc.c   2620       ptcb->fpumode = 0;
                       7419 ; rtxc.c   2621 #endif /* } BSS_NOT_ZERO */
                       7420 ; rtxc.c   2622 #endif /* } FPU */
                       7421 ; rtxc.c   2623 
                       7422 ; rtxc.c   2624 #ifdef TIME_SLICE /* { */
                       7423 ; rtxc.c   2625 #ifdef BSS_NOT_ZERO /* { */
                       7424 ; rtxc.c   2626       ptcb->tslice = (TSLICE)0;
00334A 862C42          7425         MOV.B   ES,R1L
00334D B4001E          7426         MOV.B   [R0+30],#00H
                       7427 ; rtxc.c   2627       ptcb->newslice = (TSLICE)0;
003350 862C42          7428         MOV.B   ES,R1L
003353 B4001F          7429         MOV.B   [R0+31],#00H
                       7430 ; rtxc.c   2628 #endif /* } BSS_NOT_ZERO */
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 131

ADDR   CODE            LINE SOURCELINE
                       7431 ; rtxc.c   2629 #endif /* } TIME_SLICE */
                       7432 ; rtxc.c   2630 
                       7433 ; rtxc.c   2631 #ifdef HAS_INQTASK_ARG /* { */
                       7434 ; rtxc.c   2632 #ifdef BSS_NOT_ZERO /* { */
                       7435 ; rtxc.c   2633       ptcb->arg = NULLARG;
003356 862C42          7436         MOV.B   ES,R1L
003359 BC0020          7437         MOV.W   [R0+32],#00H
00335C BC0022          7438         MOV.W   [R0+34],#00H
00335F A141            7439         ADDS.B  R2L,#01H
003361 8915            7440         MOV.W   R1,R5
003363 8904            7441         MOV.W   R0,R4
003365 964842rr        7442         MOV.B   ES,#SEG( _dntasks )
003369 9938rrrr        7443         MOV.W   R3,#SOF( _dntasks )
00336D 8253            7444         MOV.B   R2H,[R3]
00336F 4145            7445         CMP.B   R2L,R2H
003371 FDCF            7446         BLE     _521
003371 FDCF00          7446         BLE     _521
                       7447 ; rtxc.c   2634 #endif /* } BSS_NOT_ZERO */
                       7448 ; rtxc.c   2635 #endif /* } HAS_INQTASK_ARG */
                       7449 ; rtxc.c   2636    }
003374                 7450 _522:
                       7451 ; rtxc.c   2637 
                       7452 ; rtxc.c   2638    if (dntasks)
003374 964842rr        7453         MOV.B   ES,#SEG( _dntasks )
003378 9928rrrr        7454         MOV.W   R2,#SOF( _dntasks )
00337C 8242            7455         MOV.B   R2L,[R2]
00337E F306            7456         BEQ     _523
                       7457 ; rtxc.c   2639    {
                       7458 ; rtxc.c   2640       --ptcb;
003380 99020024        7459         SUB.W   R0,#024H
                       7460 ; rtxc.c   2641       ptcb->flink = NULLTCB; /* null last link */
003384 862C42          7461         MOV.B   ES,R1L
003387 BA00            7462         MOV.W   [R0],#00H
003389 BC0002          7463         MOV.W   [R0+2],#00H
003389 BC0002          7463         MOV.W   [R0+2],#00H
                       7464 ; rtxc.c   2642    }
00338C                 7465 _523:
                       7466 ; rtxc.c   2643 #endif /* } DYNAMIC_TASKS */
                       7467 ; rtxc.c   2644 
                       7468 ; rtxc.c   2645 #ifdef CBUG
                       7469 ; rtxc.c   2646    stkinit((short ks_stk *)&rtxctos[0], RTXCSTKSZ); /* init kernel stack */
                       7470 ; rtxc.c   2647 #endif /* } CBUG */
                       7471 ; rtxc.c   2648 
                       7472 ; rtxc.c   2649 #ifdef BSS_NOT_ZERO /* { */
                       7473 ; rtxc.c   2650    isrcnt = 0;
00338C B6r0rr          7474         MOV.B   _isrcnt,#00H
                       7475 ; rtxc.c   2651 #ifdef CBUG /* { */
                       7476 ; rtxc.c   2652    isrmax = 0;
                       7477 ; rtxc.c   2653 #endif /* } CBUG */
                       7478 ; rtxc.c   2654 
                       7479 ; rtxc.c   2655 #endif /* } BSS_NOT_ZERO */
                       7480 ; rtxc.c   2656 
                       7481 ; rtxc.c   2657 }
00338F 2F70            7482         POP.W   R4, R5, R6
003391 D680            7483         RET
003391 D68000          7483         RET
                       7484 ; rtxc.c   2658 
                       7485 ; rtxc.c   2659 #ifdef HAS_RESOURCES /* { */
                       7486 ; rtxc.c   2660 /* startup - initialize resource structures */
                       7487 ; rtxc.c   2661 /************************/
                       7488 ; rtxc.c   2662 void resinit(void)
                       7489 ; rtxc.c   2663 /************************/
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 132

ADDR   CODE            LINE SOURCELINE
                       7490 ; rtxc.c   2664 {
                       7491         PUBLIC  _resinit
003394                 7492 _resinit:
                       7493 ; rtxc.c   2665    register RESOURCE i;
                       7494 ; rtxc.c   2666    register RHEADER ks_tbl *prh;
                       7495 ; rtxc.c   2667 
                       7496 ; rtxc.c   2668    for (i = 1, prh = (RHEADER ks_tbl *)&rheader[1]; i <= nres; i++, prh++)
003394 914801          7497         MOV.B   R2L,#01H
003397 9918rrrr        7498         MOV.W   R1,#SEG( _rheader+18 )
00339B 9908rrrr        7499         MOV.W   R0,#SOF( _rheader+18 )
00339F 964842rr        7500         MOV.B   ES,#SEG( _nres )
0033A3 9938rrrr        7501         MOV.W   R3,#SOF( _nres )
0033A7 8253            7502         MOV.B   R2H,[R3]
0033A9 915401          7503         CMP.B   R2H,#01H
0033AC F120            7504         BCS     _529
0033AC F120            7504         BCS     _529
0033AE                 7505 _528:
                       7506 ; rtxc.c   2669    {
                       7507 ; rtxc.c   2670 #ifdef BSS_NOT_ZERO /* { */
                       7508 ; rtxc.c   2671       prh->owner = NULLTCB;
0033AE 862C42          7509         MOV.B   ES,R1L
0033B1 BA00            7510         MOV.W   [R0],#00H
0033B3 BC0002          7511         MOV.W   [R0+2],#00H
                       7512 ; rtxc.c   2672 
                       7513 ; rtxc.c   2673 #ifdef RESOURCE_WAITERS /* { */
                       7514 ; rtxc.c   2674       prh->waiters = NULLTCB;
0033B6 862C42          7515         MOV.B   ES,R1L
0033B9 BC0006          7516         MOV.W   [R0+6],#00H
0033BC BC0008          7517         MOV.W   [R0+8],#00H
                       7518 ; rtxc.c   2675       prh->dummy = NULLTCB;
0033BF 862C42          7519         MOV.B   ES,R1L
0033C2 BC000A          7520         MOV.W   [R0+10],#00H
0033C5 BC000C          7521         MOV.W   [R0+12],#00H
                       7522 ; rtxc.c   2676 #ifdef PRIORITY_INVERSION /* { */
                       7523 ; rtxc.c   2677       prh->priority = 0;
0033C8 862C42          7524         MOV.B   ES,R1L
0033CB B4000E          7525         MOV.B   [R0+14],#00H
                       7526 ; rtxc.c   2678 #endif /* } PRIORITY_INVERSION */
                       7527 ; rtxc.c   2679 #endif /* } RESOURCE_WAITERS */
                       7528 ; rtxc.c   2680 
                       7529 ; rtxc.c   2681       prh->level = 0;
0033CE 862C42          7530         MOV.B   ES,R1L
0033D1 B40004          7531         MOV.B   [R0+4],#00H
                       7532 ; rtxc.c   2682 
                       7533 ; rtxc.c   2683 #ifdef CBUG /* { */
                       7534 ; rtxc.c   2684       prh->count = 0;
                       7535 ; rtxc.c   2685       prh->conflict = 0;
                       7536 ; rtxc.c   2686 #endif /* } CBUG */
                       7537 ; rtxc.c   2687 #endif /* } BSS_NOT_ZERO */
                       7538 ; rtxc.c   2688 
                       7539 ; rtxc.c   2689 #ifdef PRIORITY_INVERSION /* { */
                       7540 ; rtxc.c   2690       prh->resattr = PRIORITY_INVERSION_T0;
0033D4 862C42          7541         MOV.B   ES,R1L
0033D7 BC0010          7542         MOV.W   [R0+16],#00H
0033DA A141            7543         ADDS.B  R2L,#01H
0033DC 99000012        7544         ADD.W   R0,#012H
0033E0 964842rr        7545         MOV.B   ES,#SEG( _nres )
0033E4 9938rrrr        7546         MOV.W   R3,#SOF( _nres )
0033E8 8253            7547         MOV.B   R2H,[R3]
0033EA 4145            7548         CMP.B   R2L,R2H
0033EC F9E0            7549         BL      _528
0033EC F9E0            7549         BL      _528
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 133

ADDR   CODE            LINE SOURCELINE
                       7550 ; rtxc.c   2691 #endif /* } PRIORITY_INVERSION */
                       7551 ; rtxc.c   2692    }
0033EE                 7552 _529:
                       7553 ; rtxc.c   2693 }
0033EE D680            7554         RET
0033EE D680            7554         RET
                       7555 ; rtxc.c   2694 #endif /* } HAS_RESOURCES */
                       7556 ; rtxc.c   2695 
                       7557 ; rtxc.c   2696 #ifdef HAS_MAILBOXES /* { */
                       7558 ; rtxc.c   2697 /* startup - initialize mailbox structures */
                       7559 ; rtxc.c   2698 /************************/
                       7560 ; rtxc.c   2699 void mboxinit(void)
                       7561 ; rtxc.c   2700 /************************/
                       7562 ; rtxc.c   2701 {
                       7563         PUBLIC  _mboxinit
0033F0                 7564 _mboxinit:
                       7565 ; rtxc.c   2702 #ifdef BSS_NOT_ZERO /* { */
                       7566 ; rtxc.c   2703    register MBOX i;
                       7567 ; rtxc.c   2704    register MHEADER ks_tbl *pmh;
                       7568 ; rtxc.c   2705 
                       7569 ; rtxc.c   2706    for (i = 1, pmh = (MHEADER ks_tbl *)&mheader[1]; i <= nmboxes; i++, pmh++)
0033F0 914801          7570         MOV.B   R2L,#01H
0033F3 9918rrrr        7571         MOV.W   R1,#SEG( _mheader+14 )
0033F7 9908rrrr        7572         MOV.W   R0,#SOF( _mheader+14 )
0033FB 964842rr        7573         MOV.B   ES,#SEG( _nmboxes )
0033FF 9938rrrr        7574         MOV.W   R3,#SOF( _nmboxes )
003403 8253            7575         MOV.B   R2H,[R3]
003405 915401          7576         CMP.B   R2H,#01H
003408 F11A            7577         BCS     _533
003408 F11A            7577         BCS     _533
00340A                 7578 _532:
                       7579 ; rtxc.c   2707    {
                       7580 ; rtxc.c   2708       pmh->link = NULL;
00340A 862C42          7581         MOV.B   ES,R1L
00340D BA00            7582         MOV.W   [R0],#00H
00340F BC0002          7583         MOV.W   [R0+2],#00H
                       7584 ; rtxc.c   2709 
                       7585 ; rtxc.c   2710 #ifdef MAILBOX_WAITERS /* { */
                       7586 ; rtxc.c   2711       pmh->waiters = NULLTCB;
003412 862C42          7587         MOV.B   ES,R1L
003415 BC0004          7588         MOV.W   [R0+4],#00H
003418 BC0006          7589         MOV.W   [R0+6],#00H
                       7590 ; rtxc.c   2712       pmh->dummy = NULLTCB;
00341B 862C42          7591         MOV.B   ES,R1L
00341E BC0008          7592         MOV.W   [R0+8],#00H
003421 BC000A          7593         MOV.W   [R0+10],#00H
                       7594 ; rtxc.c   2713 #endif /* } MAILBOX_WAITERS */
                       7595 ; rtxc.c   2714 
                       7596 ; rtxc.c   2715 #ifdef MAILBOX_SEMAS /* { */
                       7597 ; rtxc.c   2716       pmh->nesema = 0;
003424 862C42          7598         MOV.B   ES,R1L
003427 B4000C          7599         MOV.B   [R0+12],#00H
00342A A141            7600         ADDS.B  R2L,#01H
00342C 9900000E        7601         ADD.W   R0,#0EH
003430 964842rr        7602         MOV.B   ES,#SEG( _nmboxes )
003434 9938rrrr        7603         MOV.W   R3,#SOF( _nmboxes )
003438 8253            7604         MOV.B   R2H,[R3]
00343A 4145            7605         CMP.B   R2L,R2H
00343C F9E6            7606         BL      _532
00343C F9E6            7606         BL      _532
                       7607 ; rtxc.c   2717 #endif /* } MAILBOX_SEMAS */
                       7608 ; rtxc.c   2718 
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 134

ADDR   CODE            LINE SOURCELINE
                       7609 ; rtxc.c   2719 #ifdef CBUG /* { */
                       7610 ; rtxc.c   2720       pmh->count = 0;
                       7611 ; rtxc.c   2721 #endif /* } CBUG */
                       7612 ; rtxc.c   2722    }
00343E                 7613 _533:
                       7614 ; rtxc.c   2723 #endif /* } BSS_NOT_ZERO */
                       7615 ; rtxc.c   2724 }
00343E D680            7616         RET
00343E D680            7616         RET
                       7617 ; rtxc.c   2725 #endif /* } HAS_MAILBOXES */
                       7618 ; rtxc.c   2726 
                       7619 ; rtxc.c   2727 #ifdef HAS_PARTITIONS /* { */
                       7620 ; rtxc.c   2728 /* startup partition linking logic */
                       7621 ; rtxc.c   2729 /************************/
                       7622 ; rtxc.c   2730 void partinit(void)
                       7623 ; rtxc.c   2731 /************************/
                       7624 ; rtxc.c   2732 {
                       7625         PUBLIC  _partinit
003440                 7626 _partinit:
003440 0F70            7627         PUSH.W  R4, R5, R6
003442 99720014        7628         SUB.W   R7,#014H
                       7629 ; rtxc.c   2733    MAP i, k;
                       7630 ; rtxc.c   2734    int j;
                       7631 ; rtxc.c   2735    char **next;
                       7632 ; rtxc.c   2736    register PHEADER ks_tbl *pph;
                       7633 ; rtxc.c   2737    register const PKHEADER *ppkh;
                       7634 ; rtxc.c   2738 
                       7635 ; rtxc.c   2739    for (i = 1, ppkh = &pkheader[1], pph = (PHEADER ks_tbl *)&pheader[1]; i <= npa
                            rts;
003446 91C801          7636         MOV.B   R6L,#01H
003449 9958rrrr        7637         MOV.W   R5,#SEG( _pkheader+8 )
00344D 9948rrrr        7638         MOV.W   R4,#SOF( _pkheader+8 )
003451 9938rrrr        7639         MOV.W   R3,#SEG( _pheader+22 )
003455 9928rrrr        7640         MOV.W   R2,#SOF( _pheader+22 )
003459 964842rr        7641         MOV.B   ES,#SEG( _nparts )
00345D 9908rrrr        7642         MOV.W   R0,#SOF( _nparts )
003461 82D0            7643         MOV.B   R6H,[R0]
003463 91D401          7644         CMP.B   R6H,#01H
                       7645         BCS     _540
003466 F002           +7645 ;       BCC     _LG_540
003468 D50080         +7645 ;       JMP.L   _540
003468 D5008000       +7645 ;       JMP.L   _540
00346C                +7645 _LG_540:
00346C                +7645 _LG_540:
00346C                 7646 _536:
                       7647 ; rtxc.c   2740         i++,   ppkh++,              pph++)
                       7648 ; rtxc.c   2741    {
                       7649 ; rtxc.c   2742       pph->next = ppkh->next;
00346C 8C5F12          7650         MOV.W   [R7+18],R5
00346F 8C4F10          7651         MOV.W   [R7+16],R4
003472 86AC42          7652         MOV.B   ES,R5L
003475 8C5402          7653         MOV.W   R5,[R4+2]
003478 8A44            7654         MOV.W   R4,[R4]
00347A 8913            7655         MOV.W   R1,R3
00347C 8902            7656         MOV.W   R0,R2
00347E 862C42          7657         MOV.B   ES,R1L
003481 8A48            7658         MOV.W   [R0],R4
003483 8C5802          7659         MOV.W   [R0+2],R5
                       7660 ; rtxc.c   2743 
                       7661 ; rtxc.c   2744       if ( (next = (char **)pph->next) != NULL)
003486 8C1F0E          7662         MOV.W   [R7+14],R1
003489 8C0F0C          7663         MOV.W   [R7+12],R0
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 135

ADDR   CODE            LINE SOURCELINE
00348C 862C42          7664         MOV.B   ES,R1L
00348F 8C1002          7665         MOV.W   R1,[R0+2]
003492 8A00            7666         MOV.W   R0,[R0]
003494 8931            7667         MOV.W   R3,R1
003496 8920            7668         MOV.W   R2,R0
003498 6910            7669         OR.W    R1,R0
00349A F339            7670         BEQ     _539
                       7671 ; rtxc.c   2745       {
                       7672 ; rtxc.c   2746          for (j = 1; j < ppkh->count; j++, next = (char **)*next)
00349C B941            7673         MOV.W   R4,#01H
00349E 8C1712          7674         MOV.W   R1,[R7+18]
0034A1 8C0710          7675         MOV.W   R0,[R7+16]
0034A4 862C42          7676         MOV.B   ES,R1L
0034A7 8C5006          7677         MOV.W   R5,[R0+6]
0034AA 8C1712          7678         MOV.W   R1,[R7+18]
0034AD 8C0710          7679         MOV.W   R0,[R7+16]
0034B0 862C42          7680         MOV.B   ES,R1L
0034B3 9C04060001      7681         CMP.W   [R0+6],#01H
0034B8 FD26            7682         BLE     _538
0034BA 8C1712          7683         MOV.W   R1,[R7+18]
0034BD 8C0710          7684         MOV.W   R0,[R7+16]
0034C0 99000004        7685         ADD.W   R0,#04H
0034C4 8C1F06          7686         MOV.W   [R7+6],R1
0034C7 8C0F04          7687         MOV.W   [R7+4],R0
0034C7 8C0F04          7687         MOV.W   [R7+4],R0
0034CA                 7688 _537:
                       7689 ; rtxc.c   2747             *next = (char *)next + ppkh->size;
0034CA 8C1706          7690         MOV.W   R1,[R7+6]
0034CD 8C0704          7691         MOV.W   R0,[R7+4]
0034D0 862C42          7692         MOV.B   ES,R1L
0034D3 8A00            7693         MOV.W   R0,[R0]
0034D5 B910            7694         MOVS.W  R1,#00H
0034D7 8C1F02          7695         MOV.W   [R7+2],R1
0034DA 8A0F            7696         MOV.W   [R7],R0
0034DC 8C3F0A          7697         MOV.W   [R7+10],R3
0034DF 8C2F08          7698         MOV.W   [R7+8],R2
0034E2 8913            7699         MOV.W   R1,R3
0034E4 8902            7700         MOV.W   R0,R2
0034E6 8C3702          7701         MOV.W   R3,[R7+2]
0034E9 8A27            7702         MOV.W   R2,[R7]
0034EB 0902            7703         ADD.W   R0,R2
0034ED 8C370A          7704         MOV.W   R3,[R7+10]
0034F0 8C2708          7705         MOV.W   R2,[R7+8]
0034F3 866C42          7706         MOV.B   ES,R3L
0034F6 8A0A            7707         MOV.W   [R2],R0
0034F8 8C1A02          7708         MOV.W   [R2+2],R1
0034FB A941            7709         ADDS.W  R4,#01H
0034FD 8931            7710         MOV.W   R3,R1
0034FF 8920            7711         MOV.W   R2,R0
003501 4945            7712         CMP.W   R4,R5
003503 FBE3            7713         BLT     _537
003503 FBE300          7713         BLT     _537
003506                 7714 _538:
                       7715 ; rtxc.c   2748 
                       7716 ; rtxc.c   2749 #ifdef BSS_NOT_ZERO /* { */
                       7717 ; rtxc.c   2750          *next = NULL; /* null last link */
003506 866C42          7718         MOV.B   ES,R3L
003509 BA20            7719         MOV.W   [R2],#00H
00350B BC2002          7720         MOV.W   [R2+2],#00H
00350B BC2002          7720         MOV.W   [R2+2],#00H
                       7721 ; rtxc.c   2751 #endif /* } BSS_NOT_ZERO */
                       7722 ; rtxc.c   2752       }
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 136

ADDR   CODE            LINE SOURCELINE
00350E                 7723 _539:
                       7724 ; rtxc.c   2753 
                       7725 ; rtxc.c   2754       pph->size = ppkh->size;
00350E 8C1712          7726         MOV.W   R1,[R7+18]
003511 8C0710          7727         MOV.W   R0,[R7+16]
003514 862C42          7728         MOV.B   ES,R1L
003517 8C0004          7729         MOV.W   R0,[R0+4]
00351A 8C370E          7730         MOV.W   R3,[R7+14]
00351D 8C270C          7731         MOV.W   R2,[R7+12]
003520 866C42          7732         MOV.B   ES,R3L
003523 8C0A04          7733         MOV.W   [R2+4],R0
                       7734 ; rtxc.c   2755       pph->count = ppkh->count;
003526 8C1712          7735         MOV.W   R1,[R7+18]
003529 8C0710          7736         MOV.W   R0,[R7+16]
00352C 862C42          7737         MOV.B   ES,R1L
00352F 8C0006          7738         MOV.W   R0,[R0+6]
003532 866C42          7739         MOV.B   ES,R3L
003535 8C0A06          7740         MOV.W   [R2+6],R0
                       7741 ; rtxc.c   2756 
                       7742 ; rtxc.c   2757 #ifdef BSS_NOT_ZERO /* { */
                       7743 ; rtxc.c   2758 #ifdef PARTITION_WAITERS /* { */
                       7744 ; rtxc.c   2759       pph->waiters = NULLTCB;
003538 8C170E          7745         MOV.W   R1,[R7+14]
00353B 8C070C          7746         MOV.W   R0,[R7+12]
00353E 862C42          7747         MOV.B   ES,R1L
003541 BC0008          7748         MOV.W   [R0+8],#00H
003544 BC000A          7749         MOV.W   [R0+10],#00H
                       7750 ; rtxc.c   2760       pph->dummy = NULLTCB;
003547 862C42          7751         MOV.B   ES,R1L
00354A BC000C          7752         MOV.W   [R0+12],#00H
00354D BC000E          7753         MOV.W   [R0+14],#00H
003550 A1C1            7754         ADDS.B  R6L,#01H
003552 8C5712          7755         MOV.W   R5,[R7+18]
003555 8C4710          7756         MOV.W   R4,[R7+16]
003558 99400008        7757         ADD.W   R4,#08H
00355C 8C370E          7758         MOV.W   R3,[R7+14]
00355F 8C270C          7759         MOV.W   R2,[R7+12]
003562 99200016        7760         ADD.W   R2,#016H
003566 41CD            7761         CMP.B   R6L,R6H
003568 F981            7762         BL      _536
003568 F981            7762         BL      _536
                       7763 ; rtxc.c   2761 #endif /* } PARTITION_WAITERS */
                       7764 ; rtxc.c   2762 
                       7765 ; rtxc.c   2763 #ifdef CBUG /* { */
                       7766 ; rtxc.c   2764       pph->cur = 0;
                       7767 ; rtxc.c   2765       pph->worst = 0;
                       7768 ; rtxc.c   2766       pph->usage = 0;
                       7769 ; rtxc.c   2767 #endif /* } CBUG */
                       7770 ; rtxc.c   2768 #endif /* } BSS_NOT_ZERO */
                       7771 ; rtxc.c   2769    }
00356A                 7772 _540:
                       7773 ; rtxc.c   2770 
                       7774 ; rtxc.c   2771 #ifdef DYNAMIC_PARTS /* { */
                       7775 ; rtxc.c   2772    /* thread dynamic partition PHEADER free pool - possibly dnparts == 0 */
                       7776 ; rtxc.c   2773    if (dnparts)
00356A 964842rr        7777         MOV.B   ES,#SEG( _dnparts )
00356E 9908rrrr        7778         MOV.W   R0,#SOF( _dnparts )
003572 8260            7779         MOV.B   R3L,[R0]
003574 F310            7780         BEQ     _541
                       7781 ; rtxc.c   2774       dphfl = (PHEADER ks_tbl *)&pheader[nparts + 1];
003576 810D            7782         MOV.B   R0L,R6H
003578 E80016          7783         MULU.B  R0L,#016H
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 137

ADDR   CODE            LINE SOURCELINE
00357B B910            7784         MOVS.W  R1,#00H
00357D 9958rrrr        7785         MOV.W   R5,#SEG( _pheader+22 )
003581 9948rrrr        7786         MOV.W   R4,#SOF( _pheader+22 )
003585 0940            7787         ADD.W   R4,R0
003587 964842rr        7788         MOV.B   ES,#SEG( _dphfl )
00358B 9908rrrr        7789         MOV.W   R0,#SOF( _dphfl )
00358F 8B48            7790         MOV.W   [R0+],R4
003591 8A58            7791         MOV.W   [R0],R5
003593 FE07            7792         BR      _542
003593 FE0700          7792         BR      _542
003596                 7793 _541:
                       7794 ; rtxc.c   2775    else
                       7795 ; rtxc.c   2776       dphfl = NULLMAP;
003596 964842rr        7796         MOV.B   ES,#SEG( _dphfl )
00359A 9908rrrr        7797         MOV.W   R0,#SOF( _dphfl )
00359E BB00            7798         MOV.W   [R0+],#00H
0035A0 BA00            7799         MOV.W   [R0],#00H
0035A0 BA00            7799         MOV.W   [R0],#00H
0035A2                 7800 _542:
                       7801 ; rtxc.c   2777 
                       7802 ; rtxc.c   2778    for (i = 1, k = nparts + 1, pph = (PHEADER ks_tbl *)dphfl;
0035A2 915801          7803         MOV.B   R2H,#01H
0035A5 A1D1            7804         ADDS.B  R6H,#01H
0035A7 814D            7805         MOV.B   R2L,R6H
0035A9 964842rr        7806         MOV.B   ES,#SEG( _dphfl )
0035AD 9918rrrr        7807         MOV.W   R1,#SOF( _dphfl )
0035B1 8B01            7808         MOV.W   R0,[R1+]
0035B3 8A11            7809         MOV.W   R1,[R1]
0035B5 8C1F12          7810         MOV.W   [R7+18],R1
0035B8 8C0F10          7811         MOV.W   [R7+16],R0
0035BB 8C1712          7812         MOV.W   R1,[R7+18]
0035BE 8C0710          7813         MOV.W   R0,[R7+16]
0035C1 916401          7814         CMP.B   R3L,#01H
0035C4 F13C            7815         BCS     _544
0035C4 F13C            7815         BCS     _544
0035C6                 7816 _543:
                       7817 ; rtxc.c   2779         i <= dnparts; i++, k++, pph++)
                       7818 ; rtxc.c   2780    {
                       7819 ; rtxc.c   2781 
                       7820 ; rtxc.c   2782       /* insert pheader into linked list */
                       7821 ; rtxc.c   2783       pph->next = (struct xmap *)&pheader[k + 1];
0035C6 8164            7822         MOV.B   R3L,R2L
0035C8 E86016          7823         MULU.B  R3L,#016H
0035CB 8943            7824         MOV.W   R4,R3
0035CD B950            7825         MOVS.W  R5,#00H
0035CF 9918rrrr        7826         MOV.W   R1,#SEG( _pheader+22 )
0035D3 9908rrrr        7827         MOV.W   R0,#SOF( _pheader+22 )
0035D7 0904            7828         ADD.W   R0,R4
0035D9 8C5712          7829         MOV.W   R5,[R7+18]
0035DC 8C4710          7830         MOV.W   R4,[R7+16]
0035DF 86AC42          7831         MOV.B   ES,R5L
0035E2 8A0C            7832         MOV.W   [R4],R0
0035E4 8C1C02          7833         MOV.W   [R4+2],R1
                       7834 ; rtxc.c   2784 
                       7835 ; rtxc.c   2785       pph->map = k;        /* set map number for return to definer */
0035E7 8915            7836         MOV.W   R1,R5
0035E9 8904            7837         MOV.W   R0,R4
0035EB 862C42          7838         MOV.B   ES,R1L
0035EE 844810          7839         MOV.B   [R0+16],R2L
                       7840 ; rtxc.c   2786 
                       7841 ; rtxc.c   2787 #ifdef BSS_NOT_ZERO /* { */
                       7842 ; rtxc.c   2788       pph->size = 0;
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 138

ADDR   CODE            LINE SOURCELINE
0035F1 8C1712          7843         MOV.W   R1,[R7+18]
0035F4 8C0710          7844         MOV.W   R0,[R7+16]
0035F7 862C42          7845         MOV.B   ES,R1L
0035FA BC0004          7846         MOV.W   [R0+4],#00H
                       7847 ; rtxc.c   2789       pph->count = 0;
0035FD 862C42          7848         MOV.B   ES,R1L
003600 BC0006          7849         MOV.W   [R0+6],#00H
                       7850 ; rtxc.c   2790 
                       7851 ; rtxc.c   2791 #ifdef PARTITION_WAITERS /* { */
                       7852 ; rtxc.c   2792       pph->waiters = NULLTCB;
003603 8C1712          7853         MOV.W   R1,[R7+18]
003606 8C0710          7854         MOV.W   R0,[R7+16]
003609 862C42          7855         MOV.B   ES,R1L
00360C BC0008          7856         MOV.W   [R0+8],#00H
00360F BC000A          7857         MOV.W   [R0+10],#00H
                       7858 ; rtxc.c   2793       pph->dummy = NULLTCB;
003612 862C42          7859         MOV.B   ES,R1L
003615 BC000C          7860         MOV.W   [R0+12],#00H
003618 BC000E          7861         MOV.W   [R0+14],#00H
00361B A151            7862         ADDS.B  R2H,#01H
00361D A141            7863         ADDS.B  R2L,#01H
00361F 8C1712          7864         MOV.W   R1,[R7+18]
003622 8C0710          7865         MOV.W   R0,[R7+16]
003625 99000016        7866         ADD.W   R0,#016H
003629 8C1F12          7867         MOV.W   [R7+18],R1
00362C 8C0F10          7868         MOV.W   [R7+16],R0
00362F 964842rr        7869         MOV.B   ES,#SEG( _dnparts )
003633 9938rrrr        7870         MOV.W   R3,#SOF( _dnparts )
003637 8263            7871         MOV.B   R3L,[R3]
003639 4156            7872         CMP.B   R2H,R3L
00363B F9C5            7873         BL      _543
00363B F9C500          7873         BL      _543
                       7874 ; rtxc.c   2794 #endif /* } PARTITION_WAITERS */
                       7875 ; rtxc.c   2795 
                       7876 ; rtxc.c   2796 #ifdef CBUG /* { */
                       7877 ; rtxc.c   2797       pph->cur = 0;
                       7878 ; rtxc.c   2798       pph->worst = 0;
                       7879 ; rtxc.c   2799       pph->usage = 0;
                       7880 ; rtxc.c   2800 #endif /* } CBUG */
                       7881 ; rtxc.c   2801 #endif /* } BSS_NOT_ZERO */
                       7882 ; rtxc.c   2802    }
00363E                 7883 _544:
                       7884 ; rtxc.c   2803 
                       7885 ; rtxc.c   2804    if (dnparts)
00363E 964842rr        7886         MOV.B   ES,#SEG( _dnparts )
003642 9908rrrr        7887         MOV.W   R0,#SOF( _dnparts )
003646 8200            7888         MOV.B   R0L,[R0]
003648 F309            7889         BEQ     _545
                       7890 ; rtxc.c   2805    {
                       7891 ; rtxc.c   2806       pph--;
00364A 8C1712          7892         MOV.W   R1,[R7+18]
00364D 8C0710          7893         MOV.W   R0,[R7+16]
003650 99020016        7894         SUB.W   R0,#016H
                       7895 ; rtxc.c   2807       pph->next = NULL; /* null last link */
003654 862C42          7896         MOV.B   ES,R1L
003657 BA00            7897         MOV.W   [R0],#00H
003659 BC0002          7898         MOV.W   [R0+2],#00H
003659 BC0002          7898         MOV.W   [R0+2],#00H
                       7899 ; rtxc.c   2808    }
00365C                 7900 _545:
                       7901 ; rtxc.c   2809 #endif /* } DYNAMIC_PARTS */
                       7902 ; rtxc.c   2810 
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 139

ADDR   CODE            LINE SOURCELINE
                       7903 ; rtxc.c   2811 }
00365C 99700014        7904         ADD.W   R7,#014H
003660 2F70            7905         POP.W   R4, R5, R6
003662 D680            7906         RET
003662 D680            7906         RET
                       7907 ; rtxc.c   2812 #endif /* } HAS_PARTITIONS */
                       7908 ; rtxc.c   2813 
                       7909 ; rtxc.c   2814 #ifdef HAS_QUEUES /* { */
                       7910 ; rtxc.c   2815 /* queue startup support */
                       7911 ; rtxc.c   2816 /************************/
                       7912 ; rtxc.c   2817 void queueinit(void)
                       7913 ; rtxc.c   2818 /************************/
                       7914 ; rtxc.c   2819 {
                       7915         PUBLIC  _queueinit
003664                 7916 _queueinit:
003664 0F30            7917         PUSH.W  R4, R5
003666 A978            7918         ADDS.W  R7,#08H
                       7919 ; rtxc.c   2820    QUEUE i;
                       7920 ; rtxc.c   2821    register QHEADER ks_tbl *pqh;
                       7921 ; rtxc.c   2822    register const QKHEADER *pqkh;
                       7922 ; rtxc.c   2823 
                       7923 ; rtxc.c   2824    for (i = 1, pqkh = &qkheader[1], pqh = (QHEADER ks_tbl *)&qheader[1]; i <= nqu
                            eues;
003668 918801          7924         MOV.B   R4L,#01H
00366B 9938rrrr        7925         MOV.W   R3,#SEG( _qkheader+8 )
00366F 9928rrrr        7926         MOV.W   R2,#SOF( _qkheader+8 )
003673 9D780002rrrr    7927         MOV.W   [R7+2],#SEG( _qheader+24 )
003679 9A78rrrr        7928         MOV.W   [R7],#SOF( _qheader+24 )
00367D 964842rr        7929         MOV.B   ES,#SEG( _nqueues )
003681 9958rrrr        7930         MOV.W   R5,#SOF( _nqueues )
003685 8295            7931         MOV.B   R4H,[R5]
003687 919401          7932         CMP.B   R4H,#01H
00368A F15F            7933         BCS     _553
00368A F15F            7933         BCS     _553
00368C                 7934 _552:
                       7935 ; rtxc.c   2825         i++,   pqkh++,              pqh++)
                       7936 ; rtxc.c   2826    {
                       7937 ; rtxc.c   2827       pqh->base = pqkh->base;
00368C 8C3F06          7938         MOV.W   [R7+6],R3
00368F 8C2F04          7939         MOV.W   [R7+4],R2
003692 866C42          7940         MOV.B   ES,R3L
003695 8A02            7941         MOV.W   R0,[R2]
003697 8C1202          7942         MOV.W   R1,[R2+2]
00369A 8C3702          7943         MOV.W   R3,[R7+2]
00369D 8A27            7944         MOV.W   R2,[R7]
00369F 866C42          7945         MOV.B   ES,R3L
0036A2 8A0A            7946         MOV.W   [R2],R0
0036A4 8C1A02          7947         MOV.W   [R2+2],R1
                       7948 ; rtxc.c   2828       pqh->width = pqkh->width;
0036A7 8C1706          7949         MOV.W   R1,[R7+6]
0036AA 8C0704          7950         MOV.W   R0,[R7+4]
0036AD 862C42          7951         MOV.B   ES,R1L
0036B0 8C5004          7952         MOV.W   R5,[R0+4]
0036B3 8C1702          7953         MOV.W   R1,[R7+2]
0036B6 8A07            7954         MOV.W   R0,[R7]
0036B8 862C42          7955         MOV.B   ES,R1L
0036BB 8C5804          7956         MOV.W   [R0+4],R5
                       7957 ; rtxc.c   2829       pqh->depth = pqkh->depth;
0036BE 8C3706          7958         MOV.W   R3,[R7+6]
0036C1 8C2704          7959         MOV.W   R2,[R7+4]
0036C4 866C42          7960         MOV.B   ES,R3L
0036C7 8C5206          7961         MOV.W   R5,[R2+6]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 140

ADDR   CODE            LINE SOURCELINE
0036CA 862C42          7962         MOV.B   ES,R1L
0036CD 8C5806          7963         MOV.W   [R0+6],R5
                       7964 ; rtxc.c   2830       pqh->putndx = pqh->depth - 1;
0036D0 A95F            7965         ADDS.W  R5,#0FH
0036D2 8C1702          7966         MOV.W   R1,[R7+2]
0036D5 8A07            7967         MOV.W   R0,[R7]
0036D7 862C42          7968         MOV.B   ES,R1L
0036DA 8C5808          7969         MOV.W   [R0+8],R5
                       7970 ; rtxc.c   2831 #ifdef BSS_NOT_ZERO /* { */
                       7971 ; rtxc.c   2832       pqh->curndx = 0;
0036DD 862C42          7972         MOV.B   ES,R1L
0036E0 BC000A          7973         MOV.W   [R0+10],#00H
                       7974 ; rtxc.c   2833 
                       7975 ; rtxc.c   2834 #ifdef QUEUE_SEMAS /* { */
                       7976 ; rtxc.c   2835       pqh->nesema = 0;
0036E3 8C1702          7977         MOV.W   R1,[R7+2]
0036E6 8A07            7978         MOV.W   R0,[R7]
0036E8 862C42          7979         MOV.B   ES,R1L
0036EB B40015          7980         MOV.B   [R0+21],#00H
                       7981 ; rtxc.c   2836       pqh->fsema = 0;
0036EE 862C42          7982         MOV.B   ES,R1L
0036F1 B40014          7983         MOV.B   [R0+20],#00H
                       7984 ; rtxc.c   2837       pqh->nfsema = 0;
0036F4 8C1702          7985         MOV.W   R1,[R7+2]
0036F7 8A07            7986         MOV.W   R0,[R7]
0036F9 862C42          7987         MOV.B   ES,R1L
0036FC B40017          7988         MOV.B   [R0+23],#00H
                       7989 ; rtxc.c   2838       pqh->esema = 0;
0036FF 862C42          7990         MOV.B   ES,R1L
003702 B40016          7991         MOV.B   [R0+22],#00H
                       7992 ; rtxc.c   2839 #endif /* } QUEUE_SEMAS */
                       7993 ; rtxc.c   2840 
                       7994 ; rtxc.c   2841 #ifdef QUEUE_WAITERS /* { */
                       7995 ; rtxc.c   2842       pqh->waiters = NULLTCB;
003705 8C1702          7996         MOV.W   R1,[R7+2]
003708 8A07            7997         MOV.W   R0,[R7]
00370A 862C42          7998         MOV.B   ES,R1L
00370D BC000C          7999         MOV.W   [R0+12],#00H
003710 BC000E          8000         MOV.W   [R0+14],#00H
                       8001 ; rtxc.c   2843       pqh->dummy = NULLTCB;
003713 862C42          8002         MOV.B   ES,R1L
003716 BC0010          8003         MOV.W   [R0+16],#00H
003719 BC0012          8004         MOV.W   [R0+18],#00H
00371C A181            8005         ADDS.B  R4L,#01H
00371E 8C3706          8006         MOV.W   R3,[R7+6]
003721 8C2704          8007         MOV.W   R2,[R7+4]
003724 99200008        8008         ADD.W   R2,#08H
003728 8C1702          8009         MOV.W   R1,[R7+2]
00372B 8A07            8010         MOV.W   R0,[R7]
00372D 99000018        8011         ADD.W   R0,#018H
003731 8C1F02          8012         MOV.W   [R7+2],R1
003734 8A0F            8013         MOV.W   [R7],R0
003736 8C1702          8014         MOV.W   R1,[R7+2]
003739 8A07            8015         MOV.W   R0,[R7]
00373B 964842rr        8016         MOV.B   ES,#SEG( _nqueues )
00373F 9958rrrr        8017         MOV.W   R5,#SOF( _nqueues )
003743 8295            8018         MOV.B   R4H,[R5]
003745 4189            8019         CMP.B   R4L,R4H
003747 F9A2            8020         BL      _552
003747 F9A200          8020         BL      _552
                       8021 ; rtxc.c   2844 #endif /* } QUEUE_WAITERS */
                       8022 ; rtxc.c   2845 
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 141

ADDR   CODE            LINE SOURCELINE
                       8023 ; rtxc.c   2846 #ifdef CBUG /* { */
                       8024 ; rtxc.c   2847       pqh->count = 0;
                       8025 ; rtxc.c   2848       pqh->worst = 0;
                       8026 ; rtxc.c   2849 #endif /* } CBUG */
                       8027 ; rtxc.c   2850 #endif /* } BSS_NOT_ZERO */
                       8028 ; rtxc.c   2851    }
00374A                 8029 _553:
                       8030 ; rtxc.c   2852 }
00374A 99700008        8031         ADD.W   R7,#08H
00374E 2F30            8032         POP.W   R4, R5
003750 D680            8033         RET
003750 D680            8033         RET
                       8034 ; rtxc.c   2853 #endif /* } HAS_QUEUES */
                       8035 ; rtxc.c   2854 
                       8036 ; rtxc.c   2855 /* startup all semaphores as PENDing */
                       8037 ; rtxc.c   2856 /************************/
                       8038 ; rtxc.c   2857 void semainit(void)
                       8039 ; rtxc.c   2858 /************************/
                       8040 ; rtxc.c   2859 {
                       8041         PUBLIC  _semainit
003752                 8042 _semainit:
                       8043 ; rtxc.c   2860    register SEMA i;
                       8044 ; rtxc.c   2861    register SSTATE ks_tbl *s;
                       8045 ; rtxc.c   2862 #ifdef BSS_NOT_ZERO /* { */
                       8046 ; rtxc.c   2863    int j;
                       8047 ; rtxc.c   2864 #endif /* } BSS_NOT_ZERO */
                       8048 ; rtxc.c   2865 
                       8049 ; rtxc.c   2866    for (i = 1, s = (SSTATE ks_tbl *)&semat[1]; i <= nsemas; i++, s++)
003752 914801          8050         MOV.B   R2L,#01H
003755 9918rrrr        8051         MOV.W   R1,#SEG( _semat+1 )
003759 9908rrrr        8052         MOV.W   R0,#SOF( _semat+1 )
00375D 964842rr        8053         MOV.B   ES,#SEG( _nsemas )
003761 9938rrrr        8054         MOV.W   R3,#SOF( _nsemas )
003765 8253            8055         MOV.B   R2H,[R3]
003767 915401          8056         CMP.B   R2H,#01H
00376A F10D            8057         BCS     _557
00376A F10D            8057         BCS     _557
00376C                 8058 _556:
                       8059 ; rtxc.c   2867       *s = SEMA_PENDING;
00376C 862C42          8060         MOV.B   ES,R1L
00376F 9208FF          8061         MOV.B   [R0],#0FFH
003772 A141            8062         ADDS.B  R2L,#01H
003774 99000001        8063         ADD.W   R0,#01H
003778 964842rr        8064         MOV.B   ES,#SEG( _nsemas )
00377C 9938rrrr        8065         MOV.W   R3,#SOF( _nsemas )
003780 8253            8066         MOV.B   R2H,[R3]
003782 4145            8067         CMP.B   R2L,R2H
003784 F9F3            8068         BL      _556
003784 F9F3            8068         BL      _556
003786                 8069 _557:
                       8070 ; rtxc.c   2868 
                       8071 ; rtxc.c   2869    semaput = (SEMA ks_data *)&siglist[-1]; /* init empty sema deque */
003786 9Er8rrrrrr      8072         MOV.W   _semaput+2,#SEG( _siglist+-1 )
00378B 9Er8rrrrrr      8073         MOV.W   _semaput,#SOF( _siglist+-1 )
                       8074 ; rtxc.c   2870    semaget = (SEMA ks_data *)&siglist[-1]; /* init empty sema deque */
003790 9Er8rrrrrr      8075         MOV.W   _semaget+2,#SEG( _siglist+-1 )
003795 9Er8rrrrrr      8076         MOV.W   _semaget,#SOF( _siglist+-1 )
                       8077 ; rtxc.c   2871 
                       8078 ; rtxc.c   2872 #ifdef BSS_NOT_ZERO /* { */
                       8079 ; rtxc.c   2873    for (j = 0; j < siglistsize; j++)
00379A B920            8080         MOV.W   R2,#00H
00379C 9918rrrr        8081         MOV.W   R1,#SEG( _siglist )
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 142

ADDR   CODE            LINE SOURCELINE
0037A0 9908rrrr        8082         MOV.W   R0,#SOF( _siglist )
0037A4 964842rr        8083         MOV.B   ES,#SEG( _siglistsize )
0037A8 9938rrrr        8084         MOV.W   R3,#SOF( _siglistsize )
0037AC 8A33            8085         MOV.W   R3,[R3]
0037AE 99340000        8086         CMP.W   R3,#00H
0037B2 FD08            8087         BLE     _559
0037B2 FD08            8087         BLE     _559
0037B4                 8088 _558:
                       8089 ; rtxc.c   2874       siglist[j] = 0;
0037B4 862C42          8090         MOV.B   ES,R1L
0037B7 B200            8091         MOV.B   [R0],#00H
0037B9 99000001        8092         ADD.W   R0,#01H
0037BD A921            8093         ADDS.W  R2,#01H
0037BF 4923            8094         CMP.W   R2,R3
0037C1 FBF9            8095         BLT     _558
0037C1 FBF900          8095         BLT     _558
0037C4                 8096 _559:
                       8097 ; rtxc.c   2875 
                       8098 ; rtxc.c   2876 #endif /* } BSS_NOT_ZERO */
                       8099 ; rtxc.c   2877 }
0037C4 D680            8100         RET
0037C4 D680            8100         RET
                       8101 ; rtxc.c   2878 
                       8102 ; rtxc.c   2879 /* link all clock blocks into free list */
                       8103 ; rtxc.c   2880 /************************/
                       8104 ; rtxc.c   2881 void clockinit(void)
                       8105 ; rtxc.c   2882 /************************/
                       8106 ; rtxc.c   2883 {
                       8107         PUBLIC  _clockinit
0037C6                 8108 _clockinit:
0037C6 0F30            8109         PUSH.W  R4, R5
                       8110 ; rtxc.c   2884    register int i;
                       8111 ; rtxc.c   2885    register CLKBLK ks_clk *link;
                       8112 ; rtxc.c   2886 
                       8113 ; rtxc.c   2887    /* note, RTXCgen guarantees at least 1 timer */
                       8114 ; rtxc.c   2888 
                       8115 ; rtxc.c   2889    link = clkqfl = (CLKBLK ks_clk *)&clkq[0];
0037C8 964842rr        8116         MOV.B   ES,#SEG( _clkqfl )
0037CC 9908rrrr        8117         MOV.W   R0,#SOF( _clkqfl )
0037D0 9B08rrrr        8118         MOV.W   [R0+],#SOF( _clkq )
0037D4 9A08rrrr        8119         MOV.W   [R0],#SEG( _clkq )
0037D8 9958rrrr        8120         MOV.W   R5,#SEG( _clkq )
0037DC 9948rrrr        8121         MOV.W   R4,#SOF( _clkq )
                       8122 ; rtxc.c   2890 
                       8123 ; rtxc.c   2891    for (i = 1; i < ntmrs; i++, link++)
0037E0 B921            8124         MOV.W   R2,#01H
0037E2 964842rr        8125         MOV.B   ES,#SEG( _ntmrs )
0037E6 9938rrrr        8126         MOV.W   R3,#SOF( _ntmrs )
0037EA 8A33            8127         MOV.W   R3,[R3]
0037EC 99340001        8128         CMP.W   R3,#01H
0037F0 FD0D            8129         BLE     _565
0037F0 FD0D            8129         BLE     _565
0037F2                 8130 _564:
                       8131 ; rtxc.c   2892       link->flink = link + 1;
0037F2 8915            8132         MOV.W   R1,R5
0037F4 8904            8133         MOV.W   R0,R4
0037F6 99000012        8134         ADD.W   R0,#012H
0037FA 86AC42          8135         MOV.B   ES,R5L
0037FD 8A0C            8136         MOV.W   [R4],R0
0037FF 8C1C02          8137         MOV.W   [R4+2],R1
003802 A921            8138         ADDS.W  R2,#01H
003804 8951            8139         MOV.W   R5,R1
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 143

ADDR   CODE            LINE SOURCELINE
003806 8940            8140         MOV.W   R4,R0
003808 4923            8141         CMP.W   R2,R3
00380A FBF3            8142         BLT     _564
00380A FBF3            8142         BLT     _564
00380C                 8143 _565:
                       8144 ; rtxc.c   2893 
                       8145 ; rtxc.c   2894 #ifdef BSS_NOT_ZERO /* { */
                       8146 ; rtxc.c   2895    link->flink = NULLCLK;
00380C 86AC42          8147         MOV.B   ES,R5L
00380F BA40            8148         MOV.W   [R4],#00H
003811 BC4002          8149         MOV.W   [R4+2],#00H
                       8150 ; rtxc.c   2896 
                       8151 ; rtxc.c   2897    clkqptr = NULLCLK;
003814 964842rr        8152         MOV.B   ES,#SEG( _clkqptr )
003818 9908rrrr        8153         MOV.W   R0,#SOF( _clkqptr )
00381C BB00            8154         MOV.W   [R0+],#00H
00381E BA00            8155         MOV.W   [R0],#00H
                       8156 ; rtxc.c   2898 
                       8157 ; rtxc.c   2899    rtctick = (TICKS)0;
003820 964842rr        8158         MOV.B   ES,#SEG( _rtctick )
003824 9908rrrr        8159         MOV.W   R0,#SOF( _rtctick )
003828 BA00            8160         MOV.W   [R0],#00H
                       8161 ; rtxc.c   2900 
                       8162 ; rtxc.c   2901    t_expired = 0;
00382A 964842rr        8163         MOV.B   ES,#SEG( _t_expired )
00382E 9908rrrr        8164         MOV.W   R0,#SOF( _t_expired )
003832 B200            8165         MOV.B   [R0],#00H
                       8166 ; rtxc.c   2902 
                       8167 ; rtxc.c   2903 #ifdef HAS_INQTIME /* { */
                       8168 ; rtxc.c   2904    rtctime = (time_t)0;
003834 964842rr        8169         MOV.B   ES,#SEG( _rtctime )
003838 9908rrrr        8170         MOV.W   R0,#SOF( _rtctime )
00383C BB00            8171         MOV.W   [R0+],#00H
00383E BA00            8172         MOV.W   [R0],#00H
                       8173 ; rtxc.c   2905    ratecnt = 0;
003840 964842rr        8174         MOV.B   ES,#SEG( _ratecnt )
003844 9908rrrr        8175         MOV.W   R0,#SOF( _ratecnt )
003848 BA00            8176         MOV.W   [R0],#00H
                       8177 ; rtxc.c   2906 #endif /* } HAS_INQTIME */
                       8178 ; rtxc.c   2907 
                       8179 ; rtxc.c   2908 #ifdef TIME_SLICE /* { */
                       8180 ; rtxc.c   2909    sliceup = NULLTCB;
00384A BEr0rr          8181         MOV.W   _sliceup+2,#00H
00384D BEr0rr          8182         MOV.W   _sliceup,#00H
                       8183 ; rtxc.c   2910 #endif /* } TIME_SLICE */
                       8184 ; rtxc.c   2911 
                       8185 ; rtxc.c   2912 #endif /* } BSS_NOT_ZERO */
                       8186 ; rtxc.c   2913 }
003850 2F30            8187         POP.W   R4, R5
003852 D680            8188         RET
003852 D680            8188         RET
                       8189 ; rtxc.c   2914 
                       8190 ; rtxc.c   2915 #ifdef HAS_PARTITIONS /* { */
                       8191 ; rtxc.c   2916 #ifdef HAS_ALLOC /* { */
                       8192 ; rtxc.c   2917 void * KS_ISRalloc(MAP map)
                       8193 ; rtxc.c   2918 {
                       8194         PUBLIC  _KS_ISRalloc
003854                 8195 _KS_ISRalloc:
003854 0F70            8196         PUSH.W  R4, R5, R6
                       8197 ; rtxc.c   2919    unsigned char pswh;  /* local variable for saving processor priority level */
                       8198 ; rtxc.c   2920    PHEADER ks_tbl *pph;
                       8199 ; rtxc.c   2921    struct xmap *q;
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 144

ADDR   CODE            LINE SOURCELINE
                       8200 ; rtxc.c   2922 
                       8201 ; rtxc.c   2923    pph = (PHEADER ks_tbl *)&pheader[map];
003856 E80016          8202         MULU.B  R0L,#016H
003859 8920            8203         MOV.W   R2,R0
00385B B930            8204         MOVS.W  R3,#00H
                       8205 ; rtxc.c   2924 
                       8206 ; rtxc.c   2925    PUSHPSWH;   /* save current processor priority level */
00385D 86C401          8207         MOV.B   R6L,0401H
                       8208 ; rtxc.c   2926    DISABLE;   /* in case called from isr */
003860 9648018D        8209         MOV.B   0401H,#08DH
                       8210 ; rtxc.c   2927               /* can also be called from RTXC_ALLOC code */
                       8211 ; rtxc.c   2928 
                       8212 ; rtxc.c   2929    if ( (q = pph->next) != NULL) /* if any avail, return 1st */
003864 964842rr        8213         MOV.B   ES,#SEG( _pheader )
003868 8D02rrrr        8214         MOV.W   R0,[R2+SOF( _pheader )]
00386C 8D12rrrr        8215         MOV.W   R1,[R2+SOF( _pheader+2 )]
003870 8951            8216         MOV.W   R5,R1
003872 8940            8217         MOV.W   R4,R0
003874 6954            8218         OR.W    R5,R4
003876 F30A            8219         BEQ     _568
                       8220 ; rtxc.c   2930    {
                       8221 ; rtxc.c   2931       pph->next = q->link; /* unlink 1st one from list */
003878 862C42          8222         MOV.B   ES,R1L
00387B 8A40            8223         MOV.W   R4,[R0]
00387D 8C5002          8224         MOV.W   R5,[R0+2]
003880 964842rr        8225         MOV.B   ES,#SEG( _pheader )
003884 8D4Arrrr        8226         MOV.W   [R2+SOF( _pheader )],R4
003888 8D5Arrrr        8227         MOV.W   [R2+SOF( _pheader+2 )],R5
003888 8D5Arrrr        8227         MOV.W   [R2+SOF( _pheader+2 )],R5
                       8228 ; rtxc.c   2932 #ifdef CBUG /* { */
                       8229 ; rtxc.c   2933       if (++pph->cur > pph->worst) /* check for new worst case */
                       8230 ; rtxc.c   2934          pph->worst = pph->cur;          /* usage level */
                       8231 ; rtxc.c   2935 #endif /* } CBUG */
                       8232 ; rtxc.c   2936    }
00388C                 8233 _568:
                       8234 ; rtxc.c   2937    POPPSWH;
00388C 86CC01          8235         MOV.B   0401H,R6L
                       8236 ; rtxc.c   2938 
                       8237 ; rtxc.c   2939    return(q);
                       8238 ; rtxc.c   2940 }
00388F 2F70            8239         POP.W   R4, R5, R6
003891 D680            8240         RET
003891 D68000          8240         RET
                       8241 ; rtxc.c   2941 #endif /* } HAS_ALLOC */
                       8242 ; rtxc.c   2942 #endif /* } HAS_PARTITIONS */
                       8243 ; rtxc.c   2943 
                       8244 ; rtxc.c   2944 void KS_ISRsignal(SEMA sema)
                       8245 ; rtxc.c   2945 {
                       8246         PUBLIC  _KS_ISRsignal
003894                 8247 _KS_ISRsignal:
                       8248 ; rtxc.c   2946    unsigned char pswh;  /* local variable for saving processor priority level */
                       8249 ; rtxc.c   2947 
                       8250 ; rtxc.c   2948    /* save current processor priority level, disable interrupts, */
                       8251 ; rtxc.c   2949    /* stash the semaphore and restore PPL */
                       8252 ; rtxc.c   2950    SIGNAL(sema);
003894 861401          8253         MOV.B   R0H,0401H
003897 9648018D        8254         MOV.B   0401H,#08DH
00389B 9Er0rr0001      8255         ADD.W   _semaput,#01H
0038A0 8E3rrr          8256         MOV.W   R3,_semaput+2
0038A3 8E2rrr          8257         MOV.W   R2,_semaput
0038A6 866C42          8258         MOV.B   ES,R3L
0038A9 820A            8259         MOV.B   [R2],R0L
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 145

ADDR   CODE            LINE SOURCELINE
0038AB 8E3rrr          8260         MOV.W   _semaput+2,R3
0038AE 8E2rrr          8261         MOV.W   _semaput,R2
0038B1 861C01          8262         MOV.B   0401H,R0H
                       8263 ; rtxc.c   2951 }
0038B4 D680            8264         RET
0038B4 D680            8264         RET
                       8265 ; rtxc.c   2952 
                       8266 ; rtxc.c   2953 /* rtxc standard interrupt exit logic */
                       8267 ; rtxc.c   2954 /************************/
                       8268 ; rtxc.c   2955 FRAME ks_stk * KS_ISRexit(FRAME ks_stk *frame, SEMA sema)
                       8269 ; rtxc.c   2956 /************************/
                       8270 ; rtxc.c   2957 {
                       8271         PUBLIC  _KS_ISRexit
0038B6                 8272 _KS_ISRexit:
0038B6 0F30            8273         PUSH.W  R4, R5
                       8274 ; rtxc.c   2958    FRAME ks_stk *frptr;
                       8275 ; rtxc.c   2959    unsigned char pswh;  /* local variable for saving processor priority level */
                       8276 ; rtxc.c   2960 
                       8277 ; rtxc.c   2961 #ifdef CBUG /* { */
                       8278 ; rtxc.c   2962    if (isrcnt > isrmax) /* audit worst case interrupt depth */
                       8279 ; rtxc.c   2963       isrmax = isrcnt;
                       8280 ; rtxc.c   2964 #endif /* } CBUG */
                       8281 ; rtxc.c   2965 
                       8282 ; rtxc.c   2966    PUSHPSWH; /* save current processor priority level */
                       8283 ; rtxc.c   2967    DISABLE; /* turn off interrupts briefly while checking nest level */
0038B8 9648018D        8284         MOV.B   0401H,#08DH
                       8285 ; rtxc.c   2968 
                       8286 ; rtxc.c   2969    if (sema != NULLSEMA) /* if non-zero sema passed */
0038BC 6144            8287         OR.B    R2L,R2L
0038BE F30B            8288         BEQ     _569
                       8289 ; rtxc.c   2970       *++semaput = sema; /* put sema in post list */
0038C0 9Er0rr0001      8290         ADD.W   _semaput,#01H
0038C5 8E5rrr          8291         MOV.W   R5,_semaput+2
0038C8 8E4rrr          8292         MOV.W   R4,_semaput
0038CB 86AC42          8293         MOV.B   ES,R5L
0038CE 824C            8294         MOV.B   [R4],R2L
0038D0 8E5rrr          8295         MOV.W   _semaput+2,R5
0038D3 8E4rrr          8296         MOV.W   _semaput,R4
0038D3 8E4rrr          8296         MOV.W   _semaput,R4
0038D6                 8297 _569:
                       8298 ; rtxc.c   2971 
                       8299 ; rtxc.c   2972    if (isrcnt == 1)                /* if 1st nest level, ... */
0038D6 96r4rr01        8300         CMP.B   _isrcnt,#01H
0038DA F219            8301         BNE     _570
                       8302 ; rtxc.c   2973                                    /* return via postem() */
                       8303 ; rtxc.c   2974    {
                       8304 ; rtxc.c   2975       hipritsk->sp = frame;
0038DC 8E3rrr          8305         MOV.W   R3,_hipritsk+2
0038DF 8E2rrr          8306         MOV.W   R2,_hipritsk
0038E2 866C42          8307         MOV.B   ES,R3L
0038E5 8C0A0E          8308         MOV.W   [R2+14],R0
0038E8 8C1A10          8309         MOV.W   [R2+16],R1
                       8310 ; rtxc.c   2976 
                       8311 ; rtxc.c   2977       /* finished processing interrupt, .... */
                       8312 ; rtxc.c   2978       /* restore to task PPL before calling postem() */
                       8313 ; rtxc.c   2979       ENABLE;
                       8314         CALL    _ks_enable
0038EB C4rrrrrr       +8314 ;       FCALL   _ks_enable
                       8315 ; rtxc.c   2980 
                       8316 ; rtxc.c   2981       frptr = postem();
0038EF C50010          8317         CALL    _postem
                       8318 ; rtxc.c   2982       frptr->psw = (frptr->psw & 0xF0FF) | (intlvl << 8);
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 146

ADDR   CODE            LINE SOURCELINE
0038F2 862C42          8319         MOV.B   ES,R1L
0038F5 8C2012          8320         MOV.W   R2,[R0+18]
0038F8 9925F0FF        8321         AND.W   R2,#0F0FFH
0038FC 866rrr          8322         MOV.B   R3L,_intlvl
0038FF B170            8323         MOVS.B  R3H,#00H
003901 D938            8324         ASL.W   R3,#08H
003903 6923            8325         OR.W    R2,R3
003905 862C42          8326         MOV.B   ES,R1L
003908 8C2812          8327         MOV.W   [R0+18],R2
                       8328 ; rtxc.c   2983       return(frptr);
00390B FE01            8329         BR      _571
00390B FE0100          8329         BR      _571
                       8330 ; rtxc.c   2984    }
00390E                 8331 _570:
00390E                 8331 _570:
                       8332 ; rtxc.c   2985    else /* return to rtxc or isr, postem() will be performed later */
                       8333 ; rtxc.c   2986    {
                       8334 ; rtxc.c   2987       return(frame); /* return to rtxc or isr */
                       8335 ; rtxc.c   2988    }
                       8336 ; rtxc.c   2989 }
00390E                 8337 _571:
00390E 2F30            8338         POP.W   R4, R5
003910 D680            8339         RET
003910 D680            8339         RET
                       8340 ; rtxc.c   2990 
                       8341 ; rtxc.c   2991 /************************/
                       8342 ; rtxc.c   2992 static FRAME ks_stk *postem(void) /* returns with interrupts disabled */
                       8343 ; rtxc.c   2993 /************************/
                       8344 ; rtxc.c   2994 {
003912                 8345 _postem:
003912 0F70            8346         PUSH.W  R4, R5, R6
003914 A978            8347         ADDS.W  R7,#08H
003914 A978            8347         ADDS.W  R7,#08H
                       8348 ; rtxc.c   2995    unsigned char pswh;  /* local variable for saving processor priority level */
                       8349 ; rtxc.c   2996    TICKS tcnt, xx;
                       8350 ; rtxc.c   2997    SEMA sema;
                       8351 ; rtxc.c   2998    TASK task;
                       8352 ; rtxc.c   2999    SSTATE ks_tbl *sema_ptr;
                       8353 ; rtxc.c   3000    TCB ks_tbl *ptcb;
                       8354 ; rtxc.c   3001    TCB ks_tbl *prev;
                       8355 ; rtxc.c   3002    KSNUM ks_stk *p2a;
                       8356 ; rtxc.c   3003    CLKBLK ks_clk *pclkblk;
                       8357 ; rtxc.c   3004 #ifdef HAS_WAITM /* { */
                       8358 ; rtxc.c   3005    const SEMA *list;
                       8359 ; rtxc.c   3006 #endif /* } HAS_WAITM */
                       8360 ; rtxc.c   3007 #ifdef RESOURCE_TIMEOUTS /* { */
                       8361 ; rtxc.c   3008    KSNUM ks_stk *p2;
                       8362 ; rtxc.c   3009 #ifdef PRIORITY_INVERSION /* { */
                       8363 ; rtxc.c   3010     RESOURCE resource;
                       8364 ; rtxc.c   3011     RHEADER ks_tbl *prh;
                       8365 ; rtxc.c   3012     PRIORITY priority;
                       8366 ; rtxc.c   3013 #endif /* } PRIORITY_INVERSION */
                       8367 ; rtxc.c   3014 #endif /* } RESOURCE_TIMEOUTS */
                       8368 ; rtxc.c   3015 
                       8369 ; rtxc.c   3016    for (;;)
003916                 8370 _573:
                       8371 ; rtxc.c   3017    {
                       8372 ; rtxc.c   3018       PUSHPSWH;    /* save current processor priority level */
003916 860401          8373         MOV.B   R0L,0401H
                       8374 ; rtxc.c   3019       DISABLE;
003919 9648018D        8375         MOV.B   0401H,#08DH
                       8376 ; rtxc.c   3020 
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 147

ADDR   CODE            LINE SOURCELINE
                       8377 ; rtxc.c   3021       if (t_expired) /* if timer expired with last clock interrupt ... */
00391D 964842rr        8378         MOV.B   ES,#SEG( _t_expired )
003921 9918rrrr        8379         MOV.W   R1,#SOF( _t_expired )
003925 8211            8380         MOV.B   R0H,[R1]
                       8381         BEQ     _605
003927 F202           +8381 ;       BNE     _LG_580
003929 D501F4         +8381 ;       JMP.L   _605
00392C D501F4         +8381 ;       JMP.L   _605
00392C                +8381 _LG_580:
                       8382 ; rtxc.c   3022       {
                       8383 ; rtxc.c   3023          t_expired = 0;
00392C 964842rr        8384         MOV.B   ES,#SEG( _t_expired )
003930 9918rrrr        8385         MOV.W   R1,#SOF( _t_expired )
003934 B210            8386         MOV.B   [R1],#00H
                       8387 ; rtxc.c   3024          tcnt = rtctick; /* local copy of rtctick */
003936 964842rr        8388         MOV.B   ES,#SEG( _rtctick )
00393A 9968rrrr        8389         MOV.W   R6,#SOF( _rtctick )
00393E 8A66            8390         MOV.W   R6,[R6]
                       8391 ; rtxc.c   3025          POPPSWH;
003940 860C01          8392         MOV.B   0401H,R0L
                       8393 ; rtxc.c   3026 
                       8394 ; rtxc.c   3027 /*
                       8395 ; rtxc.c   3028  * xx is used in the following statement because some compilers can't
                       8396 ; rtxc.c   3029  * properly handle the arithmetic when negative values are involved
                       8397 ; rtxc.c   3030 */
                       8398 ; rtxc.c   3031          while ( (clkqptr != NULLCLK) && ((xx = tcnt-clkqptr->remain) >= 0) )
003943 964842rr        8399         MOV.B   ES,#SEG( _clkqptr )
003947 9918rrrr        8400         MOV.W   R1,#SOF( _clkqptr )
00394B 8B01            8401         MOV.W   R0,[R1+]
00394D 8A11            8402         MOV.W   R1,[R1]
00394F 8931            8403         MOV.W   R3,R1
003951 8920            8404         MOV.W   R2,R0
003953 6910            8405         OR.W    R1,R0
                       8406         BEQ     _601
003955 F202           +8406 ;       BNE     _LG_582
003957 D50195         +8406 ;       JMP.L   _601
00395A D50195         +8406 ;       JMP.L   _601
00395A                +8406 _LG_582:
00395A 8906            8407         MOV.W   R0,R6
00395C 866C42          8408         MOV.B   ES,R3L
00395F 2C0208          8409         SUB.W   R0,[R2+8]
003962 99040000        8410         CMP.W   R0,#00H
                       8411         BLT     _601
003966 FA02           +8411 ;       BGE     _LG_584
003968 D5018D         +8411 ;       JMP.L   _601
00396C D5018D00       +8411 ;       JMP.L   _601
00396C                +8411 _LG_584:
00396C                +8411 _LG_584:
00396C                 8412 _574:
                       8413 ; rtxc.c   3032          {
                       8414 ; rtxc.c   3033             pclkblk = clkqptr; /* save address of expired timer */
00396C 964842rr        8415         MOV.B   ES,#SEG( _clkqptr )
003970 9918rrrr        8416         MOV.W   R1,#SOF( _clkqptr )
003974 8B01            8417         MOV.W   R0,[R1+]
003976 8A11            8418         MOV.W   R1,[R1]
                       8419 ; rtxc.c   3034 
                       8420 ; rtxc.c   3035             PUSHPSWH;    /* save current processor priority level */
003978 868401          8421         MOV.B   R4L,0401H
                       8422 ; rtxc.c   3036             DISABLE;
00397B 9648018D        8423         MOV.B   0401H,#08DH
                       8424 ; rtxc.c   3037             /* unlink expired timer with interrupts disabled */
                       8425 ; rtxc.c   3038             if ( (clkqptr = clkqptr->flink) != NULLCLK)
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 148

ADDR   CODE            LINE SOURCELINE
00397F 862C42          8426         MOV.B   ES,R1L
003982 8A20            8427         MOV.W   R2,[R0]
003984 8C3002          8428         MOV.W   R3,[R0+2]
003987 8C1F02          8429         MOV.W   [R7+2],R1
00398A 8A0F            8430         MOV.W   [R7],R0
00398C 964842rr        8431         MOV.B   ES,#SEG( _clkqptr )
003990 9908rrrr        8432         MOV.W   R0,#SOF( _clkqptr )
003994 8B28            8433         MOV.W   [R0+],R2
003996 8A38            8434         MOV.W   [R0],R3
003998 8C3F06          8435         MOV.W   [R7+6],R3
00399B 8C2F04          8436         MOV.W   [R7+4],R2
00399E 6932            8437         OR.W    R3,R2
0039A0 F30C            8438         BEQ     _575
                       8439 ; rtxc.c   3039                 clkqptr->blink = (CLKBLK ks_clk *)&clkqptr;
0039A2 9918rrrr        8440         MOV.W   R1,#SEG( _clkqptr )
0039A6 9908rrrr        8441         MOV.W   R0,#SOF( _clkqptr )
0039AA 8C3706          8442         MOV.W   R3,[R7+6]
0039AD 8C2704          8443         MOV.W   R2,[R7+4]
0039B0 866C42          8444         MOV.B   ES,R3L
0039B3 8C0A04          8445         MOV.W   [R2+4],R0
0039B6 8C1A06          8446         MOV.W   [R2+6],R1
0039B6 8C1A0600        8446         MOV.W   [R2+6],R1
0039BA                 8447 _575:
                       8448 ; rtxc.c   3040             POPPSWH;
0039BA 868C01          8449         MOV.B   0401H,R4L
                       8450 ; rtxc.c   3041 
                       8451 ; rtxc.c   3042             pclkblk->state = TIMER_DONE;
0039BD 8C1702          8452         MOV.W   R1,[R7+2]
0039C0 8A07            8453         MOV.W   R0,[R7]
0039C2 862C42          8454         MOV.B   ES,R1L
0039C5 B4000D          8455         MOV.B   [R0+13],#00H
                       8456 ; rtxc.c   3043 
                       8457 ; rtxc.c   3044 /* force the compiler to generate a JUMP TABLE - deterministic */
                       8458 ; rtxc.c   3045 #pragma optimize t
                       8459 ; rtxc.c   3046 
                       8460 ; rtxc.c   3047             switch(pclkblk->objtype)
0039C8 862C42          8461         MOV.B   ES,R1L
0039CB 8C200E          8462         MOV.W   R2,[R0+14]
0039CE 99240006        8463         CMP.W   R2,#06H
0039D2 F31C            8464         BEQ     _576
0039D4 99240000        8465         CMP.W   R2,#00H
0039D8 F33D            8466         BEQ     _577
0039DA 99240001        8467         CMP.W   R2,#01H
0039DE F366            8468         BEQ     _578
0039E0 99240003        8469         CMP.W   R2,#03H
                       8470         BEQ     _582
0039E4 F202           +8470 ;       BNE     _LG_594
0039E6 D5009A         +8470 ;       JMP.L   _582
0039EA D5009A00       +8470 ;       JMP.L   _582
0039EA                +8470 _LG_594:
0039EA 99240002        8471         CMP.W   R2,#02H
                       8472         BEQ     _582
0039EE F202           +8472 ;       BNE     _LG_596
0039F0 D50095         +8472 ;       JMP.L   _582
0039F4 D5009500       +8472 ;       JMP.L   _582
0039F4                +8472 _LG_596:
0039F4 99240004        8473         CMP.W   R2,#04H
                       8474         BEQ     _582
0039F8 F202           +8474 ;       BNE     _LG_598
0039FA D50090         +8474 ;       JMP.L   _582
0039FE D5009000       +8474 ;       JMP.L   _582
0039FE                +8474 _LG_598:
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 149

ADDR   CODE            LINE SOURCELINE
0039FE 99240005        8475         CMP.W   R2,#05H
                       8476         BEQ     _582
003A02 F202           +8476 ;       BNE     _LG_600
003A04 D5008B         +8476 ;       JMP.L   _582
003A08 D5008B00       +8476 ;       JMP.L   _582
003A08                +8476 _LG_600:
                       8477         BR      _598
003A08 D5012A         +8477         JMP.L   _598
003A08 D5012A00       +8477         JMP.L   _598
                       8478 ; rtxc.c   3048             {
                       8479 ; rtxc.c   3049                case TIMER_OBJ:
003A0C                 8480 _576:
                       8481 ; rtxc.c   3050                   SIGNAL(pclkblk->objid); /* put semaphore in signal list */
003A0C 864401          8482         MOV.B   R2L,0401H
003A0F 9648018D        8483         MOV.B   0401H,#08DH
003A13 8C1702          8484         MOV.W   R1,[R7+2]
003A16 8A07            8485         MOV.W   R0,[R7]
003A18 862C42          8486         MOV.B   ES,R1L
003A1B 845010          8487         MOV.B   R2H,[R0+16]
003A1E 9Er0rr0001      8488         ADD.W   _semaput,#01H
003A23 8E5rrr          8489         MOV.W   R5,_semaput+2
003A26 8E4rrr          8490         MOV.W   R4,_semaput
003A29 86AC42          8491         MOV.B   ES,R5L
003A2C 825C            8492         MOV.B   [R4],R2H
003A2E 8E5rrr          8493         MOV.W   _semaput+2,R5
003A31 8E4rrr          8494         MOV.W   _semaput,R4
003A34 864C01          8495         MOV.B   0401H,R2L
                       8496 ; rtxc.c   3051 
                       8497 ; rtxc.c   3052                   if (pclkblk->recycle)         /* if timer is cyclic */
003A37 8C3702          8498         MOV.W   R3,[R7+2]
003A3A 8A27            8499         MOV.W   R2,[R7]
003A3C 9920000A        8500         ADD.W   R2,#0AH
003A40 8C1702          8501         MOV.W   R1,[R7+2]
003A43 8A07            8502         MOV.W   R0,[R7]
003A45 862C42          8503         MOV.B   ES,R1L
003A48 8C400A          8504         MOV.W   R4,[R0+10]
                       8505         BEQ     _598
003A4B F202           +8505 ;       BNE     _LG_602
003A4D D50107         +8505 ;       JMP.L   _598
003A50 D50107         +8505 ;       JMP.L   _598
003A50                +8505 _LG_602:
                       8506 ; rtxc.c   3053                   {
                       8507 ; rtxc.c   3054                      pclkblk->remain = pclkblk->recycle; /* reset counts */
                       8508 ; rtxc.c   3055 
                       8509 ; rtxc.c   3056                      /* insert clk timer */
                       8510 ; rtxc.c   3057                      insert_timer(pclkblk);
                       8511 ; rtxc.c   3058                   }
                       8512 ; rtxc.c   3059                   break;
                       8513         BR      _590
003A50 D500FC         +8513         JMP.L   _590
003A50 D500FC00       +8513         JMP.L   _590
                       8514 ; rtxc.c   3060 
                       8515 ; rtxc.c   3061                case DELAY_OBJ:
003A54                 8516 _577:
                       8517 ; rtxc.c   3062                   ptcb = (TCB ks_tbl *)&rtxtcb[pclkblk->task];
003A54 8C1702          8518         MOV.W   R1,[R7+2]
003A57 8A07            8519         MOV.W   R0,[R7]
003A59 862C42          8520         MOV.B   ES,R1L
003A5C 84000C          8521         MOV.B   R0L,[R0+12]
003A5F 9019            8522         SEXT.B  R0H
003A61 E9000024        8523         MULU.W  R0,#024H
003A65 B910            8524         MOVS.W  R1,#00H
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 150

ADDR   CODE            LINE SOURCELINE
003A67 9938rrrr        8525         MOV.W   R3,#SEG( _rtxtcb )
003A6B 9928rrrr        8526         MOV.W   R2,#SOF( _rtxtcb )
003A6F 0920            8527         ADD.W   R2,R0
                       8528 ; rtxc.c   3063 
                       8529 ; rtxc.c   3064                   ptcb->pclkblk = NULLCLK;
003A71 866C42          8530         MOV.B   ES,R3L
003A74 BC2008          8531         MOV.W   [R2+8],#00H
003A77 BC200A          8532         MOV.W   [R2+10],#00H
                       8533 ; rtxc.c   3065 
                       8534 ; rtxc.c   3066                   if ( (ptcb->status &= ~DELAY_WAIT) == READY)
003A7A 866C42          8535         MOV.B   ES,R3L
003A7D 8C0212          8536         MOV.W   R0,[R2+18]
003A80 9905FFFB        8537         AND.W   R0,#0FFFBH
003A84 866C42          8538         MOV.B   ES,R3L
003A87 9C2512FFFB      8539         AND.W   [R2+18],#0FFFBH
003A8C 6900            8540         OR.W    R0,R0
                       8541         BNE     _598
003A8E F302           +8541 ;       BEQ     _LG_604
003A90 D500E6         +8541 ;       JMP.L   _598
003A94 D500E600       +8541 ;       JMP.L   _598
003A94                +8541 _LG_604:
                       8542 ; rtxc.c   3067                   {
                       8543 ; rtxc.c   3068                      /* insert task into insert list */
                       8544 ; rtxc.c   3069                      ptcb->flink = nsrttcb;
003A94 8E1rrr          8545         MOV.W   R1,_nsrttcb+2
003A97 8E0rrr          8546         MOV.W   R0,_nsrttcb
003A9A 866C42          8547         MOV.B   ES,R3L
003A9D 8A0A            8548         MOV.W   [R2],R0
003A9F 8C1A02          8549         MOV.W   [R2+2],R1
                       8550 ; rtxc.c   3070                      nsrttcb = ptcb;
003AA2 8E3rrr          8551         MOV.W   _nsrttcb+2,R3
003AA5 8E2rrr          8552         MOV.W   _nsrttcb,R2
                       8553 ; rtxc.c   3071                   }
                       8554 ; rtxc.c   3072                   break;
                       8555         BR      _598
003AA8 D500DA         +8555         JMP.L   _598
003AA8 D500DA00       +8555         JMP.L   _598
                       8556 ; rtxc.c   3073 
                       8557 ; rtxc.c   3074 #ifdef SEMAPHORE_TIMEOUTS /* { */
                       8558 ; rtxc.c   3075                case SEMAPHORE_OBJ: /* KS_waitt() and KS_sendt() */
003AAC                 8559 _578:
                       8560 ; rtxc.c   3076                   semat[pclkblk->objid] = SEMA_PENDING;
003AAC 8C1702          8561         MOV.W   R1,[R7+2]
003AAF 8A07            8562         MOV.W   R0,[R7]
003AB1 862C42          8563         MOV.B   ES,R1L
003AB4 844010          8564         MOV.B   R2L,[R0+16]
003AB7 B150            8565         MOVS.B  R2H,#00H
003AB9 B930            8566         MOVS.W  R3,#00H
003ABB 964842rr        8567         MOV.B   ES,#SEG( _semat )
003ABF 9528rrrrFF      8568         MOV.B   [R2+SOF( _semat )],#0FFH
                       8569 ; rtxc.c   3077 
                       8570 ; rtxc.c   3078                   ptcb = (TCB ks_tbl *)&rtxtcb[pclkblk->task];
003AC4 8C1702          8571         MOV.W   R1,[R7+2]
003AC7 8A07            8572         MOV.W   R0,[R7]
003AC9 862C42          8573         MOV.B   ES,R1L
003ACC 84000C          8574         MOV.B   R0L,[R0+12]
003ACF 9019            8575         SEXT.B  R0H
003AD1 E9000024        8576         MULU.W  R0,#024H
003AD5 B910            8577         MOVS.W  R1,#00H
003AD7 9938rrrr        8578         MOV.W   R3,#SEG( _rtxtcb )
003ADB 9928rrrr        8579         MOV.W   R2,#SOF( _rtxtcb )
003ADF 0920            8580         ADD.W   R2,R0
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 151

ADDR   CODE            LINE SOURCELINE
                       8581 ; rtxc.c   3079 
                       8582 ; rtxc.c   3080                   ptcb->pclkblk = NULLCLK;
003AE1 866C42          8583         MOV.B   ES,R3L
003AE4 BC2008          8584         MOV.W   [R2+8],#00H
003AE7 BC200A          8585         MOV.W   [R2+10],#00H
                       8586 ; rtxc.c   3081 
                       8587 ; rtxc.c   3082                   if ( (ptcb->status &= ~SEMAPHORE_WAIT) == READY)
003AEA 866C42          8588         MOV.B   ES,R3L
003AED 8C0212          8589         MOV.W   R0,[R2+18]
003AF0 9905FFBF        8590         AND.W   R0,#0FFBFH
003AF4 866C42          8591         MOV.B   ES,R3L
003AF7 9C2512FFBF      8592         AND.W   [R2+18],#0FFBFH
003AFC 6900            8593         OR.W    R0,R0
                       8594         BNE     _598
003AFE F302           +8594 ;       BEQ     _LG_606
003B00 D500AE         +8594 ;       JMP.L   _598
003B04 D500AE00       +8594 ;       JMP.L   _598
003B04                +8594 _LG_606:
                       8595 ; rtxc.c   3083                   {
                       8596 ; rtxc.c   3084                      /* insert task into insert list */
                       8597 ; rtxc.c   3085                      ptcb->flink = nsrttcb;
003B04 8E1rrr          8598         MOV.W   R1,_nsrttcb+2
003B07 8E0rrr          8599         MOV.W   R0,_nsrttcb
003B0A 866C42          8600         MOV.B   ES,R3L
003B0D 8A0A            8601         MOV.W   [R2],R0
003B0F 8C1A02          8602         MOV.W   [R2+2],R1
                       8603 ; rtxc.c   3086                      nsrttcb = ptcb;
003B12 8E3rrr          8604         MOV.W   _nsrttcb+2,R3
003B15 8E2rrr          8605         MOV.W   _nsrttcb,R2
                       8606 ; rtxc.c   3087                   }
                       8607 ; rtxc.c   3088                   break;
                       8608         BR      _598
003B18 D500A2         +8608         JMP.L   _598
003B18 D500A200       +8608         JMP.L   _598
                       8609 ; rtxc.c   3089 #endif /* } SEMAPHORE_TIMEOUTS */
                       8610 ; rtxc.c   3090 
                       8611 ; rtxc.c   3091 #ifdef QUEUE_TIMEOUTS /* { */
                       8612 ; rtxc.c   3092                case QUEUE_OBJ:     /* KS_enqueuet() and KS_dequeuet() */
                       8613 ; rtxc.c   3093                   /* fall into common code */
                       8614 ; rtxc.c   3094 #endif /* } QUEUE_TIMEOUTS */
                       8615 ; rtxc.c   3095 
                       8616 ; rtxc.c   3096 #ifdef PARTITION_TIMEOUTS /* { */
                       8617 ; rtxc.c   3097                case PARTITION_OBJ: /* KS_alloct() */
                       8618 ; rtxc.c   3098                   /* fall into common code */
                       8619 ; rtxc.c   3099 #endif /* } PARTITION_TIMEOUTS */
                       8620 ; rtxc.c   3100 
                       8621 ; rtxc.c   3101 #ifdef RESOURCE_TIMEOUTS /* { */
                       8622 ; rtxc.c   3102                case RESOURCE_OBJ:  /* KS_lockt() */
                       8623 ; rtxc.c   3103                   /* fall into common code */
                       8624 ; rtxc.c   3104 #endif /* } RESOURCE_TIMEOUTS */
                       8625 ; rtxc.c   3105 
                       8626 ; rtxc.c   3106 #ifdef MAILBOX_TIMEOUTS /* { */
                       8627 ; rtxc.c   3107                case MAILBOX_OBJ:   /* KS_receivet() */
003B1C                 8628 _582:
                       8629 ; rtxc.c   3108                   /* fall into common code */
                       8630 ; rtxc.c   3109 #endif /* } MAILBOX_TIMEOUTS */
                       8631 ; rtxc.c   3110 
                       8632 ; rtxc.c   3111 #if defined(MAILBOX_TIMEOUTS)   || \ 
                       8633 ; rtxc.c   3112     defined(PARTITION_TIMEOUTS) || \ 
                       8634 ; rtxc.c   3113     defined(QUEUE_TIMEOUTS)     || \ 
                       8635 ; rtxc.c   3114     defined(RESOURCE_TIMEOUTS) /* { */
                       8636 ; rtxc.c   3115                   /* common code */
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 152

ADDR   CODE            LINE SOURCELINE
                       8637 ; rtxc.c   3116                   ptcb = (TCB ks_tbl *)&rtxtcb[pclkblk->task];
003B1C 8C1702          8638         MOV.W   R1,[R7+2]
003B1F 8A07            8639         MOV.W   R0,[R7]
003B21 862C42          8640         MOV.B   ES,R1L
003B24 84000C          8641         MOV.B   R0L,[R0+12]
003B27 9019            8642         SEXT.B  R0H
003B29 E9000024        8643         MULU.W  R0,#024H
003B2D B910            8644         MOVS.W  R1,#00H
003B2F 9958rrrr        8645         MOV.W   R5,#SEG( _rtxtcb )
003B33 9948rrrr        8646         MOV.W   R4,#SOF( _rtxtcb )
003B37 0940            8647         ADD.W   R4,R0
                       8648 ; rtxc.c   3117 
                       8649 ; rtxc.c   3118 #ifdef RESOURCE_TIMEOUTS /* { */
                       8650 ; rtxc.c   3119                   if (pclkblk->objtype == RESOURCE_OBJ)
003B39 99240004        8651         CMP.W   R2,#04H
003B3D F250            8652         BNE     _588
                       8653 ; rtxc.c   3120                   {
                       8654 ; rtxc.c   3121                      /* mark KS_lockt() failure */
                       8655 ; rtxc.c   3122                      p2 = ptcb->sp->pksnum;
003B3F 86AC42          8656         MOV.B   ES,R5L
003B42 8C040E          8657         MOV.W   R0,[R4+14]
003B45 8C1410          8658         MOV.W   R1,[R4+16]
003B48 862C42          8659         MOV.B   ES,R1L
003B4B 8C1006          8660         MOV.W   R1,[R0+6]
003B4E 8C0004          8661         MOV.W   R0,[R0+4]
                       8662 ; rtxc.c   3123 
                       8663 ; rtxc.c   3124                      ((struct larg ks_stk *)p2)->ksrc = RC_TIMEOUT;
003B51 862C42          8664         MOV.B   ES,R1L
003B54 BC0502          8665         MOV.W   [R0+2],#05H
                       8666 ; rtxc.c   3125 
                       8667 ; rtxc.c   3126 #ifdef PRIORITY_INVERSION /* { */
                       8668 ; rtxc.c   3127                      resource = ((struct larg ks_stk *)p2)->resource;
003B57 862C42          8669         MOV.B   ES,R1L
003B5A 840004          8670         MOV.B   R0L,[R0+4]
                       8671 ; rtxc.c   3128                      prh = (RHEADER ks_tbl *)&rheader[resource];
003B5D E80012          8672         MULU.B  R0L,#012H
003B60 B910            8673         MOVS.W  R1,#00H
003B62 9938rrrr        8674         MOV.W   R3,#SEG( _rheader )
003B66 9928rrrr        8675         MOV.W   R2,#SOF( _rheader )
003B6A 0920            8676         ADD.W   R2,R0
                       8677 ; rtxc.c   3129 
                       8678 ; rtxc.c   3130                      /* if task that owns resource is priority inverted */
                       8679 ; rtxc.c   3131                      if (prh->priority != (PRIORITY)0)
003B6C 8913            8680         MOV.W   R1,R3
003B6E 8902            8681         MOV.W   R0,R2
003B70 862C42          8682         MOV.B   ES,R1L
003B73 84500E          8683         MOV.B   R2H,[R0+14]
003B76 F333            8684         BEQ     _588
                       8685 ; rtxc.c   3132                      {
                       8686 ; rtxc.c   3133                         /*
                       8687 ; rtxc.c   3134                          * then determine if the task was inverted because
                       8688 ; rtxc.c   3135                          * of the lockt() that just timed-out. If so, then
                       8689 ; rtxc.c   3136                          * determine what priority to change to.  The new
                       8690 ; rtxc.c   3137                          * priority will be either the original or that of
                       8691 ; rtxc.c   3138                          * the next task waiting on the resource (if any).
                       8692 ; rtxc.c   3139                         */
                       8693 ; rtxc.c   3140 
                       8694 ; rtxc.c   3141                         if (prh->waiters == ptcb)
003B78 862C42          8695         MOV.B   ES,R1L
003B7B 4C5808          8696         CMP.W   [R0+8],R5
003B7E F202            8697         BNE     _628
003B80 4C4806          8698         CMP.W   [R0+6],R4
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 153

ADDR   CODE            LINE SOURCELINE
003B80 4C480600        8698         CMP.W   [R0+6],R4
003B84                 8699 _628:
003B84 F22C            8700         BNE     _588
                       8701 ; rtxc.c   3142                         {
                       8702 ; rtxc.c   3143                            if (prh->waiters->flink != NULLTCB)
003B86 8C1F06          8703         MOV.W   [R7+6],R1
003B89 8C0F04          8704         MOV.W   [R7+4],R0
003B8C 862C42          8705         MOV.B   ES,R1L
003B8F 8C1008          8706         MOV.W   R1,[R0+8]
003B92 8C0006          8707         MOV.W   R0,[R0+6]
003B95 862C42          8708         MOV.B   ES,R1L
003B98 8C1002          8709         MOV.W   R1,[R0+2]
003B9B 8A00            8710         MOV.W   R0,[R0]
003B9D 6910            8711         OR.W    R1,R0
003B9F F315            8712         BEQ     _583
                       8713 ; rtxc.c   3144                            {
                       8714 ; rtxc.c   3145                               priority = prh->waiters->flink->priority;
003BA1 8C1706          8715         MOV.W   R1,[R7+6]
003BA4 8C0704          8716         MOV.W   R0,[R7+4]
003BA7 862C42          8717         MOV.B   ES,R1L
003BAA 8C1008          8718         MOV.W   R1,[R0+8]
003BAD 8C0006          8719         MOV.W   R0,[R0+6]
003BB0 862C42          8720         MOV.B   ES,R1L
003BB3 8C1002          8721         MOV.W   R1,[R0+2]
003BB6 8A00            8722         MOV.W   R0,[R0]
003BB8 862C42          8723         MOV.B   ES,R1L
003BBB 84400D          8724         MOV.B   R2L,[R0+13]
                       8725 ; rtxc.c   3146                               if (priority > prh->priority)
003BBE 862C42          8726         MOV.B   ES,R1L
003BC1 44580D          8727         CMP.B   [R0+13],R2H
003BC4 FD03            8728         BLE     _585
                       8729 ; rtxc.c   3147                                  priority = prh->priority;
003BC6 8145            8730         MOV.B   R2L,R2H
                       8731 ; rtxc.c   3148                            }
003BC8 FE01            8732         BR      _585
003BC8 FE01            8732         BR      _585
003BCA                 8733 _583:
                       8734 ; rtxc.c   3149                            else
                       8735 ; rtxc.c   3150                               priority = prh->priority;
003BCA 8145            8736         MOV.B   R2L,R2H
003BCA 8145            8736         MOV.B   R2L,R2H
003BCC                 8737 _585:
                       8738 ; rtxc.c   3151 
                       8739 ; rtxc.c   3152                            chgpriority(prh->owner, priority);
003BCC 8C1706          8740         MOV.W   R1,[R7+6]
003BCF 8C0704          8741         MOV.W   R0,[R7+4]
003BD2 862C42          8742         MOV.B   ES,R1L
003BD5 8C1002          8743         MOV.W   R1,[R0+2]
003BD8 8A00            8744         MOV.W   R0,[R0]
003BDA C504FF          8745         CALL    _chgpriority
003BDA C504FF00        8745         CALL    _chgpriority
                       8746 ; rtxc.c   3153                         }
                       8747 ; rtxc.c   3154                      }
                       8748 ; rtxc.c   3155 #endif /* } PRIORITY_INVERSION */
                       8749 ; rtxc.c   3156                   }
003BDE                 8750 _588:
                       8751 ; rtxc.c   3157 #endif /* } RESOURCE_TIMEOUTS */
                       8752 ; rtxc.c   3158 
                       8753 ; rtxc.c   3159                   ptcb->pclkblk = NULLCLK;
003BDE 86AC42          8754         MOV.B   ES,R5L
003BE1 BC4008          8755         MOV.W   [R4+8],#00H
003BE4 BC400A          8756         MOV.W   [R4+10],#00H
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 154

ADDR   CODE            LINE SOURCELINE
                       8757 ; rtxc.c   3160 
                       8758 ; rtxc.c   3161                   /* remove tcb from 2-way waiter list */
                       8759 ; rtxc.c   3162                   if ( (ptcb->blink->flink = ptcb->flink) != NULLTCB)
003BE7 86AC42          8760         MOV.B   ES,R5L
003BEA 8A04            8761         MOV.W   R0,[R4]
003BEC 8C1402          8762         MOV.W   R1,[R4+2]
003BEF 86AC42          8763         MOV.B   ES,R5L
003BF2 8C2404          8764         MOV.W   R2,[R4+4]
003BF5 8C3406          8765         MOV.W   R3,[R4+6]
003BF8 866C42          8766         MOV.B   ES,R3L
003BFB 8A0A            8767         MOV.W   [R2],R0
003BFD 8C1A02          8768         MOV.W   [R2+2],R1
003C00 6910            8769         OR.W    R1,R0
003C02 F30D            8770         BEQ     _589
                       8771 ; rtxc.c   3163                      ptcb->flink->blink = ptcb->blink;
003C04 86AC42          8772         MOV.B   ES,R5L
003C07 8C0404          8773         MOV.W   R0,[R4+4]
003C0A 8C1406          8774         MOV.W   R1,[R4+6]
003C0D 86AC42          8775         MOV.B   ES,R5L
003C10 8A24            8776         MOV.W   R2,[R4]
003C12 8C3402          8777         MOV.W   R3,[R4+2]
003C15 866C42          8778         MOV.B   ES,R3L
003C18 8C0A04          8779         MOV.W   [R2+4],R0
003C1B 8C1A06          8780         MOV.W   [R2+6],R1
003C1B 8C1A06          8780         MOV.W   [R2+6],R1
003C1E                 8781 _589:
                       8782 ; rtxc.c   3164 
                       8783 ; rtxc.c   3165                   if ( (ptcb->status &= ~COMBO_WAIT) == READY)
003C1E 86AC42          8784         MOV.B   ES,R5L
003C21 8C0412          8785         MOV.W   R0,[R4+18]
003C24 9905FF55        8786         AND.W   R0,#0FF55H
003C28 86AC42          8787         MOV.B   ES,R5L
003C2B 9C4512FF55      8788         AND.W   [R4+18],#0FF55H
003C30 6900            8789         OR.W    R0,R0
003C32 F215            8790         BNE     _598
                       8791 ; rtxc.c   3166                   {
                       8792 ; rtxc.c   3167                      /* insert task into insert list */
                       8793 ; rtxc.c   3168                      ptcb->flink = nsrttcb;
003C34 8E1rrr          8794         MOV.W   R1,_nsrttcb+2
003C37 8E0rrr          8795         MOV.W   R0,_nsrttcb
003C3A 86AC42          8796         MOV.B   ES,R5L
003C3D 8A0C            8797         MOV.W   [R4],R0
003C3F 8C1C02          8798         MOV.W   [R4+2],R1
                       8799 ; rtxc.c   3169                      nsrttcb = ptcb;
003C42 8E5rrr          8800         MOV.W   _nsrttcb+2,R5
003C45 8E4rrr          8801         MOV.W   _nsrttcb,R4
                       8802 ; rtxc.c   3170                   }
                       8803 ; rtxc.c   3171                   break;
003C48 FE0A            8804         BR      _598
003C48 FE0A            8804         BR      _598
003C4A                 8805 _590:
003C4A 866C42          8806         MOV.B   ES,R3L
003C4D 8A22            8807         MOV.W   R2,[R2]
003C4F 8C1702          8808         MOV.W   R1,[R7+2]
003C52 8A07            8809         MOV.W   R0,[R7]
003C54 862C42          8810         MOV.B   ES,R1L
003C57 8C2808          8811         MOV.W   [R0+8],R2
003C5A C50227          8812         CALL    _insert_timer
003C5A C5022700        8812         CALL    _insert_timer
                       8813 ; rtxc.c   3172 #endif /* } - MAILBOX_ || PARTITION_ || QUEUE_ || RESOURCE_TIMEOUTS */
                       8814 ; rtxc.c   3173 
                       8815 ; rtxc.c   3174                default: /* serious trouble here - undefined type */
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 155

ADDR   CODE            LINE SOURCELINE
                       8816 ; rtxc.c   3175                   break;
                       8817 ; rtxc.c   3176             }
003C5E                 8818 _598:
003C5E 964842rr        8819         MOV.B   ES,#SEG( _clkqptr )
003C62 9918rrrr        8820         MOV.W   R1,#SOF( _clkqptr )
003C66 8B01            8821         MOV.W   R0,[R1+]
003C68 8A11            8822         MOV.W   R1,[R1]
003C6A 8931            8823         MOV.W   R3,R1
003C6C 8920            8824         MOV.W   R2,R0
003C6E 6910            8825         OR.W    R1,R0
003C70 F309            8826         BEQ     _601
003C72 8906            8827         MOV.W   R0,R6
003C74 866C42          8828         MOV.B   ES,R3L
003C77 2C0208          8829         SUB.W   R0,[R2+8]
003C7A 99040000        8830         CMP.W   R0,#00H
                       8831         BGE     _574
003C7E FB02           +8831 ;       BLT     _LG_626
003C80 D5FE75         +8831 ;       JMP.L   _574
003C84 D5FE7500       +8831 ;       JMP.L   _574
003C84                +8831 _LG_626:
003C84                +8831 _LG_626:
                       8832 ; rtxc.c   3177 /* end if forcing the compiler to generate a JUMP TABLE - deterministic */
                       8833 ; rtxc.c   3178 #pragma endoptimize
                       8834 ; rtxc.c   3179          }
003C84                 8835 _601:
                       8836 ; rtxc.c   3180 
                       8837 ; rtxc.c   3181 #ifdef TIME_SLICE /* { */
                       8838 ; rtxc.c   3182          if (sliceup != NULLTCB)
003C84 8E1rrr          8839         MOV.W   R1,_sliceup+2
003C87 8E0rrr          8840         MOV.W   R0,_sliceup
003C8A 8931            8841         MOV.W   R3,R1
003C8C 8920            8842         MOV.W   R2,R0
003C8E 6910            8843         OR.W    R1,R0
003C90 F33D            8844         BEQ     _604
                       8845 ; rtxc.c   3183          {
                       8846 ; rtxc.c   3184             if (sliceup->status == READY)
003C92 866C42          8847         MOV.B   ES,R3L
003C95 8C0212          8848         MOV.W   R0,[R2+18]
003C98 F236            8849         BNE     _603
                       8850 ; rtxc.c   3185             {
                       8851 ; rtxc.c   3186                if (sliceup->priority == sliceup->flink->priority)
003C9A 866C42          8852         MOV.B   ES,R3L
003C9D 8A02            8853         MOV.W   R0,[R2]
003C9F 8C1202          8854         MOV.W   R1,[R2+2]
003CA2 862C42          8855         MOV.B   ES,R1L
003CA5 84000D          8856         MOV.B   R0L,[R0+13]
003CA8 866C42          8857         MOV.B   ES,R3L
003CAB 440A0D          8858         CMP.B   [R2+13],R0L
003CAE F22B            8859         BNE     _603
                       8860 ; rtxc.c   3187                {
                       8861 ; rtxc.c   3188                   /* yield sliceup to next task in list */
                       8862 ; rtxc.c   3189 
                       8863 ; rtxc.c   3190                   /* unlink tcb */
                       8864 ; rtxc.c   3191                   sliceup->flink->blink = sliceup->blink;
003CB0 866C42          8865         MOV.B   ES,R3L
003CB3 8C0204          8866         MOV.W   R0,[R2+4]
003CB6 8C1206          8867         MOV.W   R1,[R2+6]
003CB9 866C42          8868         MOV.B   ES,R3L
003CBC 8C3202          8869         MOV.W   R3,[R2+2]
003CBF 8A22            8870         MOV.W   R2,[R2]
003CC1 866C42          8871         MOV.B   ES,R3L
003CC4 8C0A04          8872         MOV.W   [R2+4],R0
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 156

ADDR   CODE            LINE SOURCELINE
003CC7 8C1A06          8873         MOV.W   [R2+6],R1
                       8874 ; rtxc.c   3192                   sliceup->blink->flink = sliceup->flink;
003CCA 8E1rrr          8875         MOV.W   R1,_sliceup+2
003CCD 8E0rrr          8876         MOV.W   R0,_sliceup
003CD0 862C42          8877         MOV.B   ES,R1L
003CD3 8A20            8878         MOV.W   R2,[R0]
003CD5 8C3002          8879         MOV.W   R3,[R0+2]
003CD8 862C42          8880         MOV.B   ES,R1L
003CDB 8C1006          8881         MOV.W   R1,[R0+6]
003CDE 8C0004          8882         MOV.W   R0,[R0+4]
003CE1 862C42          8883         MOV.B   ES,R1L
003CE4 8A28            8884         MOV.W   [R0],R2
003CE6 8C3802          8885         MOV.W   [R0+2],R3
                       8886 ; rtxc.c   3193 
                       8887 ; rtxc.c   3194                   /* re-insert task */
                       8888 ; rtxc.c   3195                   sliceup->flink = nsrttcb;
003CE9 8E1rrr          8889         MOV.W   R1,_nsrttcb+2
003CEC 8E0rrr          8890         MOV.W   R0,_nsrttcb
003CEF 8E3rrr          8891         MOV.W   R3,_sliceup+2
003CF2 8E2rrr          8892         MOV.W   R2,_sliceup
003CF5 866C42          8893         MOV.B   ES,R3L
003CF8 8A0A            8894         MOV.W   [R2],R0
003CFA 8C1A02          8895         MOV.W   [R2+2],R1
                       8896 ; rtxc.c   3196                   nsrttcb = sliceup;
003CFD 9Frrrrrr        8897         MOV.W   _nsrttcb+2,_sliceup+2
003D01 9Frrrrrr        8898         MOV.W   _nsrttcb,_sliceup
003D01 9Frrrrrr00      8898         MOV.W   _nsrttcb,_sliceup
                       8899 ; rtxc.c   3197                }
                       8900 ; rtxc.c   3198             }
003D06                 8901 _603:
                       8902 ; rtxc.c   3199             sliceup = NULLTCB;
003D06 BEr0rr          8903         MOV.W   _sliceup+2,#00H
003D09 BEr0rr          8904         MOV.W   _sliceup,#00H
003D09 BEr0rr          8904         MOV.W   _sliceup,#00H
                       8905 ; rtxc.c   3200          }
003D0C                 8906 _604:
                       8907 ; rtxc.c   3201 #endif /* } TIME_SLICE */
                       8908 ; rtxc.c   3202 
                       8909 ; rtxc.c   3203          PUSHPSWH;    /* save current processor priority level */
003D0C 860401          8910         MOV.B   R0L,0401H
                       8911 ; rtxc.c   3204          DISABLE;
003D0F 9648018D        8912         MOV.B   0401H,#08DH
003D0F 9648018D00      8912         MOV.B   0401H,#08DH
                       8913 ; rtxc.c   3205 
                       8914 ; rtxc.c   3206       }
003D14                 8915 _605:
                       8916 ; rtxc.c   3207 
                       8917 ; rtxc.c   3208       /* check to see if any semaphores to process */
                       8918 ; rtxc.c   3209       while (semaput != semaget)
003D14 8E3rrr          8919         MOV.W   R3,_semaput+2
003D17 8E2rrr          8920         MOV.W   R2,_semaput
003D1A 4E3rrr          8921         CMP.W   R3,_semaget+2
003D1D F202            8922         BNE     _632
003D1F 4E2rrr          8923         CMP.W   R2,_semaget
003D1F 4E2rrr          8923         CMP.W   R2,_semaget
003D22                 8924 _632:
                       8925         BEQ     _619
003D22 F202           +8925 ;       BNE     _LG_636
003D24 D500B9         +8925 ;       JMP.L   _619
003D28 D500B900       +8925 ;       JMP.L   _619
003D28                +8925 _LG_636:
003D28                +8925 _LG_636:
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 157

ADDR   CODE            LINE SOURCELINE
003D28                 8926 _606:
                       8927 ; rtxc.c   3210       {
                       8928 ; rtxc.c   3211          POPPSWH;
003D28 860C01          8929         MOV.B   0401H,R0L
                       8930 ; rtxc.c   3212 
                       8931 ; rtxc.c   3213          sema = *++semaget;     /* get sema from siglist ... */
003D2B 9Er0rr0001      8932         ADD.W   _semaget,#01H
003D30 8E1rrr          8933         MOV.W   R1,_semaget+2
003D33 8E0rrr          8934         MOV.W   R0,_semaget
003D36 862C42          8935         MOV.B   ES,R1L
003D39 82C0            8936         MOV.B   R6L,[R0]
003D3B 8E1rrr          8937         MOV.W   _semaget+2,R1
003D3E 8E0rrr          8938         MOV.W   _semaget,R0
                       8939 ; rtxc.c   3214          sema_ptr = (SSTATE ks_tbl *)&semat[sema];
003D41 810C            8940         MOV.B   R0L,R6L
003D43 B110            8941         MOVS.B  R0H,#00H
003D45 B910            8942         MOVS.W  R1,#00H
003D47 9938rrrr        8943         MOV.W   R3,#SEG( _semat )
003D4B 9928rrrr        8944         MOV.W   R2,#SOF( _semat )
003D4F 0920            8945         ADD.W   R2,R0
                       8946 ; rtxc.c   3215 
                       8947 ; rtxc.c   3216          if ( (*sema_ptr == SEMA_PENDING) || (*sema_ptr == SEMA_DONE) )
003D51 964842rr        8948         MOV.B   ES,#SEG( _semat )
003D55 8500rrrr        8949         MOV.B   R0L,[R0+SOF( _semat )]
003D59 9104FF          8950         CMP.B   R0L,#0FFH
003D5C F302            8951         BEQ     _607
003D5E 6100            8952         OR.B    R0L,R0L
003D60 F204            8953         BNE     _608
003D60 F204            8953         BNE     _608
003D62                 8954 _607:
                       8955 ; rtxc.c   3217             *sema_ptr = SEMA_DONE;
003D62 866C42          8956         MOV.B   ES,R3L
003D65 B220            8957         MOV.B   [R2],#00H
                       8958         BR      _618
003D67 D50088         +8958         JMP.L   _618
003D67 D50088         +8958         JMP.L   _618
003D6A                 8959 _608:
                       8960 ; rtxc.c   3218          else /* sema was found in wait state */
                       8961 ; rtxc.c   3219          {
                       8962 ; rtxc.c   3220             task = *sema_ptr; /* extract waiting task no. */
003D6A 866C42          8963         MOV.B   ES,R3L
003D6D 8202            8964         MOV.B   R0L,[R2]
                       8965 ; rtxc.c   3221 
                       8966 ; rtxc.c   3222             *sema_ptr = SEMA_PENDING; /* reset semaphore pending */
003D6F 866C42          8967         MOV.B   ES,R3L
003D72 9228FF          8968         MOV.B   [R2],#0FFH
                       8969 ; rtxc.c   3223 
                       8970 ; rtxc.c   3224             ptcb = (TCB ks_tbl *)&rtxtcb[task];
003D75 8100            8971         MOV.B   R0L,R0L
003D77 9019            8972         SEXT.B  R0H
003D79 E9000024        8973         MULU.W  R0,#024H
003D7D 8920            8974         MOV.W   R2,R0
003D7F B930            8975         MOVS.W  R3,#00H
003D81 9918rrrr        8976         MOV.W   R1,#SEG( _rtxtcb )
003D85 9908rrrr        8977         MOV.W   R0,#SOF( _rtxtcb )
003D89 0902            8978         ADD.W   R0,R2
                       8979 ; rtxc.c   3225 
                       8980 ; rtxc.c   3226             p2a = ((FRAME ks_stk *)(ptcb->sp))->pksnum;
003D8B 862C42          8981         MOV.B   ES,R1L
003D8E 8C200E          8982         MOV.W   R2,[R0+14]
003D91 8C3010          8983         MOV.W   R3,[R0+16]
003D94 866C42          8984         MOV.B   ES,R3L
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 158

ADDR   CODE            LINE SOURCELINE
003D97 8C4204          8985         MOV.W   R4,[R2+4]
003D9A 8C5206          8986         MOV.W   R5,[R2+6]
                       8987 ; rtxc.c   3227 
                       8988 ; rtxc.c   3228 #ifdef SEMAPHORE_TIMEOUTS /* { */
                       8989 ; rtxc.c   3229             /* if timer associated with semaphore */
                       8990 ; rtxc.c   3230             if ( ((pclkblk = ptcb->pclkblk) != NULLCLK) &&
                       8991 ; rtxc.c   3231                   (pclkblk->objtype == SEMAPHORE_OBJ) &&
                       8992 ; rtxc.c   3232                   (pclkblk->objid == sema) )
003D9D 8C1F06          8993         MOV.W   [R7+6],R1
003DA0 8C0F04          8994         MOV.W   [R7+4],R0
003DA3 862C42          8995         MOV.B   ES,R1L
003DA6 8C100A          8996         MOV.W   R1,[R0+10]
003DA9 8C0008          8997         MOV.W   R0,[R0+8]
003DAC 8931            8998         MOV.W   R3,R1
003DAE 8920            8999         MOV.W   R2,R0
003DB0 6932            9000         OR.W    R3,R2
003DB2 F317            9001         BEQ     _611
003DB4 862C42          9002         MOV.B   ES,R1L
003DB7 9C040E0001      9003         CMP.W   [R0+14],#01H
003DBC F212            9004         BNE     _611
003DBE 862C42          9005         MOV.B   ES,R1L
003DC1 44C810          9006         CMP.B   [R0+16],R6L
003DC4 F20E            9007         BNE     _611
                       9008 ; rtxc.c   3233             {
                       9009 ; rtxc.c   3234                ((struct sarg ks_stk *)p2a)->ksrc = RC_GOOD;
003DC6 8935            9010         MOV.W   R3,R5
003DC8 8924            9011         MOV.W   R2,R4
003DCA 866C42          9012         MOV.B   ES,R3L
003DCD BC2002          9013         MOV.W   [R2+2],#00H
                       9014 ; rtxc.c   3235 
                       9015 ; rtxc.c   3236                unlink_timer(pclkblk);
003DD0 C501E8          9016         CALL    _unlink_timer
                       9017 ; rtxc.c   3237                ptcb->pclkblk = NULLCLK;
003DD3 8C1706          9018         MOV.W   R1,[R7+6]
003DD6 8C0704          9019         MOV.W   R0,[R7+4]
003DD9 862C42          9020         MOV.B   ES,R1L
003DDC BC0008          9021         MOV.W   [R0+8],#00H
003DDF BC000A          9022         MOV.W   [R0+10],#00H
003DDF BC000A          9022         MOV.W   [R0+10],#00H
                       9023 ; rtxc.c   3238             }
003DE2                 9024 _611:
                       9025 ; rtxc.c   3239 #endif /* } SEMAPHORE_TIMEOUTS */
                       9026 ; rtxc.c   3240 
                       9027 ; rtxc.c   3241 #ifdef HAS_WAITM /* { */
                       9028 ; rtxc.c   3242             if ( ((struct sarg ks_stk *)p2a)->ksnum == RTXC_WAITM)
003DE2 8915            9029         MOV.W   R1,R5
003DE4 8904            9030         MOV.W   R0,R4
003DE6 862C42          9031         MOV.B   ES,R1L
003DE9 920422          9032         CMP.B   [R0],#022H
003DEC F226            9033         BNE     _616
                       9034 ; rtxc.c   3243             {
                       9035 ; rtxc.c   3244                /* pass sema back via task stack arg packet */
                       9036 ; rtxc.c   3245                ((struct sarg ks_stk *)p2a)->sema = sema;
003DEE 862C42          9037         MOV.B   ES,R1L
003DF1 84C804          9038         MOV.B   [R0+4],R6L
                       9039 ; rtxc.c   3246 
                       9040 ; rtxc.c   3247                for (list = ((struct sargm ks_stk *)p2a)->list;
003DF4 862C42          9041         MOV.B   ES,R1L
003DF7 8C1008          9042         MOV.W   R1,[R0+8]
003DFA 8C0006          9043         MOV.W   R0,[R0+6]
003DFD 8951            9044         MOV.W   R5,R1
003DFF 8940            9045         MOV.W   R4,R0
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 159

ADDR   CODE            LINE SOURCELINE
003E01 862C42          9046         MOV.B   ES,R1L
003E04 8200            9047         MOV.B   R0L,[R0]
003E06 F319            9048         BEQ     _616
003E06 F319            9048         BEQ     _616
003E08                 9049 _612:
                       9050 ; rtxc.c   3248                     *list != NULLSEMA; list++)
                       9051 ; rtxc.c   3249                {
                       9052 ; rtxc.c   3250                   sema_ptr = (SSTATE ks_tbl *)&semat[*list]; /* get ptr to sema *
                            /
003E08 86AC42          9053         MOV.B   ES,R5L
003E0B 8204            9054         MOV.B   R0L,[R4]
003E0D 8140            9055         MOV.B   R2L,R0L
003E0F B150            9056         MOVS.B  R2H,#00H
003E11 B930            9057         MOVS.W  R3,#00H
                       9058 ; rtxc.c   3251                   if ( (*sema_ptr != SEMA_PENDING) &&
                       9059 ; rtxc.c   3252                        (*sema_ptr != SEMA_DONE) )
003E13 964842rr        9060         MOV.B   ES,#SEG( _semat )
003E17 8502rrrr        9061         MOV.B   R0L,[R2+SOF( _semat )]
003E1B 9104FF          9062         CMP.B   R0L,#0FFH
003E1E F307            9063         BEQ     _614
003E20 6100            9064         OR.B    R0L,R0L
003E22 F305            9065         BEQ     _614
                       9066 ; rtxc.c   3253                      *sema_ptr = SEMA_PENDING;
003E24 964842rr        9067         MOV.B   ES,#SEG( _semat )
003E28 9528rrrrFF      9068         MOV.B   [R2+SOF( _semat )],#0FFH
003E28 9528rrrrFF00    9068         MOV.B   [R2+SOF( _semat )],#0FFH
003E2E                 9069 _614:
003E2E 99400001        9070         ADD.W   R4,#01H
003E32 86AC42          9071         MOV.B   ES,R5L
003E35 8204            9072         MOV.B   R0L,[R4]
003E37 F2E8            9073         BNE     _612
003E37 F2E800          9073         BNE     _612
                       9074 ; rtxc.c   3254                }
                       9075 ; rtxc.c   3255             }
003E3A                 9076 _616:
                       9077 ; rtxc.c   3256 #endif /* } HAS_WAITM */
                       9078 ; rtxc.c   3257 
                       9079 ; rtxc.c   3258             if ( (ptcb->status &= ~SEMAPHORE_WAIT) == READY)
003E3A 8C1706          9080         MOV.W   R1,[R7+6]
003E3D 8C0704          9081         MOV.W   R0,[R7+4]
003E40 862C42          9082         MOV.B   ES,R1L
003E43 8C2012          9083         MOV.W   R2,[R0+18]
003E46 9925FFBF        9084         AND.W   R2,#0FFBFH
003E4A 8C5706          9085         MOV.W   R5,[R7+6]
003E4D 8C4704          9086         MOV.W   R4,[R7+4]
003E50 86AC42          9087         MOV.B   ES,R5L
003E53 9C4512FFBF      9088         AND.W   [R4+18],#0FFBFH
003E58 6922            9089         OR.W    R2,R2
003E5A F20F            9090         BNE     _618
                       9091 ; rtxc.c   3259             {
                       9092 ; rtxc.c   3260                ptcb->flink = nsrttcb;
003E5C 8E1rrr          9093         MOV.W   R1,_nsrttcb+2
003E5F 8E0rrr          9094         MOV.W   R0,_nsrttcb
003E62 8935            9095         MOV.W   R3,R5
003E64 8924            9096         MOV.W   R2,R4
003E66 866C42          9097         MOV.B   ES,R3L
003E69 8A0A            9098         MOV.W   [R2],R0
003E6B 8C1A02          9099         MOV.W   [R2+2],R1
                       9100 ; rtxc.c   3261                nsrttcb = ptcb;
003E6E 8C1706          9101         MOV.W   R1,[R7+6]
003E71 8C0704          9102         MOV.W   R0,[R7+4]
003E74 8E1rrr          9103         MOV.W   _nsrttcb+2,R1
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 160

ADDR   CODE            LINE SOURCELINE
003E77 8E0rrr          9104         MOV.W   _nsrttcb,R0
003E77 8E0rrr          9104         MOV.W   _nsrttcb,R0
                       9105 ; rtxc.c   3262             }
                       9106 ; rtxc.c   3263          }
003E7A                 9107 _618:
                       9108 ; rtxc.c   3264          PUSHPSWH;    /* save current processor priority level */
003E7A 860401          9109         MOV.B   R0L,0401H
                       9110 ; rtxc.c   3265          DISABLE;
003E7D 9648018D        9111         MOV.B   0401H,#08DH
003E81 8E3rrr          9112         MOV.W   R3,_semaput+2
003E84 8E2rrr          9113         MOV.W   R2,_semaput
003E87 4E3rrr          9114         CMP.W   R3,_semaget+2
                       9115         BNE     _606
003E8A F302           +9115 ;       BEQ     _LG_660
003E8C D5FF4D         +9115 ;       JMP.L   _606
003E90 D5FF4D00       +9115 ;       JMP.L   _606
003E90                +9115 _LG_660:
003E90 4E2rrr          9116         CMP.W   R2,_semaget
                       9117         BNE     _606
003E93 F302           +9117 ;       BEQ     _LG_662
003E95 D5FF48         +9117 ;       JMP.L   _606
003E98 D5FF48         +9117 ;       JMP.L   _606
003E98                +9117 _LG_662:
003E98                +9117 _LG_662:
                       9118 ; rtxc.c   3266       }
003E98                 9119 _619:
                       9120 ; rtxc.c   3267       /* loop exited with interrupts disabled, all semaphores processed */
                       9121 ; rtxc.c   3268 
                       9122 ; rtxc.c   3269       semaput = (SEMA ks_data *)&siglist[-1]; /* reset sema signal list empty */
003E98 9Er8rrrrrr      9123         MOV.W   _semaput+2,#SEG( _siglist+-1 )
003E9D 9Er8rrrrrr      9124         MOV.W   _semaput,#SOF( _siglist+-1 )
                       9125 ; rtxc.c   3270       semaget = (SEMA ks_data *)&siglist[-1]; /* reset sema signal list empty */
003EA2 9Er8rrrrrr      9126         MOV.W   _semaget+2,#SEG( _siglist+-1 )
003EA7 9Er8rrrrrr      9127         MOV.W   _semaget,#SOF( _siglist+-1 )
                       9128 ; rtxc.c   3271 
                       9129 ; rtxc.c   3272       POPPSWH;
003EAC 860C01          9130         MOV.B   0401H,R0L
                       9131 ; rtxc.c   3273 
                       9132 ; rtxc.c   3274       /* process task list now with interrupts on */
                       9133 ; rtxc.c   3275       while ( (ptcb = nsrttcb) != NULLTCB)
003EAF 8E1rrr          9134         MOV.W   R1,_nsrttcb+2
003EB2 8E0rrr          9135         MOV.W   R0,_nsrttcb
003EB5 8931            9136         MOV.W   R3,R1
003EB7 8920            9137         MOV.W   R2,R0
003EB9 6910            9138         OR.W    R1,R0
003EBB F349            9139         BEQ     _623
003EBB F34900          9139         BEQ     _623
003EBE                 9140 _620:
                       9141 ; rtxc.c   3276       {
                       9142 ; rtxc.c   3277          /* unlink first tcb in thread and insert in READY list */
                       9143 ; rtxc.c   3278          nsrttcb = ptcb->flink;
003EBE 866C42          9144         MOV.B   ES,R3L
003EC1 8A02            9145         MOV.W   R0,[R2]
003EC3 8C1202          9146         MOV.W   R1,[R2+2]
003EC6 8E1rrr          9147         MOV.W   _nsrttcb+2,R1
003EC9 8E0rrr          9148         MOV.W   _nsrttcb,R0
                       9149 ; rtxc.c   3279 
                       9150 ; rtxc.c   3280          /* insert ptcb in priority order in READY list */
                       9151 ; rtxc.c   3281          prev = (TCB ks_tbl *)&hipritsk;
003ECC 9908rrrr        9152         MOV.W   R0,#SOF( _hipritsk )
003ED0 B910            9153         MOVS.W  R1,#00H
003ED2 8951            9154         MOV.W   R5,R1
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 161

ADDR   CODE            LINE SOURCELINE
003ED4 8940            9155         MOV.W   R4,R0
                       9156 ; rtxc.c   3282 
                       9157 ; rtxc.c   3283          while (ptcb->priority >= prev->flink->priority)
003ED6 866C42          9158         MOV.B   ES,R3L
003ED9 84C20D          9159         MOV.B   R6L,[R2+13]
003EDC 862C42          9160         MOV.B   ES,R1L
003EDF 8C1002          9161         MOV.W   R1,[R0+2]
003EE2 8A00            9162         MOV.W   R0,[R0]
003EE4 862C42          9163         MOV.B   ES,R1L
003EE7 84000D          9164         MOV.B   R0L,[R0+13]
003EEA 866C42          9165         MOV.B   ES,R3L
003EED 440A0D          9166         CMP.B   [R2+13],R0L
003EF0 FB0E            9167         BLT     _622
003EF0 FB0E            9167         BLT     _622
003EF2                 9168 _621:
                       9169 ; rtxc.c   3284             prev = prev->flink;
003EF2 86AC42          9170         MOV.B   ES,R5L
003EF5 8A04            9171         MOV.W   R0,[R4]
003EF7 8C1402          9172         MOV.W   R1,[R4+2]
003EFA 8951            9173         MOV.W   R5,R1
003EFC 8940            9174         MOV.W   R4,R0
003EFE 862C42          9175         MOV.B   ES,R1L
003F01 8C1002          9176         MOV.W   R1,[R0+2]
003F04 8A00            9177         MOV.W   R0,[R0]
003F06 862C42          9178         MOV.B   ES,R1L
003F09 44C80D          9179         CMP.B   [R0+13],R6L
003F0C FDF2            9180         BLE     _621
003F0C FDF2            9180         BLE     _621
003F0E                 9181 _622:
                       9182 ; rtxc.c   3285 
                       9183 ; rtxc.c   3286          ptcb->flink = prev->flink;
003F0E 86AC42          9184         MOV.B   ES,R5L
003F11 8A04            9185         MOV.W   R0,[R4]
003F13 8C1402          9186         MOV.W   R1,[R4+2]
003F16 866C42          9187         MOV.B   ES,R3L
003F19 8A0A            9188         MOV.W   [R2],R0
003F1B 8C1A02          9189         MOV.W   [R2+2],R1
                       9190 ; rtxc.c   3287          ptcb->blink = prev;
003F1E 866C42          9191         MOV.B   ES,R3L
003F21 8C4A04          9192         MOV.W   [R2+4],R4
003F24 8C5A06          9193         MOV.W   [R2+6],R5
                       9194 ; rtxc.c   3288          prev->flink->blink = ptcb;
003F27 86AC42          9195         MOV.B   ES,R5L
003F2A 8A04            9196         MOV.W   R0,[R4]
003F2C 8C1402          9197         MOV.W   R1,[R4+2]
003F2F 862C42          9198         MOV.B   ES,R1L
003F32 8C2804          9199         MOV.W   [R0+4],R2
003F35 8C3806          9200         MOV.W   [R0+6],R3
                       9201 ; rtxc.c   3289          prev->flink = ptcb;
003F38 86AC42          9202         MOV.B   ES,R5L
003F3B 8A2C            9203         MOV.W   [R4],R2
003F3D 8C3C02          9204         MOV.W   [R4+2],R3
003F40 8E1rrr          9205         MOV.W   R1,_nsrttcb+2
003F43 8E0rrr          9206         MOV.W   R0,_nsrttcb
003F46 8931            9207         MOV.W   R3,R1
003F48 8920            9208         MOV.W   R2,R0
003F4A 6910            9209         OR.W    R1,R0
003F4C F2B8            9210         BNE     _620
003F4C F2B8            9210         BNE     _620
                       9211 ; rtxc.c   3290       }
003F4E                 9212 _623:
                       9213 ; rtxc.c   3291 
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 162

ADDR   CODE            LINE SOURCELINE
                       9214 ; rtxc.c   3292       PUSHPSWH;    /* save current processor priority level */
003F4E 860401          9215         MOV.B   R0L,0401H
                       9216 ; rtxc.c   3293       DISABLE;
003F51 9648018D        9217         MOV.B   0401H,#08DH
                       9218 ; rtxc.c   3294 
                       9219 ; rtxc.c   3295       /* check to see if any semaphores were posted while processing tasks */
                       9220 ; rtxc.c   3296       if ((semaput == semaget) && (t_expired == 0))
003F55 9Er4rrrrrr      9221         CMP.W   _semaput+2,#SEG( _siglist+-1 )
003F5A F203            9222         BNE     _641
003F5C 9Er4rrrrrr      9223         CMP.W   _semaput,#SOF( _siglist+-1 )
003F5C 9Er4rrrrrr00    9223         CMP.W   _semaput,#SOF( _siglist+-1 )
003F62                 9224 _641:
003F62 F206            9225         BNE     _624
003F64 964842rr        9226         MOV.B   ES,#SEG( _t_expired )
003F68 9918rrrr        9227         MOV.W   R1,#SOF( _t_expired )
003F6C 8211            9228         MOV.B   R0H,[R1]
003F6E F303            9229         BEQ     _625
003F6E F303            9229         BEQ     _625
                       9230 ; rtxc.c   3297          break;    /* if not, then all done - exit as fast as possible */
003F70                 9231 _624:
                       9232 ; rtxc.c   3298       else
                       9233 ; rtxc.c   3299       {
                       9234 ; rtxc.c   3300          POPPSWH; /* else, enable interrupts and back to top of loop */
003F70 860C01          9235         MOV.B   0401H,R0L
                       9236         BR      _573
003F73 D5FCD0         +9236         JMP.L   _573
003F73 D5FCD0         +9236         JMP.L   _573
                       9237 ; rtxc.c   3301       }
                       9238 ; rtxc.c   3302    }
003F76                 9239 _625:
                       9240 ; rtxc.c   3303 
                       9241 ; rtxc.c   3304 #ifdef FPU /* { */
                       9242 ; rtxc.c   3305    if ( (hipritsk->fpumode == 1) && (fputask != hipritsk) )
                       9243 ; rtxc.c   3306    {
                       9244 ; rtxc.c   3307       /* swap fpu regs */
                       9245 ; rtxc.c   3308       fpuswap(fputask->fpregs, hipritsk->fpregs);
                       9246 ; rtxc.c   3309       fputask = hipritsk; /* update new user of fpu */
                       9247 ; rtxc.c   3310    }
                       9248 ; rtxc.c   3311 #endif /* } FPU */
                       9249 ; rtxc.c   3312 
                       9250 ; rtxc.c   3313    return(hipritsk->sp); /* exit to hipritsk via tcb.sp */
003F76 8E1rrr          9251         MOV.W   R1,_hipritsk+2
003F79 8E0rrr          9252         MOV.W   R0,_hipritsk
003F7C 862C42          9253         MOV.B   ES,R1L
003F7F 8C1010          9254         MOV.W   R1,[R0+16]
003F82 8C000E          9255         MOV.W   R0,[R0+14]
                       9256 ; rtxc.c   3314 }
003F85 99700008        9257         ADD.W   R7,#08H
003F89 2F70            9258         POP.W   R4, R5, R6
003F8B D680            9259         RET
003F8B D68000          9259         RET
                       9260 ; rtxc.c   3315 
                       9261 ; rtxc.c   3316 /************************/
                       9262 ; rtxc.c   3317 static CLKBLK ks_clk *get_clkblk(void)
                       9263 ; rtxc.c   3318 /************************/
                       9264 ; rtxc.c   3319 {
003F8E                 9265 _get_clkblk:
003F8E 0F30            9266         PUSH.W  R4, R5
                       9267 ; rtxc.c   3320    CLKBLK ks_clk *pclkblk;
                       9268 ; rtxc.c   3321 
                       9269 ; rtxc.c   3322    if ( (pclkblk = clkqfl) != NULLCLK) /* allocate timer block */
003F90 964842rr        9270         MOV.B   ES,#SEG( _clkqfl )
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 163

ADDR   CODE            LINE SOURCELINE
003F94 9938rrrr        9271         MOV.W   R3,#SOF( _clkqfl )
003F98 8B23            9272         MOV.W   R2,[R3+]
003F9A 8A33            9273         MOV.W   R3,[R3]
003F9C 8953            9274         MOV.W   R5,R3
003F9E 8942            9275         MOV.W   R4,R2
003FA0 8913            9276         MOV.W   R1,R3
003FA2 8902            9277         MOV.W   R0,R2
003FA4 6954            9278         OR.W    R5,R4
003FA6 F30F            9279         BEQ     _642
                       9280 ; rtxc.c   3323    {
                       9281 ; rtxc.c   3324       clkqfl = pclkblk->flink; /* by removing 1st from free list */
003FA8 866C42          9282         MOV.B   ES,R3L
003FAB 8A42            9283         MOV.W   R4,[R2]
003FAD 8C5202          9284         MOV.W   R5,[R2+2]
003FB0 8913            9285         MOV.W   R1,R3
003FB2 8902            9286         MOV.W   R0,R2
003FB4 964842rr        9287         MOV.B   ES,#SEG( _clkqfl )
003FB8 9928rrrr        9288         MOV.W   R2,#SOF( _clkqfl )
003FBC 8B4A            9289         MOV.W   [R2+],R4
003FBE 8A5A            9290         MOV.W   [R2],R5
                       9291 ; rtxc.c   3325       pclkblk->state = TIMER_DONE;
003FC0 862C42          9292         MOV.B   ES,R1L
003FC3 B4000D          9293         MOV.B   [R0+13],#00H
003FC3 B4000D          9293         MOV.B   [R0+13],#00H
                       9294 ; rtxc.c   3326    }
003FC6                 9295 _642:
                       9296 ; rtxc.c   3327    return(pclkblk);
                       9297 ; rtxc.c   3328 }
003FC6 2F30            9298         POP.W   R4, R5
003FC8 D680            9299         RET
003FC8 D680            9299         RET
                       9300 ; rtxc.c   3329 
                       9301 ; rtxc.c   3330 /*
                       9302 ; rtxc.c   3331  *    routine to "process" a tick from clock isr
                       9303 ; rtxc.c   3332  *
                       9304 ; rtxc.c   3333  * sets t_expired and returns 1(true) if timer expires or time slice has
                       9305 ; rtxc.c   3334  * occurred
                       9306 ; rtxc.c   3335  *
                       9307 ; rtxc.c   3336 */
                       9308 ; rtxc.c   3337 int KS_ISRtick(void)
                       9309 ; rtxc.c   3338 {
                       9310         PUBLIC  _KS_ISRtick
003FCA                 9311 _KS_ISRtick:
                       9312 ; rtxc.c   3339    TICKS xx;
                       9313 ; rtxc.c   3340 
                       9314 ; rtxc.c   3341 #ifdef CBUG /* { */
                       9315 ; rtxc.c   3342    if (cbugflag) /* no clock ticks while RTXCbug active */
                       9316 ; rtxc.c   3343       return(0);    /* just return */
                       9317 ; rtxc.c   3344 #endif /* } CBUG */
                       9318 ; rtxc.c   3345 
                       9319 ; rtxc.c   3346    rtctick++; /* update tick counter */
003FCA 964842rr        9320         MOV.B   ES,#SEG( _rtctick )
003FCE 9908rrrr        9321         MOV.W   R0,#SOF( _rtctick )
003FD2 8A00            9322         MOV.W   R0,[R0]
003FD4 A901            9323         ADDS.W  R0,#01H
003FD6 964842rr        9324         MOV.B   ES,#SEG( _rtctick )
003FDA 9918rrrr        9325         MOV.W   R1,#SOF( _rtctick )
003FDE 8A09            9326         MOV.W   [R1],R0
                       9327 ; rtxc.c   3347 
                       9328 ; rtxc.c   3348 #ifdef HAS_INQTIME /* { */
                       9329 ; rtxc.c   3349    if (++ratecnt >= clkrate)
003FE0 964842rr        9330         MOV.B   ES,#SEG( _ratecnt )
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 164

ADDR   CODE            LINE SOURCELINE
003FE4 9908rrrr        9331         MOV.W   R0,#SOF( _ratecnt )
003FE8 8A00            9332         MOV.W   R0,[R0]
003FEA A901            9333         ADDS.W  R0,#01H
003FEC 964842rr        9334         MOV.B   ES,#SEG( _ratecnt )
003FF0 9918rrrr        9335         MOV.W   R1,#SOF( _ratecnt )
003FF4 8A09            9336         MOV.W   [R1],R0
003FF6 964842rr        9337         MOV.B   ES,#SEG( _clkrate )
003FFA 9918rrrr        9338         MOV.W   R1,#SOF( _clkrate )
003FFE 8A11            9339         MOV.W   R1,[R1]
004000 4901            9340         CMP.W   R0,R1
004002 FB15            9341         BLT     _643
                       9342 ; rtxc.c   3350    {
                       9343 ; rtxc.c   3351       ratecnt = 0; /* reset rate counter (0 - CLKRATE-1) */
004004 964842rr        9344         MOV.B   ES,#SEG( _ratecnt )
004008 9908rrrr        9345         MOV.W   R0,#SOF( _ratecnt )
00400C BA00            9346         MOV.W   [R0],#00H
                       9347 ; rtxc.c   3352       rtctime++; /* update second counter */
00400E 964842rr        9348         MOV.B   ES,#SEG( _rtctime )
004012 9918rrrr        9349         MOV.W   R1,#SOF( _rtctime )
004016 8B01            9350         MOV.W   R0,[R1+]
004018 8A11            9351         MOV.W   R1,[R1]
00401A 99000001        9352         ADD.W   R0,#01H
00401E 99110000        9353         ADDC.W  R1,#00H
004022 964842rr        9354         MOV.B   ES,#SEG( _rtctime )
004026 9928rrrr        9355         MOV.W   R2,#SOF( _rtctime )
00402A 8B0A            9356         MOV.W   [R2+],R0
00402C 8A1A            9357         MOV.W   [R2],R1
00402C 8A1A            9357         MOV.W   [R2],R1
                       9358 ; rtxc.c   3353    }
00402E                 9359 _643:
                       9360 ; rtxc.c   3354 #endif /* } HAS_INQTIME */
                       9361 ; rtxc.c   3355 
                       9362 ; rtxc.c   3356 #ifdef TIME_SLICE /* { */
                       9363 ; rtxc.c   3357    if (hipritsk->newslice) /* if time slicing enabled for running task */
00402E 8E1rrr          9364         MOV.W   R1,_hipritsk+2
004031 8E0rrr          9365         MOV.W   R0,_hipritsk
004034 862C42          9366         MOV.B   ES,R1L
004037 84401F          9367         MOV.B   R2L,[R0+31]
00403A F319            9368         BEQ     _645
                       9369 ; rtxc.c   3358    {
                       9370 ; rtxc.c   3359       if (--hipritsk->tslice == (TSLICE)0) /* if time slice is up */
00403C 862C42          9371         MOV.B   ES,R1L
00403F 84401E          9372         MOV.B   R2L,[R0+30]
004042 A14F            9373         ADDS.B  R2L,#0FH
004044 862C42          9374         MOV.B   ES,R1L
004047 A40F1E          9375         ADDS.B  [R0+30],#0FH
00404A 6144            9376         OR.B    R2L,R2L
00404C F210            9377         BNE     _645
                       9378 ; rtxc.c   3360       {
                       9379 ; rtxc.c   3361          sliceup = hipritsk; /* save tcb of task that timed out */
00404E 8E1rrr          9380         MOV.W   _sliceup+2,R1
004051 8E0rrr          9381         MOV.W   _sliceup,R0
                       9382 ; rtxc.c   3362          sliceup->tslice = sliceup->newslice; /* reset next slice amount */
004054 862C42          9383         MOV.B   ES,R1L
004057 84401F          9384         MOV.B   R2L,[R0+31]
00405A 862C42          9385         MOV.B   ES,R1L
00405D 84481E          9386         MOV.B   [R0+30],R2L
                       9387 ; rtxc.c   3363          t_expired = 1;
004060 964842rr        9388         MOV.B   ES,#SEG( _t_expired )
004064 9908rrrr        9389         MOV.W   R0,#SOF( _t_expired )
004068 B201            9390         MOV.B   [R0],#01H
                       9391 ; rtxc.c   3364          return(1);
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 165

ADDR   CODE            LINE SOURCELINE
00406A B901            9392         MOV.W   R0,#01H
00406C D680            9393         RET
00406C D680            9393         RET
                       9394 ; rtxc.c   3365       }
                       9395 ; rtxc.c   3366    }
00406E                 9396 _645:
                       9397 ; rtxc.c   3367 #endif /* } TIME_SLICE */
                       9398 ; rtxc.c   3368 
                       9399 ; rtxc.c   3369 /*
                       9400 ; rtxc.c   3370  * xx is used in the following statement because some compilers can't
                       9401 ; rtxc.c   3371  * properly handle the arithmetic when negative values are involved
                       9402 ; rtxc.c   3372  */
                       9403 ; rtxc.c   3373    if ( (clkqptr != NULLCLK) && ((xx = rtctick - clkqptr->remain) >= 0) )
00406E 964842rr        9404         MOV.B   ES,#SEG( _clkqptr )
004072 9918rrrr        9405         MOV.W   R1,#SOF( _clkqptr )
004076 8B01            9406         MOV.W   R0,[R1+]
004078 8A11            9407         MOV.W   R1,[R1]
00407A 8931            9408         MOV.W   R3,R1
00407C 8920            9409         MOV.W   R2,R0
00407E 6910            9410         OR.W    R1,R0
004080 F312            9411         BEQ     _647
004082 964842rr        9412         MOV.B   ES,#SEG( _rtctick )
004086 9908rrrr        9413         MOV.W   R0,#SOF( _rtctick )
00408A 8A00            9414         MOV.W   R0,[R0]
00408C 866C42          9415         MOV.B   ES,R3L
00408F 2C0208          9416         SUB.W   R0,[R2+8]
004092 99040000        9417         CMP.W   R0,#00H
004096 FB07            9418         BLT     _647
                       9419 ; rtxc.c   3374    {
                       9420 ; rtxc.c   3375       t_expired = 1;
004098 964842rr        9421         MOV.B   ES,#SEG( _t_expired )
00409C 9908rrrr        9422         MOV.W   R0,#SOF( _t_expired )
0040A0 B201            9423         MOV.B   [R0],#01H
                       9424 ; rtxc.c   3376       return(1);
0040A2 B901            9425         MOV.W   R0,#01H
0040A4 D680            9426         RET
0040A4 D680            9426         RET
                       9427 ; rtxc.c   3377    }
0040A6                 9428 _647:
                       9429 ; rtxc.c   3378 
                       9430 ; rtxc.c   3379    return(0);
0040A6 B900            9431         MOV.W   R0,#00H
0040A6 B900            9431         MOV.W   R0,#00H
                       9432 ; rtxc.c   3380 }
0040A8                 9433 _649:
0040A8 D680            9434         RET
0040A8 D680            9434         RET
                       9435 ; rtxc.c   3381 
                       9436 ; rtxc.c   3382 /*
                       9437 ; rtxc.c   3383  * initialize task stacks
                       9438 ; rtxc.c   3384  *
                       9439 ; rtxc.c   3385  * called by taskinit() and KS_deftask()
                       9440 ; rtxc.c   3386  *
                       9441 ; rtxc.c   3387 */
                       9442 ; rtxc.c   3388 #ifdef CBUG /* { */
                       9443 ; rtxc.c   3389 /************************/
                       9444 ; rtxc.c   3390 void stkinit(short ks_stk *stackbase, size_t stacksize)
                       9445 ; rtxc.c   3391 /************************/
                       9446 ; rtxc.c   3392 {
                       9447 ; rtxc.c   3393    int count, j;
                       9448 ; rtxc.c   3394 
                       9449 ; rtxc.c   3395    count = stacksize / sizeof(short);
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 166

ADDR   CODE            LINE SOURCELINE
                       9450 ; rtxc.c   3396 
                       9451 ; rtxc.c   3397    for (j = 0; j < count; j++)
                       9452 ; rtxc.c   3398         *stackbase++ = STACK_FILL;
                       9453 ; rtxc.c   3399 }
                       9454 ; rtxc.c   3400 #endif /* } CBUG */
                       9455 ; rtxc.c   3401 
                       9456 ; rtxc.c   3402 /*
                       9457 ; rtxc.c   3403  * insert timer into timer list
                       9458 ; rtxc.c   3404  *
                       9459 ; rtxc.c   3405  * called by rtxc() and by postem()
                       9460 ; rtxc.c   3406 */
                       9461 ; rtxc.c   3407 /************************/
                       9462 ; rtxc.c   3408 static void insert_timer(CLKBLK ks_clk *pclkblk)
                       9463 ; rtxc.c   3409 /************************/
                       9464 ; rtxc.c   3410 {
0040AA                 9465 _insert_timer:
0040AA 0F70            9466         PUSH.W  R4, R5, R6
0040AC A978            9467         ADDS.W  R7,#08H
                       9468 ; rtxc.c   3411    TICKS xx;
                       9469 ; rtxc.c   3412    CLKBLK ks_clk *lclkptr;
                       9470 ; rtxc.c   3413    CLKBLK ks_clk *nclkptr;
                       9471 ; rtxc.c   3414 
                       9472 ; rtxc.c   3415    pclkblk->state = TIMER_ACTIVE;
0040AE 862C42          9473         MOV.B   ES,R1L
0040B1 B4010D          9474         MOV.B   [R0+13],#01H
0040B4 8C1F06          9475         MOV.W   [R7+6],R1
0040B7 8C0F04          9476         MOV.W   [R7+4],R0
                       9477 ; rtxc.c   3416 
                       9478 ; rtxc.c   3417    lclkptr = (CLKBLK ks_clk *)&clkqptr;
0040BA 9918rrrr        9479         MOV.W   R1,#SEG( _clkqptr )
0040BE 9908rrrr        9480         MOV.W   R0,#SOF( _clkqptr )
0040C2 8C1F02          9481         MOV.W   [R7+2],R1
0040C5 8A0F            9482         MOV.W   [R7],R0
                       9483 ; rtxc.c   3418 
                       9484 ; rtxc.c   3419    /* find point of insertion */
                       9485 ; rtxc.c   3420 /*
                       9486 ; rtxc.c   3421  * xx is used in the following statement because some compilers can't
                       9487 ; rtxc.c   3422  * properly handle the arithmetic when negative values are involved
                       9488 ; rtxc.c   3423  */
                       9489 ; rtxc.c   3424    while ( ((nclkptr = lclkptr->flink) != NULLCLK) &&
0040C7 964842rr        9490         MOV.B   ES,#SEG( _clkqptr )
0040CB 9938rrrr        9491         MOV.W   R3,#SOF( _clkqptr )
0040CF 8B23            9492         MOV.W   R2,[R3+]
0040D1 8A33            9493         MOV.W   R3,[R3]
0040D3 8913            9494         MOV.W   R1,R3
0040D5 8902            9495         MOV.W   R0,R2
0040D7 8951            9496         MOV.W   R5,R1
0040D9 8940            9497         MOV.W   R4,R0
0040DB 6910            9498         OR.W    R1,R0
0040DD F32F            9499         BEQ     _655
0040DF 8C1706          9500         MOV.W   R1,[R7+6]
0040E2 8C0704          9501         MOV.W   R0,[R7+4]
0040E5 862C42          9502         MOV.B   ES,R1L
0040E8 8C6008          9503         MOV.W   R6,[R0+8]
0040EB 866C42          9504         MOV.B   ES,R3L
0040EE 8C0208          9505         MOV.W   R0,[R2+8]
0040F1 964842rr        9506         MOV.B   ES,#SEG( _rtctick )
0040F5 9918rrrr        9507         MOV.W   R1,#SOF( _rtctick )
0040F9 8A11            9508         MOV.W   R1,[R1]
0040FB 2901            9509         SUB.W   R0,R1
0040FD 8C3706          9510         MOV.W   R3,[R7+6]
004100 8C2704          9511         MOV.W   R2,[R7+4]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 167

ADDR   CODE            LINE SOURCELINE
004103 866C42          9512         MOV.B   ES,R3L
004106 4C0A08          9513         CMP.W   [R2+8],R0
004109 FB19            9514         BLT     _655
004109 FB1900          9514         BLT     _655
                       9515 ; rtxc.c   3425                   (pclkblk->remain >= (xx = nclkptr->remain - rtctick)) )
00410C                 9516 _652:
                       9517 ; rtxc.c   3426       lclkptr = nclkptr;
00410C 8C5F02          9518         MOV.W   [R7+2],R5
00410F 8A4F            9519         MOV.W   [R7],R4
004111 86AC42          9520         MOV.B   ES,R5L
004114 8A24            9521         MOV.W   R2,[R4]
004116 8C3402          9522         MOV.W   R3,[R4+2]
004119 8913            9523         MOV.W   R1,R3
00411B 8902            9524         MOV.W   R0,R2
00411D 8951            9525         MOV.W   R5,R1
00411F 8940            9526         MOV.W   R4,R0
004121 6910            9527         OR.W    R1,R0
004123 F30C            9528         BEQ     _655
004125 866C42          9529         MOV.B   ES,R3L
004128 8C2208          9530         MOV.W   R2,[R2+8]
00412B 964842rr        9531         MOV.B   ES,#SEG( _rtctick )
00412F 9908rrrr        9532         MOV.W   R0,#SOF( _rtctick )
004133 8A00            9533         MOV.W   R0,[R0]
004135 2920            9534         SUB.W   R2,R0
004137 4962            9535         CMP.W   R6,R2
004139 FAE9            9536         BGE     _652
004139 FAE900          9536         BGE     _652
00413C                 9537 _655:
                       9538 ; rtxc.c   3427 
                       9539 ; rtxc.c   3428    /* insert timer between lptr and nptr */
                       9540 ; rtxc.c   3429    pclkblk->remain += rtctick;
00413C 964842rr        9541         MOV.B   ES,#SEG( _rtctick )
004140 9908rrrr        9542         MOV.W   R0,#SOF( _rtctick )
004144 8A00            9543         MOV.W   R0,[R0]
004146 8C3706          9544         MOV.W   R3,[R7+6]
004149 8C2704          9545         MOV.W   R2,[R7+4]
00414C 866C42          9546         MOV.B   ES,R3L
00414F 0C0A08          9547         ADD.W   [R2+8],R0
                       9548 ; rtxc.c   3430    pclkblk->flink = nclkptr;
004152 8913            9549         MOV.W   R1,R3
004154 8902            9550         MOV.W   R0,R2
004156 862C42          9551         MOV.B   ES,R1L
004159 8A48            9552         MOV.W   [R0],R4
00415B 8C5802          9553         MOV.W   [R0+2],R5
                       9554 ; rtxc.c   3431    pclkblk->blink = lclkptr;
00415E 8C3706          9555         MOV.W   R3,[R7+6]
004161 8C2704          9556         MOV.W   R2,[R7+4]
004164 8C1702          9557         MOV.W   R1,[R7+2]
004167 8A07            9558         MOV.W   R0,[R7]
004169 866C42          9559         MOV.B   ES,R3L
00416C 8C0A04          9560         MOV.W   [R2+4],R0
00416F 8C1A06          9561         MOV.W   [R2+6],R1
                       9562 ; rtxc.c   3432    lclkptr->flink = pclkblk;
004172 8913            9563         MOV.W   R1,R3
004174 8902            9564         MOV.W   R0,R2
004176 8C3702          9565         MOV.W   R3,[R7+2]
004179 8A27            9566         MOV.W   R2,[R7]
00417B 866C42          9567         MOV.B   ES,R3L
00417E 8A0A            9568         MOV.W   [R2],R0
004180 8C1A02          9569         MOV.W   [R2+2],R1
                       9570 ; rtxc.c   3433    if (nclkptr != NULLCLK)
004183 8935            9571         MOV.W   R3,R5
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 168

ADDR   CODE            LINE SOURCELINE
004185 8924            9572         MOV.W   R2,R4
004187 6954            9573         OR.W    R5,R4
004189 F308            9574         BEQ     _656
                       9575 ; rtxc.c   3434       nclkptr->blink = pclkblk;
00418B 8C1706          9576         MOV.W   R1,[R7+6]
00418E 8C0704          9577         MOV.W   R0,[R7+4]
004191 866C42          9578         MOV.B   ES,R3L
004194 8C0A04          9579         MOV.W   [R2+4],R0
004197 8C1A06          9580         MOV.W   [R2+6],R1
004197 8C1A06          9580         MOV.W   [R2+6],R1
00419A                 9581 _656:
                       9582 ; rtxc.c   3435 }
00419A 99700008        9583         ADD.W   R7,#08H
00419E 2F70            9584         POP.W   R4, R5, R6
0041A0 D680            9585         RET
0041A0 D680            9585         RET
                       9586 ; rtxc.c   3436 
                       9587 ; rtxc.c   3437 /*
                       9588 ; rtxc.c   3438  * unlink timer from timer list
                       9589 ; rtxc.c   3439 */
                       9590 ; rtxc.c   3440 /************************/
                       9591 ; rtxc.c   3441 static void unlink_timer(CLKBLK ks_clk *pclkblk)
                       9592 ; rtxc.c   3442 /************************/
                       9593 ; rtxc.c   3443 {
0041A2                 9594 _unlink_timer:
0041A2 0F10            9595         PUSH.W  R4
0041A4 A978            9596         ADDS.W  R7,#08H
                       9597 ; rtxc.c   3444    unsigned char pswh;  /* local variable for saving processor priority level */
                       9598 ; rtxc.c   3445 
                       9599 ; rtxc.c   3446    pclkblk->state = TIMER_DONE;  /* mark timer done */
0041A6 862C42          9600         MOV.B   ES,R1L
0041A9 B4000D          9601         MOV.B   [R0+13],#00H
                       9602 ; rtxc.c   3447 
                       9603 ; rtxc.c   3448    PUSHPSWH;    /* save current processor priority level */
0041AC 868401          9604         MOV.B   R4L,0401H
                       9605 ; rtxc.c   3449    DISABLE;    /* disable interrutps */
0041AF 9648018D        9606         MOV.B   0401H,#08DH
                       9607 ; rtxc.c   3450    /* simply remove block from list */
                       9608 ; rtxc.c   3451    if ( (pclkblk->blink->flink = pclkblk->flink) != NULLCLK)
0041B3 862C42          9609         MOV.B   ES,R1L
0041B6 8A20            9610         MOV.W   R2,[R0]
0041B8 8C3002          9611         MOV.W   R3,[R0+2]
0041BB 8C3F02          9612         MOV.W   [R7+2],R3
0041BE 8A2F            9613         MOV.W   [R7],R2
0041C0 8C1F06          9614         MOV.W   [R7+6],R1
0041C3 8C0F04          9615         MOV.W   [R7+4],R0
0041C6 862C42          9616         MOV.B   ES,R1L
0041C9 8C2004          9617         MOV.W   R2,[R0+4]
0041CC 8C3006          9618         MOV.W   R3,[R0+6]
0041CF 8C1702          9619         MOV.W   R1,[R7+2]
0041D2 8A07            9620         MOV.W   R0,[R7]
0041D4 866C42          9621         MOV.B   ES,R3L
0041D7 8A0A            9622         MOV.W   [R2],R0
0041D9 8C1A02          9623         MOV.W   [R2+2],R1
0041DC 8C1702          9624         MOV.W   R1,[R7+2]
0041DF 8A07            9625         MOV.W   R0,[R7]
0041E1 6910            9626         OR.W    R1,R0
0041E3 F315            9627         BEQ     _659
                       9628 ; rtxc.c   3452    {
                       9629 ; rtxc.c   3453       pclkblk->flink->blink = pclkblk->blink;
0041E5 8C1706          9630         MOV.W   R1,[R7+6]
0041E8 8C0704          9631         MOV.W   R0,[R7+4]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 169

ADDR   CODE            LINE SOURCELINE
0041EB 862C42          9632         MOV.B   ES,R1L
0041EE 8C1006          9633         MOV.W   R1,[R0+6]
0041F1 8C0004          9634         MOV.W   R0,[R0+4]
0041F4 8C3706          9635         MOV.W   R3,[R7+6]
0041F7 8C2704          9636         MOV.W   R2,[R7+4]
0041FA 866C42          9637         MOV.B   ES,R3L
0041FD 8C3202          9638         MOV.W   R3,[R2+2]
004200 8A22            9639         MOV.W   R2,[R2]
004202 99200004        9640         ADD.W   R2,#04H
004206 866C42          9641         MOV.B   ES,R3L
004209 8A0A            9642         MOV.W   [R2],R0
00420B 8C1A02          9643         MOV.W   [R2+2],R1
00420B 8C1A02          9643         MOV.W   [R2+2],R1
                       9644 ; rtxc.c   3454    }
00420E                 9645 _659:
                       9646 ; rtxc.c   3455    POPPSWH;
00420E 868C01          9647         MOV.B   0401H,R4L
                       9648 ; rtxc.c   3456 }
004211 99700008        9649         ADD.W   R7,#08H
004215 2F10            9650         POP.W   R4
004217 D680            9651         RET
004217 D68000          9651         RET
                       9652 ; rtxc.c   3457 
                       9653 ; rtxc.c   3458 #if defined(MAILBOX_WAITERS)   || \ 
                       9654 ; rtxc.c   3459     defined(PARTITION_WAITERS) || \ 
                       9655 ; rtxc.c   3460     defined(QUEUE_WAITERS)     || \ 
                       9656 ; rtxc.c   3461     defined(RESOURCE_WAITERS)  /* { */
                       9657 ; rtxc.c   3462 /*
                       9658 ; rtxc.c   3463  * insert tcb in priority order
                       9659 ; rtxc.c   3464  *
                       9660 ; rtxc.c   3465  * unlink hipritsk from READY list
                       9661 ; rtxc.c   3466  * and insert hipritsk TCB in priority list (doubly linked)
                       9662 ; rtxc.c   3467  * used by mailboxes, partitions, queues, and resources
                       9663 ; rtxc.c   3468 */
                       9664 ; rtxc.c   3469 /************************/
                       9665 ; rtxc.c   3470 static void porder(TCB ks_tbl *prev)
                       9666 ; rtxc.c   3471 /************************/
                       9667 ; rtxc.c   3472 {
00421A                 9668 _porder:
00421A 0F70            9669         PUSH.W  R4, R5, R6
00421C A978            9670         ADDS.W  R7,#08H
                       9671 ; rtxc.c   3473    TCB ks_tbl *next;
                       9672 ; rtxc.c   3474    TCB ks_tbl *save;
                       9673 ; rtxc.c   3475    PRIORITY priority;
                       9674 ; rtxc.c   3476 
                       9675 ; rtxc.c   3477    save = hipritsk;
                       9676 ; rtxc.c   3478    priority = save->priority;
00421E 8E5rrr          9677         MOV.W   R5,_hipritsk+2
004221 8E4rrr          9678         MOV.W   R4,_hipritsk
004224 86AC42          9679         MOV.B   ES,R5L
004227 84C40D          9680         MOV.B   R6L,[R4+13]
                       9681 ; rtxc.c   3479 
                       9682 ; rtxc.c   3480    /* remove task from READY list (it is ALWAYS first in list) */
                       9683 ; rtxc.c   3481    UNLINK_HIPRITSK();
00422A 86AC42          9684         MOV.B   ES,R5L
00422D 8A24            9685         MOV.W   R2,[R4]
00422F 8C3402          9686         MOV.W   R3,[R4+2]
004232 8E5rrr          9687         MOV.W   _hipritsk+2,R5
004235 8E4rrr          9688         MOV.W   _hipritsk,R4
004238 8E5rrr          9689         MOV.W   R5,_hipritsk+2
00423B 8E4rrr          9690         MOV.W   R4,_hipritsk
00423E 8C5F06          9691         MOV.W   [R7+6],R5
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 170

ADDR   CODE            LINE SOURCELINE
004241 8C4F04          9692         MOV.W   [R7+4],R4
004244 8E3rrr          9693         MOV.W   _hipritsk+2,R3
004247 8E2rrr          9694         MOV.W   _hipritsk,R2
00424A 9948rrrr        9695         MOV.W   R4,#SOF( _hipritsk )
00424E B950            9696         MOVS.W  R5,#00H
004250 866C42          9697         MOV.B   ES,R3L
004253 8C4A04          9698         MOV.W   [R2+4],R4
004256 8C5A06          9699         MOV.W   [R2+6],R5
                       9700 ; rtxc.c   3482 
                       9701 ; rtxc.c   3483    /* search and insert in priority order */
                       9702 ; rtxc.c   3484    while ( ((next = prev->flink) != NULLTCB) &&
004259 862C42          9703         MOV.B   ES,R1L
00425C 8A20            9704         MOV.W   R2,[R0]
00425E 8C3002          9705         MOV.W   R3,[R0+2]
004261 8953            9706         MOV.W   R5,R3
004263 8942            9707         MOV.W   R4,R2
004265 8C5F02          9708         MOV.W   [R7+2],R5
004268 8A4F            9709         MOV.W   [R7],R4
00426A 6954            9710         OR.W    R5,R4
00426C F318            9711         BEQ     _663
00426E 866C42          9712         MOV.B   ES,R3L
004271 44CA0D          9713         CMP.B   [R2+13],R6L
004274 FC14            9714         BGT     _663
004274 FC14            9714         BGT     _663
                       9715 ; rtxc.c   3485           (next->priority <= priority) )
004276                 9716 _660:
                       9717 ; rtxc.c   3486       prev = next;
004276 8C1702          9718         MOV.W   R1,[R7+2]
004279 8A07            9719         MOV.W   R0,[R7]
00427B 8C5702          9720         MOV.W   R5,[R7+2]
00427E 8A47            9721         MOV.W   R4,[R7]
004280 86AC42          9722         MOV.B   ES,R5L
004283 8A24            9723         MOV.W   R2,[R4]
004285 8C3402          9724         MOV.W   R3,[R4+2]
004288 8953            9725         MOV.W   R5,R3
00428A 8942            9726         MOV.W   R4,R2
00428C 8C5F02          9727         MOV.W   [R7+2],R5
00428F 8A4F            9728         MOV.W   [R7],R4
004291 6954            9729         OR.W    R5,R4
004293 F305            9730         BEQ     _663
004295 866C42          9731         MOV.B   ES,R3L
004298 44CA0D          9732         CMP.B   [R2+13],R6L
00429B FDED            9733         BLE     _660
00429B FDED00          9733         BLE     _660
00429E                 9734 _663:
                       9735 ; rtxc.c   3487 
                       9736 ; rtxc.c   3488    prev->flink = save;
00429E 8C3706          9737         MOV.W   R3,[R7+6]
0042A1 8C2704          9738         MOV.W   R2,[R7+4]
0042A4 862C42          9739         MOV.B   ES,R1L
0042A7 8A28            9740         MOV.W   [R0],R2
0042A9 8C3802          9741         MOV.W   [R0+2],R3
                       9742 ; rtxc.c   3489    save->blink = prev;
0042AC 8C3706          9743         MOV.W   R3,[R7+6]
0042AF 8C2704          9744         MOV.W   R2,[R7+4]
0042B2 866C42          9745         MOV.B   ES,R3L
0042B5 8C0A04          9746         MOV.W   [R2+4],R0
0042B8 8C1A06          9747         MOV.W   [R2+6],R1
                       9748 ; rtxc.c   3490 
                       9749 ; rtxc.c   3491    if ( (save->flink = next) != NULLTCB)
0042BB 8C1702          9750         MOV.W   R1,[R7+2]
0042BE 8A07            9751         MOV.W   R0,[R7]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 171

ADDR   CODE            LINE SOURCELINE
0042C0 866C42          9752         MOV.B   ES,R3L
0042C3 8A0A            9753         MOV.W   [R2],R0
0042C5 8C1A02          9754         MOV.W   [R2+2],R1
0042C8 8C1702          9755         MOV.W   R1,[R7+2]
0042CB 8A07            9756         MOV.W   R0,[R7]
0042CD 8931            9757         MOV.W   R3,R1
0042CF 8920            9758         MOV.W   R2,R0
0042D1 6910            9759         OR.W    R1,R0
0042D3 F308            9760         BEQ     _664
                       9761 ; rtxc.c   3492       next->blink = save;
0042D5 8C1706          9762         MOV.W   R1,[R7+6]
0042D8 8C0704          9763         MOV.W   R0,[R7+4]
0042DB 866C42          9764         MOV.B   ES,R3L
0042DE 8C0A04          9765         MOV.W   [R2+4],R0
0042E1 8C1A06          9766         MOV.W   [R2+6],R1
0042E1 8C1A06          9766         MOV.W   [R2+6],R1
0042E4                 9767 _664:
                       9768 ; rtxc.c   3493 }
0042E4 99700008        9769         ADD.W   R7,#08H
0042E8 2F70            9770         POP.W   R4, R5, R6
0042EA D680            9771         RET
0042EA D680            9771         RET
                       9772 ; rtxc.c   3494 
                       9773 ; rtxc.c   3495 /*
                       9774 ; rtxc.c   3496  *
                       9775 ; rtxc.c   3497  * reorder TCB in respective WAITER list due to priority change
                       9776 ; rtxc.c   3498  *
                       9777 ; rtxc.c   3499 */
                       9778 ; rtxc.c   3500 static void reorder_waiters(TCB ks_tbl *ptcb)
                       9779 ; rtxc.c   3501 {
0042EC                 9780 _reorder_waiters:
0042EC 0F30            9781         PUSH.W  R4, R5
0042EE A97C            9782         ADDS.W  R7,#0CH
                       9783 ; rtxc.c   3502    /*
                       9784 ; rtxc.c   3503     *
                       9785 ; rtxc.c   3504     * The cases get a little nastier here than with simply reordering the
                       9786 ; rtxc.c   3505     * READY list since there may be no tasks of lower and/or higher priority
                       9787 ; rtxc.c   3506     * in the list.  Each case is handled separately (and optimized for speed).
                       9788 ; rtxc.c   3507     *
                       9789 ; rtxc.c   3508    */
                       9790 ; rtxc.c   3509 
                       9791 ; rtxc.c   3510    /* if task is the first waiter in the list */
                       9792 ; rtxc.c   3511    if (ptcb->blink->blink == NULLTCB)
0042F0 8951            9793         MOV.W   R5,R1
0042F2 8940            9794         MOV.W   R4,R0
0042F4 8935            9795         MOV.W   R3,R5
0042F6 8924            9796         MOV.W   R2,R4
0042F8 99400004        9797         ADD.W   R4,#04H
0042FC 866C42          9798         MOV.B   ES,R3L
0042FF 8C0204          9799         MOV.W   R0,[R2+4]
004302 8C1206          9800         MOV.W   R1,[R2+6]
004305 862C42          9801         MOV.B   ES,R1L
004308 8C1006          9802         MOV.W   R1,[R0+6]
00430B 8C0004          9803         MOV.W   R0,[R0+4]
00430E 6910            9804         OR.W    R1,R0
004310 F216            9805         BNE     _667
                       9806 ; rtxc.c   3512    {
                       9807 ; rtxc.c   3513       /* if (first and) also last waiter in list */
                       9808 ; rtxc.c   3514       if (ptcb->flink == NULLTCB)
004312 866C42          9809         MOV.B   ES,R3L
004315 8A02            9810         MOV.W   R0,[R2]
004317 8C1202          9811         MOV.W   R1,[R2+2]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 172

ADDR   CODE            LINE SOURCELINE
00431A 6910            9812         OR.W    R1,R0
00431C F355            9813         BEQ     _677
                       9814 ; rtxc.c   3515       {
                       9815 ; rtxc.c   3516          /* fast return since no shuffling necessary */
                       9816 ; rtxc.c   3517          return;
                       9817 ; rtxc.c   3518       }
                       9818 ; rtxc.c   3519 
                       9819 ; rtxc.c   3520       /* if (first and) still higher priority than next waiter */
                       9820 ; rtxc.c   3521       if (ptcb->priority <= ptcb->flink->priority)
00431E 866C42          9821         MOV.B   ES,R3L
004321 8A02            9822         MOV.W   R0,[R2]
004323 8C1202          9823         MOV.W   R1,[R2+2]
004326 862C42          9824         MOV.B   ES,R1L
004329 84000D          9825         MOV.B   R0L,[R0+13]
00432C 866C42          9826         MOV.B   ES,R3L
00432F 440A0D          9827         CMP.B   [R2+13],R0L
004332 FD4A            9828         BLE     _677
                       9829 ; rtxc.c   3522       {
                       9830 ; rtxc.c   3523          /* fast return since no shuffling necessary */
                       9831 ; rtxc.c   3524          return;
                       9832 ; rtxc.c   3525       }
                       9833 ; rtxc.c   3526 
                       9834 ; rtxc.c   3527       /* insert by walking forward */
                       9835 ; rtxc.c   3528       fwd_insert(ptcb);
004334 8913            9836         MOV.W   R1,R3
004336 8902            9837         MOV.W   R0,R2
004338 C5004A          9838         CALL    _fwd_insert
                       9839 ; rtxc.c   3529       return;
00433B FE46            9840         BR      _677
00433B FE4600          9840         BR      _677
                       9841 ; rtxc.c   3530    }
00433E                 9842 _667:
                       9843 ; rtxc.c   3531 
                       9844 ; rtxc.c   3532    /* if last waiter in list (and not also first) */
                       9845 ; rtxc.c   3533    if (ptcb->flink == NULLTCB)
00433E 866C42          9846         MOV.B   ES,R3L
004341 8A02            9847         MOV.W   R0,[R2]
004343 8C1202          9848         MOV.W   R1,[R2+2]
004346 6910            9849         OR.W    R1,R0
004348 F210            9850         BNE     _668
                       9851 ; rtxc.c   3534    {
                       9852 ; rtxc.c   3535       /* if (last and) still lower priority than next to last */
                       9853 ; rtxc.c   3536       if (ptcb->blink->priority <= ptcb->priority)
00434A 86AC42          9854         MOV.B   ES,R5L
00434D 8C5402          9855         MOV.W   R5,[R4+2]
004350 8A44            9856         MOV.W   R4,[R4]
004352 866C42          9857         MOV.B   ES,R3L
004355 84020D          9858         MOV.B   R0L,[R2+13]
004358 86AC42          9859         MOV.B   ES,R5L
00435B 440C0D          9860         CMP.B   [R4+13],R0L
00435E FD34            9861         BLE     _677
                       9862 ; rtxc.c   3537       {
                       9863 ; rtxc.c   3538          /* fast return since no shuffling necessary */
                       9864 ; rtxc.c   3539          return;
                       9865 ; rtxc.c   3540       }
                       9866 ; rtxc.c   3541 
                       9867 ; rtxc.c   3542       /* insert by walking backwards */
                       9868 ; rtxc.c   3543       bwd_insert(ptcb);
004360 8913            9869         MOV.W   R1,R3
004362 8902            9870         MOV.W   R0,R2
004364 C500B2          9871         CALL    _bwd_insert
                       9872 ; rtxc.c   3544       return;
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 173

ADDR   CODE            LINE SOURCELINE
004367 FE30            9873         BR      _677
004367 FE3000          9873         BR      _677
                       9874 ; rtxc.c   3545    }
00436A                 9875 _668:
                       9876 ; rtxc.c   3546 
                       9877 ; rtxc.c   3547    /* else task is somewhere in middle of list */
                       9878 ; rtxc.c   3548 
                       9879 ; rtxc.c   3549    /* if relative priorities are unchanged */
                       9880 ; rtxc.c   3550    if ( (ptcb->blink->priority <= ptcb->priority) &&
                       9881 ; rtxc.c   3551         (ptcb->priority <= ptcb->flink->priority) )
00436A 86AC42          9882         MOV.B   ES,R5L
00436D 8A04            9883         MOV.W   R0,[R4]
00436F 8C1402          9884         MOV.W   R1,[R4+2]
004372 8C3F02          9885         MOV.W   [R7+2],R3
004375 8A2F            9886         MOV.W   [R7],R2
004377 866C42          9887         MOV.B   ES,R3L
00437A 84420D          9888         MOV.B   R2L,[R2+13]
00437D 862C42          9889         MOV.B   ES,R1L
004380 44480D          9890         CMP.B   [R0+13],R2L
004383 FC11            9891         BGT     _669
004385 8C1702          9892         MOV.W   R1,[R7+2]
004388 8A07            9893         MOV.W   R0,[R7]
00438A 862C42          9894         MOV.B   ES,R1L
00438D 8C1002          9895         MOV.W   R1,[R0+2]
004390 8A00            9896         MOV.W   R0,[R0]
004392 862C42          9897         MOV.B   ES,R1L
004395 84500D          9898         MOV.B   R2H,[R0+13]
004398 8C1702          9899         MOV.W   R1,[R7+2]
00439B 8A07            9900         MOV.W   R0,[R7]
00439D 862C42          9901         MOV.B   ES,R1L
0043A0 44580D          9902         CMP.B   [R0+13],R2H
0043A3 FD12            9903         BLE     _677
0043A3 FD1200          9903         BLE     _677
                       9904 ; rtxc.c   3552    {
                       9905 ; rtxc.c   3553       /* fast return since no shuffling necessary */
                       9906 ; rtxc.c   3554       return;
                       9907 ; rtxc.c   3555    }
0043A6                 9908 _669:
                       9909 ; rtxc.c   3556 
                       9910 ; rtxc.c   3557    /* if new priority < left-side */
                       9911 ; rtxc.c   3558    if (ptcb->priority < ptcb->blink->priority)
0043A6 86AC42          9912         MOV.B   ES,R5L
0043A9 8C5402          9913         MOV.W   R5,[R4+2]
0043AC 8A44            9914         MOV.W   R4,[R4]
0043AE 86AC42          9915         MOV.B   ES,R5L
0043B1 444C0D          9916         CMP.B   [R4+13],R2L
0043B4 FD05            9917         BLE     _670
                       9918 ; rtxc.c   3559    {
                       9919 ; rtxc.c   3560       bwd_insert(ptcb);
0043B6 8C1702          9920         MOV.W   R1,[R7+2]
0043B9 8A07            9921         MOV.W   R0,[R7]
0043BB C50086          9922         CALL    _bwd_insert
                       9923 ; rtxc.c   3561    }
0043BE FE04            9924         BR      _677
0043BE FE04            9924         BR      _677
0043C0                 9925 _670:
                       9926 ; rtxc.c   3562    else
                       9927 ; rtxc.c   3563    {
                       9928 ; rtxc.c   3564       fwd_insert(ptcb);
0043C0 8C1702          9929         MOV.W   R1,[R7+2]
0043C3 8A07            9930         MOV.W   R0,[R7]
0043C5 C50003          9931         CALL    _fwd_insert
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 174

ADDR   CODE            LINE SOURCELINE
0043C5 C50003          9931         CALL    _fwd_insert
                       9932 ; rtxc.c   3565    }
                       9933 ; rtxc.c   3566 }
0043C8                 9934 _677:
0043C8 A974            9935         ADDS.W  R7,#04H
0043CA 2F30            9936         POP.W   R4, R5
0043CC D680            9937         RET
0043CC D680            9937         RET
                       9938 ; rtxc.c   3567 
                       9939 ; rtxc.c   3568 /*
                       9940 ; rtxc.c   3569  *
                       9941 ; rtxc.c   3570  * remove TCB from respective WAITER list and re-insert in forward direction
                       9942 ; rtxc.c   3571  *
                       9943 ; rtxc.c   3572 */
                       9944 ; rtxc.c   3573 static void fwd_insert(TCB ks_tbl *ptcb)
                       9945 ; rtxc.c   3574 {
0043CE                 9946 _fwd_insert:
0043CE 0F70            9947         PUSH.W  R4, R5, R6
0043D0 9972000C        9948         SUB.W   R7,#0CH
                       9949 ; rtxc.c   3575    TCB ks_tbl *prev;
                       9950 ; rtxc.c   3576    TCB ks_tbl *next;
                       9951 ; rtxc.c   3577    PRIORITY priority;
                       9952 ; rtxc.c   3578 
                       9953 ; rtxc.c   3579    priority = ptcb->priority;
0043D4 862C42          9954         MOV.B   ES,R1L
0043D7 84C00D          9955         MOV.B   R6L,[R0+13]
                       9956 ; rtxc.c   3580 
                       9957 ; rtxc.c   3581    prev = ptcb->flink;
0043DA 862C42          9958         MOV.B   ES,R1L
0043DD 8A20            9959         MOV.W   R2,[R0]
0043DF 8C3002          9960         MOV.W   R3,[R0+2]
0043E2 8C3F06          9961         MOV.W   [R7+6],R3
0043E5 8C2F04          9962         MOV.W   [R7+4],R2
                       9963 ; rtxc.c   3582 
                       9964 ; rtxc.c   3583    /* unlink task from respective WAITER list */
                       9965 ; rtxc.c   3584    ptcb->flink->blink = ptcb->blink;
0043E8 8951            9966         MOV.W   R5,R1
0043EA 8940            9967         MOV.W   R4,R0
0043EC 99400004        9968         ADD.W   R4,#04H
0043F0 8C5F02          9969         MOV.W   [R7+2],R5
0043F3 8A4F            9970         MOV.W   [R7],R4
0043F5 8C1F0A          9971         MOV.W   [R7+10],R1
0043F8 8C0F08          9972         MOV.W   [R7+8],R0
0043FB 862C42          9973         MOV.B   ES,R1L
0043FE 8C1006          9974         MOV.W   R1,[R0+6]
004401 8C0004          9975         MOV.W   R0,[R0+4]
004404 8C570A          9976         MOV.W   R5,[R7+10]
004407 8C4708          9977         MOV.W   R4,[R7+8]
00440A 86AC42          9978         MOV.B   ES,R5L
00440D 8C5402          9979         MOV.W   R5,[R4+2]
004410 8A44            9980         MOV.W   R4,[R4]
004412 86AC42          9981         MOV.B   ES,R5L
004415 8C0C04          9982         MOV.W   [R4+4],R0
004418 8C1C06          9983         MOV.W   [R4+6],R1
                       9984 ; rtxc.c   3585    ptcb->blink->flink = ptcb->flink;
00441B 8C170A          9985         MOV.W   R1,[R7+10]
00441E 8C0708          9986         MOV.W   R0,[R7+8]
004421 862C42          9987         MOV.B   ES,R1L
004424 8C1002          9988         MOV.W   R1,[R0+2]
004427 8A00            9989         MOV.W   R0,[R0]
004429 8C570A          9990         MOV.W   R5,[R7+10]
00442C 8C4708          9991         MOV.W   R4,[R7+8]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 175

ADDR   CODE            LINE SOURCELINE
00442F 86AC42          9992         MOV.B   ES,R5L
004432 8C5406          9993         MOV.W   R5,[R4+6]
004435 8C4404          9994         MOV.W   R4,[R4+4]
004438 86AC42          9995         MOV.B   ES,R5L
00443B 8A0C            9996         MOV.W   [R4],R0
00443D 8C1C02          9997         MOV.W   [R4+2],R1
                       9998 ; rtxc.c   3586 
                       9999 ; rtxc.c   3587    while ( ((next = prev->flink) != NULLTCB) &&
004440 866C42         10000         MOV.B   ES,R3L
004443 8C3202         10001         MOV.W   R3,[R2+2]
004446 8A22           10002         MOV.W   R2,[R2]
004448 8913           10003         MOV.W   R1,R3
00444A 8902           10004         MOV.W   R0,R2
00444C 8951           10005         MOV.W   R5,R1
00444E 8940           10006         MOV.W   R4,R0
004450 6910           10007         OR.W    R1,R0
004452 F315           10008         BEQ     _686
004454 866C42         10009         MOV.B   ES,R3L
004457 44CA0D         10010         CMP.B   [R2+13],R6L
00445A FC11           10011         BGT     _686
00445A FC11           10011         BGT     _686
                      10012 ; rtxc.c   3588           (next->priority <= priority) )
00445C                10013 _683:
                      10014 ; rtxc.c   3589       prev = next;
00445C 8C5F06         10015         MOV.W   [R7+6],R5
00445F 8C4F04         10016         MOV.W   [R7+4],R4
004462 86AC42         10017         MOV.B   ES,R5L
004465 8A24           10018         MOV.W   R2,[R4]
004467 8C3402         10019         MOV.W   R3,[R4+2]
00446A 8913           10020         MOV.W   R1,R3
00446C 8902           10021         MOV.W   R0,R2
00446E 8951           10022         MOV.W   R5,R1
004470 8940           10023         MOV.W   R4,R0
004472 6910           10024         OR.W    R1,R0
004474 F304           10025         BEQ     _686
004476 866C42         10026         MOV.B   ES,R3L
004479 44CA0D         10027         CMP.B   [R2+13],R6L
00447C FDEF           10028         BLE     _683
00447C FDEF           10028         BLE     _683
00447E                10029 _686:
                      10030 ; rtxc.c   3590 
                      10031 ; rtxc.c   3591    prev->flink = ptcb;
00447E 8C170A         10032         MOV.W   R1,[R7+10]
004481 8C0708         10033         MOV.W   R0,[R7+8]
004484 8C3706         10034         MOV.W   R3,[R7+6]
004487 8C2704         10035         MOV.W   R2,[R7+4]
00448A 866C42         10036         MOV.B   ES,R3L
00448D 8A0A           10037         MOV.W   [R2],R0
00448F 8C1A02         10038         MOV.W   [R2+2],R1
                      10039 ; rtxc.c   3592    ptcb->blink = prev;
004492 8913           10040         MOV.W   R1,R3
004494 8902           10041         MOV.W   R0,R2
004496 8C3702         10042         MOV.W   R3,[R7+2]
004499 8A27           10043         MOV.W   R2,[R7]
00449B 866C42         10044         MOV.B   ES,R3L
00449E 8A0A           10045         MOV.W   [R2],R0
0044A0 8C1A02         10046         MOV.W   [R2+2],R1
                      10047 ; rtxc.c   3593 
                      10048 ; rtxc.c   3594    if ( (ptcb->flink = next) != NULLTCB)
0044A3 8C170A         10049         MOV.W   R1,[R7+10]
0044A6 8C0708         10050         MOV.W   R0,[R7+8]
0044A9 862C42         10051         MOV.B   ES,R1L
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 176

ADDR   CODE            LINE SOURCELINE
0044AC 8A48           10052         MOV.W   [R0],R4
0044AE 8C5802         10053         MOV.W   [R0+2],R5
0044B1 8935           10054         MOV.W   R3,R5
0044B3 8924           10055         MOV.W   R2,R4
0044B5 6954           10056         OR.W    R5,R4
0044B7 F305           10057         BEQ     _687
                      10058 ; rtxc.c   3595       next->blink = ptcb;
0044B9 866C42         10059         MOV.B   ES,R3L
0044BC 8C0A04         10060         MOV.W   [R2+4],R0
0044BF 8C1A06         10061         MOV.W   [R2+6],R1
0044BF 8C1A06         10061         MOV.W   [R2+6],R1
0044C2                10062 _687:
                      10063 ; rtxc.c   3596 }
0044C2 9970000C       10064         ADD.W   R7,#0CH
0044C6 2F70           10065         POP.W   R4, R5, R6
0044C8 D680           10066         RET
0044C8 D680           10066         RET
                      10067 ; rtxc.c   3597 
                      10068 ; rtxc.c   3598 /*
                      10069 ; rtxc.c   3599  *
                      10070 ; rtxc.c   3600  * remove TCB from respective WAITER list and re-insert in backward direction
                      10071 ; rtxc.c   3601  *
                      10072 ; rtxc.c   3602 */
                      10073 ; rtxc.c   3603 static void bwd_insert(TCB ks_tbl *ptcb)
                      10074 ; rtxc.c   3604 {
0044CA                10075 _bwd_insert:
0044CA 0F70           10076         PUSH.W  R4, R5, R6
0044CC 9972000C       10077         SUB.W   R7,#0CH
                      10078 ; rtxc.c   3605    TCB ks_tbl *prev;
                      10079 ; rtxc.c   3606    TCB ks_tbl *next;
                      10080 ; rtxc.c   3607    PRIORITY priority;
                      10081 ; rtxc.c   3608 
                      10082 ; rtxc.c   3609    priority = ptcb->priority;
0044D0 862C42         10083         MOV.B   ES,R1L
0044D3 84C00D         10084         MOV.B   R6L,[R0+13]
                      10085 ; rtxc.c   3610 
                      10086 ; rtxc.c   3611    prev = ptcb->blink;
0044D6 8931           10087         MOV.W   R3,R1
0044D8 8920           10088         MOV.W   R2,R0
0044DA 99200004       10089         ADD.W   R2,#04H
0044DE 8C3F06         10090         MOV.W   [R7+6],R3
0044E1 8C2F04         10091         MOV.W   [R7+4],R2
0044E4 8C1F0A         10092         MOV.W   [R7+10],R1
0044E7 8C0F08         10093         MOV.W   [R7+8],R0
0044EA 862C42         10094         MOV.B   ES,R1L
0044ED 8C4004         10095         MOV.W   R4,[R0+4]
0044F0 8C5006         10096         MOV.W   R5,[R0+6]
0044F3 8C5F02         10097         MOV.W   [R7+2],R5
0044F6 8A4F           10098         MOV.W   [R7],R4
                      10099 ; rtxc.c   3612 
                      10100 ; rtxc.c   3613    /* unlink task from respective WAITER list */
                      10101 ; rtxc.c   3614    if ((ptcb->blink->flink = ptcb->flink) != NULLTCB )
0044F8 8C170A         10102         MOV.W   R1,[R7+10]
0044FB 8C0708         10103         MOV.W   R0,[R7+8]
0044FE 862C42         10104         MOV.B   ES,R1L
004501 8A20           10105         MOV.W   R2,[R0]
004503 8C3002         10106         MOV.W   R3,[R0+2]
004506 8C170A         10107         MOV.W   R1,[R7+10]
004509 8C0708         10108         MOV.W   R0,[R7+8]
00450C 862C42         10109         MOV.B   ES,R1L
00450F 8C1006         10110         MOV.W   R1,[R0+6]
004512 8C0004         10111         MOV.W   R0,[R0+4]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 177

ADDR   CODE            LINE SOURCELINE
004515 862C42         10112         MOV.B   ES,R1L
004518 8A28           10113         MOV.W   [R0],R2
00451A 8C3802         10114         MOV.W   [R0+2],R3
00451D 6932           10115         OR.W    R3,R2
00451F F314           10116         BEQ     _690
                      10117 ; rtxc.c   3615         ptcb->flink->blink = ptcb->blink;
004521 8C170A         10118         MOV.W   R1,[R7+10]
004524 8C0708         10119         MOV.W   R0,[R7+8]
004527 862C42         10120         MOV.B   ES,R1L
00452A 8C2004         10121         MOV.W   R2,[R0+4]
00452D 8C3006         10122         MOV.W   R3,[R0+6]
004530 8C170A         10123         MOV.W   R1,[R7+10]
004533 8C0708         10124         MOV.W   R0,[R7+8]
004536 862C42         10125         MOV.B   ES,R1L
004539 8C1002         10126         MOV.W   R1,[R0+2]
00453C 8A00           10127         MOV.W   R0,[R0]
00453E 862C42         10128         MOV.B   ES,R1L
004541 8C2804         10129         MOV.W   [R0+4],R2
004544 8C3806         10130         MOV.W   [R0+6],R3
004544 8C380600       10130         MOV.W   [R0+6],R3
004548                10131 _690:
                      10132 ; rtxc.c   3616 
                      10133 ; rtxc.c   3617    for (next = prev->blink;
004548 86AC42         10134         MOV.B   ES,R5L
00454B 8C2404         10135         MOV.W   R2,[R4+4]
00454E 8C3406         10136         MOV.W   R3,[R4+6]
004551 8953           10137         MOV.W   R5,R3
004553 8942           10138         MOV.W   R4,R2
004555 866C42         10139         MOV.B   ES,R3L
004558 8C0204         10140         MOV.W   R0,[R2+4]
00455B 8C1206         10141         MOV.W   R1,[R2+6]
00455E 6910           10142         OR.W    R1,R0
004560 F318           10143         BEQ     _694
004562 866C42         10144         MOV.B   ES,R3L
004565 44CA0D         10145         CMP.B   [R2+13],R6L
004568 FD14           10146         BLE     _694
004568 FD14           10146         BLE     _694
00456A                10147 _691:
                      10148 ; rtxc.c   3618       (next->blink != NULLTCB) && (priority < next->priority);
                      10149 ; rtxc.c   3619       prev = next, next = prev->blink)
00456A 8C5F02         10150         MOV.W   [R7+2],R5
00456D 8A4F           10151         MOV.W   [R7],R4
00456F 86AC42         10152         MOV.B   ES,R5L
004572 8C2404         10153         MOV.W   R2,[R4+4]
004575 8C3406         10154         MOV.W   R3,[R4+6]
004578 8953           10155         MOV.W   R5,R3
00457A 8942           10156         MOV.W   R4,R2
00457C 866C42         10157         MOV.B   ES,R3L
00457F 8C0204         10158         MOV.W   R0,[R2+4]
004582 8C1206         10159         MOV.W   R1,[R2+6]
004585 6910           10160         OR.W    R1,R0
004587 F305           10161         BEQ     _694
004589 866C42         10162         MOV.B   ES,R3L
00458C 44CA0D         10163         CMP.B   [R2+13],R6L
00458F FCED           10164         BGT     _691
00458F FCED00         10164         BGT     _691
                      10165 ; rtxc.c   3620       ; /* yes - a null loop is intended here */
004592                10166 _694:
                      10167 ; rtxc.c   3621 
                      10168 ; rtxc.c   3622    prev->blink = ptcb;
004592 8C170A         10169         MOV.W   R1,[R7+10]
004595 8C0708         10170         MOV.W   R0,[R7+8]
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 178

ADDR   CODE            LINE SOURCELINE
004598 8C3702         10171         MOV.W   R3,[R7+2]
00459B 8A27           10172         MOV.W   R2,[R7]
00459D 866C42         10173         MOV.B   ES,R3L
0045A0 8C0A04         10174         MOV.W   [R2+4],R0
0045A3 8C1A06         10175         MOV.W   [R2+6],R1
                      10176 ; rtxc.c   3623    ptcb->flink = prev;
0045A6 8913           10177         MOV.W   R1,R3
0045A8 8902           10178         MOV.W   R0,R2
0045AA 8C370A         10179         MOV.W   R3,[R7+10]
0045AD 8C2708         10180         MOV.W   R2,[R7+8]
0045B0 866C42         10181         MOV.B   ES,R3L
0045B3 8A0A           10182         MOV.W   [R2],R0
0045B5 8C1A02         10183         MOV.W   [R2+2],R1
                      10184 ; rtxc.c   3624 
                      10185 ; rtxc.c   3625    ptcb->blink = next;
0045B8 8C1706         10186         MOV.W   R1,[R7+6]
0045BB 8C0704         10187         MOV.W   R0,[R7+4]
0045BE 862C42         10188         MOV.B   ES,R1L
0045C1 8A48           10189         MOV.W   [R0],R4
0045C3 8C5802         10190         MOV.W   [R0+2],R5
                      10191 ; rtxc.c   3626    next->flink = ptcb;
0045C6 8913           10192         MOV.W   R1,R3
0045C8 8902           10193         MOV.W   R0,R2
0045CA 86AC42         10194         MOV.B   ES,R5L
0045CD 8A0C           10195         MOV.W   [R4],R0
0045CF 8C1C02         10196         MOV.W   [R4+2],R1
                      10197 ; rtxc.c   3627 }
0045D2 9970000C       10198         ADD.W   R7,#0CH
0045D6 2F70           10199         POP.W   R4, R5, R6
0045D8 D680           10200         RET
0045D8 D680           10200         RET
                      10201 ; rtxc.c   3628 #endif /* } - MAILBOX_ || PARTITION_ || QUEUE_ || RESOURCE_WAITERS */
                      10202 ; rtxc.c   3629 
                      10203 ; rtxc.c   3630 /*
                      10204 ; rtxc.c   3631  *
                      10205 ; rtxc.c   3632  * change priority of a task
                      10206 ; rtxc.c   3633  *
                      10207 ; rtxc.c   3634 */
                      10208 ; rtxc.c   3635 static void chgpriority(TCB ks_tbl *ptcb, PRIORITY priority)
                      10209 ; rtxc.c   3636 {
0045DA                10210 _chgpriority:
0045DA 0F70           10211         PUSH.W  R4, R5, R6
0045DC A97C           10212         ADDS.W  R7,#0CH
                      10213 ; rtxc.c   3637    /* set new priority */
                      10214 ; rtxc.c   3638    ptcb->priority = priority;
0045DE 81C4           10215         MOV.B   R6L,R2L
0045E0 862C42         10216         MOV.B   ES,R1L
0045E3 84480D         10217         MOV.B   [R0+13],R2L
                      10218 ; rtxc.c   3639 
                      10219 ; rtxc.c   3640    /* if current task is changing its own priority */
                      10220 ; rtxc.c   3641    if (hipritsk->task == ptcb->task)
0045E6 8E5rrr         10221         MOV.W   R5,_hipritsk+2
0045E9 8E4rrr         10222         MOV.W   R4,_hipritsk
0045EC 862C42         10223         MOV.B   ES,R1L
0045EF 84500C         10224         MOV.B   R2H,[R0+12]
0045F2 8E5rrr         10225         MOV.W   _hipritsk+2,R5
0045F5 8E4rrr         10226         MOV.W   _hipritsk,R4
0045F8 86AC42         10227         MOV.B   ES,R5L
0045FB 445C0C         10228         CMP.B   [R4+12],R2H
0045FE F225           10229         BNE     _697
                      10230 ; rtxc.c   3642    {
                      10231 ; rtxc.c   3643       /* if relative priorities are unchanged */
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 179

ADDR   CODE            LINE SOURCELINE
                      10232 ; rtxc.c   3644       if (ptcb->priority <= ptcb->flink->priority)
004600 862C42         10233         MOV.B   ES,R1L
004603 8A40           10234         MOV.W   R4,[R0]
004605 8C5002         10235         MOV.W   R5,[R0+2]
004608 86AC42         10236         MOV.B   ES,R5L
00460B 44CC0D         10237         CMP.B   [R4+13],R6L
00460E FA64           10238         BGE     _704
004610 8E3rrr         10239         MOV.W   R3,_hipritsk+2
004613 8E2rrr         10240         MOV.W   R2,_hipritsk
                      10241 ; rtxc.c   3645       {
                      10242 ; rtxc.c   3646          /* fast return since no shuffling necessary */
                      10243 ; rtxc.c   3647          return;
                      10244 ; rtxc.c   3648       }
                      10245 ; rtxc.c   3649 
                      10246 ; rtxc.c   3650       /* remove task from READY list (it is ALWAYS first in list) */
                      10247 ; rtxc.c   3651       UNLINK_HIPRITSK();
004616 866C42         10248         MOV.B   ES,R3L
004619 8C3202         10249         MOV.W   R3,[R2+2]
00461C 8A22           10250         MOV.W   R2,[R2]
00461E 8E3rrr         10251         MOV.W   _hipritsk+2,R3
004621 8E2rrr         10252         MOV.W   _hipritsk,R2
004624 9948rrrr       10253         MOV.W   R4,#SOF( _hipritsk )
004628 B950           10254         MOVS.W  R5,#00H
00462A 866C42         10255         MOV.B   ES,R3L
00462D 8C4A04         10256         MOV.W   [R2+4],R4
004630 8C5A06         10257         MOV.W   [R2+6],R5
                      10258 ; rtxc.c   3652 
                      10259 ; rtxc.c   3653       /* re-insert task */
                      10260 ; rtxc.c   3654       ptcb->flink = nsrttcb;
004633 8E3rrr         10261         MOV.W   R3,_nsrttcb+2
004636 8E2rrr         10262         MOV.W   R2,_nsrttcb
004639 862C42         10263         MOV.B   ES,R1L
00463C 8A28           10264         MOV.W   [R0],R2
00463E 8C3802         10265         MOV.W   [R0+2],R3
                      10266 ; rtxc.c   3655       nsrttcb = ptcb;
004641 8E1rrr         10267         MOV.W   _nsrttcb+2,R1
004644 8E0rrr         10268         MOV.W   _nsrttcb,R0
                      10269 ; rtxc.c   3656 
                      10270 ; rtxc.c   3657       return;
004647 FE48           10271         BR      _704
004647 FE4800         10271         BR      _704
                      10272 ; rtxc.c   3658    }
00464A                10273 _697:
                      10274 ; rtxc.c   3659 
                      10275 ; rtxc.c   3660    /* if task being changed is RUNnable */
                      10276 ; rtxc.c   3661    if (ptcb->status == READY)
00464A 862C42         10277         MOV.B   ES,R1L
00464D 8C3012         10278         MOV.W   R3,[R0+18]
004650 F23E           10279         BNE     _699
                      10280 ; rtxc.c   3662    {
                      10281 ; rtxc.c   3663       /* if relative priorities are unchanged */
                      10282 ; rtxc.c   3664       if ( (ptcb->blink->priority <= ptcb->priority) &&
                      10283 ; rtxc.c   3665            (ptcb->priority <= ptcb->flink->priority) )
004652 8951           10284         MOV.W   R5,R1
004654 8940           10285         MOV.W   R4,R0
004656 99400004       10286         ADD.W   R4,#04H
00465A 862C42         10287         MOV.B   ES,R1L
00465D 8C2004         10288         MOV.W   R2,[R0+4]
004660 8C3006         10289         MOV.W   R3,[R0+6]
004663 866C42         10290         MOV.B   ES,R3L
004666 44CA0D         10291         CMP.B   [R2+13],R6L
004669 FC09           10292         BGT     _698
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 180

ADDR   CODE            LINE SOURCELINE
00466B 862C42         10293         MOV.B   ES,R1L
00466E 8A20           10294         MOV.W   R2,[R0]
004670 8C3002         10295         MOV.W   R3,[R0+2]
004673 866C42         10296         MOV.B   ES,R3L
004676 44CA0D         10297         CMP.B   [R2+13],R6L
004679 FA2F           10298         BGE     _704
004679 FA2F00         10298         BGE     _704
                      10299 ; rtxc.c   3666       {
                      10300 ; rtxc.c   3667          /* fast return since no shuffling necessary */
                      10301 ; rtxc.c   3668          return;
                      10302 ; rtxc.c   3669       }
00467C                10303 _698:
                      10304 ; rtxc.c   3670 
                      10305 ; rtxc.c   3671       /* else unlink task from RUN list */
                      10306 ; rtxc.c   3672       ptcb->flink->blink = ptcb->blink;
00467C 8C5F02         10307         MOV.W   [R7+2],R5
00467F 8A4F           10308         MOV.W   [R7],R4
004681 86AC42         10309         MOV.B   ES,R5L
004684 8A24           10310         MOV.W   R2,[R4]
004686 8C3402         10311         MOV.W   R3,[R4+2]
004689 862C42         10312         MOV.B   ES,R1L
00468C 8A40           10313         MOV.W   R4,[R0]
00468E 8C5002         10314         MOV.W   R5,[R0+2]
004691 86AC42         10315         MOV.B   ES,R5L
004694 8C2C04         10316         MOV.W   [R4+4],R2
004697 8C3C06         10317         MOV.W   [R4+6],R3
                      10318 ; rtxc.c   3673       ptcb->blink->flink = ptcb->flink;
00469A 862C42         10319         MOV.B   ES,R1L
00469D 8A20           10320         MOV.W   R2,[R0]
00469F 8C3002         10321         MOV.W   R3,[R0+2]
0046A2 8C5702         10322         MOV.W   R5,[R7+2]
0046A5 8A47           10323         MOV.W   R4,[R7]
0046A7 86AC42         10324         MOV.B   ES,R5L
0046AA 8C5402         10325         MOV.W   R5,[R4+2]
0046AD 8A44           10326         MOV.W   R4,[R4]
0046AF 86AC42         10327         MOV.B   ES,R5L
0046B2 8A2C           10328         MOV.W   [R4],R2
0046B4 8C3C02         10329         MOV.W   [R4+2],R3
                      10330 ; rtxc.c   3674 
                      10331 ; rtxc.c   3675       /* re-insert task */
                      10332 ; rtxc.c   3676       ptcb->flink = nsrttcb;
0046B7 8E3rrr         10333         MOV.W   R3,_nsrttcb+2
0046BA 8E2rrr         10334         MOV.W   R2,_nsrttcb
0046BD 862C42         10335         MOV.B   ES,R1L
0046C0 8A28           10336         MOV.W   [R0],R2
0046C2 8C3802         10337         MOV.W   [R0+2],R3
                      10338 ; rtxc.c   3677       nsrttcb = ptcb;
0046C5 8E1rrr         10339         MOV.W   _nsrttcb+2,R1
0046C8 8E0rrr         10340         MOV.W   _nsrttcb,R0
                      10341 ; rtxc.c   3678 
                      10342 ; rtxc.c   3679       return;
0046CB FE06           10343         BR      _704
0046CB FE0600         10343         BR      _704
                      10344 ; rtxc.c   3680    }
0046CE                10345 _699:
                      10346 ; rtxc.c   3681 
                      10347 ; rtxc.c   3682 #if defined(MAILBOX_WAITERS)   || \ 
                      10348 ; rtxc.c   3683     defined(PARTITION_WAITERS) || \ 
                      10349 ; rtxc.c   3684     defined(QUEUE_WAITERS)     || \ 
                      10350 ; rtxc.c   3685     defined(RESOURCE_WAITERS)  /* { */
                      10351 ; rtxc.c   3686 
                      10352 ; rtxc.c   3687    /* if task being changed is in a WAITER list */
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 181

ADDR   CODE            LINE SOURCELINE
                      10353 ; rtxc.c   3688    if (ptcb->status & COMBO_WAIT)
0046CE 993500AA       10354         AND.W   R3,#0AAH
0046D2 F302           10355         BEQ     _704
                      10356 ; rtxc.c   3689    {
                      10357 ; rtxc.c   3690       reorder_waiters(ptcb);
0046D4 C5FE0B         10358         CALL    _reorder_waiters
0046D4 C5FE0B00       10358         CALL    _reorder_waiters
                      10359 ; rtxc.c   3691    }
                      10360 ; rtxc.c   3692 #endif /* } - MAILBOX_ || PARTITION_ || QUEUE_ || RESOURCE_WAITERS */
                      10361 ; rtxc.c   3693 
                      10362 ; rtxc.c   3694    return;
                      10363 ; rtxc.c   3695 }
0046D8                10364 _704:
0046D8 A974           10365         ADDS.W  R7,#04H
0046DA 2F70           10366         POP.W   R4, R5, R6
0046DC D680           10367         RET
0046DC D680           10367         RET
                      10368 ; rtxc.c   3696 
                      10369 ; rtxc.c   3697 #ifdef HAS_PARTITIONS /* { */
                      10370 ; rtxc.c   3698 #ifdef DYNAMIC_PARTS /* { */
                      10371 ; rtxc.c   3699 static void dn_defpart(PHEADER ks_tbl *pph, KSNUM ks_stk *p2)
                      10372 ; rtxc.c   3700 {
0046DE                10373 _dn_defpart:
0046DE 0F70           10374         PUSH.W  R4, R5, R6
0046E0 9972000A       10375         SUB.W   R7,#0AH
                      10376 ; rtxc.c   3701    size_t count, blksize;
                      10377 ; rtxc.c   3702    char **next;
                      10378 ; rtxc.c   3703    int j;
                      10379 ; rtxc.c   3704 
                      10380 ; rtxc.c   3705    pph->addr = ((struct parg ks_stk *)p2)->addr;
0046E4 866C42         10381         MOV.B   ES,R3L
0046E7 8C4214         10382         MOV.W   R4,[R2+20]
0046EA 8C5216         10383         MOV.W   R5,[R2+22]
0046ED 862C42         10384         MOV.B   ES,R1L
0046F0 8C4812         10385         MOV.W   [R0+18],R4
0046F3 8C5814         10386         MOV.W   [R0+20],R5
                      10387 ; rtxc.c   3706    blksize = ((struct parg ks_stk *)p2)->size;
0046F6 866C42         10388         MOV.B   ES,R3L
0046F9 8C620A         10389         MOV.W   R6,[R2+10]
0046FC 8C6F04         10390         MOV.W   [R7+4],R6
                      10391 ; rtxc.c   3707    count = ((struct parg ks_stk *)p2)->nblocks;
0046FF 866C42         10392         MOV.B   ES,R3L
004702 8C6218         10393         MOV.W   R6,[R2+24]
                      10394 ; rtxc.c   3708 
                      10395 ; rtxc.c   3709    pph->next = (struct xmap *)pph->addr;
004705 862C42         10396         MOV.B   ES,R1L
004708 8A48           10397         MOV.W   [R0],R4
00470A 8C5802         10398         MOV.W   [R0+2],R5
                      10399 ; rtxc.c   3710 
                      10400 ; rtxc.c   3711    next = (char **)pph->next;
00470D 8C1F08         10401         MOV.W   [R7+8],R1
004710 8C0F06         10402         MOV.W   [R7+6],R0
004713 862C42         10403         MOV.B   ES,R1L
004716 8A40           10404         MOV.W   R4,[R0]
004718 8C5002         10405         MOV.W   R5,[R0+2]
00471B 8915           10406         MOV.W   R1,R5
00471D 8904           10407         MOV.W   R0,R4
                      10408 ; rtxc.c   3712    for (j = 1; j < count; j++, next = (char **)*next)
00471F B941           10409         MOV.W   R4,#01H
004721 866C42         10410         MOV.B   ES,R3L
004724 9C24180001     10411         CMP.W   [R2+24],#01H
004729 F915           10412         BL      _710
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 182

ADDR   CODE            LINE SOURCELINE
004729 F91500         10412         BL      _710
00472C                10413 _709:
                      10414 ; rtxc.c   3713       *next = (char *)next + blksize;
00472C 8C1F02         10415         MOV.W   [R7+2],R1
00472F 8A0F           10416         MOV.W   [R7],R0
004731 8931           10417         MOV.W   R3,R1
004733 8920           10418         MOV.W   R2,R0
004735 8C0704         10419         MOV.W   R0,[R7+4]
004738 B910           10420         MOVS.W  R1,#00H
00473A 0920           10421         ADD.W   R2,R0
00473C 8C1702         10422         MOV.W   R1,[R7+2]
00473F 8A07           10423         MOV.W   R0,[R7]
004741 862C42         10424         MOV.B   ES,R1L
004744 8A28           10425         MOV.W   [R0],R2
004746 8C3802         10426         MOV.W   [R0+2],R3
004749 A941           10427         ADDS.W  R4,#01H
00474B 8913           10428         MOV.W   R1,R3
00474D 8902           10429         MOV.W   R0,R2
00474F 4946           10430         CMP.W   R4,R6
004751 F1ED           10431         BCS     _709
004751 F1ED00         10431         BCS     _709
004754                10432 _710:
                      10433 ; rtxc.c   3714 
                      10434 ; rtxc.c   3715    *next = NULL; /* null last link */
004754 862C42         10435         MOV.B   ES,R1L
004757 BA00           10436         MOV.W   [R0],#00H
004759 BC0002         10437         MOV.W   [R0+2],#00H
                      10438 ; rtxc.c   3716    pph->size = blksize;
00475C 8C3708         10439         MOV.W   R3,[R7+8]
00475F 8C2706         10440         MOV.W   R2,[R7+6]
004762 8C0704         10441         MOV.W   R0,[R7+4]
004765 866C42         10442         MOV.B   ES,R3L
004768 8C0A04         10443         MOV.W   [R2+4],R0
                      10444 ; rtxc.c   3717    pph->count = count;
00476B 8913           10445         MOV.W   R1,R3
00476D 8902           10446         MOV.W   R0,R2
00476F 862C42         10447         MOV.B   ES,R1L
004772 8C6806         10448         MOV.W   [R0+6],R6
                      10449 ; rtxc.c   3718 
                      10450 ; rtxc.c   3719 #ifdef PARTITION_WAITERS /* { */
                      10451 ; rtxc.c   3720    pph->waiters = NULLTCB;
004775 8C1708         10452         MOV.W   R1,[R7+8]
004778 8C0706         10453         MOV.W   R0,[R7+6]
00477B 862C42         10454         MOV.B   ES,R1L
00477E BC0008         10455         MOV.W   [R0+8],#00H
004781 BC000A         10456         MOV.W   [R0+10],#00H
                      10457 ; rtxc.c   3721    pph->dummy = NULLTCB;
004784 862C42         10458         MOV.B   ES,R1L
004787 BC000C         10459         MOV.W   [R0+12],#00H
00478A BC000E         10460         MOV.W   [R0+14],#00H
                      10461 ; rtxc.c   3722 #endif /* } PARTITION_WAITERS */
                      10462 ; rtxc.c   3723 
                      10463 ; rtxc.c   3724 #ifdef CBUG /* { */
                      10464 ; rtxc.c   3725    pph->cur = 0;
                      10465 ; rtxc.c   3726    pph->worst = 0;
                      10466 ; rtxc.c   3727    pph->usage = 0;
                      10467 ; rtxc.c   3728 #endif /* } CBUG */
                      10468 ; rtxc.c   3729 
                      10469 ; rtxc.c   3730    return;
                      10470 ; rtxc.c   3731 }
00478D 9970000A       10471         ADD.W   R7,#0AH
004791 2F70           10472         POP.W   R4, R5, R6
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 183

ADDR   CODE            LINE SOURCELINE
004793 D680           10473         RET
004793 D68000         10473         RET
                      10474 ; rtxc.c   3732 #endif /* } DYNAMIC_PARTS */
                      10475 ; rtxc.c   3733 #endif /* } HAS_PARTITIONS */
                      10476 ; rtxc.c   3734 
                      10477 ; rtxc.c   3735 static void ks_memcpyFN(void ks_queue * d1, const void * s1, size_t n)
                      10478 ; rtxc.c   3736 {
004796                10479 _ks_memcpyFN:
004796 0F50           10480         PUSH.W  R4, R6
                      10481 ; rtxc.c   3737   register char ks_queue * d;
                      10482 ; rtxc.c   3738   register const char * s;
                      10483 ; rtxc.c   3739 
                      10484 ; rtxc.c   3740    s = s1;
                      10485 ; rtxc.c   3741    d = d1;
                      10486 ; rtxc.c   3742    while (n--)
004798 8946           10487         MOV.W   R4,R6
00479A A96F           10488         ADDS.W  R6,#0FH
00479C 6944           10489         OR.W    R4,R4
00479E F30D           10490         BEQ     _714
00479E F30D           10490         BEQ     _714
0047A0                10491 _713:
                      10492 ; rtxc.c   3743       *d++ = *s++;
0047A0 866C42         10493         MOV.B   ES,R3L
0047A3 8282           10494         MOV.B   R4L,[R2]
0047A5 862C42         10495         MOV.B   ES,R1L
0047A8 8288           10496         MOV.B   [R0],R4L
0047AA 99200001       10497         ADD.W   R2,#01H
0047AE 99000001       10498         ADD.W   R0,#01H
0047B2 8946           10499         MOV.W   R4,R6
0047B4 A96F           10500         ADDS.W  R6,#0FH
0047B6 6944           10501         OR.W    R4,R4
0047B8 F2F3           10502         BNE     _713
0047B8 F2F3           10502         BNE     _713
0047BA                10503 _714:
                      10504 ; rtxc.c   3744 }
0047BA 2F50           10505         POP.W   R4, R6
0047BC D680           10506         RET
0047BC D680           10506         RET
                      10507 ; rtxc.c   3745 
                      10508 ; rtxc.c   3746 static void ks_memcpyNF(void * d1, const void ks_queue * s1, size_t n)
                      10509 ; rtxc.c   3747 {
0047BE                10510 _ks_memcpyNF:
0047BE 0F50           10511         PUSH.W  R4, R6
                      10512 ; rtxc.c   3748   register char * d;
                      10513 ; rtxc.c   3749   register const char ks_queue * s;
                      10514 ; rtxc.c   3750 
                      10515 ; rtxc.c   3751    s = s1;
                      10516 ; rtxc.c   3752    d = d1;
                      10517 ; rtxc.c   3753    while (n--)
0047C0 8946           10518         MOV.W   R4,R6
0047C2 A96F           10519         ADDS.W  R6,#0FH
0047C4 6944           10520         OR.W    R4,R4
0047C6 F30D           10521         BEQ     _716
0047C6 F30D           10521         BEQ     _716
0047C8                10522 _715:
                      10523 ; rtxc.c   3754       *d++ = *s++;
0047C8 866C42         10524         MOV.B   ES,R3L
0047CB 8282           10525         MOV.B   R4L,[R2]
0047CD 862C42         10526         MOV.B   ES,R1L
0047D0 8288           10527         MOV.B   [R0],R4L
0047D2 99200001       10528         ADD.W   R2,#01H
0047D6 99000001       10529         ADD.W   R0,#01H
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 184

ADDR   CODE            LINE SOURCELINE
0047DA 8946           10530         MOV.W   R4,R6
0047DC A96F           10531         ADDS.W  R6,#0FH
0047DE 6944           10532         OR.W    R4,R4
0047E0 F2F3           10533         BNE     _715
0047E0 F2F3           10533         BNE     _715
0047E2                10534 _716:
                      10535 ; rtxc.c   3755 }
0047E2 2F50           10536         POP.W   R4, R6
0047E4 D680           10537         RET
                      10538 ; rtxc.c   3756 
                      10539 ; rtxc.c   3757 /* end of rtxc.c */
000000                10541 RTXC_CLR_FA     SEGMENT HDATA INSEGMENT CLEAR
000000                10542         RSEG    RTXC_CLR_FA
                      10543         ALIGN   1
000000                10544 _ratecnt:       DS      2
   |  RESERVED             
000001
                      10545         EXTRN   HDATA(_pkheader)
                      10546         PUBLIC  _clkqfl
                      10547         ALIGN   1
000002                10548 _clkqfl:        DS      4
   |  RESERVED             
000005
                      10549         PUBLIC  _dtcbfl
                      10550         ALIGN   1
000006                10551 _dtcbfl:        DS      4
   |  RESERVED             
000009
                      10552         EXTRN   HDATA(_semat)
                      10553         EXTRN   HDATA(_nsemas)
000000                10554 RTXC_CLR_NE@DS  SEGMENT DATA JOIN CLEAR
000000                10555         RSEG    RTXC_CLR_NE@DS
                      10556         PUBLIC  _semaget
                      10557         ALIGN   1
000000                10558 _semaget:       DS      4
   |  RESERVED             
000003
                      10559         EXTRN   HDATA(_dnparts)
                      10560         EXTRN   HDATA(_nqueues)
                      10561         EXTRN   HDATA(_ntasks)
                      10562         PUBLIC  _hipritsk
                      10563         ALIGN   1
000004                10564 _hipritsk:      DS      4
   |  RESERVED             
000007
                      10565         EXTRN   HDATA(_dntasks)
                      10566         EXTRN   HDATA(_rtxtcb)
                      10567         EXTRN   HDATA(_ntmrs)
00000A                10568         RSEG    RTXC_CLR_FA
                      10569         PUBLIC  _dphfl
                      10570         ALIGN   1
00000A                10571 _dphfl: DS      4
   |  RESERVED             
00000D
000008                10572         RSEG    RTXC_CLR_NE@DS
                      10573         PUBLIC  _intlvl
000008 RESERVED       10574 _intlvl:        DS      1
000008
00000E                10575         RSEG    RTXC_CLR_FA
                      10576         PUBLIC  _rtctimetick
                      10577         ALIGN   1
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 185

ADDR   CODE            LINE SOURCELINE
00000E                10578 _rtctimetick:   DS      2
   |  RESERVED             
00000F
                      10579         EXTRN   HDATA(_nres)
                      10580         EXTRN   HDATA(_clkrate)
                      10581         EXTRN   HDATA(_nmboxes)
                      10582         EXTRN   HDATA(_rheader)
000009                10583         RSEG    RTXC_CLR_NE@DS
                      10584         PUBLIC  _sliceup
000009 RESERVED       10585         ALIGN   1
000009
00000A                10586 _sliceup:       DS      4
   |  RESERVED             
00000D
000010                10587         RSEG    RTXC_CLR_FA
                      10588         PUBLIC  _rtctime
                      10589         ALIGN   1
000010                10590 _rtctime:       DS      4
   |  RESERVED             
000013
00000E                10591         RSEG    RTXC_CLR_NE@DS
                      10592         PUBLIC  _semaput
                      10593         ALIGN   1
00000E                10594 _semaput:       DS      4
   |  RESERVED             
000011
                      10595         PUBLIC  _nsrttcb
                      10596         ALIGN   1
000012                10597 _nsrttcb:       DS      4
   |  RESERVED             
000015
000014                10598         RSEG    RTXC_CLR_FA
                      10599         PUBLIC  _rtctick
                      10600         ALIGN   1
000014                10601 _rtctick:       DS      2
   |  RESERVED             
000015
                      10602         EXTRN   HDATA(_mheader)
                      10603         EXTRN   HDATA(_pheader)
                      10604         EXTRN   HDATA(_qheader)
                      10605         EXTRN   HCODE(_ks_enable)
                      10606         EXTRN   HCODE(__ICALL)
                      10607         EXTRN   HDATA(_nparts)
                      10608         PUBLIC  _clkqptr
                      10609         ALIGN   1
000016                10610 _clkqptr:       DS      4
   |  RESERVED             
000019
                      10611         EXTRN   HDATA(_qkheader)
                      10612         EXTRN   HDATA(_siglist)
00001A RESERVED       10613 _t_expired:     DS      1
00001A
                      10614         EXTRN   HDATA(_siglistsize)
000016                10615         RSEG    RTXC_CLR_NE@DS
                      10616         PUBLIC  _isrcnt
000016 RESERVED       10617 _isrcnt:        DS      1
000016
                      10618         EXTRN   HDATA(_rtxktcb)
                      10619         EXTRN   HCODE(_memcpy)
                      10620         EXTRN   HDATA(_clkq)
                      10621         CALLS   'rtxc', 'RTXC?insert_timer'
                      10622         CALLS   'rtxc', 'KS_ISRalloc'
XA assembler v2.0 r2                    SN00085795-037 (c) 1998 TASKING, Inc.
                                                                                                                            Page 186

ADDR   CODE            LINE SOURCELINE
                      10623         CALLS   'rtxc', 'RTXC?porder'
                      10624         CALLS   'rtxc', 'RTXC?insert_timer'
                      10625         CALLS   'rtxc', 'RTXC?unlink_timer'
                      10626         CALLS   'rtxc', 'RTXC?dn_defpart'
                      10627         CALLS   'rtxc', 'RTXC?reorder_waiters'
                      10628         CALLS   'rtxc', 'RTXC?porder'
                      10629         CALLS   'rtxc', 'RTXC?insert_timer'
                      10630         CALLS   'rtxc', 'RTXC?unlink_timer'
                      10631         CALLS   'rtxc', 'RTXC?get_clkblk'
                      10632         CALLS   'rtxc', 'RTXC?unlink_timer'
                      10633         CALLS   'rtxc', 'RTXC?get_clkblk'
                      10634         CALLS   'rtxc', 'RTXC?unlink_timer'
                      10635         CALLS   'rtxc', 'RTXC?insert_timer'
                      10636         CALLS   'rtxc', 'RTXC?unlink_timer'
                      10637         CALLS   'rtxc', 'RTXC?insert_timer'
                      10638         CALLS   'rtxc', 'RTXC?unlink_timer'
                      10639         CALLS   'rtxc', 'RTXC?insert_message'
                      10640         CALLS   'rtxc', 'RTXC?insert_timer'
                      10641         CALLS   'rtxc', 'RTXC?remove_message'
                      10642         CALLS   'rtxc', 'RTXC?porder'
                      10643         CALLS   'rtxc', 'RTXC?insert_timer'
                      10644         CALLS   'rtxc', 'RTXC?porder'
                      10645         CALLS   'rtxc', 'RTXC?insert_timer'
                      10646         CALLS   'rtxc', 'RTXC?unlink_timer'
                      10647         CALLS   'rtxc', 'memcpy'
                      10648         CALLS   'rtxc', 'RTXC?ks_memcpyFN'
                      10649         CALLS   'rtxc', 'RTXC?porder'
                      10650         CALLS   'rtxc', 'RTXC?insert_timer'
                      10651         CALLS   'rtxc', 'RTXC?ks_memcpyNF'
                      10652         CALLS   'rtxc', 'RTXC?unlink_timer'
                      10653         CALLS   'rtxc', 'RTXC?ks_memcpyFN'
                      10654         CALLS   'rtxc', 'RTXC?unlink_timer'
                      10655         CALLS   'rtxc', 'RTXC?ks_memcpyFN'
                      10656         CALLS   'rtxc', 'swap_pc_t0'
                      10657         CALLS   'rtxc', 'RTXC?unlink_timer'
                      10658         CALLS   'rtxc', 'RTXC?chgpriority'
                      10659         CALLS   'rtxc', 'RTXC?postem'
                      10660         CALLS   'taskinit', 'swap_pc_t0'
                      10661         CALLS   'KS_ISRexit', 'ks_enable'
                      10662         CALLS   'KS_ISRexit', 'RTXC?postem'
                      10663         CALLS   'RTXC?postem', 'RTXC?chgpriority'
                      10664         CALLS   'RTXC?postem', 'RTXC?insert_timer'
                      10665         CALLS   'RTXC?postem', 'RTXC?unlink_timer'
                      10666         CALLS   'RTXC?reorder_waiters', 'RTXC?fwd_insert'
                      10667         CALLS   'RTXC?reorder_waiters', 'RTXC?bwd_insert'
                      10668         CALLS   'RTXC?reorder_waiters', 'RTXC?fwd_insert'
                      10669         CALLS   'RTXC?chgpriority', 'RTXC?reorder_waiters'
