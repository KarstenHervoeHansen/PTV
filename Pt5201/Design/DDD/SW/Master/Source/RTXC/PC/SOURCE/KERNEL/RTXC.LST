Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 1
.\rtxc.asm



      1					     .286
      2					     ifndef  ??version
      3				     ?debug  macro
      4					     endm
      5				     publicdll macro name
      6					     public  name
      7					     endm
      8				     $comm   macro   name,dist,size,count
      9					     comm    dist name:BYTE:count*size
     10					     endm
     11					     else
     12				     $comm   macro   name,dist,size,count
     13					     comm    dist name[size]:BYTE:count
     14					     endm
     15					     endif
     16					     ?debug  V 301h
     17					     ?debug  S "rtxc.c"
     18					     ?debug  C E9336DC32606727478632E63
     19					     ?debug  C E95C6F2B26172E2E5C2E2E5C496E636C7564655C74797065646566+
     20					     ?debug  C 2E68
     21					     ?debug  C E9734F9326182E2E5C2E2E5C496E636C7564655C727478636F7074+
     22					     ?debug  C 732E68
     23					     ?debug  C E912599326172E2E5C2E2E5C496E636C7564655C62696E64696E67+
     24					     ?debug  C 2E68
     25					     ?debug  C E9F46CF222182E2E5C2E2E5C496E636C7564655C72747873747275+
     26					     ?debug  C 632E68
     27					     ?debug  C E9734F9326182E2E5C2E2E5C496E636C7564655C727478636F7074+
     28					     ?debug  C 732E68
     29					     ?debug  C E980639724172E2E5C2E2E5C496E636C7564655C72747863617267+
     30					     ?debug  C 2E68
     31					     ?debug  C E9858AD922162E2E5C2E2E5C496E636C7564655C7473746174652E+
     32					     ?debug  C 68
     33					     ?debug  C E906948923162E2E5C2E2E5C496E636C7564655C656E61626C652E+
     34					     ?debug  C 68
     35					     ?debug  C E9734F9326182E2E5C2E2E5C496E636C7564655C727478636F7074+
     36					     ?debug  C 732E68
     37	0000			     RTXC_TEXT	     segment byte public 'CODE'
     38	0000			     RTXC_TEXT	     ends
     39				     DGROUP  group   _DATA,_BSS
     40					     assume  cs:RTXC_TEXT,ds:DGROUP
     41	0000			     _DATA   segment word public 'DATA'
     42	0000			     d@	     label   byte
     43	0000			     d@w     label   word
     44	0000			     _DATA   ends
     45	0000			     _BSS    segment word public 'BSS'
     46	0000			     b@	     label   byte
     47	0000			     b@w     label   word
     48	0000			     _BSS    ends
     49	0000			     _DATA   segment word public 'DATA'
     50	0000			     _init_flags     label   byte
     51	0000  00			     db	     0
     52					     ?debug  C E94020CA1C132E2E5C2E2E5C496E636C7564655C646F732E68
     53					     ?debug  C E94020CA1C152E2E5C2E2E5C496E636C7564655C5F646566732E68
     54	0001			     _DATA   ends
     55	0000			     RTXC_TEXT	     segment byte public 'CODE'
     56					     ?debug  C E80106727478632E63336DC326
     57					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 2
.\rtxc.asm



     58					;    static char *spfixup(TASK task)
     59					;
     60					     ?debug  L 279
     61					     assume  cs:RTXC_TEXT,ds:DGROUP
     62	0000			     spfixup proc    near
     63					     ?debug  B
     64	0000  55			     push    bp
     65	0001  8B EC			     mov     bp,sp
     66	0003  83 EC 0A			     sub     sp,10
     67					     ?debug  C E6047461736B040A04000000
     68					     ?debug  B
     69					;
     70					;    {
     71					;
     72					;    /*
     73					;     *
     74					;     *	note: custom versions of Borland <dos.h> macros	to allow for near and
     75					;     *	      far keywords to "survive"	the "#define near/far" used in building
     76					;     *	      huge kernel.
     77					;     *
     78					;    */
     79					;
     80					;	TCB near *ptcb;
     81					;	char ks_stk *pstackbase;
     82					;	unsigned short segment,	offset;
     83					;
     84					;	ptcb = &rtxtcb[task];
     85					;
     86					     ?debug  L 294
     87	0006  8B 46 04			     mov     ax,word ptr [bp+4]
     88	0009  6B C0 28			     imul    ax,ax,40
     89	000C  05 0000e			     add     ax,offset DGROUP:_rtxtcb
     90	000F  89 46 FE			     mov     word ptr [bp-2],ax
     91					;
     92					;	pstackbase = ptcb->stackbase;
     93					;
     94					     ?debug  L 295
     95	0012  8B 5E FE			     mov     bx,word ptr [bp-2]
     96	0015  8B 57 18			     mov     dx,word ptr [bx+24]
     97	0018  8B 47 16			     mov     ax,word ptr [bx+22]
     98	001B  89 56 FC			     mov     word ptr [bp-4],dx
     99	001E  89 46 FA			     mov     word ptr [bp-6],ax
    100					;
    101					;
    102					;	/* normalize ptr: 0 <= OFFSET <= 15 */
    103					;	segment	= ( (unsigned)(void _seg *)(void _far *)(pstackbase)) +	((( (unsigned)	    +
    104				     (pstackbase)) & 0xfff0) >>	4);
    105					;
    106					     ?debug  L 298
    107	0021  25 FFF0			     and     ax,-16
    108	0024  C1 E8 04			     shr     ax,4
    109	0027  03 46 FC			     add     ax,word ptr [bp-4]
    110	002A  89 46 F8			     mov     word ptr [bp-8],ax
    111					;
    112					;	offset	= ( (unsigned)(pstackbase)) & 0x000f;
    113					;
    114					     ?debug  L 299
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 3
.\rtxc.asm



    115	002D  8B 46 FA			     mov     ax,word ptr [bp-6]
    116	0030  25 000F			     and     ax,15
    117	0033  89 46 F6			     mov     word ptr [bp-10],ax
    118					;
    119					;
    120					;	if (offset != 0)
    121					;
    122					     ?debug  L 301
    123	0036  83 7E F6 00		     cmp     word ptr [bp-10],0
    124	003A  74 0C			     je	     short @1@86
    125					;
    126					;	{
    127					;	   segment++; /* advance to next paragraph (16 byte) boundary */
    128					;
    129					     ?debug  L 303
    130	003C  FF 46 F8			     inc     word ptr [bp-8]
    131					;
    132					;	   ptcb->stacksize -= 16 - offset; /* adjust stack size	as needed */
    133					;
    134					     ?debug  L 304
    135	003F  B8 0010			     mov     ax,16
    136	0042  2B 46 F6			     sub     ax,word ptr [bp-10]
    137	0045  29 47 1A			     sub     word ptr [bx+26],ax
    138	0048			     @1@86:
    139					;
    140					;	}
    141					;
    142					;	offset = ptcb->stacksize - sizeof(FRAME);
    143					;
    144					     ?debug  L 307
    145	0048  8B 5E FE			     mov     bx,word ptr [bp-2]
    146	004B  8B 47 1A			     mov     ax,word ptr [bx+26]
    147	004E  2D 001A			     sub     ax,26
    148	0051  89 46 F6			     mov     word ptr [bp-10],ax
    149					;
    150					;
    151					;	return(	(char *)( (void	_seg *)(segment) + (void _near *)(offset)));
    152					;
    153					     ?debug  L 309
    154	0054  8B 56 F8			     mov     dx,word ptr [bp-8]
    155					;
    156					;    }
    157					;
    158					     ?debug  L 310
    159	0057  C9			     leave
    160	0058  C3			     ret
    161					     ?debug  C E318000400160200
    162					     ?debug  C E31A0374636228001E01
    163					     ?debug  C E31C06636C6B626C6B18001E0F
    164					     ?debug  C E31D074F424A54595045020022000080FF7F19
    165					     ?debug  C E31B000400161C00
    166					     ?debug  C E320056672616D651A001E20
    167					     ?debug  C E321000400160400
    168					     ?debug  C E32300000023010400
    169					     ?debug  C E322000400162300
    170					     ?debug  C E31F000400162000
    171					     ?debug  C E32500000023010400
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 4
.\rtxc.asm



    172					     ?debug  C E324000400162500
    173					     ?debug  C E326000400160100
    174					     ?debug  C E319000200151A04
    175					     ?debug  C E6066F66667365740A02F6FF0000077365676D65+
    176					     ?debug  C 6E740A02F8FF00000A70737461636B6261736518+
    177					     ?debug  C 02FAFF000004707463621902FEFF000004746173+
    178					     ?debug  C 6B040A04000000
    179					     ?debug  E
    180					     ?debug  E
    181	0059			     spfixup endp
    182					;
    183					;    FRAME * __cdecl rtxc(FRAME	ks_stk *p)
    184					;
    185					     ?debug  L 318
    186					     assume  cs:RTXC_TEXT,ds:DGROUP
    187	0059			     _rtxc   proc    near
    188					     ?debug  B
    189	0059  55			     push    bp
    190	005A  8B EC			     mov     bp,sp
    191	005C  83 EC 3C			     sub     sp,60
    192	005F  56			     push    si
    193					     ?debug  C E601701F0A04000000
    194					     ?debug  B
    195					;
    196					;    {
    197					;	KSNUM ks_stk *p2 = p->pksnum;
    198					;
    199					     ?debug  L 320
    200	0060  C4 5E 04			     les     bx,dword ptr [bp+4]
    201	0063  26: 8B 57	0E		     mov     dx,word ptr es:[bx+14]
    202	0067  26: 8B 47	0C		     mov     ax,word ptr es:[bx+12]
    203	006B  89 56 FE			     mov     word ptr [bp-2],dx
    204	006E  89 46 FC			     mov     word ptr [bp-4],ax
    205					;
    206					;
    207					;	FRAME ks_stk *frame;
    208					;
    209					;	TCB near *ptcb;
    210					;	TASK task;
    211					;	CLKBLK ks_clk *pclkblk;
    212					;	TICKS tcnt; /* local copy of rtctick */
    213					;	SEMA sema;
    214					;	const SEMA *semalist;
    215					;	SSTATE near *sema_ptr;
    216					;	KSNUM ks_stk *p2a;
    217					;
    218					;    #ifdef HAS_BLOCK /* { */
    219					;	TASK endtask;
    220					;    #endif /* } HAS_BLOCK */
    221					;
    222					;    #ifdef HAS_MAILBOXES /* { */
    223					;	MHEADER	near *pmh;
    224					;	RTXCMSG	*prtxcmsg;
    225					;    #endif /* } HAS_MAILBOXES */
    226					;
    227					;    #ifdef HAS_PARTITIONS /* {	*/
    228					;	PHEADER	near *pph;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 5
.\rtxc.asm



    229					;	struct xmap *q;
    230					;    #endif /* } HAS_PARTITIONS	*/
    231					;
    232					;    #ifdef HAS_QUEUES /* { */
    233					;	QHEADER	near *pqh;
    234					;	int qindex, depth;
    235					;	size_t width;
    236					;    #ifdef HAS_DEFQUEUE /* { */
    237					;	int cursz;
    238					;    #endif /* } HAS_DEFQUEUE */
    239					;    #endif /* } HAS_QUEUES */
    240					;
    241					;    #ifdef HAS_RESOURCES /* { */
    242					;	RHEADER	near *prh;
    243					;    #endif /* } HAS_RESOURCES */
    244					;
    245					;    #ifdef FPU	/* { */
    246					;	FPREGS near *fpregs;
    247					;    #endif /* } FPU */
    248					;
    249					;	hipritsk->sp = (FRAME *)p; /* always save &stk frame */
    250					;
    251					     ?debug  L 364
    252	0071  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
    253	0075  8B 56 06			     mov     dx,word ptr [bp+6]
    254	0078  8B 46 04			     mov     ax,word ptr [bp+4]
    255	007B  89 57 0E			     mov     word ptr [bx+14],dx
    256	007E  89 47 0C			     mov     word ptr [bx+12],ax
    257					;
    258					;
    259					;	switch(*p2)
    260					;
    261					     ?debug  L 366
    262	0081  C4 5E FC			     les     bx,dword ptr [bp-4]
    263	0084  26: 8B 1F			     mov     bx,word ptr es:[bx]
    264	0087  83 FB 2F			     cmp     bx,47
    265	008A  76 03			     jbe     @@0
    266	008C  E9 203F			     jmp     @2@15430
    267	008F			     @@0:
    268	008F  03 DB			     add     bx,bx
    269	0091  2E: FF A7	2135r		     jmp     word ptr cs:@2@C82[bx]
    270	0096			     @2@142:
    271					;
    272					;	{
    273					;    /************************/
    274					;	   case	RTXC_SIGNAL:
    275					;    /************************/
    276					;	      sema = ((struct sarg ks_stk *)p2)->sema;
    277					;
    278					     ?debug  L 371
    279	0096  C4 5E FC			     les     bx,dword ptr [bp-4]
    280	0099  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
    281	009D  89 46 EA			     mov     word ptr [bp-22],ax
    282					;
    283					;
    284					;	      if (semat[sema] == SEMA_DONE)
    285					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 6
.\rtxc.asm



    286					     ?debug  L 373
    287	00A0  8B 5E EA			     mov     bx,word ptr [bp-22]
    288	00A3  03 DB			     add     bx,bx
    289	00A5  83 BF 0000e 00		     cmp     word ptr DGROUP:_semat[bx],0
    290	00AA  75 0C			     jne     short @2@198
    291					;
    292					;		 ((struct sarg ks_stk *)p2)->ksrc = RC_MISSED_EVENT;
    293					;
    294					     ?debug  L 374
    295	00AC  8B 5E FC			     mov     bx,word ptr [bp-4]
    296	00AF  26: C7 47	02 000E		     mov     word ptr es:[bx+2],14
    297	00B5  E9 2016			     jmp     @2@15430
    298	00B8			     @2@198:
    299					;
    300					;	      else
    301					;	      {
    302					;		    SIGNAL(sema);
    303					;
    304					     ?debug  L 377
    305	00B8  FA			     cli
    306	00B9  90			     nop
    307	00BA  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
    308	00BE  8B 46 EA			     mov     ax,word ptr [bp-22]
    309	00C1  89 07			     mov     word ptr [bx],ax
    310	00C3  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
    311	00C8  FB			     sti
    312					;
    313					;	      }
    314					;	      break;
    315					;
    316					     ?debug  L 379
    317	00C9  E9 2002			     jmp     @2@15430
    318	00CC			     @2@338:
    319					;
    320					;
    321					;    #ifdef HAS_SIGNALM	/* { */
    322					;    /************************/
    323					;	   case	RTXC_SIGNALM:
    324					;    /************************/
    325					;	      for (semalist = ((struct sargm ks_stk *)p2)->list;
    326					;
    327					     ?debug  L 385
    328	00CC  C4 5E FC			     les     bx,dword ptr [bp-4]
    329	00CF  26: 8B 57	08		     mov     dx,word ptr es:[bx+8]
    330	00D3  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
    331	00D7  89 56 E8			     mov     word ptr [bp-24],dx
    332	00DA  89 46 E6			     mov     word ptr [bp-26],ax
    333	00DD  EB 2A			     jmp     short @2@534
    334	00DF			     @2@366:
    335					;
    336					;		   *semalist !=	NULLSEMA; semalist++)
    337					;	      {
    338					;		 if (semat[*semalist] != SEMA_DONE)
    339					;
    340					     ?debug  L 388
    341	00DF  C4 5E E6			     les     bx,dword ptr [bp-26]
    342	00E2  26: 8B 1F			     mov     bx,word ptr es:[bx]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 7
.\rtxc.asm



    343	00E5  03 DB			     add     bx,bx
    344	00E7  89 5E C4			     mov     word ptr [bp-60],bx
    345	00EA  83 BF 0000e 00		     cmp     word ptr DGROUP:_semat[bx],0
    346	00EF  74 14			     je	     short @2@506
    347					;
    348					;		 {
    349					;		       SIGNAL(*semalist);
    350					;
    351					     ?debug  L 390
    352	00F1  FA			     cli
    353	00F2  90			     nop
    354	00F3  C4 5E E6			     les     bx,dword ptr [bp-26]
    355	00F6  26: 8B 07			     mov     ax,word ptr es:[bx]
    356	00F9  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
    357	00FD  89 07			     mov     word ptr [bx],ax
    358	00FF  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
    359	0104  FB			     sti
    360	0105			     @2@506:
    361					     ?debug  L 386
    362	0105  83 46 E6 02		     add     word ptr [bp-26],2
    363	0109			     @2@534:
    364	0109  C4 5E E6			     les     bx,dword ptr [bp-26]
    365	010C  26: 83 3F	00		     cmp     word ptr es:[bx],0
    366	0110  75 CD			     jne     short @2@366
    367					;
    368					;		 }
    369					;	      }
    370					;	      break;
    371					;
    372					     ?debug  L 393
    373	0112  E9 1FB9			     jmp     @2@15430
    374	0115			     @2@590:
    375					;
    376					;    #endif /* } HAS_SIGNALM */
    377					;
    378					;    /************************/
    379					;	   case	RTXC_WAIT:
    380					;    /************************/
    381					;	      sema = ((struct sarg ks_stk *)p2)->sema;
    382					;
    383					     ?debug  L 399
    384	0115  C4 5E FC			     les     bx,dword ptr [bp-4]
    385	0118  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
    386	011C  89 46 EA			     mov     word ptr [bp-22],ax
    387					;
    388					;
    389					;	      if (semat[sema] == SEMA_PENDING)
    390					;
    391					     ?debug  L 401
    392	011F  8B 5E EA			     mov     bx,word ptr [bp-22]
    393	0122  03 DB			     add     bx,bx
    394	0124  83 BF 0000e FF		     cmp     word ptr DGROUP:_semat[bx],-1
    395	0129  74 03			     je	     @@1
    396	012B  E9 00A3			     jmp     @2@730
    397	012E			     @@1:
    398					;
    399					;	      {
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 8
.\rtxc.asm



    400					;		 ptcb =	hipritsk; /* save for later */
    401					;
    402					     ?debug  L 403
    403	012E  A1 0000r			     mov     ax,word ptr DGROUP:_hipritsk
    404	0131  89 46 F6			     mov     word ptr [bp-10],ax
    405					;
    406					;
    407					;    #ifdef SEMAPHORE_TIMEOUTS /* { */
    408					;		 if ( ((struct sarg ks_stk *)p2)->ticks) /* if timeout active */
    409					;
    410					     ?debug  L 406
    411	0134  8B 5E FC			     mov     bx,word ptr [bp-4]
    412	0137  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
    413	013B  26: 0B 47	08		     or	     ax,word ptr es:[bx+8]
    414	013F  74 64			     je	     short @2@674
    415					;
    416					;		 {
    417					;		    pclkblk = ptcb->pclkblk = ((struct sarg ks_stk *)p2)->pclkblk;
    418					;
    419					     ?debug  L 408
    420	0141  26: 8B 57	0C		     mov     dx,word ptr es:[bx+12]
    421	0145  26: 8B 47	0A		     mov     ax,word ptr es:[bx+10]
    422	0149  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
    423	014D  89 57 06			     mov     word ptr [bx+6],dx
    424	0150  89 47 04			     mov     word ptr [bx+4],ax
    425	0153  89 56 F2			     mov     word ptr [bp-14],dx
    426	0156  89 46 F0			     mov     word ptr [bp-16],ax
    427					;
    428					;		    pclkblk->remain = ((struct sarg ks_stk *)p2)->ticks;
    429					;
    430					     ?debug  L 409
    431	0159  8B 5E FC			     mov     bx,word ptr [bp-4]
    432	015C  26: 8B 57	08		     mov     dx,word ptr es:[bx+8]
    433	0160  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
    434	0164  C4 5E F0			     les     bx,dword ptr [bp-16]
    435	0167  26: 89 57	0A		     mov     word ptr es:[bx+10],dx
    436	016B  26: 89 47	08		     mov     word ptr es:[bx+8],ax
    437					;
    438					;		    pclkblk->recycle = (TICKS)0; /* non-cyclic */
    439					;
    440					     ?debug  L 410
    441	016F  26: C7 47	0E 0000		     mov     word ptr es:[bx+14],0
    442	0175  26: C7 47	0C 0000		     mov     word ptr es:[bx+12],0
    443					;
    444					;
    445					;		    /* mark object type	*/
    446					;		    pclkblk->objtype = SEMAPHORE_OBJ;
    447					;
    448					     ?debug  L 413
    449	017B  26: C7 47	14 0001		     mov     word ptr es:[bx+20],1
    450					;
    451					;		    pclkblk->objid = sema;
    452					;
    453					     ?debug  L 414
    454	0181  8B 46 EA			     mov     ax,word ptr [bp-22]
    455	0184  26: 89 47	16		     mov     word ptr es:[bx+22],ax
    456					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 9
.\rtxc.asm



    457					;		    pclkblk->task = ptcb->task;
    458					;
    459					     ?debug  L 415
    460	0188  8B 76 F6			     mov     si,word ptr [bp-10]
    461	018B  8B 44 08			     mov     ax,word ptr [si+8]
    462	018E  26: 89 47	10		     mov     word ptr es:[bx+16],ax
    463					;
    464					;
    465					;		    /* insert timer */
    466					;		    insert_timer(pclkblk);
    467					;
    468					     ?debug  L 418
    469	0192  FF 76 F2			     push    word ptr [bp-14]
    470	0195  53			     push    bx
    471	0196  E8 2B5B			     call    near ptr insert_timer
    472	0199  83 C4 04			     add     sp,4
    473					;
    474					;		    ((struct sarg ks_stk *)p2)->ksrc = RC_TIMEOUT;
    475					;
    476					     ?debug  L 419
    477	019C  C4 5E FC			     les     bx,dword ptr [bp-4]
    478	019F  26: C7 47	02 0005		     mov     word ptr es:[bx+2],5
    479	01A5			     @2@674:
    480					;
    481					;		 }
    482					;    #endif /* } SEMAPHORE_TIMEOUTS */
    483					;
    484					;		 /* put	sema into wait state */
    485					;		 semat[sema] = (SSTATE)ptcb->task;
    486					;
    487					     ?debug  L 424
    488	01A5  8B 5E EA			     mov     bx,word ptr [bp-22]
    489	01A8  03 DB			     add     bx,bx
    490	01AA  8B 76 F6			     mov     si,word ptr [bp-10]
    491	01AD  8B 44 08			     mov     ax,word ptr [si+8]
    492	01B0  89 87 0000e		     mov     word ptr DGROUP:_semat[bx],ax
    493					;
    494					;
    495					;		 ptcb->status =	SEMAPHORE_WAIT;
    496					;
    497					     ?debug  L 426
    498	01B4  8B 5E F6			     mov     bx,word ptr [bp-10]
    499	01B7			     @2@702:
    500	01B7  C7 47 10 0040		     mov     word ptr [bx+16],64
    501					;
    502					;
    503					;		 UNLINK_HIPRITSK(); /* unlink first tcb	*/
    504					;
    505					     ?debug  L 428
    506	01BC  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
    507	01C0  8B 07			     mov     ax,word ptr [bx]
    508	01C2  A3 0000r			     mov     word ptr DGROUP:_hipritsk,ax
    509	01C5  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
    510	01C9  C7 47 02 0000r		     mov     word ptr [bx+2],offset DGROUP:_hipritsk
    511					;
    512					;		 break;
    513					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 10
.\rtxc.asm



    514					     ?debug  L 429
    515	01CE  E9 1EFD			     jmp     @2@15430
    516	01D1			     @2@730:
    517					;
    518					;	      }
    519					;
    520					;	      if (semat[sema] == SEMA_DONE) /* if sema already done */
    521					;
    522					     ?debug  L 432
    523	01D1  8B 5E EA			     mov     bx,word ptr [bp-22]
    524	01D4  03 DB			     add     bx,bx
    525	01D6  83 BF 0000e 00		     cmp     word ptr DGROUP:_semat[bx],0
    526	01DB  75 0E			     jne     short @2@786
    527					;
    528					;	      {
    529					;		 semat[sema] = SEMA_PENDING;  /* set sema pending */
    530					;
    531					     ?debug  L 434
    532	01DD  8B 5E EA			     mov     bx,word ptr [bp-22]
    533	01E0  03 DB			     add     bx,bx
    534	01E2  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
    535					;
    536					;	      }
    537					;
    538					     ?debug  L 435
    539	01E8  E9 1EE3			     jmp     @2@15430
    540	01EB			     @2@786:
    541					;
    542					;	      else     /* else sema was	already	in a wait state	*/
    543					;	      {
    544					;		 /* if here, application task design flaw */
    545					;		    /* since no	corresponding semaphore	*/
    546					;		 ((struct sarg ks_stk *)p2)->ksrc = RC_WAIT_CONFLICT;
    547					;
    548					     ?debug  L 440
    549	01EB  C4 5E FC			     les     bx,dword ptr [bp-4]
    550	01EE  26: C7 47	02 0001		     mov     word ptr es:[bx+2],1
    551	01F4  E9 1ED7			     jmp     @2@15430
    552	01F7			     @2@814:
    553					;
    554					;	      }
    555					;	      break;
    556					;
    557					;    #ifdef HAS_WAITM /* { */
    558					;    /************************/
    559					;	   case	RTXC_WAITM:
    560					;    /************************/
    561					;	      semalist = ((struct sargm	ks_stk *)p2)->list;
    562					;
    563					     ?debug  L 448
    564	01F7  C4 5E FC			     les     bx,dword ptr [bp-4]
    565	01FA  26: 8B 57	08		     mov     dx,word ptr es:[bx+8]
    566	01FE  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
    567	0202  89 56 E8			     mov     word ptr [bp-24],dx
    568	0205  89 46 E6			     mov     word ptr [bp-26],ax
    569	0208  EB 29			     jmp     short @2@898
    570	020A			     @2@842:
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 11
.\rtxc.asm



    571					;
    572					;	      while (*semalist != NULLSEMA) /* while not at end	of waitm list */
    573					;	      {
    574					;		 sema_ptr = &semat[*semalist]; /* get ptr to sema */
    575					;
    576					     ?debug  L 451
    577	020A  C4 5E E6			     les     bx,dword ptr [bp-26]
    578	020D  26: 8B 07			     mov     ax,word ptr es:[bx]
    579	0210  03 C0			     add     ax,ax
    580	0212  89 46 C4			     mov     word ptr [bp-60],ax
    581	0215  05 0000e			     add     ax,offset DGROUP:_semat
    582	0218  89 46 E4			     mov     word ptr [bp-28],ax
    583					;
    584					;
    585					;		 if (*sema_ptr == SEMA_PENDING)
    586					;
    587					     ?debug  L 453
    588	021B  8B 5E E4			     mov     bx,word ptr [bp-28]
    589	021E  83 3F FF			     cmp     word ptr [bx],-1
    590	0221  75 19			     jne     short @2@926
    591					;
    592					;		 {
    593					;		    *sema_ptr =	(SSTATE)hipritsk->task;	/* set sema waiting */
    594					;
    595					     ?debug  L 455
    596	0223  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
    597	0227  8B 47 08			     mov     ax,word ptr [bx+8]
    598	022A  8B 5E E4			     mov     bx,word ptr [bp-28]
    599	022D  89 07			     mov     word ptr [bx],ax
    600					;
    601					;		    semalist++;				 /* bump list ptr */
    602					;
    603					     ?debug  L 456
    604	022F  83 46 E6 02		     add     word ptr [bp-26],2
    605					;
    606					;		 }
    607					;
    608					     ?debug  L 457
    609	0233			     @2@898:
    610					     ?debug  L 449
    611	0233  C4 5E E6			     les     bx,dword ptr [bp-26]
    612	0236  26: 83 3F	00		     cmp     word ptr es:[bx],0
    613	023A  75 CE			     jne     short @2@842
    614	023C			     @2@926:
    615					;
    616					;		 else /* found sema in WAIT or DONE state */
    617					;		    break;
    618					;	      }
    619					;
    620					;	      if (*semalist == NULLSEMA) /* all	semas now in WAIT state	*/
    621					;
    622					     ?debug  L 462
    623	023C  C4 5E E6			     les     bx,dword ptr [bp-26]
    624	023F  26: 83 3F	00		     cmp     word ptr es:[bx],0
    625	0243  75 02			     jne     short @2@982
    626	0245  EB 42			     jmp     short @2@1150
    627	0247			     @2@982:
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 12
.\rtxc.asm



    628					;
    629					;	      {
    630					;		 hipritsk->status = SEMAPHORE_WAIT; /* mark status SEMAPHORE_WAIT */
    631					;
    632					;		 UNLINK_HIPRITSK(); /* unlink first tcb	*/
    633					;		 break;		   /* force task switch	*/
    634					;	      }
    635					;
    636					;	      if (*sema_ptr == SEMA_DONE) /* found a sema in list in DONE state	*/
    637					;
    638					     ?debug  L 470
    639	0247  8B 5E E4			     mov     bx,word ptr [bp-28]
    640	024A  83 3F 00			     cmp     word ptr [bx],0
    641	024D  75 3A			     jne     short @2@1150
    642					;
    643					;	      {
    644					;		 /* return sema	to user	*/
    645					;		 ((struct sargm	ks_stk *)p2)->sema = *semalist;
    646					;
    647					     ?debug  L 473
    648	024F  C4 5E FC			     les     bx,dword ptr [bp-4]
    649	0252  06			     push    es
    650	0253  C4 76 E6			     les     si,dword ptr [bp-26]
    651	0256  26: 8B 04			     mov     ax,word ptr es:[si]
    652	0259  07			     pop     es
    653	025A  26: 89 47	04		     mov     word ptr es:[bx+4],ax
    654	025E  EB 1A			     jmp     short @2@1094
    655	0260			     @2@1038:
    656					;
    657					;
    658					;		    /* set all semas in	list to	PEND state */
    659					;		 for ( ; ((struct sargm	ks_stk *)p2)->list <= semalist;
    660					;			 ((struct sargm	ks_stk *)p2)->list++)
    661					;		    semat[*(((struct sargm ks_stk *)p2)->list)]	= SEMA_PENDING;
    662					;
    663					     ?debug  L 478
    664	0260  C4 5E FC			     les     bx,dword ptr [bp-4]
    665	0263  26: C4 5F	06		     les     bx,dword ptr es:[bx+6]
    666	0267  26: 8B 1F			     mov     bx,word ptr es:[bx]
    667	026A  03 DB			     add     bx,bx
    668	026C  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
    669					     ?debug  L 477
    670	0272  C4 5E FC			     les     bx,dword ptr [bp-4]
    671	0275  26: 83 47	06 02		     add     word ptr es:[bx+6],2
    672	027A			     @2@1094:
    673					     ?debug  L 476
    674	027A  C4 5E FC			     les     bx,dword ptr [bp-4]
    675	027D  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
    676	0281  3B 46 E6			     cmp     ax,word ptr [bp-26]
    677	0284  76 DA			     jbe     short @2@1038
    678					;
    679					;	      }
    680					;
    681					     ?debug  L 479
    682	0286  E9 1E45			     jmp     @2@15430
    683	0289			     @2@1150:
    684	0289  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 13
.\rtxc.asm



    685	028D  E9 FF27			     jmp     @2@702
    686	0290			     @2@1178:
    687					;
    688					;	      else /* semaphore	was found already in a WAIT state */
    689					;	      {
    690					;		    /* if arrive here, application task	design flaw */
    691					;		      /* since no corresponding	semaphore waiting */
    692					;		 hipritsk->status = SEMAPHORE_WAIT;
    693					;
    694					;		 UNLINK_HIPRITSK(); /* unlink first tcb	*/
    695					;	      }
    696					;	      break;
    697					;    #endif /* } HAS_WAITM */
    698					;
    699					;    #ifdef HAS_PEND /*	{ */
    700					;    /************************/
    701					;	   case	RTXC_PEND:
    702					;    /************************/
    703					;	      sema = ((struct sarg ks_stk *)p2)->sema;
    704					;
    705					     ?debug  L 495
    706	0290  C4 5E FC			     les     bx,dword ptr [bp-4]
    707	0293  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
    708	0297  89 46 EA			     mov     word ptr [bp-22],ax
    709					;
    710					;
    711					;	      if (semat[sema] == SEMA_DONE)
    712					;
    713					     ?debug  L 497
    714	029A  8B 5E EA			     mov     bx,word ptr [bp-22]
    715	029D  03 DB			     add     bx,bx
    716	029F  83 BF 0000e 00		     cmp     word ptr DGROUP:_semat[bx],0
    717	02A4  74 03			     je	     @@2
    718	02A6  E9 1E25			     jmp     @2@15430
    719	02A9			     @@2:
    720					;
    721					;		 semat[sema] = SEMA_PENDING;
    722					;
    723					     ?debug  L 498
    724	02A9  8B 5E EA			     mov     bx,word ptr [bp-22]
    725	02AC  03 DB			     add     bx,bx
    726	02AE  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
    727	02B4  E9 1E17			     jmp     @2@15430
    728	02B7			     @2@1234:
    729					;
    730					;	      break;
    731					;    #endif /* } HAS_PEND */
    732					;
    733					;    #ifdef HAS_PENDM /* { */
    734					;    /************************/
    735					;	   case	RTXC_PENDM:
    736					;    /************************/
    737					;	      for (semalist = ((struct sargm ks_stk *)p2)->list;
    738					;
    739					     ?debug  L 506
    740	02B7  C4 5E FC			     les     bx,dword ptr [bp-4]
    741	02BA  26: 8B 57	08		     mov     dx,word ptr es:[bx+8]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 14
.\rtxc.asm



    742	02BE  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
    743	02C2  89 56 E8			     mov     word ptr [bp-24],dx
    744	02C5  89 46 E6			     mov     word ptr [bp-26],ax
    745	02C8  EB 1C			     jmp     short @2@1346
    746	02CA			     @2@1262:
    747					;
    748					;		   *semalist !=	NULLSEMA; semalist++)
    749					;		 if (semat[*semalist] == SEMA_DONE)
    750					;
    751					     ?debug  L 508
    752	02CA  C4 5E E6			     les     bx,dword ptr [bp-26]
    753	02CD  26: 8B 1F			     mov     bx,word ptr es:[bx]
    754	02D0  03 DB			     add     bx,bx
    755	02D2  89 5E C4			     mov     word ptr [bp-60],bx
    756	02D5  83 BF 0000e 00		     cmp     word ptr DGROUP:_semat[bx],0
    757	02DA  75 06			     jne     short @2@1318
    758					;
    759					;		    semat[*semalist] = SEMA_PENDING;
    760					;
    761					     ?debug  L 509
    762	02DC  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
    763	02E2			     @2@1318:
    764					     ?debug  L 507
    765	02E2  83 46 E6 02		     add     word ptr [bp-26],2
    766	02E6			     @2@1346:
    767	02E6  C4 5E E6			     les     bx,dword ptr [bp-26]
    768	02E9  26: 83 3F	00		     cmp     word ptr es:[bx],0
    769	02ED  75 DB			     jne     short @2@1262
    770					;
    771					;	      break;
    772					;
    773					     ?debug  L 510
    774	02EF  E9 1DDC			     jmp     @2@15430
    775	02F2			     @2@1402:
    776					;
    777					;    #endif /* } HAS_PENDM */
    778					;
    779					;    #ifdef HAS_SUSPEND	/* { */
    780					;    /************************/
    781					;	   case	RTXC_SUSPEND:
    782					;    /************************/
    783					;	      if ( (task = ((struct targ ks_stk	*)p2)->task) ==	SELFTASK)
    784					;
    785					     ?debug  L 517
    786	02F2  C4 5E FC			     les     bx,dword ptr [bp-4]
    787	02F5  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
    788	02F9  89 46 F4			     mov     word ptr [bp-12],ax
    789	02FC  0B C0			     or	     ax,ax
    790	02FE  75 08			     jne     short @2@1458
    791					;
    792					;		 ptcb =	hipritsk;
    793					;
    794					     ?debug  L 518
    795	0300  A1 0000r			     mov     ax,word ptr DGROUP:_hipritsk
    796	0303  89 46 F6			     mov     word ptr [bp-10],ax
    797	0306  EB 1C			     jmp     short @2@1514
    798	0308			     @2@1458:
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 15
.\rtxc.asm



    799					;
    800					;	      else
    801					;	      {
    802					;		 ptcb =	&rtxtcb[task];
    803					;
    804					     ?debug  L 521
    805	0308  8B 46 F4			     mov     ax,word ptr [bp-12]
    806	030B  6B C0 28			     imul    ax,ax,40
    807	030E  05 0000e			     add     ax,offset DGROUP:_rtxtcb
    808	0311  89 46 F6			     mov     word ptr [bp-10],ax
    809					;
    810					;		 if (ptcb->status != READY)
    811					;
    812					     ?debug  L 522
    813	0314  8B 5E F6			     mov     bx,word ptr [bp-10]
    814	0317  83 7F 10 00		     cmp     word ptr [bx+16],0
    815	031B  74 07			     je	     short @2@1514
    816					;
    817					;		 {
    818					;		    ptcb->status |= SUSPFLG; /*	mark suspended */
    819					;
    820					     ?debug  L 524
    821	031D  83 4F 10 01		     or	     word ptr [bx+16],1
    822					;
    823					;		    break;
    824					;
    825					     ?debug  L 525
    826	0321  E9 1DAA			     jmp     @2@15430
    827	0324			     @2@1514:
    828					;
    829					;		 }
    830					;	      }
    831					;	      ptcb->status |= SUSPFLG; /* mark suspended */
    832					;
    833					     ?debug  L 528
    834	0324  8B 5E F6			     mov     bx,word ptr [bp-10]
    835	0327  83 4F 10 01		     or	     word ptr [bx+16],1
    836					;
    837					;
    838					;	      ptcb->flink->blink = ptcb->blink;	/* general task	unlink */
    839					;
    840					     ?debug  L 530
    841	032B  8B 47 02			     mov     ax,word ptr [bx+2]
    842	032E  8B 1F			     mov     bx,word ptr [bx]
    843	0330  89 47 02			     mov     word ptr [bx+2],ax
    844					;
    845					;	      ptcb->blink->flink = ptcb->flink;
    846					;
    847					     ?debug  L 531
    848	0333  8B 5E F6			     mov     bx,word ptr [bp-10]
    849	0336  8B 07			     mov     ax,word ptr [bx]
    850	0338  8B 5F 02			     mov     bx,word ptr [bx+2]
    851	033B  89 07			     mov     word ptr [bx],ax
    852					;
    853					;
    854					;	      break;
    855					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 16
.\rtxc.asm



    856					     ?debug  L 533
    857	033D  E9 1D8E			     jmp     @2@15430
    858	0340			     @2@1542:
    859					;
    860					;    #endif /* } HAS_SUSPEND */
    861					;
    862					;    #ifdef HAS_RESUME /* { */
    863					;    /************************/
    864					;	   case	RTXC_RESUME:
    865					;    /************************/
    866					;	      ptcb = &rtxtcb[((struct targ ks_stk *)p2)->task];
    867					;
    868					     ?debug  L 540
    869	0340  C4 5E FC			     les     bx,dword ptr [bp-4]
    870	0343  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
    871	0347  6B C0 28			     imul    ax,ax,40
    872	034A  05 0000e			     add     ax,offset DGROUP:_rtxtcb
    873	034D  89 46 F6			     mov     word ptr [bp-10],ax
    874					;
    875					;
    876					;	      if (ptcb->status != READY)
    877					;
    878					     ?debug  L 542
    879	0350  8B 5E F6			     mov     bx,word ptr [bp-10]
    880	0353  83 7F 10 00		     cmp     word ptr [bx+16],0
    881	0357  75 03			     jne     @@3
    882	0359  E9 1D72			     jmp     @2@15430
    883	035C			     @@3:
    884					;
    885					;	      {
    886					;		    /* clear suspended and test	for ready now */
    887					;		  if ( (ptcb->status &=	~SUSPFLG) == READY)
    888					;
    889					     ?debug  L 545
    890	035C  83 67 10 FE		     and     word ptr [bx+16],-2
    891	0360  8B 47 10			     mov     ax,word ptr [bx+16]
    892	0363  0B C0			     or	     ax,ax
    893	0365  74 03			     je	     @@4
    894	0367  E9 1D64			     jmp     @2@15430
    895	036A			     @@4:
    896					;
    897					;		  {
    898					;		      ptcb->flink = nsrttcb;
    899					;
    900					     ?debug  L 547
    901	036A  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
    902	036D  89 07			     mov     word ptr [bx],ax
    903					;
    904					;		      nsrttcb =	ptcb;
    905					;
    906					     ?debug  L 548
    907	036F  8B 46 F6			     mov     ax,word ptr [bp-10]
    908	0372  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
    909	0375  E9 1D56			     jmp     @2@15430
    910	0378			     @2@1626:
    911					;
    912					;		  }
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 17
.\rtxc.asm



    913					;	      }
    914					;	      break;
    915					;    #endif /* } HAS_RESUME */
    916					;
    917					;    #ifdef HAS_PARTITIONS /* {	*/
    918					;    #ifdef HAS_ALLOC /* { */
    919					;    /************************/
    920					;	   case	RTXC_ALLOC:
    921					;    /************************/
    922					;	      pph = &pheader[((struct parg ks_stk *)p2)->map];
    923					;
    924					     ?debug  L 559
    925	0378  C4 5E FC			     les     bx,dword ptr [bp-4]
    926	037B  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
    927	037F  6B C0 12			     imul    ax,ax,18
    928	0382  05 0000e			     add     ax,offset DGROUP:_pheader
    929	0385  89 46 D6			     mov     word ptr [bp-42],ax
    930					;
    931					;
    932					;	      /* Get 1st free block. If	none available,	thread waiter */
    933					;	      if ( (q =	(struct	xmap *)KS_ISRalloc(((struct parg ks_stk	*)p2)->map))
    934					;
    935					     ?debug  L 562
    936					;
    937					;					    == NULL)
    938					;
    939					     ?debug  L 563
    940	0388  26: FF 77	04		     push    word ptr es:[bx+4]
    941	038C  0E E8 23A9 90		     call    far ptr _KS_ISRalloc
    942	0391  83 C4 02			     add     sp,2
    943	0394  89 56 D4			     mov     word ptr [bp-44],dx
    944	0397  89 46 D2			     mov     word ptr [bp-46],ax
    945	039A  0B C2			     or	     ax,dx
    946	039C  74 03			     je	     @@5
    947	039E  E9 00A6			     jmp     @2@1738
    948	03A1			     @@5:
    949					;
    950					;	      {
    951					;    #ifdef PARTITION_WAITERS /* { */
    952					;		 if ( ((struct parg ks_stk *)p2)->wait)
    953					;
    954					     ?debug  L 566
    955	03A1  C4 5E FC			     les     bx,dword ptr [bp-4]
    956	03A4  26: 83 7F	0C 00		     cmp     word ptr es:[bx+12],0
    957	03A9  75 03			     jne     @@6
    958	03AB  E9 0099			     jmp     @2@1738
    959	03AE			     @@6:
    960					;
    961					;		 {
    962					;		    ptcb = hipritsk; /*	save hipritsk for later	use */
    963					;
    964					     ?debug  L 568
    965	03AE  A1 0000r			     mov     ax,word ptr DGROUP:_hipritsk
    966	03B1  89 46 F6			     mov     word ptr [bp-10],ax
    967					;
    968					;
    969					;		    ptcb->status = PARTITION_WAIT;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 18
.\rtxc.asm



    970					;
    971					     ?debug  L 570
    972	03B4  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
    973	03B8  C7 47 10 0002		     mov     word ptr [bx+16],2
    974					;
    975					;
    976					;		    porder((TCB	near *)&pph->waiters);
    977					;
    978					     ?debug  L 572
    979	03BD  8B 46 D6			     mov     ax,word ptr [bp-42]
    980	03C0  05 0008			     add     ax,8
    981	03C3  50			     push    ax
    982	03C4  E8 2A27			     call    near ptr porder
    983	03C7  83 C4 02			     add     sp,2
    984					;
    985					;
    986					;    #ifdef PARTITION_TIMEOUTS /* { */
    987					;		    if ( ((struct parg ks_stk *)p2)->ticks)
    988					;
    989					     ?debug  L 575
    990	03CA  C4 5E FC			     les     bx,dword ptr [bp-4]
    991	03CD  26: 8B 47	0E		     mov     ax,word ptr es:[bx+14]
    992	03D1  26: 0B 47	10		     or	     ax,word ptr es:[bx+16]
    993	03D5  74 70			     je	     short @2@1738
    994					;
    995					;		    {
    996					;		       ptcb->pclkblk = ((struct	parg ks_stk *)p2)->pclkblk;
    997					;
    998					     ?debug  L 577
    999	03D7  26: 8B 57	14		     mov     dx,word ptr es:[bx+20]
   1000	03DB  26: 8B 47	12		     mov     ax,word ptr es:[bx+18]
   1001	03DF  8B 5E F6			     mov     bx,word ptr [bp-10]
   1002	03E2  89 57 06			     mov     word ptr [bx+6],dx
   1003	03E5  89 47 04			     mov     word ptr [bx+4],ax
   1004					;
   1005					;		       pclkblk = ptcb->pclkblk;
   1006					;
   1007					     ?debug  L 578
   1008	03E8  8B 57 06			     mov     dx,word ptr [bx+6]
   1009	03EB  8B 47 04			     mov     ax,word ptr [bx+4]
   1010	03EE  89 56 F2			     mov     word ptr [bp-14],dx
   1011	03F1  89 46 F0			     mov     word ptr [bp-16],ax
   1012					;
   1013					;		       pclkblk->remain = ((struct parg ks_stk *)p2)->ticks;
   1014					;
   1015					     ?debug  L 579
   1016	03F4  8B 5E FC			     mov     bx,word ptr [bp-4]
   1017	03F7  26: 8B 57	10		     mov     dx,word ptr es:[bx+16]
   1018	03FB  26: 8B 47	0E		     mov     ax,word ptr es:[bx+14]
   1019	03FF  C4 5E F0			     les     bx,dword ptr [bp-16]
   1020	0402  26: 89 57	0A		     mov     word ptr es:[bx+10],dx
   1021	0406  26: 89 47	08		     mov     word ptr es:[bx+8],ax
   1022					;
   1023					;		       pclkblk->recycle	= (TICKS)0;
   1024					;
   1025					     ?debug  L 580
   1026	040A  26: C7 47	0E 0000		     mov     word ptr es:[bx+14],0
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 19
.\rtxc.asm



   1027	0410  26: C7 47	0C 0000		     mov     word ptr es:[bx+12],0
   1028					;
   1029					;
   1030					;		       /* mark object type */
   1031					;		       pclkblk->objtype	= PARTITION_OBJ;
   1032					;
   1033					     ?debug  L 583
   1034	0416  26: C7 47	14 0002		     mov     word ptr es:[bx+20],2
   1035					;
   1036					;		       pclkblk->objid =	((struct parg ks_stk *)p2)->map;
   1037					;
   1038					     ?debug  L 584
   1039	041C  C4 5E FC			     les     bx,dword ptr [bp-4]
   1040	041F  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   1041	0423  C4 5E F0			     les     bx,dword ptr [bp-16]
   1042	0426  26: 89 47	16		     mov     word ptr es:[bx+22],ax
   1043					;
   1044					;		       pclkblk->task = ptcb->task;
   1045					;
   1046					     ?debug  L 585
   1047	042A  8B 76 F6			     mov     si,word ptr [bp-10]
   1048	042D  8B 44 08			     mov     ax,word ptr [si+8]
   1049	0430  26: 89 47	10		     mov     word ptr es:[bx+16],ax
   1050					;
   1051					;
   1052					;		       /* insert timer */
   1053					;		       insert_timer(pclkblk);
   1054					;
   1055					     ?debug  L 588
   1056	0434  FF 76 F2			     push    word ptr [bp-14]
   1057	0437  53			     push    bx
   1058	0438  E8 28B9			     call    near ptr insert_timer
   1059	043B  83 C4 04			     add     sp,4
   1060					;
   1061					;
   1062					;		       ((struct	parg ks_stk *)p2)->ksrc	= RC_TIMEOUT;
   1063					;
   1064					     ?debug  L 590
   1065	043E  C4 5E FC			     les     bx,dword ptr [bp-4]
   1066	0441  26: C7 47	02 0005		     mov     word ptr es:[bx+2],5
   1067	0447			     @2@1738:
   1068					;
   1069					;		    }
   1070					;    #endif /* } PARTITION_TIMEOUTS */
   1071					;		 }
   1072					;    #endif /* } PARTITION_WAITERS */
   1073					;	      }
   1074					;	      ((struct parg ks_stk *)p2)->val =	(char *)q;
   1075					;
   1076					     ?debug  L 596
   1077	0447  C4 5E FC			     les     bx,dword ptr [bp-4]
   1078	044A  8B 56 D4			     mov     dx,word ptr [bp-44]
   1079	044D  8B 46 D2			     mov     ax,word ptr [bp-46]
   1080	0450  26: 89 57	08		     mov     word ptr es:[bx+8],dx
   1081	0454  26: 89 47	06		     mov     word ptr es:[bx+6],ax
   1082					;
   1083					;	      break;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 20
.\rtxc.asm



   1084					;
   1085					     ?debug  L 597
   1086	0458  E9 1C73			     jmp     @2@15430
   1087	045B			     @2@1766:
   1088					;
   1089					;    #endif /* } HAS_ALLOC */
   1090					;
   1091					;    #ifdef HAS_FREE /*	{ */
   1092					;    /************************/
   1093					;	   case	RTXC_FREE:
   1094					;    /************************/
   1095					;	      q	= (struct xmap *)((struct parg ks_stk *)p2)->val;
   1096					;
   1097					     ?debug  L 604
   1098	045B  C4 5E FC			     les     bx,dword ptr [bp-4]
   1099	045E  26: 8B 57	08		     mov     dx,word ptr es:[bx+8]
   1100	0462  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
   1101	0466  89 56 D4			     mov     word ptr [bp-44],dx
   1102	0469  89 46 D2			     mov     word ptr [bp-46],ax
   1103					;
   1104					;
   1105					;	      pph = &pheader[((struct parg ks_stk *)p2)->map];
   1106					;
   1107					     ?debug  L 606
   1108	046C  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   1109	0470  6B C0 12			     imul    ax,ax,18
   1110	0473  05 0000e			     add     ax,offset DGROUP:_pheader
   1111	0476  89 46 D6			     mov     word ptr [bp-42],ax
   1112					;
   1113					;
   1114					;    #ifdef CBUG /* { */
   1115					;	      pph->usage++; /* increment no. frees */
   1116					;    #endif /* } CBUG */
   1117					;
   1118					;    #ifdef PARTITION_WAITERS /* { */
   1119					;	      if ( (ptcb = pph->waiters) != NULLTCB) /*	if any waiters */
   1120					;
   1121					     ?debug  L 613
   1122	0479  8B 5E D6			     mov     bx,word ptr [bp-42]
   1123	047C  8B 47 08			     mov     ax,word ptr [bx+8]
   1124	047F  89 46 F6			     mov     word ptr [bp-10],ax
   1125	0482  0B C0			     or	     ax,ax
   1126	0484  74 74			     je	     short @2@1962
   1127					;
   1128					;	      {
   1129					;		 /* pass ptr directly from freeing task	to allocating task */
   1130					;		 p2a = ((FRAME ks_stk *)(ptcb->sp))->pksnum;
   1131					;
   1132					     ?debug  L 616
   1133	0486  8B 5E F6			     mov     bx,word ptr [bp-10]
   1134	0489  C4 5F 0C			     les     bx,dword ptr [bx+12]
   1135	048C  26: 8B 57	0E		     mov     dx,word ptr es:[bx+14]
   1136	0490  26: 8B 47	0C		     mov     ax,word ptr es:[bx+12]
   1137	0494  89 56 E2			     mov     word ptr [bp-30],dx
   1138	0497  89 46 E0			     mov     word ptr [bp-32],ax
   1139					;
   1140					;		 ((struct parg ks_stk *)p2a)->val = (char *)q;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 21
.\rtxc.asm



   1141					;
   1142					     ?debug  L 617
   1143	049A  C4 5E E0			     les     bx,dword ptr [bp-32]
   1144	049D  8B 56 D4			     mov     dx,word ptr [bp-44]
   1145	04A0  8B 46 D2			     mov     ax,word ptr [bp-46]
   1146	04A3  26: 89 57	08		     mov     word ptr es:[bx+8],dx
   1147	04A7  26: 89 47	06		     mov     word ptr es:[bx+6],ax
   1148					;
   1149					;
   1150					;		 /* remove first waiter	from list */
   1151					;		 if ( (pph->waiters = ptcb->flink) != NULLTCB)
   1152					;
   1153					     ?debug  L 620
   1154	04AB  8B 5E F6			     mov     bx,word ptr [bp-10]
   1155	04AE  8B 07			     mov     ax,word ptr [bx]
   1156	04B0  8B 5E D6			     mov     bx,word ptr [bp-42]
   1157	04B3  89 47 08			     mov     word ptr [bx+8],ax
   1158	04B6  0B C0			     or	     ax,ax
   1159	04B8  74 0E			     je	     short @2@1850
   1160					;
   1161					;		    ptcb->flink->blink = (TCB near *)&pph->waiters;
   1162					;
   1163					     ?debug  L 621
   1164	04BA  8B 46 D6			     mov     ax,word ptr [bp-42]
   1165	04BD  05 0008			     add     ax,8
   1166	04C0  8B 5E F6			     mov     bx,word ptr [bp-10]
   1167	04C3  8B 1F			     mov     bx,word ptr [bx]
   1168	04C5  89 47 02			     mov     word ptr [bx+2],ax
   1169	04C8			     @2@1850:
   1170					;
   1171					;
   1172					;		 /* "resume" first waiter */
   1173					;		 if ( (ptcb->status &= ~PARTITION_WAIT)	== READY)
   1174					;
   1175					     ?debug  L 624
   1176	04C8  8B 5E F6			     mov     bx,word ptr [bp-10]
   1177	04CB  83 67 10 FD		     and     word ptr [bx+16],-3
   1178	04CF  8B 47 10			     mov     ax,word ptr [bx+16]
   1179	04D2  0B C0			     or	     ax,ax
   1180	04D4  75 0B			     jne     short @2@1906
   1181					;
   1182					;		 {
   1183					;		    /* insert waiter into READY	list */
   1184					;		    ptcb->flink	= nsrttcb;
   1185					;
   1186					     ?debug  L 627
   1187	04D6  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
   1188	04D9  89 07			     mov     word ptr [bx],ax
   1189					;
   1190					;		    nsrttcb = ptcb;
   1191					;
   1192					     ?debug  L 628
   1193	04DB  8B 46 F6			     mov     ax,word ptr [bp-10]
   1194	04DE  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
   1195	04E1			     @2@1906:
   1196					;
   1197					;		 }
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 22
.\rtxc.asm



   1198					;
   1199					;    #ifdef PARTITION_TIMEOUTS /* { */
   1200					;		 /* cleanup any	pending	timeout	*/
   1201					;		 if ( (pclkblk = ptcb->pclkblk)	!= NULLCLK)
   1202					;
   1203					     ?debug  L 633
   1204	04E1  8B 5E F6			     mov     bx,word ptr [bp-10]
   1205	04E4  8B 57 06			     mov     dx,word ptr [bx+6]
   1206	04E7  8B 47 04			     mov     ax,word ptr [bx+4]
   1207	04EA  89 56 F2			     mov     word ptr [bp-14],dx
   1208	04ED  89 46 F0			     mov     word ptr [bp-16],ax
   1209	04F0  0B C2			     or	     ax,dx
   1210	04F2  75 03			     jne     @@7
   1211	04F4  E9 1BD7			     jmp     @2@15430
   1212	04F7			     @@7:
   1213	04F7  E9 035B			     jmp     @2@3138
   1214	04FA			     @2@1962:
   1215					;
   1216					;		 {
   1217					;		    /* mark waiter GOOD	*/
   1218					;		    ((struct parg ks_stk *)p2a)->ksrc =	RC_GOOD;
   1219					;
   1220					;		    unlink_timer(pclkblk);
   1221					;		    ptcb->pclkblk = NULLCLK;
   1222					;		 }
   1223					;    #endif /* } PARTITION_TIMEOUTS */
   1224					;	      }
   1225					;	      else
   1226					;    #endif /* } PARTITION_WAITERS */
   1227					;	      {
   1228					;		 /* put	block back on free list	*/
   1229					;		 q->link = pph->next;
   1230					;
   1231					     ?debug  L 647
   1232	04FA  8B 5E D6			     mov     bx,word ptr [bp-42]
   1233	04FD  8B 57 02			     mov     dx,word ptr [bx+2]
   1234	0500  8B 07			     mov     ax,word ptr [bx]
   1235	0502  C4 5E D2			     les     bx,dword ptr [bp-46]
   1236	0505  26: 89 57	02		     mov     word ptr es:[bx+2],dx
   1237	0509  26: 89 07			     mov     word ptr es:[bx],ax
   1238					;
   1239					;		 pph->next = q;
   1240					;
   1241					     ?debug  L 648
   1242	050C  8B 5E D6			     mov     bx,word ptr [bp-42]
   1243	050F  8B 56 D4			     mov     dx,word ptr [bp-44]
   1244	0512  8B 46 D2			     mov     ax,word ptr [bp-46]
   1245	0515  89 57 02			     mov     word ptr [bx+2],dx
   1246	0518  89 07			     mov     word ptr [bx],ax
   1247	051A  E9 1BB1			     jmp     @2@15430
   1248	051D			     @2@1990:
   1249					;
   1250					;
   1251					;    #ifdef CBUG /* { */
   1252					;		 pph->cur--;   /* track	current	no. used */
   1253					;    #endif /* } CBUG */
   1254					;	      }
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 23
.\rtxc.asm



   1255					;	      break;
   1256					;    #endif /* } HAS_FREE */
   1257					;
   1258					;    #ifdef HAS_CREATE_PART /* { */
   1259					;    /************************/
   1260					;	   case	RTXC_CREATE_PART:
   1261					;    /************************/
   1262					;	      if ( (pph	= dphfl) != NULLMAP)
   1263					;
   1264					     ?debug  L 661
   1265	051D  A1 000Ar			     mov     ax,word ptr DGROUP:_dphfl
   1266	0520  89 46 D6			     mov     word ptr [bp-42],ax
   1267	0523  0B C0			     or	     ax,ax
   1268	0525  75 03			     jne     @@8
   1269	0527  E9 19B5			     jmp     @2@14450
   1270	052A			     @@8:
   1271					;
   1272					;	      {
   1273					;		 /* allocate pheader by	removing 1st from free list */
   1274					;		 dphfl = (PHEADER near *)pph->next;
   1275					;
   1276					     ?debug  L 664
   1277	052A  8B 5E D6			     mov     bx,word ptr [bp-42]
   1278	052D  8B 07			     mov     ax,word ptr [bx]
   1279	052F  A3 000Ar			     mov     word ptr DGROUP:_dphfl,ax
   1280					;
   1281					;
   1282					;		 /* put	map number in arg packet */
   1283					;		 ((struct parg ks_stk *)p2)->map = pph->map;
   1284					;
   1285					     ?debug  L 667
   1286	0532  C4 5E FC			     les     bx,dword ptr [bp-4]
   1287	0535  8B 76 D6			     mov     si,word ptr [bp-42]
   1288	0538  8B 44 0C			     mov     ax,word ptr [si+12]
   1289	053B  26: 89 47	04		     mov     word ptr es:[bx+4],ax
   1290	053F			     @2@2046:
   1291					;
   1292					;
   1293					;		 /* use	header to define partition */
   1294					;		 dn_defpart(pph,p2);
   1295					;
   1296					     ?debug  L 670
   1297	053F  FF 76 FE			     push    word ptr [bp-2]
   1298	0542  FF 76 FC			     push    word ptr [bp-4]
   1299	0545  FF 76 D6			     push    word ptr [bp-42]
   1300	0548  E8 2B06			     call    near ptr dn_defpart
   1301	054B  83 C4 06			     add     sp,6
   1302					;
   1303					;	      }
   1304					;
   1305					     ?debug  L 671
   1306	054E  E9 1B7D			     jmp     @2@15430
   1307	0551			     @2@2074:
   1308					;
   1309					;	      else  /* pheader not available, return 0 */
   1310					;		 ((struct parg ks_stk *)p2)->map = (MAP)0;
   1311					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 24
.\rtxc.asm



   1312					;	      break;
   1313					;    #endif /* } HAS_CREATE_PART */
   1314					;
   1315					;    #ifdef HAS_DEFPART	/* { */
   1316					;    /************************/
   1317					;	   case	RTXC_DEFPART:
   1318					;    /************************/
   1319					;	      pph = &pheader[((struct parg ks_stk *)p2)->map];
   1320					;
   1321					     ?debug  L 682
   1322	0551  C4 5E FC			     les     bx,dword ptr [bp-4]
   1323	0554  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   1324	0558  6B C0 12			     imul    ax,ax,18
   1325	055B  05 0000e			     add     ax,offset DGROUP:_pheader
   1326	055E  89 46 D6			     mov     word ptr [bp-42],ax
   1327	0561  EB DC			     jmp     short @2@2046
   1328	0563			     @2@2102:
   1329					;
   1330					;	      dn_defpart(pph,p2);  /* use header to define partition */
   1331					;
   1332					;	      break;
   1333					;    #endif /* } HAS_DEFPART */
   1334					;
   1335					;    #ifdef HAS_ALLOC_PART /* {	*/
   1336					;    /************************/
   1337					;	   case	RTXC_ALLOC_PART:
   1338					;    /************************/
   1339					;	      if ( (pph	= dphfl) != NULLMAP)
   1340					;
   1341					     ?debug  L 692
   1342	0563  A1 000Ar			     mov     ax,word ptr DGROUP:_dphfl
   1343	0566  89 46 D6			     mov     word ptr [bp-42],ax
   1344	0569  0B C0			     or	     ax,ax
   1345	056B  75 03			     jne     @@9
   1346	056D  E9 196F			     jmp     @2@14450
   1347	0570			     @@9:
   1348					;
   1349					;	      {
   1350					;		 /* allocate pheader by	removing 1st from free list */
   1351					;		 dphfl = (PHEADER near *)pph->next;
   1352					;
   1353					     ?debug  L 695
   1354	0570  8B 5E D6			     mov     bx,word ptr [bp-42]
   1355	0573  8B 07			     mov     ax,word ptr [bx]
   1356	0575  A3 000Ar			     mov     word ptr DGROUP:_dphfl,ax
   1357					;
   1358					;
   1359					;		 /* put	map number in arg packet */
   1360					;		 ((struct parg ks_stk *)p2)->map = pph->map;
   1361					;
   1362					     ?debug  L 698
   1363	0578  C4 5E FC			     les     bx,dword ptr [bp-4]
   1364	057B  8B 76 D6			     mov     si,word ptr [bp-42]
   1365	057E  8B 44 0C			     mov     ax,word ptr [si+12]
   1366	0581  26: 89 47	04		     mov     word ptr es:[bx+4],ax
   1367					;
   1368					;	      }
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 25
.\rtxc.asm



   1369					;
   1370					     ?debug  L 699
   1371	0585  E9 1B46			     jmp     @2@15430
   1372	0588			     @2@2158:
   1373					;
   1374					;	      else /* pheader not available, return 0 */
   1375					;		 ((struct parg ks_stk *)p2)->map = (MAP)0;
   1376					;
   1377					;	      break;
   1378					;    #endif /* } HAS_ALLOC_PART	*/
   1379					;
   1380					;    #ifdef HAS_FREE_PART /* { */
   1381					;    /************************/
   1382					;	   case	RTXC_FREE_PART:
   1383					;    /************************/
   1384					;	      pph = &pheader[((struct parg ks_stk *)p2)->map];
   1385					;
   1386					     ?debug  L 710
   1387	0588  C4 5E FC			     les     bx,dword ptr [bp-4]
   1388	058B  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   1389	058F  6B C0 12			     imul    ax,ax,18
   1390	0592  05 0000e			     add     ax,offset DGROUP:_pheader
   1391	0595  89 46 D6			     mov     word ptr [bp-42],ax
   1392					;
   1393					;
   1394					;	      /* reset dimension and stats */
   1395					;	      pph->size	= 0;
   1396					;
   1397					     ?debug  L 713
   1398	0598  8B 5E D6			     mov     bx,word ptr [bp-42]
   1399	059B  C7 47 04 0000		     mov     word ptr [bx+4],0
   1400					;
   1401					;	      pph->count = 0;
   1402					;
   1403					     ?debug  L 714
   1404	05A0  C7 47 06 0000		     mov     word ptr [bx+6],0
   1405					;
   1406					;    #ifdef PARTITION_WAITERS /* { */
   1407					;	      pph->waiters = NULL;
   1408					;
   1409					     ?debug  L 716
   1410	05A5  C7 47 08 0000		     mov     word ptr [bx+8],0
   1411					;
   1412					;	      pph->dummy = NULL;
   1413					;
   1414					     ?debug  L 717
   1415	05AA  C7 47 0A 0000		     mov     word ptr [bx+10],0
   1416					;
   1417					;    #endif /* } PARTITION_WAITERS */
   1418					;    #ifdef CBUG /* { */
   1419					;	      pph->cur = 0;
   1420					;	      pph->worst = 0;
   1421					;	      pph->usage = 0;
   1422					;    #endif /* } CBUG */
   1423					;
   1424					;	      /* re-insert pheader into	pheader	free list for dynamic partitions */
   1425					;	      pph->next	= (struct xmap *)dphfl;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 26
.\rtxc.asm



   1426					;
   1427					     ?debug  L 726
   1428	05AF  A1 000Ar			     mov     ax,word ptr DGROUP:_dphfl
   1429	05B2  8C 5F 02			     mov     word ptr [bx+2],ds
   1430	05B5  89 07			     mov     word ptr [bx],ax
   1431					;
   1432					;	      dphfl = pph;
   1433					;
   1434					     ?debug  L 727
   1435	05B7  8B 46 D6			     mov     ax,word ptr [bp-42]
   1436	05BA  A3 000Ar			     mov     word ptr DGROUP:_dphfl,ax
   1437					;
   1438					;
   1439					;	      ((struct parg ks_stk *)p2)->addr = pph->addr;
   1440					;
   1441					     ?debug  L 729
   1442	05BD  8B 57 10			     mov     dx,word ptr [bx+16]
   1443	05C0  8B 47 0E			     mov     ax,word ptr [bx+14]
   1444	05C3  8B 5E FC			     mov     bx,word ptr [bp-4]
   1445	05C6  26: 89 57	18		     mov     word ptr es:[bx+24],dx
   1446	05CA  26: 89 47	16		     mov     word ptr es:[bx+22],ax
   1447					;
   1448					;
   1449					;	      break;
   1450					;
   1451					     ?debug  L 731
   1452	05CE  E9 1AFD			     jmp     @2@15430
   1453	05D1			     @2@2186:
   1454					;
   1455					;    #endif /* } HAS_FREE_PART */
   1456					;
   1457					;    #endif /* } HAS_PARTITIONS	*/
   1458					;
   1459					;    #ifdef HAS_RESOURCES /* { */
   1460					;    #ifdef HAS_LOCK /*	{ */
   1461					;    /************************/
   1462					;	   case	RTXC_LOCK:
   1463					;    /************************/
   1464					;	      prh = &rheader[((struct larg ks_stk *)p2)->resource];
   1465					;
   1466					     ?debug  L 741
   1467	05D1  C4 5E FC			     les     bx,dword ptr [bp-4]
   1468	05D4  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   1469	05D8  6B C0 0C			     imul    ax,ax,12
   1470	05DB  05 0000e			     add     ax,offset DGROUP:_rheader
   1471	05DE  89 46 C6			     mov     word ptr [bp-58],ax
   1472					;
   1473					;
   1474					;    #ifdef CBUG /* { */
   1475					;	      prh->count++; /* update statistics */
   1476					;    #endif /* } CBUG */
   1477					;
   1478					;	      if (prh->owner ==	NULLTCB)  /* if	resource not currently owned */
   1479					;
   1480					     ?debug  L 747
   1481	05E1  8B 5E C6			     mov     bx,word ptr [bp-58]
   1482	05E4  83 3F 00			     cmp     word ptr [bx],0
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 27
.\rtxc.asm



   1483	05E7  75 16			     jne     short @2@2242
   1484					;
   1485					;	      {
   1486					;		 prh->owner = hipritsk;	/* lock	resource with task */
   1487					;
   1488					     ?debug  L 749
   1489	05E9  A1 0000r			     mov     ax,word ptr DGROUP:_hipritsk
   1490	05EC  89 07			     mov     word ptr [bx],ax
   1491					;
   1492					;		 prh->level = 1;	 /* set	nesting	level =	1 */
   1493					;
   1494					     ?debug  L 750
   1495	05EE  C7 47 02 0001		     mov     word ptr [bx+2],1
   1496					;
   1497					;		 ((struct larg ks_stk *)p2)->ksrc = RC_GOOD;
   1498					;
   1499					     ?debug  L 751
   1500	05F3  8B 5E FC			     mov     bx,word ptr [bp-4]
   1501	05F6  26: C7 47	02 0000		     mov     word ptr es:[bx+2],0
   1502					;
   1503					;		 break;
   1504					;
   1505					     ?debug  L 752
   1506	05FC  E9 1ACF			     jmp     @2@15430
   1507	05FF			     @2@2242:
   1508					;
   1509					;	      }
   1510					;
   1511					;	      if (prh->owner ==	hipritsk) /* if	nested lock */
   1512					;
   1513					     ?debug  L 755
   1514	05FF  8B 5E C6			     mov     bx,word ptr [bp-58]
   1515	0602  8B 07			     mov     ax,word ptr [bx]
   1516	0604  3B 06 0000r		     cmp     ax,word ptr DGROUP:_hipritsk
   1517	0608  75 0F			     jne     short @2@2298
   1518					;
   1519					;	      {
   1520					;		 prh->level++; /* bump nesting level only */
   1521					;
   1522					     ?debug  L 757
   1523	060A  FF 47 02			     inc     word ptr [bx+2]
   1524					;
   1525					;			/* indicate NESTED lock	*/
   1526					;		 ((struct larg ks_stk *)p2)->ksrc = RC_NESTED;
   1527					;
   1528					     ?debug  L 759
   1529	060D  C4 5E FC			     les     bx,dword ptr [bp-4]
   1530	0610  26: C7 47	02 000A		     mov     word ptr es:[bx+2],10
   1531					;
   1532					;		 break;
   1533					;
   1534					     ?debug  L 760
   1535	0616  E9 1AB5			     jmp     @2@15430
   1536	0619			     @2@2298:
   1537					;
   1538					;	      }
   1539					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 28
.\rtxc.asm



   1540					;    #ifdef CBUG /* { */
   1541					;	      prh->conflict++; /* count	resource bottlenecks */
   1542					;    #endif /* } CBUG */
   1543					;
   1544					;    #ifdef RESOURCE_WAITERS /*	{ */
   1545					;	      /* if wait on resource not available */
   1546					;	      if ( ((struct larg ks_stk	*)p2)->wait)
   1547					;
   1548					     ?debug  L 769
   1549	0619  C4 5E FC			     les     bx,dword ptr [bp-4]
   1550	061C  26: 83 7F	06 00		     cmp     word ptr es:[bx+6],0
   1551	0621  75 03			     jne     @@10
   1552	0623  E9 0147			     jmp     @2@2718
   1553	0626			     @@10:
   1554					;
   1555					;	      {
   1556					;    #ifdef PRIORITY_INVERSION /* { */
   1557					;		 if (prh->resattr == PRIORITY_INVERSION_ON)
   1558					;
   1559					     ?debug  L 772
   1560	0626  8B 5E C6			     mov     bx,word ptr [bp-58]
   1561	0629  83 7F 0A 01		     cmp     word ptr [bx+10],1
   1562	062D  75 6D			     jne     short @2@2550
   1563					;
   1564					;		 {
   1565					;		    /* if owner	is lower priority than requestor */
   1566					;		    if ( (ptcb = prh->owner)->priority > hipritsk->priority)
   1567					;
   1568					     ?debug  L 775
   1569	062F  8B 07			     mov     ax,word ptr [bx]
   1570	0631  89 46 F6			     mov     word ptr [bp-10],ax
   1571	0634  8B D8			     mov     bx,ax
   1572	0636  8B 47 0A			     mov     ax,word ptr [bx+10]
   1573	0639  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   1574	063D  3B 47 0A			     cmp     ax,word ptr [bx+10]
   1575	0640  7E 5A			     jle     short @2@2550
   1576					;
   1577					;		    {
   1578					;		       /* priority inversion is	necessary */
   1579					;
   1580					;		       /* save owner's priority	only for first conflict	*/
   1581					;		       if (prh->priority == (PRIORITY)0)
   1582					;
   1583					     ?debug  L 780
   1584	0642  8B 5E C6			     mov     bx,word ptr [bp-58]
   1585	0645  83 7F 08 00		     cmp     word ptr [bx+8],0
   1586	0649  75 0C			     jne     short @2@2438
   1587					;
   1588					;			  prh->priority	= ptcb->priority;
   1589					;
   1590					     ?debug  L 781
   1591	064B  8B 5E F6			     mov     bx,word ptr [bp-10]
   1592	064E  8B 47 0A			     mov     ax,word ptr [bx+10]
   1593	0651  8B 5E C6			     mov     bx,word ptr [bp-58]
   1594	0654  89 47 08			     mov     word ptr [bx+8],ax
   1595	0657			     @2@2438:
   1596					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 29
.\rtxc.asm



   1597					;
   1598					;		       /* but always elevate owner's priority to hipri->priority */
   1599					;		       ptcb->priority =	hipritsk->priority;
   1600					;
   1601					     ?debug  L 784
   1602	0657  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   1603	065B  8B 47 0A			     mov     ax,word ptr [bx+10]
   1604	065E  8B 5E F6			     mov     bx,word ptr [bp-10]
   1605	0661  89 47 0A			     mov     word ptr [bx+10],ax
   1606					;
   1607					;
   1608					;		       /* change priority - whatever it	takes */
   1609					;		       if (ptcb->status	== READY)
   1610					;
   1611					     ?debug  L 787
   1612	0664  83 7F 10 00		     cmp     word ptr [bx+16],0
   1613	0668  75 22			     jne     short @2@2494
   1614					;
   1615					;		       {
   1616					;			  /* unlink owner task from RUN	list */
   1617					;			  ptcb->flink->blink = ptcb->blink;
   1618					;
   1619					     ?debug  L 790
   1620	066A  8B 47 02			     mov     ax,word ptr [bx+2]
   1621	066D  8B 1F			     mov     bx,word ptr [bx]
   1622	066F  89 47 02			     mov     word ptr [bx+2],ax
   1623					;
   1624					;			  ptcb->blink->flink = ptcb->flink;
   1625					;
   1626					     ?debug  L 791
   1627	0672  8B 5E F6			     mov     bx,word ptr [bp-10]
   1628	0675  8B 07			     mov     ax,word ptr [bx]
   1629	0677  8B 5F 02			     mov     bx,word ptr [bx+2]
   1630	067A  89 07			     mov     word ptr [bx],ax
   1631					;
   1632					;
   1633					;			  /* re-insert task */
   1634					;			  ptcb->flink =	nsrttcb;
   1635					;
   1636					     ?debug  L 794
   1637	067C  8B 5E F6			     mov     bx,word ptr [bp-10]
   1638	067F  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
   1639	0682  89 07			     mov     word ptr [bx],ax
   1640					;
   1641					;			  nsrttcb = ptcb;
   1642					;
   1643					     ?debug  L 795
   1644	0684  8B 46 F6			     mov     ax,word ptr [bp-10]
   1645	0687  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
   1646					;
   1647					;		       }
   1648					;
   1649					     ?debug  L 796
   1650	068A  EB 10			     jmp     short @2@2550
   1651	068C			     @2@2494:
   1652					;
   1653					;		       else
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 30
.\rtxc.asm



   1654					;		       {
   1655					;			  /* if	task being changed is in a WAITER list */
   1656					;			  if (ptcb->status & COMBO_WAIT)
   1657					;
   1658					     ?debug  L 800
   1659	068C  8B 5E F6			     mov     bx,word ptr [bp-10]
   1660	068F  F6 47 10 AA		     test    byte ptr [bx+16],170
   1661	0693  74 07			     je	     short @2@2550
   1662					;
   1663					;			  {
   1664					;			     /*
   1665					;			      *	need to	re-order within	partition, queue, resource,
   1666					;			      *	or mailbox header
   1667					;			     */
   1668					;			     reorder_waiters(ptcb);
   1669					;
   1670					     ?debug  L 806
   1671	0695  53			     push    bx
   1672	0696  E8 27BD			     call    near ptr reorder_waiters
   1673	0699  83 C4 02			     add     sp,2
   1674					;
   1675					;			  }
   1676					;
   1677					     ?debug  L 807
   1678	069C			     @2@2550:
   1679					;
   1680					;			  else
   1681					;			  {
   1682					;			     /*	task is	suspended, terminated or blocked */
   1683					;			     /*	priority change	above is all that is needed */
   1684					;			  }
   1685					;		       }
   1686					;		    }
   1687					;		 }
   1688					;    #endif /* } PRIORITY_INVERSION */
   1689					;
   1690					;		 ptcb =	hipritsk; /* save hipritsk for later use */
   1691					;
   1692					     ?debug  L 818
   1693	069C  A1 0000r			     mov     ax,word ptr DGROUP:_hipritsk
   1694	069F  89 46 F6			     mov     word ptr [bp-10],ax
   1695					;
   1696					;
   1697					;		 ptcb->status =	RESOURCE_WAIT; /* mark task waiting */
   1698					;
   1699					     ?debug  L 820
   1700	06A2  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   1701	06A6  C7 47 10 0008		     mov     word ptr [bx+16],8
   1702					;
   1703					;
   1704					;		 /* thread waiting task	in priority order */
   1705					;		 porder((TCB near *)&prh->waiters);
   1706					;
   1707					     ?debug  L 823
   1708	06AB  8B 46 C6			     mov     ax,word ptr [bp-58]
   1709	06AE  05 0004			     add     ax,4
   1710	06B1  50			     push    ax
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 31
.\rtxc.asm



   1711	06B2  E8 2739			     call    near ptr porder
   1712	06B5  83 C4 02			     add     sp,2
   1713					;
   1714					;
   1715					;    #ifdef RESOURCE_TIMEOUTS /* { */
   1716					;		 if ( ((struct larg ks_stk *)p2)->ticks) /* if timeout active */
   1717					;
   1718					     ?debug  L 826
   1719	06B8  C4 5E FC			     les     bx,dword ptr [bp-4]
   1720	06BB  26: 8B 47	08		     mov     ax,word ptr es:[bx+8]
   1721	06BF  26: 0B 47	0A		     or	     ax,word ptr es:[bx+10]
   1722	06C3  75 03			     jne     @@11
   1723	06C5  E9 1A06			     jmp     @2@15430
   1724	06C8			     @@11:
   1725					;
   1726					;		 {
   1727					;		    ptcb->pclkblk = ((struct larg ks_stk *)p2)->pclkblk;
   1728					;
   1729					     ?debug  L 828
   1730	06C8  26: 8B 57	0E		     mov     dx,word ptr es:[bx+14]
   1731	06CC  26: 8B 47	0C		     mov     ax,word ptr es:[bx+12]
   1732	06D0  8B 5E F6			     mov     bx,word ptr [bp-10]
   1733	06D3  89 57 06			     mov     word ptr [bx+6],dx
   1734	06D6  89 47 04			     mov     word ptr [bx+4],ax
   1735					;
   1736					;		    pclkblk = ptcb->pclkblk;
   1737					;
   1738					     ?debug  L 829
   1739	06D9  8B 57 06			     mov     dx,word ptr [bx+6]
   1740	06DC  8B 47 04			     mov     ax,word ptr [bx+4]
   1741	06DF  89 56 F2			     mov     word ptr [bp-14],dx
   1742	06E2  89 46 F0			     mov     word ptr [bp-16],ax
   1743					;
   1744					;		    pclkblk->remain = ((struct larg ks_stk *)p2)->ticks;
   1745					;
   1746					     ?debug  L 830
   1747	06E5  8B 5E FC			     mov     bx,word ptr [bp-4]
   1748	06E8  26: 8B 57	0A		     mov     dx,word ptr es:[bx+10]
   1749	06EC  26: 8B 47	08		     mov     ax,word ptr es:[bx+8]
   1750	06F0  C4 5E F0			     les     bx,dword ptr [bp-16]
   1751	06F3  26: 89 57	0A		     mov     word ptr es:[bx+10],dx
   1752	06F7  26: 89 47	08		     mov     word ptr es:[bx+8],ax
   1753					;
   1754					;		    pclkblk->recycle = (TICKS)0;
   1755					;
   1756					     ?debug  L 831
   1757	06FB  26: C7 47	0E 0000		     mov     word ptr es:[bx+14],0
   1758	0701  26: C7 47	0C 0000		     mov     word ptr es:[bx+12],0
   1759					;
   1760					;
   1761					;		    /* mark object type	*/
   1762					;		    pclkblk->objtype = RESOURCE_OBJ;
   1763					;
   1764					     ?debug  L 834
   1765	0707  26: C7 47	14 0004		     mov     word ptr es:[bx+20],4
   1766					;
   1767					;		    pclkblk->objid = ((struct larg ks_stk *)p2)->resource;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 32
.\rtxc.asm



   1768					;
   1769					     ?debug  L 835
   1770	070D  C4 5E FC			     les     bx,dword ptr [bp-4]
   1771	0710  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   1772	0714  C4 5E F0			     les     bx,dword ptr [bp-16]
   1773	0717			     @2@2606:
   1774	0717  26: 89 47	16		     mov     word ptr es:[bx+22],ax
   1775					;
   1776					;		    pclkblk->task = ptcb->task;
   1777					;
   1778					     ?debug  L 836
   1779	071B  C4 5E F0			     les     bx,dword ptr [bp-16]
   1780	071E  8B 76 F6			     mov     si,word ptr [bp-10]
   1781	0721  8B 44 08			     mov     ax,word ptr [si+8]
   1782	0724  26: 89 47	10		     mov     word ptr es:[bx+16],ax
   1783					;
   1784					;
   1785					;		    /* insert timer */
   1786					;		    insert_timer(pclkblk);
   1787					;
   1788					     ?debug  L 839
   1789	0728  FF 76 F2			     push    word ptr [bp-14]
   1790	072B  53			     push    bx
   1791	072C  E8 25C5			     call    near ptr insert_timer
   1792	072F  83 C4 04			     add     sp,4
   1793					;
   1794					;
   1795					;		    ((struct larg ks_stk *)p2)->ksrc = RC_TIMEOUT;
   1796					;
   1797					     ?debug  L 841
   1798	0732  C4 5E FC			     les     bx,dword ptr [bp-4]
   1799	0735  26: C7 47	02 0005		     mov     word ptr es:[bx+2],5
   1800	073B  E9 1990			     jmp     @2@15430
   1801	073E			     @2@2634:
   1802					;
   1803					;		 }
   1804					;    #endif /* } RESOURCE_TIMEOUTS */
   1805					;	      }
   1806					;	      else
   1807					;    #endif /* } RESOURCE_WAITERS */
   1808					;	      {
   1809					;			/* indicate lock failure */
   1810					;		 ((struct larg ks_stk *)p2)->ksrc = RC_BUSY;
   1811					;	      }
   1812					;	      break;
   1813					;    #endif /* } HAS_LOCK */
   1814					;
   1815					;    #ifdef HAS_UNLOCK /* { */
   1816					;    /************************/
   1817					;	   case	RTXC_UNLOCK:
   1818					;    /************************/
   1819					;	      prh = &rheader[((struct larg ks_stk *)p2)->resource];
   1820					;
   1821					     ?debug  L 858
   1822	073E  C4 5E FC			     les     bx,dword ptr [bp-4]
   1823	0741  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   1824	0745  6B C0 0C			     imul    ax,ax,12
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 33
.\rtxc.asm



   1825	0748  05 0000e			     add     ax,offset DGROUP:_rheader
   1826	074B  89 46 C6			     mov     word ptr [bp-58],ax
   1827					;
   1828					;
   1829					;	      if (prh->owner ==	NULLTCB) /* if no owner, then NOP */
   1830					;
   1831					     ?debug  L 860
   1832	074E  8B 5E C6			     mov     bx,word ptr [bp-58]
   1833	0751  83 3F 00			     cmp     word ptr [bx],0
   1834	0754  75 0C			     jne     short @2@2690
   1835					;
   1836					;	      {
   1837					;		 ((struct larg ks_stk *)p2)->ksrc = RC_GOOD;
   1838					;
   1839					     ?debug  L 862
   1840	0756  8B 5E FC			     mov     bx,word ptr [bp-4]
   1841	0759  26: C7 47	02 0000		     mov     word ptr es:[bx+2],0
   1842					;
   1843					;		 break;
   1844					;
   1845					     ?debug  L 863
   1846	075F  E9 196C			     jmp     @2@15430
   1847	0762			     @2@2690:
   1848					;
   1849					;	      }
   1850					;
   1851					;	      if (prh->owner !=	hipritsk) /* if	hipritsk not owner, then NOP */
   1852					;
   1853					     ?debug  L 866
   1854	0762  8B 5E C6			     mov     bx,word ptr [bp-58]
   1855	0765  8B 07			     mov     ax,word ptr [bx]
   1856	0767  3B 06 0000r		     cmp     ax,word ptr DGROUP:_hipritsk
   1857	076B  74 0C			     je	     short @2@2746
   1858	076D			     @2@2718:
   1859					;
   1860					;	      {
   1861					;		 ((struct larg ks_stk *)p2)->ksrc = RC_BUSY;
   1862					;
   1863					     ?debug  L 868
   1864	076D  C4 5E FC			     les     bx,dword ptr [bp-4]
   1865	0770  26: C7 47	02 0009		     mov     word ptr es:[bx+2],9
   1866					;
   1867					;		 break;
   1868					;
   1869					     ?debug  L 869
   1870	0776  E9 1955			     jmp     @2@15430
   1871	0779			     @2@2746:
   1872					;
   1873					;	      }
   1874					;
   1875					;	      if (--prh->level)	/* if more nesting remaining, then NOP */
   1876					;
   1877					     ?debug  L 872
   1878	0779  8B 5E C6			     mov     bx,word ptr [bp-58]
   1879	077C  FF 4F 02			     dec     word ptr [bx+2]
   1880	077F  74 0C			     je	     short @2@2802
   1881					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 34
.\rtxc.asm



   1882					;	      {
   1883					;		 ((struct larg ks_stk *)p2)->ksrc = RC_NESTED;
   1884					;
   1885					     ?debug  L 874
   1886	0781  C4 5E FC			     les     bx,dword ptr [bp-4]
   1887	0784  26: C7 47	02 000A		     mov     word ptr es:[bx+2],10
   1888					;
   1889					;		 break;
   1890					;
   1891					     ?debug  L 875
   1892	078A  E9 1941			     jmp     @2@15430
   1893	078D			     @2@2802:
   1894					;
   1895					;	      }
   1896					;
   1897					;    #ifdef RESOURCE_WAITERS /*	{ */
   1898					;    #ifdef PRIORITY_INVERSION /* { */
   1899					;	      /*
   1900					;	       *
   1901					;	       * tech note: The	owner task may be "priority inverted" even though
   1902					;	       *	    there are currently	no waiting tasks.  This	state
   1903					;	       *	    can	happen when a waiting task times out and leaves
   1904					;	       *	    the	owner inadvertently inverted.  There is	no attempt
   1905					;	       *	    on the timeout to revert the owner.	 Reversion would
   1906					;	       *	    involve changing the owner's priority to that of the
   1907					;	       *	    next waiting task or back to the original if there
   1908					;	       *	    were no more waiting tasks.	 This case is really
   1909					;	       *	    ambiguous since the	resource's owner may have since
   1910					;	       *	    intentionally changed his own priority.
   1911					;	       *
   1912					;	      */
   1913					;	      if (prh->resattr == PRIORITY_INVERSION_ON)
   1914					;
   1915					     ?debug  L 894
   1916	078D  8B 5E C6			     mov     bx,word ptr [bp-58]
   1917	0790  83 7F 0A 01		     cmp     word ptr [bx+10],1
   1918	0794  75 45			     jne     short @2@2942
   1919					;
   1920					;	      {
   1921					;		 if (prh->priority != (PRIORITY)0)
   1922					;
   1923					     ?debug  L 896
   1924	0796  83 7F 08 00		     cmp     word ptr [bx+8],0
   1925	079A  74 3F			     je	     short @2@2942
   1926					;
   1927					;		 {
   1928					;		    /* return owner task to pre-inversion priority
   1929					;		     *
   1930					;		     * note - owner task may have manually changed its priority
   1931					;		     *	      unbeknownst to kernel
   1932					;		    */
   1933					;
   1934					;		    /* iff relative priorities are changed then	re-prioritize */
   1935					;		    if ( (hipritsk->priority = prh->priority) >
   1936					;
   1937					     ?debug  L 905
   1938					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 35
.\rtxc.asm



   1939					;			 hipritsk->flink->priority)
   1940					;
   1941					     ?debug  L 906
   1942	079C  8B 47 08			     mov     ax,word ptr [bx+8]
   1943	079F  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   1944	07A3  89 47 0A			     mov     word ptr [bx+10],ax
   1945	07A6  8B 1F			     mov     bx,word ptr [bx]
   1946	07A8  3B 47 0A			     cmp     ax,word ptr [bx+10]
   1947	07AB  7E 26			     jle     short @2@2914
   1948					;
   1949					;		    {
   1950					;		       ptcb = hipritsk;	/* save	for later */
   1951					;
   1952					     ?debug  L 908
   1953	07AD  A1 0000r			     mov     ax,word ptr DGROUP:_hipritsk
   1954	07B0  89 46 F6			     mov     word ptr [bp-10],ax
   1955					;
   1956					;
   1957					;		       /* remove self from READY list (ALWAYS first in list) */
   1958					;		       UNLINK_HIPRITSK();
   1959					;
   1960					     ?debug  L 911
   1961	07B3  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   1962	07B7  8B 07			     mov     ax,word ptr [bx]
   1963	07B9  A3 0000r			     mov     word ptr DGROUP:_hipritsk,ax
   1964	07BC  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   1965	07C0  C7 47 02 0000r		     mov     word ptr [bx+2],offset DGROUP:_hipritsk
   1966					;
   1967					;
   1968					;		       /* re-insert task */
   1969					;		       ptcb->flink = nsrttcb;
   1970					;
   1971					     ?debug  L 914
   1972	07C5  8B 5E F6			     mov     bx,word ptr [bp-10]
   1973	07C8  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
   1974	07CB  89 07			     mov     word ptr [bx],ax
   1975					;
   1976					;		       nsrttcb = ptcb;
   1977					;
   1978					     ?debug  L 915
   1979	07CD  8B 46 F6			     mov     ax,word ptr [bp-10]
   1980	07D0  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
   1981	07D3			     @2@2914:
   1982					;
   1983					;		    }
   1984					;
   1985					;		    prh->priority = 0; /* reset	priority inversion history flag	*/
   1986					;
   1987					     ?debug  L 918
   1988	07D3  8B 5E C6			     mov     bx,word ptr [bp-58]
   1989	07D6  C7 47 08 0000		     mov     word ptr [bx+8],0
   1990	07DB			     @2@2942:
   1991					;
   1992					;		 }
   1993					;	      }
   1994					;    #endif /* } PRIORITY_INVERSION */
   1995					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 36
.\rtxc.asm



   1996					;	      /* if any	task is	waiting	for the	resource */
   1997					;	      if ( (ptcb = prh->waiters) != NULLTCB)
   1998					;
   1999					     ?debug  L 924
   2000	07DB  8B 5E C6			     mov     bx,word ptr [bp-58]
   2001	07DE  8B 47 04			     mov     ax,word ptr [bx+4]
   2002	07E1  89 46 F6			     mov     word ptr [bp-10],ax
   2003	07E4  0B C0			     or	     ax,ax
   2004	07E6  75 03			     jne     @@12
   2005	07E8  E9 008F			     jmp     @2@3166
   2006	07EB			     @@12:
   2007					;
   2008					;	      {
   2009					;		 /* remove first waiter	from list */
   2010					;		 if ( (prh->waiters = ptcb->flink) != NULLTCB)
   2011					;
   2012					     ?debug  L 927
   2013	07EB  8B 5E F6			     mov     bx,word ptr [bp-10]
   2014	07EE  8B 07			     mov     ax,word ptr [bx]
   2015	07F0  8B 5E C6			     mov     bx,word ptr [bp-58]
   2016	07F3  89 47 04			     mov     word ptr [bx+4],ax
   2017	07F6  0B C0			     or	     ax,ax
   2018	07F8  74 0E			     je	     short @2@3026
   2019					;
   2020					;		    ptcb->flink->blink = (TCB near *)&prh->waiters;
   2021					;
   2022					     ?debug  L 928
   2023	07FA  8B 46 C6			     mov     ax,word ptr [bp-58]
   2024	07FD  05 0004			     add     ax,4
   2025	0800  8B 5E F6			     mov     bx,word ptr [bp-10]
   2026	0803  8B 1F			     mov     bx,word ptr [bx]
   2027	0805  89 47 02			     mov     word ptr [bx+2],ax
   2028	0808			     @2@3026:
   2029					;
   2030					;
   2031					;		      /* "resume" first	waiter */
   2032					;		 if ( (ptcb->status &= ~RESOURCE_WAIT) == READY)
   2033					;
   2034					     ?debug  L 931
   2035	0808  8B 5E F6			     mov     bx,word ptr [bp-10]
   2036	080B  83 67 10 F7		     and     word ptr [bx+16],-9
   2037	080F  8B 47 10			     mov     ax,word ptr [bx+16]
   2038	0812  0B C0			     or	     ax,ax
   2039	0814  75 0B			     jne     short @2@3082
   2040					;
   2041					;		 {
   2042					;		    /* insert waiter into READY	list */
   2043					;		    ptcb->flink	= nsrttcb;
   2044					;
   2045					     ?debug  L 934
   2046	0816  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
   2047	0819  89 07			     mov     word ptr [bx],ax
   2048					;
   2049					;		    nsrttcb = ptcb;
   2050					;
   2051					     ?debug  L 935
   2052	081B  8B 46 F6			     mov     ax,word ptr [bp-10]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 37
.\rtxc.asm



   2053	081E  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
   2054	0821			     @2@3082:
   2055					;
   2056					;		 }
   2057					;
   2058					;		 prh->owner = ptcb; /* mark resource owned */
   2059					;
   2060					     ?debug  L 938
   2061	0821  8B 5E C6			     mov     bx,word ptr [bp-58]
   2062	0824  8B 46 F6			     mov     ax,word ptr [bp-10]
   2063	0827  89 07			     mov     word ptr [bx],ax
   2064					;
   2065					;		 prh->level = 1;
   2066					;
   2067					     ?debug  L 939
   2068	0829  C7 47 02 0001		     mov     word ptr [bx+2],1
   2069					;
   2070					;
   2071					;    #ifdef RESOURCE_TIMEOUTS /* { */
   2072					;		 /* cleanup any	pending	timeout	*/
   2073					;		 if ( (pclkblk = ptcb->pclkblk)	!= NULLCLK)
   2074					;
   2075					     ?debug  L 943
   2076	082E  8B 5E F6			     mov     bx,word ptr [bp-10]
   2077	0831  8B 57 06			     mov     dx,word ptr [bx+6]
   2078	0834  8B 47 04			     mov     ax,word ptr [bx+4]
   2079	0837  89 56 F2			     mov     word ptr [bp-14],dx
   2080	083A  89 46 F0			     mov     word ptr [bp-16],ax
   2081	083D  0B C2			     or	     ax,dx
   2082	083F  75 03			     jne     @@13
   2083	0841  E9 188A			     jmp     @2@15430
   2084	0844			     @@13:
   2085					;
   2086					;		 {
   2087					;		    p2a	= ((FRAME ks_stk *)(ptcb->sp))->pksnum;
   2088					;
   2089					     ?debug  L 945
   2090	0844  C4 5F 0C			     les     bx,dword ptr [bx+12]
   2091	0847  26: 8B 57	0E		     mov     dx,word ptr es:[bx+14]
   2092	084B  26: 8B 47	0C		     mov     ax,word ptr es:[bx+12]
   2093	084F  89 56 E2			     mov     word ptr [bp-30],dx
   2094	0852  89 46 E0			     mov     word ptr [bp-32],ax
   2095					;
   2096					;		    ((struct larg ks_stk *)p2a)->ksrc =	RC_GOOD;
   2097					;
   2098					     ?debug  L 946
   2099	0855			     @2@3138:
   2100	0855  C4 5E E0			     les     bx,dword ptr [bp-32]
   2101	0858  26: C7 47	02 0000		     mov     word ptr es:[bx+2],0
   2102					;
   2103					;
   2104					;		    unlink_timer(pclkblk);
   2105					;
   2106					     ?debug  L 948
   2107	085E  FF 76 F2			     push    word ptr [bp-14]
   2108	0861  FF 76 F0			     push    word ptr [bp-16]
   2109	0864  E8 2548			     call    near ptr unlink_timer
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 38
.\rtxc.asm



   2110	0867  83 C4 04			     add     sp,4
   2111					;
   2112					;		    ptcb->pclkblk = NULLCLK;
   2113					;
   2114					     ?debug  L 949
   2115	086A  8B 5E F6			     mov     bx,word ptr [bp-10]
   2116	086D  C7 47 06 0000		     mov     word ptr [bx+6],0
   2117	0872  C7 47 04 0000		     mov     word ptr [bx+4],0
   2118	0877  E9 1854			     jmp     @2@15430
   2119	087A			     @2@3166:
   2120					;
   2121					;		 }
   2122					;    #endif /* } RESOURCE_TIMEOUTS */
   2123					;	      }
   2124					;	      else
   2125					;    #endif /* } RESOURCE_WAITERS */
   2126					;	      {
   2127					;		 prh->owner = NULLTCB; /* mark resource	not owned */
   2128					;
   2129					     ?debug  L 956
   2130	087A  8B 5E C6			     mov     bx,word ptr [bp-58]
   2131	087D  C7 07 0000		     mov     word ptr [bx],0
   2132					;
   2133					;		 ((struct larg ks_stk *)p2)->ksrc = RC_GOOD;
   2134					;
   2135					     ?debug  L 957
   2136	0881  C4 5E FC			     les     bx,dword ptr [bp-4]
   2137	0884  26: C7 47	02 0000		     mov     word ptr es:[bx+2],0
   2138	088A  E9 1841			     jmp     @2@15430
   2139	088D			     @2@3194:
   2140					;
   2141					;	      }
   2142					;	      break;
   2143					;    #endif /* } HAS_UNLOCK */
   2144					;
   2145					;    #ifdef HAS_INQRES /* { */
   2146					;    /************************/
   2147					;	   case	RTXC_INQRES:
   2148					;    /************************/
   2149					;	      prh = &rheader[((struct larg ks_stk *)p2)->resource];
   2150					;
   2151					     ?debug  L 966
   2152	088D  C4 5E FC			     les     bx,dword ptr [bp-4]
   2153	0890  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   2154	0894  6B C0 0C			     imul    ax,ax,12
   2155	0897  05 0000e			     add     ax,offset DGROUP:_rheader
   2156	089A  89 46 C6			     mov     word ptr [bp-58],ax
   2157					;
   2158					;
   2159					;	      /* return	owner task or 0	if none	(0 set in API since faster) */
   2160					;	      if (prh->owner !=	NULLTCB)
   2161					;
   2162					     ?debug  L 969
   2163	089D  8B 5E C6			     mov     bx,word ptr [bp-58]
   2164	08A0  83 3F 00			     cmp     word ptr [bx],0
   2165	08A3  75 03			     jne     @@14
   2166	08A5  E9 1826			     jmp     @2@15430
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 39
.\rtxc.asm



   2167	08A8			     @@14:
   2168					;
   2169					;		 ((struct larg ks_stk *)p2)->task = prh->owner->task;
   2170					;
   2171					     ?debug  L 970
   2172	08A8  8B 5E FC			     mov     bx,word ptr [bp-4]
   2173	08AB  8B 76 C6			     mov     si,word ptr [bp-58]
   2174	08AE  8B 34			     mov     si,word ptr [si]
   2175	08B0  8B 44 08			     mov     ax,word ptr [si+8]
   2176	08B3  26: 89 47	10		     mov     word ptr es:[bx+16],ax
   2177	08B7  E9 1814			     jmp     @2@15430
   2178	08BA			     @2@3250:
   2179					;
   2180					;	      break;
   2181					;    #endif /* } HAS_INQRES */
   2182					;
   2183					;    #ifdef PRIORITY_INVERSION /* { */
   2184					;    #ifdef HAS_DEFRES /* { */
   2185					;    /************************/
   2186					;	   case	RTXC_DEFRES:
   2187					;    /************************/
   2188					;	      prh = &rheader[((struct larg ks_stk *)p2)->resource];
   2189					;
   2190					     ?debug  L 979
   2191	08BA  C4 5E FC			     les     bx,dword ptr [bp-4]
   2192	08BD  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   2193	08C1  6B C0 0C			     imul    ax,ax,12
   2194	08C4  05 0000e			     add     ax,offset DGROUP:_rheader
   2195	08C7  89 46 C6			     mov     word ptr [bp-58],ax
   2196					;
   2197					;
   2198					;	      /* note: ksrc initialized	to RC_GOOD in API */
   2199					;
   2200					;	      if (prh->owner ==	NULLTCB)
   2201					;
   2202					     ?debug  L 983
   2203	08CA  8B 5E C6			     mov     bx,word ptr [bp-58]
   2204	08CD  83 3F 00			     cmp     word ptr [bx],0
   2205	08D0  74 03			     je	     @@15
   2206	08D2  E9 FE98			     jmp     @2@2718
   2207	08D5			     @@15:
   2208					;
   2209					;		 prh->resattr =	((struct larg ks_stk *)p2)->resattr;
   2210					;
   2211					     ?debug  L 984
   2212	08D5  8B 5E FC			     mov     bx,word ptr [bp-4]
   2213	08D8  26: 8B 47	12		     mov     ax,word ptr es:[bx+18]
   2214	08DC  8B 5E C6			     mov     bx,word ptr [bp-58]
   2215	08DF  89 47 0A			     mov     word ptr [bx+10],ax
   2216	08E2  E9 17E9			     jmp     @2@15430
   2217	08E5			     @2@3306:
   2218					;
   2219					;	      else
   2220					;		 ((struct larg ks_stk *)p2)->ksrc = RC_BUSY;
   2221					;	      break;
   2222					;    #endif /* } HAS_DEFRES */
   2223					;    #endif /* } PRIORITY_INVERSION */
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 40
.\rtxc.asm



   2224					;
   2225					;    #endif /* } HAS_RESOURCES */
   2226					;
   2227					;    #ifdef HAS_BLOCK /* { */
   2228					;    /************************/
   2229					;	   case	RTXC_BLOCK:
   2230					;    /************************/
   2231					;	      /* handle	block world (all tasks)	*/
   2232					;	      if ( (endtask = ((struct blkarg ks_stk *)p2)->endtask) ==	SELFTASK)
   2233					;
   2234					     ?debug  L 998
   2235	08E5  C4 5E FC			     les     bx,dword ptr [bp-4]
   2236	08E8  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   2237	08EC  89 46 DE			     mov     word ptr [bp-34],ax
   2238	08EF  0B C0			     or	     ax,ax
   2239	08F1  75 0A			     jne     short @2@3362
   2240					;
   2241					;		 endtask = hipritsk->task; /* -1 could block null task 0 */
   2242					;
   2243					     ?debug  L 999
   2244	08F3  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   2245	08F7  8B 47 08			     mov     ax,word ptr [bx+8]
   2246	08FA  89 46 DE			     mov     word ptr [bp-34],ax
   2247	08FD			     @2@3362:
   2248					;
   2249					;
   2250					;	      if ( (task = ((struct blkarg ks_stk *)p2)->starttask) == SELFTASK)
   2251					;
   2252					     ?debug  L 1001
   2253	08FD  C4 5E FC			     les     bx,dword ptr [bp-4]
   2254	0900  26: 8B 47	02		     mov     ax,word ptr es:[bx+2]
   2255	0904  89 46 F4			     mov     word ptr [bp-12],ax
   2256	0907  0B C0			     or	     ax,ax
   2257	0909  75 0A			     jne     short @2@3418
   2258					;
   2259					;		 task =	hipritsk->task;	/* +1 could block past last task */
   2260					;
   2261					     ?debug  L 1002
   2262	090B  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   2263	090F  8B 47 08			     mov     ax,word ptr [bx+8]
   2264	0912  89 46 F4			     mov     word ptr [bp-12],ax
   2265	0915			     @2@3418:
   2266					;
   2267					;
   2268					;	      for (ptcb	= &rtxtcb[task]; task <= endtask; task++, ptcb++)
   2269					;
   2270					     ?debug  L 1004
   2271	0915  8B 46 F4			     mov     ax,word ptr [bp-12]
   2272	0918  6B C0 28			     imul    ax,ax,40
   2273	091B  05 0000e			     add     ax,offset DGROUP:_rtxtcb
   2274	091E  89 46 F6			     mov     word ptr [bp-10],ax
   2275	0921  EB 37			     jmp     short @2@3614
   2276	0923			     @2@3446:
   2277					;
   2278					;	      {
   2279					;		 if (hipritsk->task == task) /*	never block self */
   2280					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 41
.\rtxc.asm



   2281					     ?debug  L 1006
   2282	0923  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   2283	0927  8B 47 08			     mov     ax,word ptr [bx+8]
   2284	092A  3B 46 F4			     cmp     ax,word ptr [bp-12]
   2285	092D  75 02			     jne     short @2@3502
   2286					;
   2287					;		    continue;
   2288					;
   2289					     ?debug  L 1007
   2290	092F  EB 22			     jmp     short @2@3586
   2291	0931			     @2@3502:
   2292					;
   2293					;
   2294					;		 if (ptcb->status == READY)
   2295					;
   2296					     ?debug  L 1009
   2297	0931  8B 5E F6			     mov     bx,word ptr [bp-10]
   2298	0934  83 7F 10 00		     cmp     word ptr [bx+16],0
   2299	0938  75 12			     jne     short @2@3558
   2300					;
   2301					;		 {
   2302					;		    ptcb->flink->blink = ptcb->blink; /* general unlink	*/
   2303					;
   2304					     ?debug  L 1011
   2305	093A  8B 47 02			     mov     ax,word ptr [bx+2]
   2306	093D  8B 1F			     mov     bx,word ptr [bx]
   2307	093F  89 47 02			     mov     word ptr [bx+2],ax
   2308					;
   2309					;		    ptcb->blink->flink = ptcb->flink;
   2310					;
   2311					     ?debug  L 1012
   2312	0942  8B 5E F6			     mov     bx,word ptr [bp-10]
   2313	0945  8B 07			     mov     ax,word ptr [bx]
   2314	0947  8B 5F 02			     mov     bx,word ptr [bx+2]
   2315	094A  89 07			     mov     word ptr [bx],ax
   2316	094C			     @2@3558:
   2317					;
   2318					;		 }
   2319					;
   2320					;		 ptcb->status |= BLOCK_WAIT;
   2321					;
   2322					     ?debug  L 1015
   2323	094C  8B 5E F6			     mov     bx,word ptr [bp-10]
   2324	094F  83 4F 10 10		     or	     word ptr [bx+16],16
   2325	0953			     @2@3586:
   2326					     ?debug  L 1004
   2327	0953  FF 46 F4			     inc     word ptr [bp-12]
   2328	0956  83 46 F6 28		     add     word ptr [bp-10],40
   2329	095A			     @2@3614:
   2330	095A  8B 46 F4			     mov     ax,word ptr [bp-12]
   2331	095D  3B 46 DE			     cmp     ax,word ptr [bp-34]
   2332	0960  7E C1			     jle     short @2@3446
   2333					;
   2334					;	      }
   2335					;	      break;
   2336					;
   2337					     ?debug  L 1017
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 42
.\rtxc.asm



   2338	0962  E9 1769			     jmp     @2@15430
   2339	0965			     @2@3670:
   2340					;
   2341					;    #endif /* } HAS_BLOCK */
   2342					;
   2343					;    #ifdef HAS_UNBLOCK	/* { */
   2344					;    /************************/
   2345					;	   case	RTXC_UNBLOCK:
   2346					;    /************************/
   2347					;	      if ( (endtask = ((struct blkarg ks_stk *)p2)->endtask) ==	SELFTASK)
   2348					;
   2349					     ?debug  L 1024
   2350	0965  C4 5E FC			     les     bx,dword ptr [bp-4]
   2351	0968  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   2352	096C  89 46 DE			     mov     word ptr [bp-34],ax
   2353	096F  0B C0			     or	     ax,ax
   2354	0971  75 0A			     jne     short @2@3726
   2355					;
   2356					;		 endtask = hipritsk->task; /* -1 could unblock null task */
   2357					;
   2358					     ?debug  L 1025
   2359	0973  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   2360	0977  8B 47 08			     mov     ax,word ptr [bx+8]
   2361	097A  89 46 DE			     mov     word ptr [bp-34],ax
   2362	097D			     @2@3726:
   2363					;
   2364					;
   2365					;	      if ( (task = ((struct blkarg ks_stk *)p2)->starttask) == SELFTASK)
   2366					;
   2367					     ?debug  L 1027
   2368	097D  C4 5E FC			     les     bx,dword ptr [bp-4]
   2369	0980  26: 8B 47	02		     mov     ax,word ptr es:[bx+2]
   2370	0984  89 46 F4			     mov     word ptr [bp-12],ax
   2371	0987  0B C0			     or	     ax,ax
   2372	0989  75 0A			     jne     short @2@3782
   2373					;
   2374					;		 task =	hipritsk->task;	/* +1 could unblock past last task */
   2375					;
   2376					     ?debug  L 1028
   2377	098B  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   2378	098F  8B 47 08			     mov     ax,word ptr [bx+8]
   2379	0992  89 46 F4			     mov     word ptr [bp-12],ax
   2380	0995			     @2@3782:
   2381					;
   2382					;
   2383					;	      for (ptcb	= &rtxtcb[task]; task <= endtask; task++, ptcb++)
   2384					;
   2385					     ?debug  L 1030
   2386	0995  8B 46 F4			     mov     ax,word ptr [bp-12]
   2387	0998  6B C0 28			     imul    ax,ax,40
   2388	099B  05 0000e			     add     ax,offset DGROUP:_rtxtcb
   2389	099E  89 46 F6			     mov     word ptr [bp-10],ax
   2390	09A1  EB 2B			     jmp     short @2@3950
   2391	09A3			     @2@3810:
   2392					;
   2393					;	      {
   2394					;		 if (ptcb->status == READY)
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 43
.\rtxc.asm



   2395					;
   2396					     ?debug  L 1032
   2397	09A3  8B 5E F6			     mov     bx,word ptr [bp-10]
   2398	09A6  83 7F 10 00		     cmp     word ptr [bx+16],0
   2399	09AA  75 02			     jne     short @2@3866
   2400					;
   2401					;		    continue;
   2402					;
   2403					     ?debug  L 1033
   2404	09AC  EB 19			     jmp     short @2@3922
   2405	09AE			     @2@3866:
   2406					;
   2407					;
   2408					;		 if ( (ptcb->status &= ~BLOCK_WAIT) == READY)
   2409					;
   2410					     ?debug  L 1035
   2411	09AE  8B 5E F6			     mov     bx,word ptr [bp-10]
   2412	09B1  83 67 10 EF		     and     word ptr [bx+16],-17
   2413	09B5  8B 47 10			     mov     ax,word ptr [bx+16]
   2414	09B8  0B C0			     or	     ax,ax
   2415	09BA  75 0B			     jne     short @2@3922
   2416					;
   2417					;		 {
   2418					;		    ptcb->flink	= nsrttcb;
   2419					;
   2420					     ?debug  L 1037
   2421	09BC  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
   2422	09BF  89 07			     mov     word ptr [bx],ax
   2423					;
   2424					;		    nsrttcb = ptcb;
   2425					;
   2426					     ?debug  L 1038
   2427	09C1  8B 46 F6			     mov     ax,word ptr [bp-10]
   2428	09C4  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
   2429	09C7			     @2@3922:
   2430					     ?debug  L 1030
   2431	09C7  FF 46 F4			     inc     word ptr [bp-12]
   2432	09CA  83 46 F6 28		     add     word ptr [bp-10],40
   2433	09CE			     @2@3950:
   2434	09CE  8B 46 F4			     mov     ax,word ptr [bp-12]
   2435	09D1  3B 46 DE			     cmp     ax,word ptr [bp-34]
   2436	09D4  7E CD			     jle     short @2@3810
   2437					;
   2438					;		 }
   2439					;	      }
   2440					;	      break;
   2441					;
   2442					     ?debug  L 1041
   2443	09D6  E9 16F5			     jmp     @2@15430
   2444	09D9			     @2@4006:
   2445					;
   2446					;    #endif /* } HAS_UNBLOCK */
   2447					;
   2448					;    #ifdef HAS_ALLOC_TIMER /* { */
   2449					;    /************************/
   2450					;	   case	RTXC_ALLOC_TIMER:
   2451					;    /************************/
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 44
.\rtxc.asm



   2452					;	      ((struct clkarg ks_stk *)p2)->pclkblk = get_clkblk();
   2453					;
   2454					     ?debug  L 1048
   2455	09D9  E8 223B			     call    near ptr get_clkblk
   2456	09DC  C4 5E FC			     les     bx,dword ptr [bp-4]
   2457	09DF  26: 89 57	10		     mov     word ptr es:[bx+16],dx
   2458	09E3  26: 89 47	0E		     mov     word ptr es:[bx+14],ax
   2459					;
   2460					;	      break;
   2461					;
   2462					     ?debug  L 1049
   2463	09E7  E9 16E4			     jmp     @2@15430
   2464	09EA			     @2@4034:
   2465					;
   2466					;    #endif /* } HAS_ALLOC_TIMER */
   2467					;
   2468					;    #ifdef HAS_FREE_TIMER /* {	*/
   2469					;    /************************/
   2470					;	   case	RTXC_FREE_TIMER:
   2471					;    /************************/
   2472					;	      pclkblk =	((struct clkarg	ks_stk *)p2)->pclkblk;
   2473					;
   2474					     ?debug  L 1056
   2475	09EA  C4 5E FC			     les     bx,dword ptr [bp-4]
   2476	09ED  26: 8B 57	10		     mov     dx,word ptr es:[bx+16]
   2477	09F1  26: 8B 47	0E		     mov     ax,word ptr es:[bx+14]
   2478	09F5  89 56 F2			     mov     word ptr [bp-14],dx
   2479	09F8  89 46 F0			     mov     word ptr [bp-16],ax
   2480					;
   2481					;
   2482					;	      if (pclkblk->state == TIMER_ACTIVE)
   2483					;
   2484					     ?debug  L 1058
   2485	09FB  C4 5E F0			     les     bx,dword ptr [bp-16]
   2486	09FE  26: 80 7F	12 01		     cmp     byte ptr es:[bx+18],1
   2487	0A03  75 08			     jne     short @2@4090
   2488					;
   2489					;	      {
   2490					;		 unlink_timer(pclkblk);
   2491					;
   2492					     ?debug  L 1060
   2493	0A05  52			     push    dx
   2494	0A06  50			     push    ax
   2495	0A07  E8 23A5			     call    near ptr unlink_timer
   2496	0A0A  83 C4 04			     add     sp,4
   2497	0A0D			     @2@4090:
   2498					;
   2499					;	      }
   2500					;
   2501					;	      pclkblk->flink = clkqfl; /* insert block at front	of free	list */
   2502					;
   2503					     ?debug  L 1063
   2504	0A0D  C4 5E F0			     les     bx,dword ptr [bp-16]
   2505	0A10  8B 16 0016r		     mov     dx,word ptr DGROUP:_clkqfl+2
   2506	0A14  A1 0014r			     mov     ax,word ptr DGROUP:_clkqfl
   2507	0A17  26: 89 57	02		     mov     word ptr es:[bx+2],dx
   2508	0A1B  26: 89 07			     mov     word ptr es:[bx],ax
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 45
.\rtxc.asm



   2509					;
   2510					;	      clkqfl = pclkblk;
   2511					;
   2512					     ?debug  L 1064
   2513	0A1E  8B 56 F2			     mov     dx,word ptr [bp-14]
   2514	0A21  8B 46 F0			     mov     ax,word ptr [bp-16]
   2515	0A24  89 16 0016r		     mov     word ptr DGROUP:_clkqfl+2,dx
   2516	0A28  A3 0014r			     mov     word ptr DGROUP:_clkqfl,ax
   2517					;
   2518					;	      break;
   2519					;
   2520					     ?debug  L 1065
   2521	0A2B  E9 16A0			     jmp     @2@15430
   2522	0A2E			     @2@4118:
   2523					;
   2524					;    #endif /* } HAS_FREE_TIMER	*/
   2525					;
   2526					;    #ifdef HAS_STOP_TIMER /* {	*/
   2527					;    /************************/
   2528					;	   case	RTXC_STOP_TIMER:
   2529					;    /************************/
   2530					;	      /* fall through to common	code */
   2531					;    #endif /* } HAS_STOP_TIMER	*/
   2532					;    #ifdef HAS_RESTART_TIMER /* { */
   2533					;    /************************/
   2534					;	   case	RTXC_RESTART_TIMER:
   2535					;    /************************/
   2536					;	      /* fall through to common	code */
   2537					;    #endif /* } HAS_RESTART_TIMER */
   2538					;    #ifdef HAS_START_TIMER /* { */
   2539					;    /************************/
   2540					;	   case	RTXC_START_TIMER:
   2541					;    /************************/
   2542					;
   2543					;	      if ( (pclkblk = ((struct clkarg ks_stk *)p2)->pclkblk) ==	NULLCLK)
   2544					;
   2545					     ?debug  L 1085
   2546	0A2E  C4 5E FC			     les     bx,dword ptr [bp-4]
   2547	0A31  26: 8B 57	10		     mov     dx,word ptr es:[bx+16]
   2548	0A35  26: 8B 47	0E		     mov     ax,word ptr es:[bx+14]
   2549	0A39  89 56 F2			     mov     word ptr [bp-14],dx
   2550	0A3C  89 46 F0			     mov     word ptr [bp-16],ax
   2551	0A3F  0B C2			     or	     ax,dx
   2552	0A41  75 2B			     jne     short @2@4286
   2553					;
   2554					;	      {
   2555					;		 if (*p2 != RTXC_START_TIMER)
   2556					;
   2557					     ?debug  L 1087
   2558	0A43  26: 83 3F	12		     cmp     word ptr es:[bx],18
   2559	0A47  74 02			     je	     short @2@4202
   2560	0A49  EB 3C			     jmp     short @2@4342
   2561	0A4B			     @2@4202:
   2562					;
   2563					;		 {
   2564					;    #ifdef HAS_RESTART_TIMER /* { */
   2565					;		    /* no clkblk sent for RTXC_STOP_TIMER or RTXC_RESTART_TIMER	*/
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 46
.\rtxc.asm



   2566					;    #else /* }	HAS_RESTART_TIMER { */
   2567					;		    /* no clkblk sent for RTXC_STOP_TIMER */
   2568					;    #endif /* } HAS_RESTART_TIMER */
   2569					;		    ((struct clkarg ks_stk *)p2)->ksrc = RC_TIMER_ILLEGAL;
   2570					;		    break;
   2571					;		 }
   2572					;		 else /* is RTXC_START_TIMER */
   2573					;		 {
   2574					;		    if ( (pclkblk = get_clkblk()) == NULLCLK)
   2575					;
   2576					     ?debug  L 1099
   2577	0A4B  E8 21C9			     call    near ptr get_clkblk
   2578	0A4E  89 56 F2			     mov     word ptr [bp-14],dx
   2579	0A51  89 46 F0			     mov     word ptr [bp-16],ax
   2580	0A54  0B C2			     or	     ax,dx
   2581	0A56  75 03			     jne     short @2@4258
   2582					;
   2583					;		       break; /* no timer available, NULLCLK returned */
   2584					;
   2585					     ?debug  L 1100
   2586	0A58  E9 1673			     jmp     @2@15430
   2587	0A5B			     @2@4258:
   2588					;
   2589					;		    else
   2590					;		       ((struct	clkarg ks_stk *)p2)->pclkblk = pclkblk;
   2591					;
   2592					     ?debug  L 1102
   2593	0A5B  C4 5E FC			     les     bx,dword ptr [bp-4]
   2594	0A5E  8B 56 F2			     mov     dx,word ptr [bp-14]
   2595	0A61  8B 46 F0			     mov     ax,word ptr [bp-16]
   2596	0A64  26: 89 57	10		     mov     word ptr es:[bx+16],dx
   2597	0A68  26: 89 47	0E		     mov     word ptr es:[bx+14],ax
   2598	0A6C  EB 25			     jmp     short @2@4370
   2599	0A6E			     @2@4286:
   2600					;
   2601					;		 }
   2602					;	      }
   2603					;	      else /* clkblk was sent */
   2604					;	      {
   2605					;		 if (*p2 != RTXC_START_TIMER)
   2606					;
   2607					     ?debug  L 1107
   2608	0A6E  C4 5E FC			     les     bx,dword ptr [bp-4]
   2609	0A71  26: 83 3F	12		     cmp     word ptr es:[bx],18
   2610	0A75  74 1C			     je	     short @2@4370
   2611					;
   2612					;		 {
   2613					;		    if (pclkblk->task != hipritsk->task)
   2614					;
   2615					     ?debug  L 1109
   2616	0A77  C4 5E F0			     les     bx,dword ptr [bp-16]
   2617	0A7A  26: 8B 47	10		     mov     ax,word ptr es:[bx+16]
   2618	0A7E  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   2619	0A82  3B 47 08			     cmp     ax,word ptr [bx+8]
   2620	0A85  74 0C			     je	     short @2@4370
   2621	0A87			     @2@4342:
   2622					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 47
.\rtxc.asm



   2623					;		    {
   2624					;    #ifdef HAS_RESTART_TIMER /* { */
   2625					;		       /* attempt to STOP or RESTART someone else's timer */
   2626					;    #else /* }	HAS_RESTART_TIMER { */
   2627					;		       /* attempt to STOP someone else's timer */
   2628					;    #endif /* } HAS_RESTART_TIMER */
   2629					;		       ((struct	clkarg ks_stk *)p2)->ksrc = RC_TIMER_ILLEGAL;
   2630					;
   2631					     ?debug  L 1116
   2632	0A87  C4 5E FC			     les     bx,dword ptr [bp-4]
   2633	0A8A  26: C7 47	02 0004		     mov     word ptr es:[bx+2],4
   2634					;
   2635					;		       break;
   2636					;
   2637					     ?debug  L 1117
   2638	0A90  E9 163B			     jmp     @2@15430
   2639	0A93			     @2@4370:
   2640					;
   2641					;		    }
   2642					;		 }
   2643					;	      }
   2644					;
   2645					;	      if (pclkblk->state == TIMER_DONE)
   2646					;
   2647					     ?debug  L 1122
   2648	0A93  C4 5E F0			     les     bx,dword ptr [bp-16]
   2649	0A96  26: 80 7F	12 00		     cmp     byte ptr es:[bx+18],0
   2650	0A9B  75 12			     jne     short @2@4454
   2651					;
   2652					;	      {
   2653					;		 if (*p2 == RTXC_STOP_TIMER)
   2654					;
   2655					     ?debug  L 1124
   2656	0A9D  C4 5E FC			     les     bx,dword ptr [bp-4]
   2657	0AA0  26: 83 3F	13		     cmp     word ptr es:[bx],19
   2658	0AA4  75 21			     jne     short @2@4510
   2659					;
   2660					;		 {
   2661					;		    ((struct clkarg ks_stk *)p2)->ksrc = RC_TIMER_INACTIVE;
   2662					;
   2663					     ?debug  L 1126
   2664	0AA6  26: C7 47	02 0003		     mov     word ptr es:[bx+2],3
   2665					;
   2666					;		    break;
   2667					;
   2668					     ?debug  L 1127
   2669	0AAC  E9 161F			     jmp     @2@15430
   2670	0AAF			     @2@4454:
   2671					;
   2672					;		 }
   2673					;	      }
   2674					;	      else   /*	stop active timer */
   2675					;	      {
   2676					;		 unlink_timer(pclkblk);
   2677					;
   2678					     ?debug  L 1132
   2679	0AAF  FF 76 F2			     push    word ptr [bp-14]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 48
.\rtxc.asm



   2680	0AB2  FF 76 F0			     push    word ptr [bp-16]
   2681	0AB5  E8 22F7			     call    near ptr unlink_timer
   2682	0AB8  83 C4 04			     add     sp,4
   2683					;
   2684					;
   2685					;		 if (*p2 == RTXC_STOP_TIMER)
   2686					;
   2687					     ?debug  L 1134
   2688	0ABB  C4 5E FC			     les     bx,dword ptr [bp-4]
   2689	0ABE  26: 83 3F	13		     cmp     word ptr es:[bx],19
   2690	0AC2  75 03			     jne     short @2@4510
   2691					;
   2692					;		    break;
   2693					;
   2694					     ?debug  L 1135
   2695	0AC4  E9 1607			     jmp     @2@15430
   2696	0AC7			     @2@4510:
   2697					;
   2698					;	      }
   2699					;
   2700					;    #ifdef HAS_RESTART_TIMER /* { */
   2701					;	      /* at this point,	the function is	START_TIMER or RESTART_TIMER */
   2702					;    #else /* }	HAS_RESTART_TIMER { */
   2703					;	      /* at this point,	the function should be START_TIMER */
   2704					;    #endif /* } HAS_RESTART_TIMER */
   2705					;
   2706					;	      if (*p2 == RTXC_START_TIMER)
   2707					;
   2708					     ?debug  L 1144
   2709	0AC7  C4 5E FC			     les     bx,dword ptr [bp-4]
   2710	0ACA  26: 83 3F	12		     cmp     word ptr es:[bx],18
   2711	0ACE  74 03			     je	     @@16
   2712	0AD0  EB 79 90			     jmp     @2@4986
   2713	0AD3			     @@16:
   2714					;
   2715					;	      {
   2716					;		 /* if special case of zero initial and	recycle	times ... */
   2717					;		 /* signal semaphore and leave */
   2718					;		 if ( ((struct clkarg ks_stk *)p2)->ticks == (TICKS)0 &&
   2719					;
   2720					     ?debug  L 1148
   2721					;
   2722					;		      ((struct clkarg ks_stk *)p2)->period == (TICKS)0 )
   2723					;
   2724					     ?debug  L 1149
   2725	0AD3  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
   2726	0AD7  26: 0B 47	08		     or	     ax,word ptr es:[bx+8]
   2727	0ADB  75 30			     jne     short @2@4762
   2728	0ADD  26: 8B 47	0A		     mov     ax,word ptr es:[bx+10]
   2729	0AE1  26: 0B 47	0C		     or	     ax,word ptr es:[bx+12]
   2730	0AE5  75 26			     jne     short @2@4762
   2731					;
   2732					;		 {
   2733					;		    pclkblk->task = hipritsk->task;
   2734					;
   2735					     ?debug  L 1151
   2736	0AE7  C4 5E F0			     les     bx,dword ptr [bp-16]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 49
.\rtxc.asm



   2737	0AEA  8B 36 0000r		     mov     si,word ptr DGROUP:_hipritsk
   2738	0AEE  8B 44 08			     mov     ax,word ptr [si+8]
   2739	0AF1  26: 89 47	10		     mov     word ptr es:[bx+16],ax
   2740					;
   2741					;		    SIGNAL(((struct clkarg ks_stk *)p2)->sema);
   2742					;
   2743					     ?debug  L 1152
   2744	0AF5  FA			     cli
   2745	0AF6  90			     nop
   2746	0AF7  C4 5E FC			     les     bx,dword ptr [bp-4]
   2747	0AFA  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   2748	0AFE  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
   2749	0B02  89 07			     mov     word ptr [bx],ax
   2750	0B04  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
   2751	0B09  FB			     sti
   2752					;
   2753					;		    break;
   2754					;
   2755					     ?debug  L 1153
   2756	0B0A  E9 15C1			     jmp     @2@15430
   2757	0B0D			     @2@4762:
   2758					;
   2759					;		 }
   2760					;
   2761					;		 /* if zero initial time and non-zero recycle time ... */
   2762					;		 /* start timer	with recycle time & signal semaphore */
   2763					;		 if ( ((struct clkarg ks_stk *)p2)->ticks == (TICKS)0 &&
   2764					;
   2765					     ?debug  L 1158
   2766					;
   2767					;		      ((struct clkarg ks_stk *)p2)->period != (TICKS)0 )
   2768					;
   2769					     ?debug  L 1159
   2770	0B0D  C4 5E FC			     les     bx,dword ptr [bp-4]
   2771	0B10  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
   2772	0B14  26: 0B 47	08		     or	     ax,word ptr es:[bx+8]
   2773	0B18  75 3F			     jne     short @2@5014
   2774	0B1A  26: 8B 47	0A		     mov     ax,word ptr es:[bx+10]
   2775	0B1E  26: 0B 47	0C		     or	     ax,word ptr es:[bx+12]
   2776	0B22  74 35			     je	     short @2@5014
   2777					;
   2778					;		 {
   2779					;		    ((struct clkarg ks_stk *)p2)->ticks	=
   2780					;
   2781					     ?debug  L 1161
   2782					;
   2783					;				((struct clkarg	ks_stk *)p2)->period;
   2784					;
   2785					     ?debug  L 1162
   2786	0B24  26: 8B 57	0C		     mov     dx,word ptr es:[bx+12]
   2787	0B28  26: 8B 47	0A		     mov     ax,word ptr es:[bx+10]
   2788	0B2C  26: 89 57	08		     mov     word ptr es:[bx+8],dx
   2789	0B30  26: 89 47	06		     mov     word ptr es:[bx+6],ax
   2790					;
   2791					;		       SIGNAL(((struct clkarg ks_stk *)p2)->sema);
   2792					;
   2793					     ?debug  L 1163
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 50
.\rtxc.asm



   2794	0B34  FA			     cli
   2795	0B35  90			     nop
   2796	0B36  C4 5E FC			     les     bx,dword ptr [bp-4]
   2797	0B39  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   2798	0B3D  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
   2799	0B41  89 07			     mov     word ptr [bx],ax
   2800	0B43  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
   2801	0B48  FB			     sti
   2802					;
   2803					;		 }
   2804					;	      }
   2805					;
   2806					     ?debug  L 1165
   2807	0B49  EB 0E			     jmp     short @2@5014
   2808	0B4B			     @2@4986:
   2809					;
   2810					;    #ifdef HAS_RESTART_TIMER /* { */
   2811					;	      else  /* is RTXC_RESTART_TIMER */
   2812					;	      {
   2813					;		 /* get	sema from clkblk & put in arg struct */
   2814					;		 ((struct clkarg ks_stk	*)p2)->sema = pclkblk->objid;
   2815					;
   2816					     ?debug  L 1170
   2817	0B4B  C4 5E F0			     les     bx,dword ptr [bp-16]
   2818	0B4E  26: 8B 47	16		     mov     ax,word ptr es:[bx+22]
   2819	0B52  C4 5E FC			     les     bx,dword ptr [bp-4]
   2820	0B55  26: 89 47	04		     mov     word ptr es:[bx+4],ax
   2821	0B59			     @2@5014:
   2822					;
   2823					;	      }
   2824					;    #endif /* } HAS_RESTART_TIMER */
   2825					;
   2826					;	      pclkblk->remain =	((struct clkarg	ks_stk *)p2)->ticks;
   2827					;
   2828					     ?debug  L 1174
   2829	0B59  C4 5E FC			     les     bx,dword ptr [bp-4]
   2830	0B5C  26: 8B 57	08		     mov     dx,word ptr es:[bx+8]
   2831	0B60  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
   2832	0B64  C4 5E F0			     les     bx,dword ptr [bp-16]
   2833	0B67  26: 89 57	0A		     mov     word ptr es:[bx+10],dx
   2834	0B6B  26: 89 47	08		     mov     word ptr es:[bx+8],ax
   2835					;
   2836					;	      pclkblk->recycle = ((struct clkarg ks_stk	*)p2)->period;
   2837					;
   2838					     ?debug  L 1175
   2839	0B6F  C4 5E FC			     les     bx,dword ptr [bp-4]
   2840	0B72  26: 8B 57	0C		     mov     dx,word ptr es:[bx+12]
   2841	0B76  26: 8B 47	0A		     mov     ax,word ptr es:[bx+10]
   2842	0B7A  C4 5E F0			     les     bx,dword ptr [bp-16]
   2843	0B7D  26: 89 57	0E		     mov     word ptr es:[bx+14],dx
   2844	0B81  26: 89 47	0C		     mov     word ptr es:[bx+12],ax
   2845					;
   2846					;
   2847					;	      /* mark object type */
   2848					;	      pclkblk->objtype = TIMER_OBJ;
   2849					;
   2850					     ?debug  L 1178
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 51
.\rtxc.asm



   2851	0B85  26: C7 47	14 0006		     mov     word ptr es:[bx+20],6
   2852					;
   2853					;	      pclkblk->task = hipritsk->task;
   2854					;
   2855					     ?debug  L 1179
   2856	0B8B  8B 36 0000r		     mov     si,word ptr DGROUP:_hipritsk
   2857	0B8F  8B 44 08			     mov     ax,word ptr [si+8]
   2858	0B92  26: 89 47	10		     mov     word ptr es:[bx+16],ax
   2859					;
   2860					;
   2861					;	      /* force Sema pending in case it was already DONE	*/
   2862					;	      if ( (semat[pclkblk->objid = ((struct clkarg ks_stk *)p2)->sema]
   2863					;
   2864					     ?debug  L 1182
   2865					;
   2866					;				 == SEMA_DONE)
   2867					;				      &&
   2868					;		   ( ((struct clkarg ks_stk *)p2)->period == (TICKS)0) )
   2869					;
   2870					     ?debug  L 1185
   2871	0B96  C4 5E FC			     les     bx,dword ptr [bp-4]
   2872	0B99  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   2873	0B9D  C4 5E F0			     les     bx,dword ptr [bp-16]
   2874	0BA0  26: 89 47	16		     mov     word ptr es:[bx+22],ax
   2875	0BA4  8B D8			     mov     bx,ax
   2876	0BA6  03 DB			     add     bx,bx
   2877	0BA8  83 BF 0000e 00		     cmp     word ptr DGROUP:_semat[bx],0
   2878	0BAD  74 03			     je	     @@17
   2879	0BAF  E9 0954			     jmp     @2@9270
   2880	0BB2			     @@17:
   2881	0BB2  C4 5E FC			     les     bx,dword ptr [bp-4]
   2882	0BB5  26: 8B 47	0A		     mov     ax,word ptr es:[bx+10]
   2883	0BB9  26: 0B 47	0C		     or	     ax,word ptr es:[bx+12]
   2884	0BBD  74 03			     je	     @@18
   2885	0BBF  E9 0944			     jmp     @2@9270
   2886	0BC2			     @@18:
   2887					;
   2888					;		 semat[pclkblk->objid] = SEMA_PENDING;
   2889					;
   2890					     ?debug  L 1186
   2891	0BC2  C4 5E F0			     les     bx,dword ptr [bp-16]
   2892	0BC5  26: 8B 5F	16		     mov     bx,word ptr es:[bx+22]
   2893	0BC9  03 DB			     add     bx,bx
   2894	0BCB  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
   2895	0BD1  E9 0932			     jmp     @2@9270
   2896	0BD4			     @2@5098:
   2897					;
   2898					;
   2899					;	      /* insert	timer */
   2900					;	      insert_timer(pclkblk);
   2901					;
   2902					;	      break;
   2903					;    #endif /* } HAS_START_TIMER */
   2904					;
   2905					;    #ifdef HAS_DELAY /* { */
   2906					;    /************************/
   2907					;	   case	RTXC_DELAY:
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 52
.\rtxc.asm



   2908					;    /************************/
   2909					;	      if ( (task = ((struct delayarg ks_stk *)p2)->task) == SELFTASK  ||
   2910					;
   2911					     ?debug  L 1198
   2912					;
   2913					;		     task == hipritsk->task)  /* delaying self */
   2914					;
   2915					     ?debug  L 1199
   2916	0BD4  C4 5E FC			     les     bx,dword ptr [bp-4]
   2917	0BD7  26: 8B 47	02		     mov     ax,word ptr es:[bx+2]
   2918	0BDB  89 46 F4			     mov     word ptr [bp-12],ax
   2919	0BDE  0B C0			     or	     ax,ax
   2920	0BE0  74 0C			     je	     short @2@5154
   2921	0BE2  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   2922	0BE6  8B 47 08			     mov     ax,word ptr [bx+8]
   2923	0BE9  3B 46 F4			     cmp     ax,word ptr [bp-12]
   2924	0BEC  75 2D			     jne     short @2@5238
   2925	0BEE			     @2@5154:
   2926					;
   2927					;	      {
   2928					;		 if ( ((struct delayarg	ks_stk *)p2)->ticks == 0)
   2929					;
   2930					     ?debug  L 1201
   2931	0BEE  C4 5E FC			     les     bx,dword ptr [bp-4]
   2932	0BF1  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   2933	0BF5  26: 0B 47	06		     or	     ax,word ptr es:[bx+6]
   2934	0BF9  75 03			     jne     short @2@5210
   2935					;
   2936					;		    break;   /*	zero time for self = NOP */
   2937					;
   2938					     ?debug  L 1202
   2939	0BFB  E9 14D0			     jmp     @2@15430
   2940	0BFE			     @2@5210:
   2941					;
   2942					;		 ptcb =	hipritsk;
   2943					;
   2944					     ?debug  L 1203
   2945	0BFE  A1 0000r			     mov     ax,word ptr DGROUP:_hipritsk
   2946	0C01  89 46 F6			     mov     word ptr [bp-10],ax
   2947					;
   2948					;		 task =	ptcb->task;
   2949					;
   2950					     ?debug  L 1204
   2951	0C04  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   2952	0C08  8B 47 08			     mov     ax,word ptr [bx+8]
   2953	0C0B  89 46 F4			     mov     word ptr [bp-12],ax
   2954					;
   2955					;		 pclkblk = ((struct delayarg ks_stk *)p2)->pclkblk;
   2956					;
   2957					     ?debug  L 1205
   2958	0C0E  C4 5E FC			     les     bx,dword ptr [bp-4]
   2959	0C11  26: 8B 57	0A		     mov     dx,word ptr es:[bx+10]
   2960	0C15  26: 8B 47	08		     mov     ax,word ptr es:[bx+8]
   2961	0C19  EB 61			     jmp     short @2@5378
   2962	0C1B			     @2@5238:
   2963					;
   2964					;	      }
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 53
.\rtxc.asm



   2965					;	      else  /* current task is delaying	another	task */
   2966					;	      {
   2967					;		 ptcb =	&rtxtcb[task];
   2968					;
   2969					     ?debug  L 1209
   2970	0C1B  8B 46 F4			     mov     ax,word ptr [bp-12]
   2971	0C1E  6B C0 28			     imul    ax,ax,40
   2972	0C21  05 0000e			     add     ax,offset DGROUP:_rtxtcb
   2973	0C24  89 46 F6			     mov     word ptr [bp-10],ax
   2974					;
   2975					;
   2976					;		 if (ptcb->status & DELAY_WAIT)
   2977					;
   2978					     ?debug  L 1211
   2979	0C27  8B 5E F6			     mov     bx,word ptr [bp-10]
   2980	0C2A  F6 47 10 04		     test    byte ptr [bx+16],4
   2981	0C2E  74 40			     je	     short @2@5350
   2982					;
   2983					;		 {
   2984					;		    /* if task is already delayed ... */
   2985					;		    /* get current clkblk and unlink from active timers	*/
   2986					;		    pclkblk = ptcb->pclkblk;
   2987					;
   2988					     ?debug  L 1215
   2989	0C30  8B 57 06			     mov     dx,word ptr [bx+6]
   2990	0C33  8B 47 04			     mov     ax,word ptr [bx+4]
   2991	0C36  89 56 F2			     mov     word ptr [bp-14],dx
   2992	0C39  89 46 F0			     mov     word ptr [bp-16],ax
   2993					;
   2994					;		    unlink_timer(pclkblk);
   2995					;
   2996					     ?debug  L 1216
   2997	0C3C  52			     push    dx
   2998	0C3D  50			     push    ax
   2999	0C3E  E8 216E			     call    near ptr unlink_timer
   3000	0C41  83 C4 04			     add     sp,4
   3001					;
   3002					;
   3003					;		    if ( ((struct delayarg ks_stk *)p2)->ticks == 0)
   3004					;
   3005					     ?debug  L 1218
   3006	0C44  C4 5E FC			     les     bx,dword ptr [bp-4]
   3007	0C47  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   3008	0C4B  26: 0B 47	06		     or	     ax,word ptr es:[bx+6]
   3009	0C4F  75 31			     jne     short @2@5406
   3010					;
   3011					;		    {
   3012					;		       /* if 0 delay, clear DELAY_WAIT flag ...	*/
   3013					;		       if ( (ptcb->status &= ~DELAY_WAIT) == READY)
   3014					;
   3015					     ?debug  L 1221
   3016	0C51  8B 5E F6			     mov     bx,word ptr [bp-10]
   3017	0C54  83 67 10 FB		     and     word ptr [bx+16],-5
   3018	0C58  8B 47 10			     mov     ax,word ptr [bx+16]
   3019	0C5B  0B C0			     or	     ax,ax
   3020	0C5D  74 03			     je	     @@19
   3021	0C5F  E9 146C			     jmp     @2@15430
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 54
.\rtxc.asm



   3022	0C62			     @@19:
   3023					;
   3024					;		       {
   3025					;			  /* ... if task is now	READY, put in ready list */
   3026					;			  ptcb->flink =	nsrttcb;
   3027					;
   3028					     ?debug  L 1224
   3029	0C62  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
   3030	0C65  89 07			     mov     word ptr [bx],ax
   3031					;
   3032					;			  nsrttcb = ptcb;
   3033					;
   3034					     ?debug  L 1225
   3035	0C67  8B 46 F6			     mov     ax,word ptr [bp-10]
   3036	0C6A  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
   3037	0C6D  E9 145E			     jmp     @2@15430
   3038	0C70			     @2@5350:
   3039					;
   3040					;		       }
   3041					;
   3042					;		       break;
   3043					;		    }
   3044					;		 }
   3045					;		 else  /* task was not already delayed */
   3046					;		    /* allocate	space on task's	personal stack for clkblk */
   3047					;		    pclkblk = (CLKBLK ks_clk *)(ptcb->sp) - 1;
   3048					;
   3049					     ?debug  L 1233
   3050	0C70  8B 5E F6			     mov     bx,word ptr [bp-10]
   3051	0C73  8B 57 0E			     mov     dx,word ptr [bx+14]
   3052	0C76  8B 47 0C			     mov     ax,word ptr [bx+12]
   3053	0C79  05 FFE8			     add     ax,-24
   3054	0C7C			     @2@5378:
   3055	0C7C  89 56 F2			     mov     word ptr [bp-14],dx
   3056	0C7F  89 46 F0			     mov     word ptr [bp-16],ax
   3057	0C82			     @2@5406:
   3058					;
   3059					;	      }
   3060					;
   3061					;	      ptcb->pclkblk = pclkblk; /* put pointer to clkblk	in tcb */
   3062					;
   3063					     ?debug  L 1236
   3064	0C82  8B 5E F6			     mov     bx,word ptr [bp-10]
   3065	0C85  8B 56 F2			     mov     dx,word ptr [bp-14]
   3066	0C88  8B 46 F0			     mov     ax,word ptr [bp-16]
   3067	0C8B  89 57 06			     mov     word ptr [bx+6],dx
   3068	0C8E  89 47 04			     mov     word ptr [bx+4],ax
   3069					;
   3070					;
   3071					;	      if (ptcb->status == READY)
   3072					;
   3073					     ?debug  L 1238
   3074	0C91  83 7F 10 00		     cmp     word ptr [bx+16],0
   3075	0C95  75 12			     jne     short @2@5462
   3076					;
   3077					;	      {
   3078					;		    /* general unlink from tcb READY list */
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 55
.\rtxc.asm



   3079					;		 ptcb->flink->blink = ptcb->blink;
   3080					;
   3081					     ?debug  L 1241
   3082	0C97  8B 47 02			     mov     ax,word ptr [bx+2]
   3083	0C9A  8B 1F			     mov     bx,word ptr [bx]
   3084	0C9C  89 47 02			     mov     word ptr [bx+2],ax
   3085					;
   3086					;		 ptcb->blink->flink = ptcb->flink;
   3087					;
   3088					     ?debug  L 1242
   3089	0C9F  8B 5E F6			     mov     bx,word ptr [bp-10]
   3090	0CA2  8B 07			     mov     ax,word ptr [bx]
   3091	0CA4  8B 5F 02			     mov     bx,word ptr [bx+2]
   3092	0CA7  89 07			     mov     word ptr [bx],ax
   3093	0CA9			     @2@5462:
   3094					;
   3095					;	      }
   3096					;
   3097					;	      ptcb->status |= DELAY_WAIT;
   3098					;
   3099					     ?debug  L 1245
   3100	0CA9  8B 5E F6			     mov     bx,word ptr [bp-10]
   3101	0CAC  83 4F 10 04		     or	     word ptr [bx+16],4
   3102					;
   3103					;
   3104					;	      pclkblk->remain =	((struct delayarg ks_stk *)p2)->ticks;
   3105					;
   3106					     ?debug  L 1247
   3107	0CB0  C4 5E FC			     les     bx,dword ptr [bp-4]
   3108	0CB3  26: 8B 57	06		     mov     dx,word ptr es:[bx+6]
   3109	0CB7  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   3110	0CBB  C4 5E F0			     les     bx,dword ptr [bp-16]
   3111	0CBE  26: 89 57	0A		     mov     word ptr es:[bx+10],dx
   3112	0CC2  26: 89 47	08		     mov     word ptr es:[bx+8],ax
   3113					;
   3114					;	      pclkblk->recycle = (TICKS)0;
   3115					;
   3116					     ?debug  L 1248
   3117	0CC6  26: C7 47	0E 0000		     mov     word ptr es:[bx+14],0
   3118	0CCC  26: C7 47	0C 0000		     mov     word ptr es:[bx+12],0
   3119					;
   3120					;
   3121					;	      /* mark object type */
   3122					;	      pclkblk->objtype = DELAY_OBJ;
   3123					;
   3124					     ?debug  L 1251
   3125	0CD2  26: C7 47	14 0000		     mov     word ptr es:[bx+20],0
   3126					;
   3127					;	      pclkblk->objid = task;
   3128					;
   3129					     ?debug  L 1252
   3130	0CD8  8B 46 F4			     mov     ax,word ptr [bp-12]
   3131	0CDB  26: 89 47	16		     mov     word ptr es:[bx+22],ax
   3132					;
   3133					;	      pclkblk->task = task;
   3134					;
   3135					     ?debug  L 1253
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 56
.\rtxc.asm



   3136	0CDF  E9 0820			     jmp     @2@9242
   3137	0CE2			     @2@5490:
   3138					;
   3139					;
   3140					;	      /* insert	timer */
   3141					;	      insert_timer(pclkblk);
   3142					;	      break;
   3143					;    #endif /* } HAS_DELAY */
   3144					;
   3145					;    #ifdef HAS_ELAPSE /* { */
   3146					;    /************************/
   3147					;	   case	RTXC_ELAPSE:
   3148					;    /************************/
   3149					;	      DISABLE; /* snapshot rtctick */
   3150					;
   3151					     ?debug  L 1264
   3152	0CE2  FA			     cli
   3153	0CE3  90			     nop
   3154					;
   3155					;	      tcnt = rtctick;
   3156					;
   3157					     ?debug  L 1265
   3158	0CE4  8B 16 000Er		     mov     dx,word ptr DGROUP:_rtctick+2
   3159	0CE8  A1 000Cr			     mov     ax,word ptr DGROUP:_rtctick
   3160	0CEB  89 56 EE			     mov     word ptr [bp-18],dx
   3161	0CEE  89 46 EC			     mov     word ptr [bp-20],ax
   3162					;
   3163					;	      ENABLE;
   3164					;
   3165					     ?debug  L 1266
   3166	0CF1  FB			     sti
   3167					;
   3168					;	      ((struct etarg ks_stk *)p2)->val = tcnt -
   3169					;
   3170					     ?debug  L 1267
   3171					;
   3172					;				     *(((struct	etarg ks_stk *)p2)->stamp);
   3173					;
   3174					     ?debug  L 1268
   3175	0CF2  C4 5E FC			     les     bx,dword ptr [bp-4]
   3176	0CF5  26: C4 5F	02		     les     bx,dword ptr es:[bx+2]
   3177	0CF9  8B 56 EE			     mov     dx,word ptr [bp-18]
   3178	0CFC  8B 46 EC			     mov     ax,word ptr [bp-20]
   3179	0CFF  26: 2B 07			     sub     ax,word ptr es:[bx]
   3180	0D02  26: 1B 57	02		     sbb     dx,word ptr es:[bx+2]
   3181	0D06  C4 5E FC			     les     bx,dword ptr [bp-4]
   3182	0D09  26: 89 57	08		     mov     word ptr es:[bx+8],dx
   3183	0D0D  26: 89 47	06		     mov     word ptr es:[bx+6],ax
   3184					;
   3185					;	      *(((struct etarg ks_stk *)p2)->stamp) = tcnt;
   3186					;
   3187					     ?debug  L 1269
   3188	0D11  26: C4 5F	02		     les     bx,dword ptr es:[bx+2]
   3189	0D15  8B 56 EE			     mov     dx,word ptr [bp-18]
   3190	0D18  8B 46 EC			     mov     ax,word ptr [bp-20]
   3191	0D1B  26: 89 57	02		     mov     word ptr es:[bx+2],dx
   3192	0D1F  26: 89 07			     mov     word ptr es:[bx],ax
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 57
.\rtxc.asm



   3193					;
   3194					;	      break;
   3195					;
   3196					     ?debug  L 1270
   3197	0D22  E9 13A9			     jmp     @2@15430
   3198	0D25			     @2@5630:
   3199					;
   3200					;    #endif /* } HAS_ELAPSE */
   3201					;
   3202					;    #ifdef HAS_INQTIMER /* { */
   3203					;    /************************/
   3204					;	   case	RTXC_INQTIMER:
   3205					;    /************************/
   3206					;	      pclkblk =	((struct clkarg	ks_stk *)p2)->pclkblk;
   3207					;
   3208					     ?debug  L 1277
   3209	0D25  C4 5E FC			     les     bx,dword ptr [bp-4]
   3210	0D28  26: 8B 57	10		     mov     dx,word ptr es:[bx+16]
   3211	0D2C  26: 8B 47	0E		     mov     ax,word ptr es:[bx+14]
   3212	0D30  89 56 F2			     mov     word ptr [bp-14],dx
   3213	0D33  89 46 F0			     mov     word ptr [bp-16],ax
   3214					;
   3215					;
   3216					;	      if (pclkblk->state == TIMER_ACTIVE)
   3217					;
   3218					     ?debug  L 1279
   3219	0D36  C4 5E F0			     les     bx,dword ptr [bp-16]
   3220	0D39  26: 80 7F	12 01		     cmp     byte ptr es:[bx+18],1
   3221	0D3E  75 24			     jne     short @2@5798
   3222					;
   3223					;	      {
   3224					;		 DISABLE; /* prevent changing rtctick while reading */
   3225					;
   3226					     ?debug  L 1281
   3227	0D40  FA			     cli
   3228	0D41  90			     nop
   3229					;
   3230					;		 ((struct clkarg ks_stk	*)p2)->ticks = pclkblk->remain - rtctick;
   3231					;
   3232					     ?debug  L 1282
   3233	0D42  C4 5E F0			     les     bx,dword ptr [bp-16]
   3234	0D45  26: 8B 57	0A		     mov     dx,word ptr es:[bx+10]
   3235	0D49  26: 8B 47	08		     mov     ax,word ptr es:[bx+8]
   3236	0D4D  2B 06 000Cr		     sub     ax,word ptr DGROUP:_rtctick
   3237	0D51  1B 16 000Er		     sbb     dx,word ptr DGROUP:_rtctick+2
   3238	0D55  C4 5E FC			     les     bx,dword ptr [bp-4]
   3239	0D58  26: 89 57	08		     mov     word ptr es:[bx+8],dx
   3240	0D5C  26: 89 47	06		     mov     word ptr es:[bx+6],ax
   3241					;
   3242					;		 ENABLE;
   3243					;
   3244					     ?debug  L 1283
   3245	0D60  FB			     sti
   3246					;
   3247					;	      }
   3248					;
   3249					     ?debug  L 1284
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 58
.\rtxc.asm



   3250	0D61  E9 136A			     jmp     @2@15430
   3251	0D64			     @2@5798:
   3252					;
   3253					;	      else
   3254					;		 ((struct clkarg ks_stk	*)p2)->ticks = (TICKS)0;
   3255					;
   3256					     ?debug  L 1286
   3257	0D64  C4 5E FC			     les     bx,dword ptr [bp-4]
   3258	0D67  26: C7 47	08 0000		     mov     word ptr es:[bx+8],0
   3259	0D6D  26: C7 47	06 0000		     mov     word ptr es:[bx+6],0
   3260	0D73  E9 1358			     jmp     @2@15430
   3261	0D76			     @2@5826:
   3262					;
   3263					;	      break;
   3264					;    #endif /* } HAS_INQTIMER */
   3265					;
   3266					;    #ifdef HAS_INQTIME	/* { */
   3267					;    /************************/
   3268					;	   case	RTXC_INQTIME:
   3269					;    /************************/
   3270					;	      DISABLE; /* prevent changing while reading */
   3271					;
   3272					     ?debug  L 1294
   3273	0D76  FA			     cli
   3274	0D77  90			     nop
   3275					;
   3276					;	      ((struct timearg ks_stk *)p2)->time = rtctime;
   3277					;
   3278					     ?debug  L 1295
   3279	0D78  C4 5E FC			     les     bx,dword ptr [bp-4]
   3280	0D7B  8B 16 0012r		     mov     dx,word ptr DGROUP:_rtctime+2
   3281	0D7F  A1 0010r			     mov     ax,word ptr DGROUP:_rtctime
   3282	0D82  26: 89 57	04		     mov     word ptr es:[bx+4],dx
   3283	0D86  26: 89 47	02		     mov     word ptr es:[bx+2],ax
   3284					;
   3285					;	      rtctimetick=ratecnt;
   3286					;
   3287					     ?debug  L 1296
   3288	0D8A  B8 0000s			     mov     ax,seg _rtctimetick
   3289	0D8D  8B 16 001Er		     mov     dx,word ptr DGROUP:ratecnt
   3290	0D91  8E C0			     mov     es,ax
   3291	0D93  26: 89 16	0000r		     mov     word ptr es:_rtctimetick,dx
   3292					;
   3293					;	      ENABLE;
   3294					;
   3295					     ?debug  L 1297
   3296	0D98  FB			     sti
   3297					;
   3298					;	      break;
   3299					;
   3300					     ?debug  L 1298
   3301	0D99  E9 1332			     jmp     @2@15430
   3302	0D9C			     @2@5966:
   3303					;
   3304					;    #endif /* } HAS_INQTIME */
   3305					;
   3306					;    #ifdef HAS_DEFTIME	/* { */
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 59
.\rtxc.asm



   3307					;    /************************/
   3308					;	   case	RTXC_DEFTIME:
   3309					;    /************************/
   3310					;	      DISABLE; /* prevent changing while writing */
   3311					;
   3312					     ?debug  L 1305
   3313	0D9C  FA			     cli
   3314	0D9D  90			     nop
   3315					;
   3316					;	      rtctime =	((struct timearg ks_stk	*)p2)->time;
   3317					;
   3318					     ?debug  L 1306
   3319	0D9E  C4 5E FC			     les     bx,dword ptr [bp-4]
   3320	0DA1  26: 8B 57	04		     mov     dx,word ptr es:[bx+4]
   3321	0DA5  26: 8B 47	02		     mov     ax,word ptr es:[bx+2]
   3322	0DA9  89 16 0012r		     mov     word ptr DGROUP:_rtctime+2,dx
   3323	0DAD  A3 0010r			     mov     word ptr DGROUP:_rtctime,ax
   3324					;
   3325					;	      ratecnt=0;
   3326					;
   3327					     ?debug  L 1307
   3328	0DB0  C7 06 001Er 0000		     mov     word ptr DGROUP:ratecnt,0
   3329					;
   3330					;	      ENABLE;
   3331					;
   3332					     ?debug  L 1308
   3333	0DB6  FB			     sti
   3334					;
   3335					;	      break;
   3336					;
   3337					     ?debug  L 1309
   3338	0DB7  E9 1314			     jmp     @2@15430
   3339	0DBA			     @2@6106:
   3340					;
   3341					;    #endif /* } HAS_DEFTIME */
   3342					;
   3343					;    #ifdef HAS_MAILBOXES /* { */
   3344					;    #ifdef HAS_SEND /*	{ */
   3345					;    /************************/
   3346					;	   case	RTXC_SEND:
   3347					;    /************************/
   3348					;	      if ( ((struct msgarg ks_stk *)p2)->priority == (PRIORITY)0)
   3349					;
   3350					     ?debug  L 1317
   3351	0DBA  C4 5E FC			     les     bx,dword ptr [bp-4]
   3352	0DBD  26: 83 7F	0A 00		     cmp     word ptr es:[bx+10],0
   3353	0DC2  75 0D			     jne     short @2@6162
   3354					;
   3355					;	      {
   3356					;		 /* priority = 0 yields	sender's priority */
   3357					;		 ((struct msgarg ks_stk	*)p2)->prtxcmsg->priority =
   3358					;
   3359					     ?debug  L 1320
   3360					;
   3361					;		    hipritsk->priority;
   3362					;
   3363					     ?debug  L 1321
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 60
.\rtxc.asm



   3364	0DC4  26: C4 5F	0C		     les     bx,dword ptr es:[bx+12]
   3365	0DC8  8B 36 0000r		     mov     si,word ptr DGROUP:_hipritsk
   3366	0DCC  8B 44 0A			     mov     ax,word ptr [si+10]
   3367	0DCF  EB 0B			     jmp     short @2@6190
   3368	0DD1			     @2@6162:
   3369					;
   3370					;	      }
   3371					;	      else
   3372					;	      {
   3373					;		 ((struct msgarg ks_stk	*)p2)->prtxcmsg->priority =
   3374					;
   3375					     ?debug  L 1325
   3376					;
   3377					;		    ((struct msgarg ks_stk *)p2)->priority;
   3378					;
   3379					     ?debug  L 1326
   3380	0DD1  C4 5E FC			     les     bx,dword ptr [bp-4]
   3381	0DD4  26: 8B 47	0A		     mov     ax,word ptr es:[bx+10]
   3382	0DD8  26: C4 5F	0C		     les     bx,dword ptr es:[bx+12]
   3383	0DDC			     @2@6190:
   3384	0DDC  26: 89 47	06		     mov     word ptr es:[bx+6],ax
   3385					;
   3386					;	      }
   3387					;
   3388					;	      ((struct msgarg ks_stk *)p2)->prtxcmsg->sema =
   3389					;
   3390					     ?debug  L 1329
   3391					;
   3392					;		 ((struct msgarg ks_stk	*)p2)->sema;
   3393					;
   3394					     ?debug  L 1330
   3395	0DE0  C4 5E FC			     les     bx,dword ptr [bp-4]
   3396	0DE3  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   3397	0DE7  26: C4 5F	0C		     les     bx,dword ptr es:[bx+12]
   3398	0DEB  26: 89 47	08		     mov     word ptr es:[bx+8],ax
   3399					;
   3400					;
   3401					;	      ((struct msgarg ks_stk *)p2)->prtxcmsg->task = hipritsk->task;
   3402					;
   3403					     ?debug  L 1332
   3404	0DEF  8B 36 0000r		     mov     si,word ptr DGROUP:_hipritsk
   3405	0DF3  8B 44 08			     mov     ax,word ptr [si+8]
   3406	0DF6  26: 89 47	04		     mov     word ptr es:[bx+4],ax
   3407					;
   3408					;
   3409					;	      pmh = &mheader[((struct msgarg ks_stk *)p2)->mbox];
   3410					;
   3411					     ?debug  L 1334
   3412	0DFA  C4 5E FC			     les     bx,dword ptr [bp-4]
   3413	0DFD  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
   3414	0E01  6B C0 0A			     imul    ax,ax,10
   3415	0E04  05 0000e			     add     ax,offset DGROUP:_mheader
   3416	0E07  89 46 DC			     mov     word ptr [bp-36],ax
   3417					;
   3418					;
   3419					;    #ifdef MAILBOX_SEMAS /* { */
   3420					;	      /* if was	empty and there	is a not_empty semaphore defined */
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 61
.\rtxc.asm



   3421					;	      if (pmh->link == NULL)
   3422					;
   3423					     ?debug  L 1338
   3424	0E0A  8B 5E DC			     mov     bx,word ptr [bp-36]
   3425	0E0D  8B 07			     mov     ax,word ptr [bx]
   3426	0E0F  0B 47 02			     or	     ax,word ptr [bx+2]
   3427	0E12  75 47			     jne     short @2@6498
   3428					;
   3429					;	      {
   3430					;		 UPDATE_SEMA(pmh->nesema);
   3431					;
   3432					     ?debug  L 1340
   3433	0E14  83 7F 08 00		     cmp     word ptr [bx+8],0
   3434	0E18  74 41			     je	     short @2@6498
   3435	0E1A  8B 5F 08			     mov     bx,word ptr [bx+8]
   3436	0E1D  03 DB			     add     bx,bx
   3437	0E1F  83 BF 0000e FF		     cmp     word ptr DGROUP:_semat[bx],-1
   3438	0E24  75 10			     jne     short @2@6330
   3439	0E26  8B 5E DC			     mov     bx,word ptr [bp-36]
   3440	0E29  8B 5F 08			     mov     bx,word ptr [bx+8]
   3441	0E2C  03 DB			     add     bx,bx
   3442	0E2E  C7 87 0000e 0000		     mov     word ptr DGROUP:_semat[bx],0
   3443	0E34  EB 25			     jmp     short @2@6498
   3444	0E36			     @2@6330:
   3445	0E36  8B 5E DC			     mov     bx,word ptr [bp-36]
   3446	0E39  8B 5F 08			     mov     bx,word ptr [bx+8]
   3447	0E3C  03 DB			     add     bx,bx
   3448	0E3E  83 BF 0000e 00		     cmp     word ptr DGROUP:_semat[bx],0
   3449	0E43  75 02			     jne     short @2@6386
   3450	0E45  EB 14			     jmp     short @2@6498
   3451	0E47			     @2@6386:
   3452	0E47  FA			     cli
   3453	0E48  90			     nop
   3454	0E49  8B 5E DC			     mov     bx,word ptr [bp-36]
   3455	0E4C  8B 47 08			     mov     ax,word ptr [bx+8]
   3456	0E4F  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
   3457	0E53  89 07			     mov     word ptr [bx],ax
   3458	0E55  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
   3459	0E5A  FB			     sti
   3460	0E5B			     @2@6498:
   3461					;
   3462					;	      }
   3463					;    #endif /* } MAILBOX_SEMAS */
   3464					;
   3465					;    #ifdef MAILBOX_WAITERS /* { */
   3466					;	      if ( (ptcb = pmh->waiters) != NULLTCB) /*	if a task waiting */
   3467					;
   3468					     ?debug  L 1345
   3469	0E5B  8B 5E DC			     mov     bx,word ptr [bp-36]
   3470	0E5E  8B 47 04			     mov     ax,word ptr [bx+4]
   3471	0E61  89 46 F6			     mov     word ptr [bp-10],ax
   3472	0E64  0B C0			     or	     ax,ax
   3473	0E66  75 03			     jne     @@20
   3474	0E68  E9 00AF			     jmp     @2@6750
   3475	0E6B			     @@20:
   3476					;
   3477					;	      {
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 62
.\rtxc.asm



   3478					;		 /* pass data directly from sender to receiver */
   3479					;		 p2a = ((FRAME ks_stk *)(ptcb->sp))->pksnum;
   3480					;
   3481					     ?debug  L 1348
   3482	0E6B  8B 5E F6			     mov     bx,word ptr [bp-10]
   3483	0E6E  C4 5F 0C			     les     bx,dword ptr [bx+12]
   3484	0E71  26: 8B 57	0E		     mov     dx,word ptr es:[bx+14]
   3485	0E75  26: 8B 47	0C		     mov     ax,word ptr es:[bx+12]
   3486	0E79  89 56 E2			     mov     word ptr [bp-30],dx
   3487	0E7C  89 46 E0			     mov     word ptr [bp-32],ax
   3488					;
   3489					;
   3490					;		 /* if receiving from anybody (0) or a specific	task match */
   3491					;		 if ( (((struct	msgarg ks_stk *)p2a)->task == (TASK)0) ||
   3492					;
   3493					     ?debug  L 1351
   3494					;
   3495					;		      (((struct	msgarg ks_stk *)p2a)->task ==
   3496					;		       hipritsk->task) )
   3497					;
   3498					     ?debug  L 1353
   3499	0E7F  C4 5E E0			     les     bx,dword ptr [bp-32]
   3500	0E82  26: 83 7F	08 00		     cmp     word ptr es:[bx+8],0
   3501	0E87  74 10			     je	     short @2@6582
   3502	0E89  26: 8B 47	08		     mov     ax,word ptr es:[bx+8]
   3503	0E8D  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   3504	0E91  3B 47 08			     cmp     ax,word ptr [bx+8]
   3505	0E94  74 03			     je	     @@21
   3506	0E96  E9 0081			     jmp     @2@6750
   3507	0E99			     @@21:
   3508	0E99			     @2@6582:
   3509					;
   3510					;		 {
   3511					;		    /* pass &message directly to receiver */
   3512					;		    ((struct msgarg ks_stk *)p2a)->prtxcmsg =
   3513					;
   3514					     ?debug  L 1356
   3515					;
   3516					;		       ((struct	msgarg ks_stk *)p2)->prtxcmsg;
   3517					;
   3518					     ?debug  L 1357
   3519	0E99  C4 5E FC			     les     bx,dword ptr [bp-4]
   3520	0E9C  26: 8B 57	0E		     mov     dx,word ptr es:[bx+14]
   3521	0EA0  26: 8B 47	0C		     mov     ax,word ptr es:[bx+12]
   3522	0EA4  C4 5E E0			     les     bx,dword ptr [bp-32]
   3523	0EA7  26: 89 57	0E		     mov     word ptr es:[bx+14],dx
   3524	0EAB  26: 89 47	0C		     mov     word ptr es:[bx+12],ax
   3525					;
   3526					;
   3527					;    #ifdef CBUG /* { */
   3528					;		    pmh->count++;
   3529					;    #endif /* } CBUG */
   3530					;
   3531					;		    /* remove tcb from waiter's	list */
   3532					;		    if ( (pmh->waiters = ptcb->flink) != NULLTCB)
   3533					;
   3534					     ?debug  L 1364
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 63
.\rtxc.asm



   3535	0EAF  8B 5E F6			     mov     bx,word ptr [bp-10]
   3536	0EB2  8B 07			     mov     ax,word ptr [bx]
   3537	0EB4  8B 5E DC			     mov     bx,word ptr [bp-36]
   3538	0EB7  89 47 04			     mov     word ptr [bx+4],ax
   3539	0EBA  0B C0			     or	     ax,ax
   3540	0EBC  74 0E			     je	     short @2@6638
   3541					;
   3542					;		       ptcb->flink->blink = (TCB near *)&pmh->waiters;
   3543					;
   3544					     ?debug  L 1365
   3545	0EBE  8B 46 DC			     mov     ax,word ptr [bp-36]
   3546	0EC1  05 0004			     add     ax,4
   3547	0EC4  8B 5E F6			     mov     bx,word ptr [bp-10]
   3548	0EC7  8B 1F			     mov     bx,word ptr [bx]
   3549	0EC9  89 47 02			     mov     word ptr [bx+2],ax
   3550	0ECC			     @2@6638:
   3551					;
   3552					;
   3553					;		    /* clear MSG WAIT in receiving task	and check if runnable */
   3554					;		    if ( (ptcb->status &= ~MSG_WAIT) ==	READY)
   3555					;
   3556					     ?debug  L 1368
   3557	0ECC  8B 5E F6			     mov     bx,word ptr [bp-10]
   3558	0ECF  83 67 10 DF		     and     word ptr [bx+16],-33
   3559	0ED3  8B 47 10			     mov     ax,word ptr [bx+16]
   3560	0ED6  0B C0			     or	     ax,ax
   3561	0ED8  75 0B			     jne     short @2@6694
   3562					;
   3563					;		    {
   3564					;		       /* insert waiter	into READY list	*/
   3565					;		       ptcb->flink = nsrttcb;
   3566					;
   3567					     ?debug  L 1371
   3568	0EDA  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
   3569	0EDD  89 07			     mov     word ptr [bx],ax
   3570					;
   3571					;		       nsrttcb = ptcb;
   3572					;
   3573					     ?debug  L 1372
   3574	0EDF  8B 46 F6			     mov     ax,word ptr [bp-10]
   3575	0EE2  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
   3576	0EE5			     @2@6694:
   3577					;
   3578					;		    }
   3579					;
   3580					;    #ifdef MAILBOX_TIMEOUTS /*	{ */
   3581					;		    /* cleanup any pending timeout */
   3582					;		    if ( (pclkblk = ptcb->pclkblk) != NULLCLK)
   3583					;
   3584					     ?debug  L 1377
   3585	0EE5  8B 5E F6			     mov     bx,word ptr [bp-10]
   3586	0EE8  8B 57 06			     mov     dx,word ptr [bx+6]
   3587	0EEB  8B 47 04			     mov     ax,word ptr [bx+4]
   3588	0EEE  89 56 F2			     mov     word ptr [bp-14],dx
   3589	0EF1  89 46 F0			     mov     word ptr [bp-16],ax
   3590	0EF4  0B C2			     or	     ax,dx
   3591	0EF6  74 36			     je	     short @2@6778
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 64
.\rtxc.asm



   3592					;
   3593					;		    {
   3594					;		       /* mark waiter GOOD */
   3595					;		       ((struct	msgarg ks_stk *)p2a)->ksrc = RC_GOOD;
   3596					;
   3597					     ?debug  L 1380
   3598	0EF8  C4 5E E0			     les     bx,dword ptr [bp-32]
   3599	0EFB  26: C7 47	02 0000		     mov     word ptr es:[bx+2],0
   3600					;
   3601					;
   3602					;		       unlink_timer(pclkblk);
   3603					;
   3604					     ?debug  L 1382
   3605	0F01  52			     push    dx
   3606	0F02  FF 76 F0			     push    word ptr [bp-16]
   3607	0F05  E8 1EA7			     call    near ptr unlink_timer
   3608	0F08  83 C4 04			     add     sp,4
   3609					;
   3610					;		       ptcb->pclkblk = NULLCLK;
   3611					;
   3612					     ?debug  L 1383
   3613	0F0B  8B 5E F6			     mov     bx,word ptr [bp-10]
   3614	0F0E  C7 47 06 0000		     mov     word ptr [bx+6],0
   3615	0F13  C7 47 04 0000		     mov     word ptr [bx+4],0
   3616	0F18  EB 14			     jmp     short @2@6778
   3617	0F1A			     @2@6750:
   3618	0F1A  C4 5E FC			     les     bx,dword ptr [bp-4]
   3619	0F1D  26: FF 77	0E		     push    word ptr es:[bx+14]
   3620	0F21  26: FF 77	0C		     push    word ptr es:[bx+12]
   3621	0F25  FF 76 DC			     push    word ptr [bp-36]
   3622	0F28  E8 126A			     call    near ptr insert_message
   3623	0F2B  83 C4 06			     add     sp,6
   3624	0F2E			     @2@6778:
   3625					;
   3626					;		    }
   3627					;    #endif /* } MAILBOX_TIMEOUTS */
   3628					;		 }
   3629					;		 else
   3630					;		 {
   3631					;		    insert_message(pmh,	((struct msgarg	ks_stk *)p2)->prtxcmsg);
   3632					;		 }
   3633					;	      }
   3634					;	      else
   3635					;    #endif /* } MAILBOX_WAITERS */
   3636					;	      {
   3637					;		 insert_message(pmh, ((struct msgarg ks_stk *)p2)->prtxcmsg);
   3638					;	      }
   3639					;
   3640					;	      sema = ((struct msgarg ks_stk *)p2)->sema;
   3641					;
   3642					     ?debug  L 1398
   3643	0F2E  C4 5E FC			     les     bx,dword ptr [bp-4]
   3644	0F31  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   3645	0F35  89 46 EA			     mov     word ptr [bp-22],ax
   3646					;
   3647					;
   3648					;    #ifdef MAILBOX_WAITERS /* { */
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 65
.\rtxc.asm



   3649					;	      /* if need to wait on response (sema) */
   3650					;	      if ( ((struct msgarg ks_stk *)p2)->wait)
   3651					;
   3652					     ?debug  L 1402
   3653	0F38  26: 83 7F	10 00		     cmp     word ptr es:[bx+16],0
   3654	0F3D  75 03			     jne     @@22
   3655	0F3F  E9 008B			     jmp     @2@6862
   3656	0F42			     @@22:
   3657					;
   3658					;	      {
   3659					;		 ptcb =	hipritsk; /* save for later */
   3660					;
   3661					     ?debug  L 1404
   3662	0F42  A1 0000r			     mov     ax,word ptr DGROUP:_hipritsk
   3663	0F45  89 46 F6			     mov     word ptr [bp-10],ax
   3664					;
   3665					;
   3666					;		 semat[sema] = (SSTATE)ptcb->task;
   3667					;
   3668					     ?debug  L 1406
   3669	0F48  8B 5E EA			     mov     bx,word ptr [bp-22]
   3670	0F4B  03 DB			     add     bx,bx
   3671	0F4D  8B 36 0000r		     mov     si,word ptr DGROUP:_hipritsk
   3672	0F51  8B 44 08			     mov     ax,word ptr [si+8]
   3673	0F54  89 87 0000e		     mov     word ptr DGROUP:_semat[bx],ax
   3674					;
   3675					;
   3676					;		 ptcb->status =	SEMAPHORE_WAIT;
   3677					;
   3678					     ?debug  L 1408
   3679	0F58  8B 5E F6			     mov     bx,word ptr [bp-10]
   3680	0F5B  C7 47 10 0040		     mov     word ptr [bx+16],64
   3681					;
   3682					;
   3683					;		 UNLINK_HIPRITSK(); /* unlink first tcb	*/
   3684					;
   3685					     ?debug  L 1410
   3686	0F60  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   3687	0F64  8B 07			     mov     ax,word ptr [bx]
   3688	0F66  A3 0000r			     mov     word ptr DGROUP:_hipritsk,ax
   3689	0F69  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   3690	0F6D  C7 47 02 0000r		     mov     word ptr [bx+2],offset DGROUP:_hipritsk
   3691					;
   3692					;
   3693					;    #ifdef SEMAPHORE_TIMEOUTS /* { */
   3694					;		 if ( ((struct msgarg ks_stk *)p2)->ticks) /* if timeout active	*/
   3695					;
   3696					     ?debug  L 1413
   3697	0F72  8B 5E FC			     mov     bx,word ptr [bp-4]
   3698	0F75  26: 8B 47	12		     mov     ax,word ptr es:[bx+18]
   3699	0F79  26: 0B 47	14		     or	     ax,word ptr es:[bx+20]
   3700	0F7D  75 03			     jne     @@23
   3701	0F7F  E9 114C			     jmp     @2@15430
   3702	0F82			     @@23:
   3703					;
   3704					;		 {
   3705					;		    ptcb->pclkblk = ((struct msgarg ks_stk *)p2)->pclkblk;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 66
.\rtxc.asm



   3706					;
   3707					     ?debug  L 1415
   3708	0F82  26: 8B 57	18		     mov     dx,word ptr es:[bx+24]
   3709	0F86  26: 8B 47	16		     mov     ax,word ptr es:[bx+22]
   3710	0F8A  8B 5E F6			     mov     bx,word ptr [bp-10]
   3711	0F8D  89 57 06			     mov     word ptr [bx+6],dx
   3712	0F90  89 47 04			     mov     word ptr [bx+4],ax
   3713					;
   3714					;		    pclkblk = ptcb->pclkblk;
   3715					;
   3716					     ?debug  L 1416
   3717	0F93  8B 57 06			     mov     dx,word ptr [bx+6]
   3718	0F96  8B 47 04			     mov     ax,word ptr [bx+4]
   3719	0F99  89 56 F2			     mov     word ptr [bp-14],dx
   3720	0F9C  89 46 F0			     mov     word ptr [bp-16],ax
   3721					;
   3722					;		    pclkblk->remain = ((struct msgarg ks_stk *)p2)->ticks;
   3723					;
   3724					     ?debug  L 1417
   3725	0F9F  8B 5E FC			     mov     bx,word ptr [bp-4]
   3726	0FA2  26: 8B 57	14		     mov     dx,word ptr es:[bx+20]
   3727	0FA6  26: 8B 47	12		     mov     ax,word ptr es:[bx+18]
   3728	0FAA  C4 5E F0			     les     bx,dword ptr [bp-16]
   3729	0FAD  26: 89 57	0A		     mov     word ptr es:[bx+10],dx
   3730	0FB1  26: 89 47	08		     mov     word ptr es:[bx+8],ax
   3731					;
   3732					;		    pclkblk->recycle = (TICKS)0;
   3733					;
   3734					     ?debug  L 1418
   3735	0FB5  26: C7 47	0E 0000		     mov     word ptr es:[bx+14],0
   3736	0FBB  26: C7 47	0C 0000		     mov     word ptr es:[bx+12],0
   3737					;
   3738					;
   3739					;		    /* mark object type	*/
   3740					;		    pclkblk->objtype = SEMAPHORE_OBJ;
   3741					;
   3742					     ?debug  L 1421
   3743	0FC1  26: C7 47	14 0001		     mov     word ptr es:[bx+20],1
   3744					;
   3745					;		    pclkblk->objid = sema;
   3746					;
   3747					     ?debug  L 1422
   3748	0FC7  8B 46 EA			     mov     ax,word ptr [bp-22]
   3749	0FCA  E9 F74A			     jmp     @2@2606
   3750	0FCD			     @2@6862:
   3751					;
   3752					;		    pclkblk->task = ptcb->task;
   3753					;
   3754					;		    /* insert timer */
   3755					;		    insert_timer(pclkblk);
   3756					;
   3757					;		    ((struct msgarg ks_stk *)p2)->ksrc = RC_TIMEOUT;
   3758					;		 }
   3759					;    #endif /* } SEMAPHORE_TIMEOUTS */
   3760					;	      }
   3761					;	      else
   3762					;    #endif /* } MAILBOX_WAITERS */
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 67
.\rtxc.asm



   3763					;	      {
   3764					;		 if (sema)
   3765					;
   3766					     ?debug  L 1435
   3767	0FCD  83 7E EA 00		     cmp     word ptr [bp-22],0
   3768	0FD1  75 03			     jne     @@24
   3769	0FD3  E9 10F8			     jmp     @2@15430
   3770	0FD6			     @@24:
   3771					;
   3772					;		    semat[sema]	= SEMA_PENDING;
   3773					;
   3774					     ?debug  L 1436
   3775	0FD6  8B 5E EA			     mov     bx,word ptr [bp-22]
   3776	0FD9  03 DB			     add     bx,bx
   3777	0FDB  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
   3778	0FE1  E9 10EA			     jmp     @2@15430
   3779	0FE4			     @2@6918:
   3780					;
   3781					;	      }
   3782					;	      break;
   3783					;    #endif /* } HAS_SEND */
   3784					;
   3785					;    #ifdef HAS_RECEIVE	/* { */
   3786					;    /************************/
   3787					;	   case	RTXC_RECEIVE:
   3788					;    /************************/
   3789					;	      pmh = &mheader[((struct msgarg ks_stk *)p2)->mbox];
   3790					;
   3791					     ?debug  L 1445
   3792	0FE4  C4 5E FC			     les     bx,dword ptr [bp-4]
   3793	0FE7  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
   3794	0FEB  6B C0 0A			     imul    ax,ax,10
   3795	0FEE  05 0000e			     add     ax,offset DGROUP:_mheader
   3796	0FF1  89 46 DC			     mov     word ptr [bp-36],ax
   3797					;
   3798					;
   3799					;	      /* if no messages	are available */
   3800					;	      if ( (prtxcmsg = remove_message(pmh,
   3801					;
   3802					     ?debug  L 1448
   3803					;
   3804					;				 ((struct msgarg ks_stk	*)p2)->task)) == NULL)
   3805					;
   3806					     ?debug  L 1449
   3807	0FF4  26: FF 77	08		     push    word ptr es:[bx+8]
   3808	0FF8  50			     push    ax
   3809	0FF9  E8 121E			     call    near ptr remove_message
   3810	0FFC  83 C4 04			     add     sp,4
   3811	0FFF  89 56 DA			     mov     word ptr [bp-38],dx
   3812	1002  89 46 D8			     mov     word ptr [bp-40],ax
   3813	1005  0B C2			     or	     ax,dx
   3814	1007  74 03			     je	     @@25
   3815	1009  E9 00AB			     jmp     @2@7030
   3816	100C			     @@25:
   3817					;
   3818					;	      {
   3819					;    #ifdef MAILBOX_WAITERS /* { */
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 68
.\rtxc.asm



   3820					;		 if ( ((struct msgarg ks_stk *)p2)->wait)
   3821					;
   3822					     ?debug  L 1452
   3823	100C  C4 5E FC			     les     bx,dword ptr [bp-4]
   3824	100F  26: 83 7F	10 00		     cmp     word ptr es:[bx+16],0
   3825	1014  75 03			     jne     @@26
   3826	1016  E9 00C9			     jmp     @2@7142
   3827	1019			     @@26:
   3828					;
   3829					;		 {
   3830					;		    ptcb = hipritsk; /*	save for later */
   3831					;
   3832					     ?debug  L 1454
   3833	1019  A1 0000r			     mov     ax,word ptr DGROUP:_hipritsk
   3834	101C  89 46 F6			     mov     word ptr [bp-10],ax
   3835					;
   3836					;
   3837					;		    ptcb->status = MSG_WAIT; /*	set MSG_WAIT in	status word */
   3838					;
   3839					     ?debug  L 1456
   3840	101F  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   3841	1023  C7 47 10 0020		     mov     word ptr [bx+16],32
   3842					;
   3843					;
   3844					;		    /* thread waiting task in priority order */
   3845					;		    porder((TCB	near *)&pmh->waiters);
   3846					;
   3847					     ?debug  L 1459
   3848	1028  8B 46 DC			     mov     ax,word ptr [bp-36]
   3849	102B  05 0004			     add     ax,4
   3850	102E  50			     push    ax
   3851	102F  E8 1DBC			     call    near ptr porder
   3852	1032  83 C4 02			     add     sp,2
   3853					;
   3854					;
   3855					;    #ifdef MAILBOX_TIMEOUTS /*	{ */
   3856					;		    if ( ((struct msgarg ks_stk	*)p2)->ticks) /* if timeout active*/
   3857					;
   3858					     ?debug  L 1462
   3859	1035  C4 5E FC			     les     bx,dword ptr [bp-4]
   3860	1038  26: 8B 47	12		     mov     ax,word ptr es:[bx+18]
   3861	103C  26: 0B 47	14		     or	     ax,word ptr es:[bx+20]
   3862	1040  75 03			     jne     @@27
   3863	1042  E9 009D			     jmp     @2@7142
   3864	1045			     @@27:
   3865					;
   3866					;		    {
   3867					;		       ptcb->pclkblk = ((struct	msgarg ks_stk *)p2)->pclkblk;
   3868					;
   3869					     ?debug  L 1464
   3870	1045  26: 8B 57	18		     mov     dx,word ptr es:[bx+24]
   3871	1049  26: 8B 47	16		     mov     ax,word ptr es:[bx+22]
   3872	104D  8B 5E F6			     mov     bx,word ptr [bp-10]
   3873	1050  89 57 06			     mov     word ptr [bx+6],dx
   3874	1053  89 47 04			     mov     word ptr [bx+4],ax
   3875					;
   3876					;		       pclkblk = ptcb->pclkblk;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 69
.\rtxc.asm



   3877					;
   3878					     ?debug  L 1465
   3879	1056  8B 57 06			     mov     dx,word ptr [bx+6]
   3880	1059  8B 47 04			     mov     ax,word ptr [bx+4]
   3881	105C  89 56 F2			     mov     word ptr [bp-14],dx
   3882	105F  89 46 F0			     mov     word ptr [bp-16],ax
   3883					;
   3884					;		       pclkblk->remain = ((struct msgarg ks_stk	*)p2)->ticks;
   3885					;
   3886					     ?debug  L 1466
   3887	1062  8B 5E FC			     mov     bx,word ptr [bp-4]
   3888	1065  26: 8B 57	14		     mov     dx,word ptr es:[bx+20]
   3889	1069  26: 8B 47	12		     mov     ax,word ptr es:[bx+18]
   3890	106D  C4 5E F0			     les     bx,dword ptr [bp-16]
   3891	1070  26: 89 57	0A		     mov     word ptr es:[bx+10],dx
   3892	1074  26: 89 47	08		     mov     word ptr es:[bx+8],ax
   3893					;
   3894					;		       pclkblk->recycle	= (TICKS)0;
   3895					;
   3896					     ?debug  L 1467
   3897	1078  26: C7 47	0E 0000		     mov     word ptr es:[bx+14],0
   3898	107E  26: C7 47	0C 0000		     mov     word ptr es:[bx+12],0
   3899					;
   3900					;
   3901					;		       /* mark object type */
   3902					;		       pclkblk->objtype	= MAILBOX_OBJ;
   3903					;
   3904					     ?debug  L 1470
   3905	1084  26: C7 47	14 0005		     mov     word ptr es:[bx+20],5
   3906					;
   3907					;		       pclkblk->objid =	((struct msgarg	ks_stk *)p2)->mbox;
   3908					;
   3909					     ?debug  L 1471
   3910	108A  C4 5E FC			     les     bx,dword ptr [bp-4]
   3911	108D  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
   3912	1091  C4 5E F0			     les     bx,dword ptr [bp-16]
   3913	1094  26: 89 47	16		     mov     word ptr es:[bx+22],ax
   3914					;
   3915					;		       pclkblk->task = ptcb->task;
   3916					;
   3917					     ?debug  L 1472
   3918	1098  8B 76 F6			     mov     si,word ptr [bp-10]
   3919	109B  8B 44 08			     mov     ax,word ptr [si+8]
   3920	109E  26: 89 47	10		     mov     word ptr es:[bx+16],ax
   3921					;
   3922					;
   3923					;		       /* insert timer */
   3924					;		       insert_timer(pclkblk);
   3925					;
   3926					     ?debug  L 1475
   3927	10A2  FF 76 F2			     push    word ptr [bp-14]
   3928	10A5  53			     push    bx
   3929	10A6  E8 1C4B			     call    near ptr insert_timer
   3930	10A9  83 C4 04			     add     sp,4
   3931					;
   3932					;
   3933					;		       ((struct	msgarg ks_stk *)p2)->ksrc = RC_TIMEOUT;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 70
.\rtxc.asm



   3934					;
   3935					     ?debug  L 1477
   3936	10AC  C4 5E FC			     les     bx,dword ptr [bp-4]
   3937	10AF  26: C7 47	02 0005		     mov     word ptr es:[bx+2],5
   3938	10B5  EB 2B			     jmp     short @2@7142
   3939	10B7			     @2@7030:
   3940					;
   3941					;		    }
   3942					;    #endif /* } MAILBOX_TIMEOUTS */
   3943					;		 }
   3944					;    #endif /* } MAILBOX_WAITERS */
   3945					;	      }
   3946					;	      else /* message returned to caller */
   3947					;	      {
   3948					;    #ifdef CBUG /* { */
   3949					;		 pmh->count++;
   3950					;    #endif /* } CBUG */
   3951					;
   3952					;    #ifdef MAILBOX_SEMAS /* { */
   3953					;		 if (pmh->nesema)
   3954					;
   3955					     ?debug  L 1490
   3956	10B7  8B 5E DC			     mov     bx,word ptr [bp-36]
   3957	10BA  83 7F 08 00		     cmp     word ptr [bx+8],0
   3958	10BE  74 22			     je	     short @2@7142
   3959					;
   3960					;		 {
   3961					;		    /* if now empty */
   3962					;		    if (pmh->link == NULL)
   3963					;
   3964					     ?debug  L 1493
   3965	10C0  8B 07			     mov     ax,word ptr [bx]
   3966	10C2  0B 47 02			     or	     ax,word ptr [bx+2]
   3967	10C5  75 0D			     jne     short @2@7114
   3968					;
   3969					;		       semat[pmh->nesema] = SEMA_PENDING; /* reset */
   3970					;
   3971					     ?debug  L 1494
   3972	10C7  8B 5F 08			     mov     bx,word ptr [bx+8]
   3973	10CA  03 DB			     add     bx,bx
   3974	10CC  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
   3975	10D2  EB 0E			     jmp     short @2@7142
   3976	10D4			     @2@7114:
   3977					;
   3978					;		    else
   3979					;		       semat[pmh->nesema] = SEMA_DONE; /* force	not empty */
   3980					;
   3981					     ?debug  L 1496
   3982	10D4  8B 5E DC			     mov     bx,word ptr [bp-36]
   3983	10D7  8B 5F 08			     mov     bx,word ptr [bx+8]
   3984	10DA  03 DB			     add     bx,bx
   3985	10DC  C7 87 0000e 0000		     mov     word ptr DGROUP:_semat[bx],0
   3986	10E2			     @2@7142:
   3987					;
   3988					;		 }
   3989					;    #endif /* } MAILBOX_SEMAS */
   3990					;	      }
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 71
.\rtxc.asm



   3991					;
   3992					;	      /* return	msg to caller */
   3993					;	      ((struct msgarg ks_stk *)p2)->prtxcmsg = prtxcmsg;
   3994					;
   3995					     ?debug  L 1502
   3996	10E2  C4 5E FC			     les     bx,dword ptr [bp-4]
   3997	10E5  8B 56 DA			     mov     dx,word ptr [bp-38]
   3998	10E8  8B 46 D8			     mov     ax,word ptr [bp-40]
   3999	10EB  26: 89 57	0E		     mov     word ptr es:[bx+14],dx
   4000	10EF  26: 89 47	0C		     mov     word ptr es:[bx+12],ax
   4001					;
   4002					;	      break;
   4003					;
   4004					     ?debug  L 1503
   4005	10F3  E9 0FD8			     jmp     @2@15430
   4006	10F6			     @2@7170:
   4007					;
   4008					;    #endif /* } HAS_RECEIVE */
   4009					;    #endif /* } HAS_MAILBOXES */
   4010					;
   4011					;    #ifdef HAS_QUEUES /* { */
   4012					;    #ifdef HAS_ENQUEUE	/* { */
   4013					;    /************************/
   4014					;	   case	RTXC_ENQUEUE:
   4015					;    /************************/
   4016					;	      pqh = &qheader[((struct qarg ks_stk *)p2)->queue];
   4017					;
   4018					     ?debug  L 1512
   4019	10F6  C4 5E FC			     les     bx,dword ptr [bp-4]
   4020	10F9  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
   4021	10FD  6B C0 18			     imul    ax,ax,24
   4022	1100  05 0000e			     add     ax,offset DGROUP:_qheader
   4023	1103  89 46 D0			     mov     word ptr [bp-48],ax
   4024					;
   4025					;
   4026					;	      if ( (depth = pqh->depth)	== pqh->curndx)	/* queue was already full */
   4027					;
   4028					     ?debug  L 1514
   4029	1106  8B 5E D0			     mov     bx,word ptr [bp-48]
   4030	1109  8B 47 06			     mov     ax,word ptr [bx+6]
   4031	110C  89 46 CC			     mov     word ptr [bp-52],ax
   4032	110F  3B 47 0A			     cmp     ax,word ptr [bx+10]
   4033	1112  75 3C			     jne     short @2@7282
   4034					;
   4035					;	      {
   4036					;    #ifdef ENQUEUE_WAITERS /* { */
   4037					;		 if ( ((struct qarg ks_stk *)p2)->wait)
   4038					;
   4039					     ?debug  L 1517
   4040	1114  8B 5E FC			     mov     bx,word ptr [bp-4]
   4041	1117  26: 83 7F	0C 00		     cmp     word ptr es:[bx+12],0
   4042	111C  75 03			     jne     @@28
   4043	111E  E9 0FAD			     jmp     @2@15430
   4044	1121			     @@28:
   4045					;
   4046					;		 {
   4047					;		    ptcb = hipritsk; /*	save hipritsk for later	*/
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 72
.\rtxc.asm



   4048					;
   4049					     ?debug  L 1519
   4050	1121  A1 0000r			     mov     ax,word ptr DGROUP:_hipritsk
   4051	1124  89 46 F6			     mov     word ptr [bp-10],ax
   4052					;
   4053					;
   4054					;		    ptcb->status = QUEUE_WAIT; /* set QUEUE_WAIT in status */
   4055					;
   4056					     ?debug  L 1521
   4057	1127  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   4058	112B  C7 47 10 0080		     mov     word ptr [bx+16],128
   4059					;
   4060					;
   4061					;		    /* thread waiting task in priority order */
   4062					;		    porder((TCB	near *)&pqh->waiters);
   4063					;
   4064					     ?debug  L 1524
   4065	1130  8B 46 D0			     mov     ax,word ptr [bp-48]
   4066	1133  05 000C			     add     ax,12
   4067	1136  50			     push    ax
   4068	1137  E8 1CB4			     call    near ptr porder
   4069	113A  83 C4 02			     add     sp,2
   4070					;
   4071					;
   4072					;    #ifdef ENQUEUE_TIMEOUTS /*	{ */
   4073					;		    if ( ((struct qarg ks_stk *)p2)->ticks) /* if timeout active */
   4074					;
   4075					     ?debug  L 1527
   4076	113D  C4 5E FC			     les     bx,dword ptr [bp-4]
   4077	1140  26: 8B 47	0E		     mov     ax,word ptr es:[bx+14]
   4078	1144  26: 0B 47	10		     or	     ax,word ptr es:[bx+16]
   4079	1148  75 03			     jne     @@29
   4080	114A  E9 0F81			     jmp     @2@15430
   4081	114D			     @@29:
   4082	114D  E9 0356			     jmp     @2@9214
   4083	1150			     @2@7282:
   4084					;
   4085					;		    {
   4086					;		       ptcb->pclkblk = ((struct	qarg ks_stk *)p2)->pclkblk;
   4087					;		       pclkblk = ptcb->pclkblk;
   4088					;		       pclkblk->remain = ((struct qarg ks_stk *)p2)->ticks;
   4089					;		       pclkblk->recycle	= (TICKS)0;
   4090					;
   4091					;		       /* mark object type */
   4092					;		       pclkblk->objtype	= QUEUE_OBJ;
   4093					;		       pclkblk->objid =	((struct qarg ks_stk *)p2)->queue;
   4094					;		       pclkblk->task = ptcb->task;
   4095					;
   4096					;		       /* insert timer */
   4097					;		       insert_timer(pclkblk);
   4098					;		    }
   4099					;    #endif /* } ENQUEUE_TIMEOUTS */
   4100					;		 }
   4101					;    #endif /* } ENQUEUE_WAITERS */
   4102					;		 break;
   4103					;	      }
   4104					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 73
.\rtxc.asm



   4105					;	      ((struct qarg ks_stk *)p2)->ksrc = RC_GOOD;
   4106					;
   4107					     ?debug  L 1548
   4108	1150  C4 5E FC			     les     bx,dword ptr [bp-4]
   4109	1153  26: C7 47	02 0000		     mov     word ptr es:[bx+2],0
   4110					;
   4111					;
   4112					;	      width = pqh->width;
   4113					;
   4114					     ?debug  L 1550
   4115	1159  8B 5E D0			     mov     bx,word ptr [bp-48]
   4116	115C  8B 47 04			     mov     ax,word ptr [bx+4]
   4117	115F  89 46 CA			     mov     word ptr [bp-54],ax
   4118					;
   4119					;
   4120					;    #ifdef DEQUEUE_WAITERS /* { */
   4121					;	      /* if queue is empty && if there are waiters */
   4122					;	      if ( (pqh->curndx	== 0) && ((ptcb	= pqh->waiters)	!= NULLTCB) )
   4123					;
   4124					     ?debug  L 1554
   4125	1162  83 7F 0A 00		     cmp     word ptr [bx+10],0
   4126	1166  74 03			     je	     @@30
   4127	1168  E9 015E			     jmp     @2@8038
   4128	116B			     @@30:
   4129	116B  8B 47 0C			     mov     ax,word ptr [bx+12]
   4130	116E  89 46 F6			     mov     word ptr [bp-10],ax
   4131	1171  0B C0			     or	     ax,ax
   4132	1173  75 03			     jne     @@31
   4133	1175  E9 0151			     jmp     @2@8038
   4134	1178			     @@31:
   4135					;
   4136					;	      {
   4137					;		 /* move data directly to first	waiter */
   4138					;
   4139					;		 /* remove highest priority waiter (1st) */
   4140					;		 if ( (pqh->waiters = ptcb->flink) != NULLTCB)
   4141					;
   4142					     ?debug  L 1559
   4143	1178  8B 5E F6			     mov     bx,word ptr [bp-10]
   4144	117B  8B 07			     mov     ax,word ptr [bx]
   4145	117D  8B 5E D0			     mov     bx,word ptr [bp-48]
   4146	1180  89 47 0C			     mov     word ptr [bx+12],ax
   4147	1183  0B C0			     or	     ax,ax
   4148	1185  74 0E			     je	     short @2@7394
   4149					;
   4150					;		      ptcb->flink->blink = (TCB	near *)&pqh->waiters;
   4151					;
   4152					     ?debug  L 1560
   4153	1187  8B 46 D0			     mov     ax,word ptr [bp-48]
   4154	118A  05 000C			     add     ax,12
   4155	118D  8B 5E F6			     mov     bx,word ptr [bp-10]
   4156	1190  8B 1F			     mov     bx,word ptr [bx]
   4157	1192  89 47 02			     mov     word ptr [bx+2],ax
   4158	1195			     @2@7394:
   4159					;
   4160					;
   4161					;		 if ( (ptcb->status &= ~QUEUE_WAIT) == READY)
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 74
.\rtxc.asm



   4162					;
   4163					     ?debug  L 1562
   4164	1195  8B 5E F6			     mov     bx,word ptr [bp-10]
   4165	1198  81 67 10 FF7F		     and     word ptr [bx+16],-129
   4166	119D  8B 47 10			     mov     ax,word ptr [bx+16]
   4167	11A0  0B C0			     or	     ax,ax
   4168	11A2  75 0B			     jne     short @2@7450
   4169					;
   4170					;		 {
   4171					;		    ptcb->flink	= nsrttcb;
   4172					;
   4173					     ?debug  L 1564
   4174	11A4  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
   4175	11A7  89 07			     mov     word ptr [bx],ax
   4176					;
   4177					;		    nsrttcb = ptcb;
   4178					;
   4179					     ?debug  L 1565
   4180	11A9  8B 46 F6			     mov     ax,word ptr [bp-10]
   4181	11AC  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
   4182	11AF			     @2@7450:
   4183					;
   4184					;		 }
   4185					;
   4186					;    #ifdef DEQUEUE_TIMEOUTS /*	{ */
   4187					;		 /* cleanup any	pending	timeout	*/
   4188					;		 if ( (pclkblk = ptcb->pclkblk)	!= NULLCLK)
   4189					;
   4190					     ?debug  L 1570
   4191	11AF  8B 5E F6			     mov     bx,word ptr [bp-10]
   4192	11B2  8B 57 06			     mov     dx,word ptr [bx+6]
   4193	11B5  8B 47 04			     mov     ax,word ptr [bx+4]
   4194	11B8  89 56 F2			     mov     word ptr [bp-14],dx
   4195	11BB  89 46 F0			     mov     word ptr [bp-16],ax
   4196	11BE  0B C2			     or	     ax,dx
   4197	11C0  74 17			     je	     short @2@7506
   4198					;
   4199					;		 {
   4200					;		    unlink_timer(pclkblk);
   4201					;
   4202					     ?debug  L 1572
   4203	11C2  52			     push    dx
   4204	11C3  FF 76 F0			     push    word ptr [bp-16]
   4205	11C6  E8 1BE6			     call    near ptr unlink_timer
   4206	11C9  83 C4 04			     add     sp,4
   4207					;
   4208					;		    ptcb->pclkblk = NULLCLK;
   4209					;
   4210					     ?debug  L 1573
   4211	11CC  8B 5E F6			     mov     bx,word ptr [bp-10]
   4212	11CF  C7 47 06 0000		     mov     word ptr [bx+6],0
   4213	11D4  C7 47 04 0000		     mov     word ptr [bx+4],0
   4214	11D9			     @2@7506:
   4215					;
   4216					;		 }
   4217					;    #endif /* } DEQUEUE_TIMEOUTS */
   4218					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 75
.\rtxc.asm



   4219					;		 p2a = ((FRAME ks_stk *)(ptcb->sp))->pksnum;
   4220					;
   4221					     ?debug  L 1577
   4222	11D9  8B 5E F6			     mov     bx,word ptr [bp-10]
   4223	11DC  C4 5F 0C			     les     bx,dword ptr [bx+12]
   4224	11DF  26: 8B 57	0E		     mov     dx,word ptr es:[bx+14]
   4225	11E3  26: 8B 47	0C		     mov     ax,word ptr es:[bx+12]
   4226	11E7  89 56 E2			     mov     word ptr [bp-30],dx
   4227	11EA  89 46 E0			     mov     word ptr [bp-32],ax
   4228					;
   4229					;
   4230					;		 ((struct qarg ks_stk *)p2a)->ksrc = RC_GOOD;
   4231					;
   4232					     ?debug  L 1579
   4233	11ED  C4 5E E0			     les     bx,dword ptr [bp-32]
   4234	11F0  26: C7 47	02 0000		     mov     word ptr es:[bx+2],0
   4235					;
   4236					;
   4237					;    #ifdef QUEUE_MEMCPY /* { */
   4238					;		 if (width)
   4239					;		    memcpy( ((struct qarg ks_stk *)p2a)->data,
   4240					;			    ((struct qarg ks_stk *)p2)->data,
   4241					;			    width);
   4242					;    #else /* }	QUEUE_MEMCPY { */
   4243					;		 switch(width)
   4244					;
   4245					     ?debug  L 1587
   4246	11F6  8B 5E CA			     mov     bx,word ptr [bp-54]
   4247	11F9  83 FB 04			     cmp     bx,4
   4248	11FC  77 51			     ja	     short @2@7702
   4249	11FE  03 DB			     add     bx,bx
   4250	1200  2E: FF A7	212Br		     jmp     word ptr cs:@2@C15170[bx]
   4251	1205			     @2@7618:
   4252					;
   4253					;		 {
   4254					;		    case 0:
   4255					;		       break;
   4256					;
   4257					;		    case sizeof(char):
   4258					;		       *(char *)(((struct qarg ks_stk *)p2a)->data) =
   4259					;
   4260					     ?debug  L 1593
   4261					;
   4262					;				   *(char *)(((struct qarg ks_stk *)p2)->data);
   4263					;
   4264					     ?debug  L 1594
   4265	1205  C4 5E FC			     les     bx,dword ptr [bp-4]
   4266	1208  26: C4 5F	08		     les     bx,dword ptr es:[bx+8]
   4267	120C  26: 8A 07			     mov     al,byte ptr es:[bx]
   4268	120F  C4 5E E0			     les     bx,dword ptr [bp-32]
   4269	1212  26: C4 5F	08		     les     bx,dword ptr es:[bx+8]
   4270	1216  26: 88 07			     mov     byte ptr es:[bx],al
   4271					;
   4272					;		       break;
   4273					;
   4274					     ?debug  L 1595
   4275	1219  EB 55			     jmp     short @2@7730
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 76
.\rtxc.asm



   4276	121B			     @2@7646:
   4277					;
   4278					;
   4279					;		    case sizeof(short):
   4280					;		       *(short *)(((struct qarg	ks_stk *)p2a)->data) =
   4281					;
   4282					     ?debug  L 1598
   4283					;
   4284					;				   *(short *)(((struct qarg ks_stk *)p2)->data);
   4285					;
   4286					     ?debug  L 1599
   4287	121B  C4 5E FC			     les     bx,dword ptr [bp-4]
   4288	121E  26: C4 5F	08		     les     bx,dword ptr es:[bx+8]
   4289	1222  26: 8B 07			     mov     ax,word ptr es:[bx]
   4290	1225  C4 5E E0			     les     bx,dword ptr [bp-32]
   4291	1228  26: C4 5F	08		     les     bx,dword ptr es:[bx+8]
   4292	122C  26: 89 07			     mov     word ptr es:[bx],ax
   4293					;
   4294					;		       break;
   4295					;
   4296					     ?debug  L 1600
   4297	122F  EB 3F			     jmp     short @2@7730
   4298	1231			     @2@7674:
   4299					;
   4300					;
   4301					;		    case sizeof(long):
   4302					;		       *(long *)(((struct qarg ks_stk *)p2a)->data) =
   4303					;
   4304					     ?debug  L 1603
   4305					;
   4306					;				   *(long *)(((struct qarg ks_stk *)p2)->data);
   4307					;
   4308					     ?debug  L 1604
   4309	1231  C4 5E FC			     les     bx,dword ptr [bp-4]
   4310	1234  26: C4 5F	08		     les     bx,dword ptr es:[bx+8]
   4311	1238  26: 8B 57	02		     mov     dx,word ptr es:[bx+2]
   4312	123C  26: 8B 07			     mov     ax,word ptr es:[bx]
   4313	123F  C4 5E E0			     les     bx,dword ptr [bp-32]
   4314	1242  26: C4 5F	08		     les     bx,dword ptr es:[bx+8]
   4315	1246  26: 89 57	02		     mov     word ptr es:[bx+2],dx
   4316	124A  26: 89 07			     mov     word ptr es:[bx],ax
   4317					;
   4318					;		       break;
   4319					;
   4320					     ?debug  L 1605
   4321	124D  EB 21			     jmp     short @2@7730
   4322	124F			     @2@7702:
   4323					;
   4324					;
   4325					;		    default:
   4326					;		       memcpy( ((struct	qarg ks_stk *)p2a)->data,
   4327					;
   4328					     ?debug  L 1608
   4329					;
   4330					;			       ((struct	qarg ks_stk *)p2)->data,
   4331					;			       width);
   4332					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 77
.\rtxc.asm



   4333					     ?debug  L 1610
   4334	124F  FF 76 CA			     push    word ptr [bp-54]
   4335	1252  C4 5E FC			     les     bx,dword ptr [bp-4]
   4336	1255  26: FF 77	0A		     push    word ptr es:[bx+10]
   4337	1259  26: FF 77	08		     push    word ptr es:[bx+8]
   4338	125D  C4 5E E0			     les     bx,dword ptr [bp-32]
   4339	1260  26: FF 77	0A		     push    word ptr es:[bx+10]
   4340	1264  26: FF 77	08		     push    word ptr es:[bx+8]
   4341	1268  9A 00000000se		     call    far ptr _memcpy
   4342	126D  83 C4 0A			     add     sp,10
   4343					;
   4344					;		       break;
   4345					;
   4346					     ?debug  L 1611
   4347	1270			     @2@7730:
   4348					;
   4349					;		 }
   4350					;    #endif /* } QUEUE_MEMCPY */
   4351					;
   4352					;    #ifdef CBUG /* { */
   4353					;		 pqh->count++; /* increment total no. of enqueues to date */
   4354					;    #endif /* } CBUG */
   4355					;
   4356					;    #ifdef QUEUE_SEMAS	/* { */
   4357					;		 /* queue was empty - process not empty	sema for consumer */
   4358					;		 UPDATE_SEMA(pqh->nesema);
   4359					;
   4360					     ?debug  L 1621
   4361	1270  8B 5E D0			     mov     bx,word ptr [bp-48]
   4362	1273  83 7F 12 00		     cmp     word ptr [bx+18],0
   4363	1277  74 41			     je	     short @2@7982
   4364	1279  8B 5F 12			     mov     bx,word ptr [bx+18]
   4365	127C  03 DB			     add     bx,bx
   4366	127E  83 BF 0000e FF		     cmp     word ptr DGROUP:_semat[bx],-1
   4367	1283  75 10			     jne     short @2@7814
   4368	1285  8B 5E D0			     mov     bx,word ptr [bp-48]
   4369	1288  8B 5F 12			     mov     bx,word ptr [bx+18]
   4370	128B  03 DB			     add     bx,bx
   4371	128D  C7 87 0000e 0000		     mov     word ptr DGROUP:_semat[bx],0
   4372	1293  EB 25			     jmp     short @2@7982
   4373	1295			     @2@7814:
   4374	1295  8B 5E D0			     mov     bx,word ptr [bp-48]
   4375	1298  8B 5F 12			     mov     bx,word ptr [bx+18]
   4376	129B  03 DB			     add     bx,bx
   4377	129D  83 BF 0000e 00		     cmp     word ptr DGROUP:_semat[bx],0
   4378	12A2  75 02			     jne     short @2@7870
   4379	12A4  EB 14			     jmp     short @2@7982
   4380	12A6			     @2@7870:
   4381	12A6  FA			     cli
   4382	12A7  90			     nop
   4383	12A8  8B 5E D0			     mov     bx,word ptr [bp-48]
   4384	12AB  8B 47 12			     mov     ax,word ptr [bx+18]
   4385	12AE  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
   4386	12B2  89 07			     mov     word ptr [bx],ax
   4387	12B4  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
   4388	12B9  FB			     sti
   4389	12BA			     @2@7982:
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 78
.\rtxc.asm



   4390					;
   4391					;
   4392					;		 /* queue was empty - process not full sema for	producer */
   4393					;		 if (pqh->nfsema)
   4394					;
   4395					     ?debug  L 1624
   4396	12BA  8B 5E D0			     mov     bx,word ptr [bp-48]
   4397	12BD  83 7F 16 00		     cmp     word ptr [bx+22],0
   4398	12C1  75 03			     jne     @@32
   4399	12C3  E9 0E08			     jmp     @2@15430
   4400	12C6			     @@32:
   4401					;
   4402					;		       semat[pqh->nfsema] = SEMA_DONE;
   4403					;
   4404					     ?debug  L 1625
   4405	12C6  E9 071F			     jmp     @2@12266
   4406	12C9			     @2@8038:
   4407					;
   4408					;    #endif /* } QUEUE_SEMAS */
   4409					;		 break;
   4410					;	      }
   4411					;    #endif /* } DEQUEUE_WAITERS */
   4412					;
   4413					;	      /* move data into	queue */
   4414					;	      pqh->curndx++;
   4415					;
   4416					     ?debug  L 1632
   4417	12C9  8B 5E D0			     mov     bx,word ptr [bp-48]
   4418	12CC  FF 47 0A			     inc     word ptr [bx+10]
   4419					;
   4420					;	      if (++pqh->putndx	== depth)
   4421					;
   4422					     ?debug  L 1633
   4423	12CF  FF 47 08			     inc     word ptr [bx+8]
   4424	12D2  8B 47 08			     mov     ax,word ptr [bx+8]
   4425	12D5  3B 46 CC			     cmp     ax,word ptr [bp-52]
   4426	12D8  75 05			     jne     short @2@8094
   4427					;
   4428					;		 pqh->putndx = 0;  /* recycle index */
   4429					;
   4430					     ?debug  L 1634
   4431	12DA  C7 47 08 0000		     mov     word ptr [bx+8],0
   4432	12DF			     @2@8094:
   4433					;
   4434					;
   4435					;	      qindex = pqh->putndx; /* local for speed */
   4436					;
   4437					     ?debug  L 1636
   4438	12DF  8B 5E D0			     mov     bx,word ptr [bp-48]
   4439	12E2  8B 47 08			     mov     ax,word ptr [bx+8]
   4440	12E5  89 46 CE			     mov     word ptr [bp-50],ax
   4441					;
   4442					;
   4443					;    #ifdef QUEUE_MEMCPY /* { */
   4444					;	      if (width)
   4445					;		 memcpy(pqh->base + (qindex * width),
   4446					;			((struct qarg ks_stk *)p2)->data, width);
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 79
.\rtxc.asm



   4447					;    #else /* }	QUEUE_MEMCPY { */
   4448					;	      switch(width)
   4449					;
   4450					     ?debug  L 1643
   4451	12E8  8B 5E CA			     mov     bx,word ptr [bp-54]
   4452	12EB  83 FB 04			     cmp     bx,4
   4453	12EE  77 61			     ja	     short @2@8290
   4454	12F0  03 DB			     add     bx,bx
   4455	12F2  2E: FF A7	2121r		     jmp     word ptr cs:@2@C14994[bx]
   4456	12F7			     @2@8206:
   4457					;
   4458					;	      {
   4459					;		 case 0:
   4460					;		    break;
   4461					;
   4462					;		 case sizeof(char):
   4463					;		    *(char *)(pqh->base	+ qindex) =
   4464					;
   4465					     ?debug  L 1649
   4466					;
   4467					;				       *(char *)(((struct qarg ks_stk *)p2)->data);
   4468					;
   4469					     ?debug  L 1650
   4470	12F7  C4 5E FC			     les     bx,dword ptr [bp-4]
   4471	12FA  26: C4 5F	08		     les     bx,dword ptr es:[bx+8]
   4472	12FE  26: 8A 07			     mov     al,byte ptr es:[bx]
   4473	1301  8B 5E D0			     mov     bx,word ptr [bp-48]
   4474	1304  C4 1F			     les     bx,dword ptr [bx]
   4475	1306  03 5E CE			     add     bx,word ptr [bp-50]
   4476	1309  26: 88 07			     mov     byte ptr es:[bx],al
   4477					;
   4478					;		    break;
   4479					;
   4480					     ?debug  L 1651
   4481	130C  EB 6E			     jmp     short @2@8318
   4482	130E			     @2@8234:
   4483					;
   4484					;
   4485					;		 case sizeof(short):
   4486					;		    *(short *)(pqh->base + (qindex << 1)) =
   4487					;
   4488					     ?debug  L 1654
   4489					;
   4490					;				       *(short *)(((struct qarg	ks_stk *)p2)->data);
   4491					;
   4492					     ?debug  L 1655
   4493	130E  8B 5E D0			     mov     bx,word ptr [bp-48]
   4494	1311  C4 1F			     les     bx,dword ptr [bx]
   4495	1313  8B 46 CE			     mov     ax,word ptr [bp-50]
   4496	1316  03 C0			     add     ax,ax
   4497	1318  03 D8			     add     bx,ax
   4498	131A  06			     push    es
   4499	131B  C4 76 FC			     les     si,dword ptr [bp-4]
   4500	131E  26: C4 74	08		     les     si,dword ptr es:[si+8]
   4501	1322  26: 8B 04			     mov     ax,word ptr es:[si]
   4502	1325  07			     pop     es
   4503	1326  26: 89 07			     mov     word ptr es:[bx],ax
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 80
.\rtxc.asm



   4504					;
   4505					;		    break;
   4506					;
   4507					     ?debug  L 1656
   4508	1329  EB 51			     jmp     short @2@8318
   4509	132B			     @2@8262:
   4510					;
   4511					;
   4512					;		 case sizeof(long):
   4513					;		    *(long *)(pqh->base	+ (qindex << 2)) =
   4514					;
   4515					     ?debug  L 1659
   4516					;
   4517					;				       *(long *)(((struct qarg ks_stk *)p2)->data);
   4518					;
   4519					     ?debug  L 1660
   4520	132B  8B 5E D0			     mov     bx,word ptr [bp-48]
   4521	132E  C4 1F			     les     bx,dword ptr [bx]
   4522	1330  8B 46 CE			     mov     ax,word ptr [bp-50]
   4523	1333  C1 E0 02			     shl     ax,2
   4524	1336  03 D8			     add     bx,ax
   4525	1338  06			     push    es
   4526	1339  C4 76 FC			     les     si,dword ptr [bp-4]
   4527	133C  26: C4 74	08		     les     si,dword ptr es:[si+8]
   4528	1340  26: 8B 54	02		     mov     dx,word ptr es:[si+2]
   4529	1344  26: 8B 04			     mov     ax,word ptr es:[si]
   4530	1347  07			     pop     es
   4531	1348  26: 89 57	02		     mov     word ptr es:[bx+2],dx
   4532	134C  26: 89 07			     mov     word ptr es:[bx],ax
   4533					;
   4534					;		    break;
   4535					;
   4536					     ?debug  L 1661
   4537	134F  EB 2B			     jmp     short @2@8318
   4538	1351			     @2@8290:
   4539					;
   4540					;
   4541					;		 default:
   4542					;		    memcpy(pqh->base + (qindex * width),
   4543					;
   4544					     ?debug  L 1664
   4545					;
   4546					;			    ((struct qarg ks_stk *)p2)->data,
   4547					;			    width);
   4548					;
   4549					     ?debug  L 1666
   4550	1351  FF 76 CA			     push    word ptr [bp-54]
   4551	1354  C4 5E FC			     les     bx,dword ptr [bp-4]
   4552	1357  26: FF 77	0A		     push    word ptr es:[bx+10]
   4553	135B  26: FF 77	08		     push    word ptr es:[bx+8]
   4554	135F  8B 5E D0			     mov     bx,word ptr [bp-48]
   4555	1362  8B 07			     mov     ax,word ptr [bx]
   4556	1364  53			     push    bx
   4557	1365  50			     push    ax
   4558	1366  8B 46 CE			     mov     ax,word ptr [bp-50]
   4559	1369  F7 6E CA			     imul    word ptr [bp-54]
   4560	136C  5A			     pop     dx
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 81
.\rtxc.asm



   4561	136D  03 D0			     add     dx,ax
   4562	136F  5B			     pop     bx
   4563	1370  FF 77 02			     push    word ptr [bx+2]
   4564	1373  52			     push    dx
   4565	1374  9A 00000000se		     call    far ptr _memcpy
   4566	1379  83 C4 0A			     add     sp,10
   4567					;
   4568					;		    break;
   4569					;
   4570					     ?debug  L 1667
   4571	137C			     @2@8318:
   4572					;
   4573					;	      }
   4574					;    #endif /* } QUEUE_MEMCPY */
   4575					;
   4576					;    #ifdef CBUG /* { */
   4577					;	      pqh->count++; /* increment total no. of enqueues to date */
   4578					;	      if (pqh->curndx >	pqh->worst) /* check for new worst case	full condition */
   4579					;		 pqh->worst = pqh->curndx;
   4580					;    #endif /* } CBUG */
   4581					;
   4582					;    #ifdef QUEUE_SEMAS	/* { */
   4583					;	      if (pqh->curndx == depth)		      /* queue is now full */
   4584					;
   4585					     ?debug  L 1678
   4586	137C  8B 5E D0			     mov     bx,word ptr [bp-48]
   4587	137F  8B 47 0A			     mov     ax,word ptr [bx+10]
   4588	1382  3B 46 CC			     cmp     ax,word ptr [bp-52]
   4589	1385  75 55			     jne     short @2@8682
   4590					;
   4591					;	      {
   4592					;		 if (pqh->nfsema)
   4593					;
   4594					     ?debug  L 1680
   4595	1387  83 7F 16 00		     cmp     word ptr [bx+22],0
   4596	138B  74 0B			     je	     short @2@8402
   4597					;
   4598					;		    semat[pqh->nfsema] = SEMA_PENDING; /*set not full sema pending*/
   4599					;
   4600					     ?debug  L 1681
   4601	138D  8B 5F 16			     mov     bx,word ptr [bx+22]
   4602	1390  03 DB			     add     bx,bx
   4603	1392  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
   4604	1398			     @2@8402:
   4605					;
   4606					;
   4607					;		 UPDATE_SEMA(pqh->fsema);
   4608					;
   4609					     ?debug  L 1683
   4610	1398  8B 5E D0			     mov     bx,word ptr [bp-48]
   4611	139B  83 7F 10 00		     cmp     word ptr [bx+16],0
   4612	139F  74 4F			     je	     short @2@8766
   4613	13A1  8B 5F 10			     mov     bx,word ptr [bx+16]
   4614	13A4  03 DB			     add     bx,bx
   4615	13A6  83 BF 0000e FF		     cmp     word ptr DGROUP:_semat[bx],-1
   4616	13AB  75 08			     jne     short @2@8486
   4617	13AD  8B 5E D0			     mov     bx,word ptr [bp-48]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 82
.\rtxc.asm



   4618	13B0  8B 5F 10			     mov     bx,word ptr [bx+16]
   4619	13B3  EB 33			     jmp     short @2@8738
   4620	13B5			     @2@8486:
   4621	13B5  8B 5E D0			     mov     bx,word ptr [bp-48]
   4622	13B8  8B 5F 10			     mov     bx,word ptr [bx+16]
   4623	13BB  03 DB			     add     bx,bx
   4624	13BD  83 BF 0000e 00		     cmp     word ptr DGROUP:_semat[bx],0
   4625	13C2  75 02			     jne     short @2@8542
   4626	13C4  EB 2A			     jmp     short @2@8766
   4627	13C6			     @2@8542:
   4628	13C6  FA			     cli
   4629	13C7  90			     nop
   4630	13C8  8B 5E D0			     mov     bx,word ptr [bp-48]
   4631	13CB  8B 47 10			     mov     ax,word ptr [bx+16]
   4632	13CE  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
   4633	13D2  89 07			     mov     word ptr [bx],ax
   4634	13D4  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
   4635	13D9  FB			     sti
   4636					;
   4637					;	      }
   4638					;
   4639					     ?debug  L 1684
   4640	13DA  EB 14			     jmp     short @2@8766
   4641	13DC			     @2@8682:
   4642					;
   4643					;	      else				 /* still room in queue	*/
   4644					;	      {
   4645					;		 if (pqh->nfsema)
   4646					;
   4647					     ?debug  L 1687
   4648	13DC  8B 5E D0			     mov     bx,word ptr [bp-48]
   4649	13DF  83 7F 16 00		     cmp     word ptr [bx+22],0
   4650	13E3  74 0B			     je	     short @2@8766
   4651					;
   4652					;		    semat[pqh->nfsema] = SEMA_DONE;
   4653					;
   4654					     ?debug  L 1688
   4655	13E5  8B 5F 16			     mov     bx,word ptr [bx+22]
   4656	13E8			     @2@8738:
   4657	13E8  03 DB			     add     bx,bx
   4658	13EA  C7 87 0000e 0000		     mov     word ptr DGROUP:_semat[bx],0
   4659	13F0			     @2@8766:
   4660					;
   4661					;	      }
   4662					;
   4663					;	      if (pqh->curndx == 1) /* if was empty */
   4664					;
   4665					     ?debug  L 1691
   4666	13F0  8B 5E D0			     mov     bx,word ptr [bp-48]
   4667	13F3  83 7F 0A 01		     cmp     word ptr [bx+10],1
   4668	13F7  74 03			     je	     @@33
   4669	13F9  E9 0CD2			     jmp     @2@15430
   4670	13FC			     @@33:
   4671					;
   4672					;	      {
   4673					;		 if (pqh->esema)
   4674					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 83
.\rtxc.asm



   4675					     ?debug  L 1693
   4676	13FC  83 7F 14 00		     cmp     word ptr [bx+20],0
   4677	1400  74 0B			     je	     short @2@8850
   4678					;
   4679					;		    semat[pqh->esema] =	SEMA_PENDING;
   4680					;
   4681					     ?debug  L 1694
   4682	1402  8B 5F 14			     mov     bx,word ptr [bx+20]
   4683	1405  03 DB			     add     bx,bx
   4684	1407  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
   4685	140D			     @2@8850:
   4686					;
   4687					;
   4688					;		 UPDATE_SEMA(pqh->nesema);
   4689					;
   4690					     ?debug  L 1696
   4691	140D  8B 5E D0			     mov     bx,word ptr [bp-48]
   4692	1410  83 7F 12 00		     cmp     word ptr [bx+18],0
   4693	1414  75 03			     jne     @@34
   4694	1416  E9 0CB5			     jmp     @2@15430
   4695	1419			     @@34:
   4696	1419  8B 5F 12			     mov     bx,word ptr [bx+18]
   4697	141C  03 DB			     add     bx,bx
   4698	141E  83 BF 0000e FF		     cmp     word ptr DGROUP:_semat[bx],-1
   4699	1423  75 03			     jne     short @2@8934
   4700	1425  E9 0589			     jmp     @2@12182
   4701	1428			     @2@8934:
   4702	1428  8B 5E D0			     mov     bx,word ptr [bp-48]
   4703	142B  8B 5F 12			     mov     bx,word ptr [bx+18]
   4704	142E  03 DB			     add     bx,bx
   4705	1430  83 BF 0000e 00		     cmp     word ptr DGROUP:_semat[bx],0
   4706	1435  75 03			     jne     short @2@8990
   4707	1437  E9 0C94			     jmp     @2@15430
   4708	143A			     @2@8990:
   4709	143A  FA			     cli
   4710	143B  90			     nop
   4711	143C  8B 5E D0			     mov     bx,word ptr [bp-48]
   4712	143F  8B 47 12			     mov     ax,word ptr [bx+18]
   4713	1442  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
   4714	1446  89 07			     mov     word ptr [bx],ax
   4715	1448  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
   4716	144D  FB			     sti
   4717					;
   4718					;	      }
   4719					;    #endif /* } QUEUE_SEMAS */
   4720					;	      break;
   4721					;
   4722					     ?debug  L 1699
   4723	144E  E9 0C7D			     jmp     @2@15430
   4724	1451			     @2@9130:
   4725					;
   4726					;    #endif /* } HAS_ENQUEUE */
   4727					;
   4728					;    #ifdef HAS_DEQUEUE	/* { */
   4729					;    /************************/
   4730					;	   case	RTXC_DEQUEUE:
   4731					;    /************************/
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 84
.\rtxc.asm



   4732					;	      pqh = &qheader[((struct qarg ks_stk *)p2)->queue];
   4733					;
   4734					     ?debug  L 1706
   4735	1451  C4 5E FC			     les     bx,dword ptr [bp-4]
   4736	1454  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
   4737	1458  6B C0 18			     imul    ax,ax,24
   4738	145B  05 0000e			     add     ax,offset DGROUP:_qheader
   4739	145E  89 46 D0			     mov     word ptr [bp-48],ax
   4740					;
   4741					;
   4742					;	      if (pqh->curndx == 0)  /*	empty queue */
   4743					;
   4744					     ?debug  L 1708
   4745	1461  8B 5E D0			     mov     bx,word ptr [bp-48]
   4746	1464  83 7F 0A 00		     cmp     word ptr [bx+10],0
   4747	1468  74 03			     je	     @@35
   4748	146A  E9 00A8			     jmp     @2@9298
   4749	146D			     @@35:
   4750					;
   4751					;	      {
   4752					;    #ifdef DEQUEUE_WAITERS /* { */
   4753					;		 if ( ((struct qarg ks_stk *)p2)->wait)
   4754					;
   4755					     ?debug  L 1711
   4756	146D  8B 5E FC			     mov     bx,word ptr [bp-4]
   4757	1470  26: 83 7F	0C 00		     cmp     word ptr es:[bx+12],0
   4758	1475  75 03			     jne     @@36
   4759	1477  E9 0C54			     jmp     @2@15430
   4760	147A			     @@36:
   4761					;
   4762					;		 {
   4763					;		    ptcb = hipritsk; /*	save copy of hipritsk */
   4764					;
   4765					     ?debug  L 1713
   4766	147A  A1 0000r			     mov     ax,word ptr DGROUP:_hipritsk
   4767	147D  89 46 F6			     mov     word ptr [bp-10],ax
   4768					;
   4769					;
   4770					;		    ptcb->status = QUEUE_WAIT; /* set QUEUE_WAIT in status */
   4771					;
   4772					     ?debug  L 1715
   4773	1480  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   4774	1484  C7 47 10 0080		     mov     word ptr [bx+16],128
   4775					;
   4776					;
   4777					;		    /* thread waiting task in priority order */
   4778					;		    porder((TCB	near *)&pqh->waiters);
   4779					;
   4780					     ?debug  L 1718
   4781	1489  8B 46 D0			     mov     ax,word ptr [bp-48]
   4782	148C  05 000C			     add     ax,12
   4783	148F  50			     push    ax
   4784	1490  E8 195B			     call    near ptr porder
   4785	1493  83 C4 02			     add     sp,2
   4786					;
   4787					;
   4788					;    #ifdef DEQUEUE_TIMEOUTS /*	{ */
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 85
.\rtxc.asm



   4789					;		    if ( ((struct qarg ks_stk *)p2)->ticks) /* if timeout active */
   4790					;
   4791					     ?debug  L 1721
   4792	1496  C4 5E FC			     les     bx,dword ptr [bp-4]
   4793	1499  26: 8B 47	0E		     mov     ax,word ptr es:[bx+14]
   4794	149D  26: 0B 47	10		     or	     ax,word ptr es:[bx+16]
   4795	14A1  75 03			     jne     @@37
   4796	14A3  E9 0C28			     jmp     @2@15430
   4797	14A6			     @@37:
   4798	14A6			     @2@9214:
   4799					;
   4800					;		    {
   4801					;		       ptcb->pclkblk = ((struct	qarg ks_stk *)p2)->pclkblk;
   4802					;
   4803					     ?debug  L 1723
   4804	14A6  C4 5E FC			     les     bx,dword ptr [bp-4]
   4805	14A9  26: 8B 57	14		     mov     dx,word ptr es:[bx+20]
   4806	14AD  26: 8B 47	12		     mov     ax,word ptr es:[bx+18]
   4807	14B1  8B 5E F6			     mov     bx,word ptr [bp-10]
   4808	14B4  89 57 06			     mov     word ptr [bx+6],dx
   4809	14B7  89 47 04			     mov     word ptr [bx+4],ax
   4810					;
   4811					;		       pclkblk = ptcb->pclkblk;
   4812					;
   4813					     ?debug  L 1724
   4814	14BA  8B 57 06			     mov     dx,word ptr [bx+6]
   4815	14BD  8B 47 04			     mov     ax,word ptr [bx+4]
   4816	14C0  89 56 F2			     mov     word ptr [bp-14],dx
   4817	14C3  89 46 F0			     mov     word ptr [bp-16],ax
   4818					;
   4819					;		       pclkblk->remain = ((struct qarg ks_stk *)p2)->ticks;
   4820					;
   4821					     ?debug  L 1725
   4822	14C6  8B 5E FC			     mov     bx,word ptr [bp-4]
   4823	14C9  26: 8B 57	10		     mov     dx,word ptr es:[bx+16]
   4824	14CD  26: 8B 47	0E		     mov     ax,word ptr es:[bx+14]
   4825	14D1  C4 5E F0			     les     bx,dword ptr [bp-16]
   4826	14D4  26: 89 57	0A		     mov     word ptr es:[bx+10],dx
   4827	14D8  26: 89 47	08		     mov     word ptr es:[bx+8],ax
   4828					;
   4829					;		       pclkblk->recycle	= (TICKS)0;
   4830					;
   4831					     ?debug  L 1726
   4832	14DC  26: C7 47	0E 0000		     mov     word ptr es:[bx+14],0
   4833	14E2  26: C7 47	0C 0000		     mov     word ptr es:[bx+12],0
   4834					;
   4835					;
   4836					;		       /* mark object type */
   4837					;		       pclkblk->objtype	= QUEUE_OBJ;
   4838					;
   4839					     ?debug  L 1729
   4840	14E8  26: C7 47	14 0003		     mov     word ptr es:[bx+20],3
   4841					;
   4842					;		       pclkblk->objid =	((struct qarg ks_stk *)p2)->queue;
   4843					;
   4844					     ?debug  L 1730
   4845	14EE  C4 5E FC			     les     bx,dword ptr [bp-4]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 86
.\rtxc.asm



   4846	14F1  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
   4847	14F5  C4 5E F0			     les     bx,dword ptr [bp-16]
   4848	14F8  26: 89 47	16		     mov     word ptr es:[bx+22],ax
   4849					;
   4850					;		       pclkblk->task = ptcb->task;
   4851					;
   4852					     ?debug  L 1731
   4853	14FC  8B 76 F6			     mov     si,word ptr [bp-10]
   4854	14FF  8B 44 08			     mov     ax,word ptr [si+8]
   4855	1502			     @2@9242:
   4856	1502  26: 89 47	10		     mov     word ptr es:[bx+16],ax
   4857					;
   4858					;
   4859					;		       /* insert timer */
   4860					;		       insert_timer(pclkblk);
   4861					;
   4862					     ?debug  L 1734
   4863	1506			     @2@9270:
   4864	1506  FF 76 F2			     push    word ptr [bp-14]
   4865	1509  FF 76 F0			     push    word ptr [bp-16]
   4866	150C  E8 17E5			     call    near ptr insert_timer
   4867	150F  83 C4 04			     add     sp,4
   4868	1512  E9 0BB9			     jmp     @2@15430
   4869	1515			     @2@9298:
   4870					;
   4871					;		    }
   4872					;
   4873					;    #endif /* } DEQUEUE_TIMEOUTS */
   4874					;		 }
   4875					;
   4876					;    #endif /* } DEQUEUE_WAITERS */
   4877					;		 break;
   4878					;	      }
   4879					;
   4880					;	      /* queue not empty, get entry */
   4881					;
   4882					;	      ((struct qarg ks_stk *)p2)->ksrc = RC_GOOD;
   4883					;
   4884					     ?debug  L 1746
   4885	1515  C4 5E FC			     les     bx,dword ptr [bp-4]
   4886	1518  26: C7 47	02 0000		     mov     word ptr es:[bx+2],0
   4887					;
   4888					;
   4889					;	      qindex = pqh->putndx - --pqh->curndx;
   4890					;
   4891					     ?debug  L 1748
   4892	151E  8B 5E D0			     mov     bx,word ptr [bp-48]
   4893	1521  8B 47 08			     mov     ax,word ptr [bx+8]
   4894	1524  FF 4F 0A			     dec     word ptr [bx+10]
   4895	1527  8B 57 0A			     mov     dx,word ptr [bx+10]
   4896	152A  2B C2			     sub     ax,dx
   4897	152C  89 46 CE			     mov     word ptr [bp-50],ax
   4898					;
   4899					;	      if (qindex < 0)
   4900					;
   4901					     ?debug  L 1749
   4902	152F  83 7E CE 00		     cmp     word ptr [bp-50],0
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 87
.\rtxc.asm



   4903	1533  7D 06			     jge     short @2@9354
   4904					;
   4905					;		 qindex	+= pqh->depth;	/* wrap	around */
   4906					;
   4907					     ?debug  L 1750
   4908	1535  8B 47 06			     mov     ax,word ptr [bx+6]
   4909	1538  01 46 CE			     add     word ptr [bp-50],ax
   4910	153B			     @2@9354:
   4911					;
   4912					;
   4913					;    #ifdef QUEUE_MEMCPY /* { */
   4914					;	      if ( (width = pqh->width)	!= 0)
   4915					;		 memcpy( ((struct qarg ks_stk *)p2)->data,
   4916					;			 pqh->base + (qindex * width),
   4917					;			 width);
   4918					;    #else /* }	QUEUE_MEMCPY { */
   4919					;	      switch(width = pqh->width)
   4920					;
   4921					     ?debug  L 1758
   4922	153B  8B 5E D0			     mov     bx,word ptr [bp-48]
   4923	153E  8B 47 04			     mov     ax,word ptr [bx+4]
   4924	1541  89 46 CA			     mov     word ptr [bp-54],ax
   4925	1544  8B D8			     mov     bx,ax
   4926	1546  83 FB 04			     cmp     bx,4
   4927	1549  77 5D			     ja	     short @2@9522
   4928	154B  03 DB			     add     bx,bx
   4929	154D  2E: FF A7	2117r		     jmp     word ptr cs:@2@C14914[bx]
   4930	1552			     @2@9438:
   4931					;
   4932					;	      {
   4933					;		 case 0:
   4934					;		    break;
   4935					;
   4936					;		 case sizeof(char):
   4937					;		    *(char *)(((struct qarg ks_stk *)p2)->data)	=
   4938					;
   4939					     ?debug  L 1764
   4940					;
   4941					;					      *(char *)(pqh->base + qindex);
   4942					;
   4943					     ?debug  L 1765
   4944	1552  8B 5E D0			     mov     bx,word ptr [bp-48]
   4945	1555  C4 1F			     les     bx,dword ptr [bx]
   4946	1557  03 5E CE			     add     bx,word ptr [bp-50]
   4947	155A  26: 8A 07			     mov     al,byte ptr es:[bx]
   4948	155D  C4 5E FC			     les     bx,dword ptr [bp-4]
   4949	1560  26: C4 5F	08		     les     bx,dword ptr es:[bx+8]
   4950	1564  26: 88 07			     mov     byte ptr es:[bx],al
   4951					;
   4952					;		    break;
   4953					;
   4954					     ?debug  L 1766
   4955	1567  EB 6A			     jmp     short @2@9550
   4956	1569			     @2@9466:
   4957					;
   4958					;
   4959					;		 case sizeof(short):
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 88
.\rtxc.asm



   4960					;		    *(short *)(((struct	qarg ks_stk *)p2)->data) =
   4961					;
   4962					     ?debug  L 1769
   4963					;
   4964					;					      *(short *)(pqh->base + (qindex <<	1));
   4965					;
   4966					     ?debug  L 1770
   4967	1569  8B 5E D0			     mov     bx,word ptr [bp-48]
   4968	156C  C4 1F			     les     bx,dword ptr [bx]
   4969	156E  8B 46 CE			     mov     ax,word ptr [bp-50]
   4970	1571  03 C0			     add     ax,ax
   4971	1573  03 D8			     add     bx,ax
   4972	1575  26: 8B 07			     mov     ax,word ptr es:[bx]
   4973	1578  C4 5E FC			     les     bx,dword ptr [bp-4]
   4974	157B  26: C4 5F	08		     les     bx,dword ptr es:[bx+8]
   4975	157F  26: 89 07			     mov     word ptr es:[bx],ax
   4976					;
   4977					;		    break;
   4978					;
   4979					     ?debug  L 1771
   4980	1582  EB 4F			     jmp     short @2@9550
   4981	1584			     @2@9494:
   4982					;
   4983					;
   4984					;		 case sizeof(long):
   4985					;		    *(long *)(((struct qarg ks_stk *)p2)->data)	=
   4986					;
   4987					     ?debug  L 1774
   4988					;
   4989					;					      *(long *)(pqh->base + (qindex << 2));
   4990					;
   4991					     ?debug  L 1775
   4992	1584  8B 5E D0			     mov     bx,word ptr [bp-48]
   4993	1587  C4 1F			     les     bx,dword ptr [bx]
   4994	1589  8B 46 CE			     mov     ax,word ptr [bp-50]
   4995	158C  C1 E0 02			     shl     ax,2
   4996	158F  03 D8			     add     bx,ax
   4997	1591  26: 8B 57	02		     mov     dx,word ptr es:[bx+2]
   4998	1595  26: 8B 07			     mov     ax,word ptr es:[bx]
   4999	1598  C4 5E FC			     les     bx,dword ptr [bp-4]
   5000	159B  26: C4 5F	08		     les     bx,dword ptr es:[bx+8]
   5001	159F  26: 89 57	02		     mov     word ptr es:[bx+2],dx
   5002	15A3  26: 89 07			     mov     word ptr es:[bx],ax
   5003					;
   5004					;		    break;
   5005					;
   5006					     ?debug  L 1776
   5007	15A6  EB 2B			     jmp     short @2@9550
   5008	15A8			     @2@9522:
   5009					;
   5010					;
   5011					;		 default:
   5012					;		    memcpy( ((struct qarg ks_stk *)p2)->data,
   5013					;
   5014					     ?debug  L 1779
   5015					;
   5016					;			    pqh->base +	(qindex	* width),
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 89
.\rtxc.asm



   5017					;			    width);
   5018					;
   5019					     ?debug  L 1781
   5020	15A8  FF 76 CA			     push    word ptr [bp-54]
   5021	15AB  8B 5E D0			     mov     bx,word ptr [bp-48]
   5022	15AE  8B 07			     mov     ax,word ptr [bx]
   5023	15B0  53			     push    bx
   5024	15B1  50			     push    ax
   5025	15B2  8B 46 CE			     mov     ax,word ptr [bp-50]
   5026	15B5  F7 6E CA			     imul    word ptr [bp-54]
   5027	15B8  5A			     pop     dx
   5028	15B9  03 D0			     add     dx,ax
   5029	15BB  5B			     pop     bx
   5030	15BC  FF 77 02			     push    word ptr [bx+2]
   5031	15BF  52			     push    dx
   5032	15C0  C4 5E FC			     les     bx,dword ptr [bp-4]
   5033	15C3  26: FF 77	0A		     push    word ptr es:[bx+10]
   5034	15C7  26: FF 77	08		     push    word ptr es:[bx+8]
   5035	15CB  9A 00000000se		     call    far ptr _memcpy
   5036	15D0  83 C4 0A			     add     sp,10
   5037					;
   5038					;		    break;
   5039					;
   5040					     ?debug  L 1782
   5041	15D3			     @2@9550:
   5042					;
   5043					;	      }
   5044					;    #endif /* } QUEUE_MEMCPY */
   5045					;
   5046					;    #ifdef QUEUE_SEMAS	/* { */
   5047					;	      if (pqh->curndx == 0)  /*	just dequeued last item	(now empty) */
   5048					;
   5049					     ?debug  L 1787
   5050	15D3  8B 5E D0			     mov     bx,word ptr [bp-48]
   5051	15D6  83 7F 0A 00		     cmp     word ptr [bx+10],0
   5052	15DA  75 55			     jne     short @2@9914
   5053					;
   5054					;	      {
   5055					;		 if (pqh->nesema)
   5056					;
   5057					     ?debug  L 1789
   5058	15DC  83 7F 12 00		     cmp     word ptr [bx+18],0
   5059	15E0  74 0B			     je	     short @2@9634
   5060					;
   5061					;		    semat[pqh->nesema] = SEMA_PENDING; /* pend not empty sema */
   5062					;
   5063					     ?debug  L 1790
   5064	15E2  8B 5F 12			     mov     bx,word ptr [bx+18]
   5065	15E5  03 DB			     add     bx,bx
   5066	15E7  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
   5067	15ED			     @2@9634:
   5068					;
   5069					;
   5070					;		 UPDATE_SEMA(pqh->esema);
   5071					;
   5072					     ?debug  L 1792
   5073	15ED  8B 5E D0			     mov     bx,word ptr [bp-48]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 90
.\rtxc.asm



   5074	15F0  83 7F 14 00		     cmp     word ptr [bx+20],0
   5075	15F4  74 4F			     je	     short @2@9998
   5076	15F6  8B 5F 14			     mov     bx,word ptr [bx+20]
   5077	15F9  03 DB			     add     bx,bx
   5078	15FB  83 BF 0000e FF		     cmp     word ptr DGROUP:_semat[bx],-1
   5079	1600  75 08			     jne     short @2@9718
   5080	1602  8B 5E D0			     mov     bx,word ptr [bp-48]
   5081	1605  8B 5F 14			     mov     bx,word ptr [bx+20]
   5082	1608  EB 33			     jmp     short @2@9970
   5083	160A			     @2@9718:
   5084	160A  8B 5E D0			     mov     bx,word ptr [bp-48]
   5085	160D  8B 5F 14			     mov     bx,word ptr [bx+20]
   5086	1610  03 DB			     add     bx,bx
   5087	1612  83 BF 0000e 00		     cmp     word ptr DGROUP:_semat[bx],0
   5088	1617  75 02			     jne     short @2@9774
   5089	1619  EB 2A			     jmp     short @2@9998
   5090	161B			     @2@9774:
   5091	161B  FA			     cli
   5092	161C  90			     nop
   5093	161D  8B 5E D0			     mov     bx,word ptr [bp-48]
   5094	1620  8B 47 14			     mov     ax,word ptr [bx+20]
   5095	1623  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
   5096	1627  89 07			     mov     word ptr [bx],ax
   5097	1629  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
   5098	162E  FB			     sti
   5099					;
   5100					;	      }
   5101					;
   5102					     ?debug  L 1793
   5103	162F  EB 14			     jmp     short @2@9998
   5104	1631			     @2@9914:
   5105					;
   5106					;	      else /* there are	still more entries in queue */
   5107					;	      {
   5108					;		 if (pqh->nesema)
   5109					;
   5110					     ?debug  L 1796
   5111	1631  8B 5E D0			     mov     bx,word ptr [bp-48]
   5112	1634  83 7F 12 00		     cmp     word ptr [bx+18],0
   5113	1638  74 0B			     je	     short @2@9998
   5114					;
   5115					;		    semat[pqh->nesema] = SEMA_DONE; /* set not empty sema done */
   5116					;
   5117					     ?debug  L 1797
   5118	163A  8B 5F 12			     mov     bx,word ptr [bx+18]
   5119	163D			     @2@9970:
   5120	163D  03 DB			     add     bx,bx
   5121	163F  C7 87 0000e 0000		     mov     word ptr DGROUP:_semat[bx],0
   5122	1645			     @2@9998:
   5123					;
   5124					;	      }
   5125					;    #endif /* } QUEUE_SEMAS */
   5126					;
   5127					;    #ifdef ENQUEUE_WAITERS /* { */
   5128					;	      if (pqh->curndx == pqh->depth - 1)  /* queue was full before deq */
   5129					;
   5130					     ?debug  L 1802
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 91
.\rtxc.asm



   5131	1645  8B 5E D0			     mov     bx,word ptr [bp-48]
   5132	1648  8B 76 D0			     mov     si,word ptr [bp-48]
   5133	164B  8B 44 06			     mov     ax,word ptr [si+6]
   5134	164E  48			     dec     ax
   5135	164F  39 47 0A			     cmp     word ptr [bx+10],ax
   5136	1652  74 03			     je	     @@38
   5137	1654  E9 0257			     jmp     @2@11594
   5138	1657			     @@38:
   5139					;
   5140					;	      {
   5141					;		 /* insert first waiter	into insert list */
   5142					;		 if ( (ptcb = pqh->waiters) != NULLTCB)
   5143					;
   5144					     ?debug  L 1805
   5145	1657  8B 47 0C			     mov     ax,word ptr [bx+12]
   5146	165A  89 46 F6			     mov     word ptr [bp-10],ax
   5147	165D  0B C0			     or	     ax,ax
   5148	165F  75 03			     jne     @@39
   5149	1661  E9 01F2			     jmp     @2@11258
   5150	1664			     @@39:
   5151					;
   5152					;		 {
   5153					;		    /* remove highest priority waiter */
   5154					;		    if ( (pqh->waiters = ptcb->flink) != NULLTCB)
   5155					;
   5156					     ?debug  L 1808
   5157	1664  8B 5E F6			     mov     bx,word ptr [bp-10]
   5158	1667  8B 07			     mov     ax,word ptr [bx]
   5159	1669  8B 5E D0			     mov     bx,word ptr [bp-48]
   5160	166C  89 47 0C			     mov     word ptr [bx+12],ax
   5161	166F  0B C0			     or	     ax,ax
   5162	1671  74 0E			     je	     short @2@10110
   5163					;
   5164					;		       ptcb->flink->blink = (TCB near *)&pqh->waiters;
   5165					;
   5166					     ?debug  L 1809
   5167	1673  8B 46 D0			     mov     ax,word ptr [bp-48]
   5168	1676  05 000C			     add     ax,12
   5169	1679  8B 5E F6			     mov     bx,word ptr [bp-10]
   5170	167C  8B 1F			     mov     bx,word ptr [bx]
   5171	167E  89 47 02			     mov     word ptr [bx+2],ax
   5172	1681			     @2@10110:
   5173					;
   5174					;
   5175					;		    if ( (ptcb->status &= ~QUEUE_WAIT) == READY)
   5176					;
   5177					     ?debug  L 1811
   5178	1681  8B 5E F6			     mov     bx,word ptr [bp-10]
   5179	1684  81 67 10 FF7F		     and     word ptr [bx+16],-129
   5180	1689  8B 47 10			     mov     ax,word ptr [bx+16]
   5181	168C  0B C0			     or	     ax,ax
   5182	168E  75 0B			     jne     short @2@10166
   5183					;
   5184					;		    {
   5185					;		       ptcb->flink = nsrttcb;
   5186					;
   5187					     ?debug  L 1813
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 92
.\rtxc.asm



   5188	1690  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
   5189	1693  89 07			     mov     word ptr [bx],ax
   5190					;
   5191					;		       nsrttcb = ptcb;
   5192					;
   5193					     ?debug  L 1814
   5194	1695  8B 46 F6			     mov     ax,word ptr [bp-10]
   5195	1698  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
   5196	169B			     @2@10166:
   5197					;
   5198					;		    }
   5199					;
   5200					;    #ifdef ENQUEUE_TIMEOUTS /*	{ */
   5201					;		    /* cleanup any pending timeout */
   5202					;		    if ( (pclkblk = ptcb->pclkblk) != NULLCLK)
   5203					;
   5204					     ?debug  L 1819
   5205	169B  8B 5E F6			     mov     bx,word ptr [bp-10]
   5206	169E  8B 57 06			     mov     dx,word ptr [bx+6]
   5207	16A1  8B 47 04			     mov     ax,word ptr [bx+4]
   5208	16A4  89 56 F2			     mov     word ptr [bp-14],dx
   5209	16A7  89 46 F0			     mov     word ptr [bp-16],ax
   5210	16AA  0B C2			     or	     ax,dx
   5211	16AC  74 17			     je	     short @2@10222
   5212					;
   5213					;		    {
   5214					;		       unlink_timer(pclkblk);
   5215					;
   5216					     ?debug  L 1821
   5217	16AE  52			     push    dx
   5218	16AF  FF 76 F0			     push    word ptr [bp-16]
   5219	16B2  E8 16FA			     call    near ptr unlink_timer
   5220	16B5  83 C4 04			     add     sp,4
   5221					;
   5222					;		       ptcb->pclkblk = NULLCLK;
   5223					;
   5224					     ?debug  L 1822
   5225	16B8  8B 5E F6			     mov     bx,word ptr [bp-10]
   5226	16BB  C7 47 06 0000		     mov     word ptr [bx+6],0
   5227	16C0  C7 47 04 0000		     mov     word ptr [bx+4],0
   5228	16C5			     @2@10222:
   5229					;
   5230					;		    }
   5231					;    #endif /* } ENQUEUE_TIMEOUTS */
   5232					;
   5233					;		    /* perform enqueue for waiter */
   5234					;
   5235					;		    pqh->curndx++;
   5236					;
   5237					     ?debug  L 1828
   5238	16C5  8B 5E D0			     mov     bx,word ptr [bp-48]
   5239	16C8  FF 47 0A			     inc     word ptr [bx+10]
   5240					;
   5241					;		    if (++pqh->putndx == pqh->depth)
   5242					;
   5243					     ?debug  L 1829
   5244	16CB  FF 47 08			     inc     word ptr [bx+8]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 93
.\rtxc.asm



   5245	16CE  8B 47 08			     mov     ax,word ptr [bx+8]
   5246	16D1  3B 47 06			     cmp     ax,word ptr [bx+6]
   5247	16D4  75 05			     jne     short @2@10278
   5248					;
   5249					;		       pqh->putndx = 0;	 /* recycle index */
   5250					;
   5251					     ?debug  L 1830
   5252	16D6  C7 47 08 0000		     mov     word ptr [bx+8],0
   5253	16DB			     @2@10278:
   5254					;
   5255					;
   5256					;		    qindex = pqh->putndx; /* local for speed */
   5257					;
   5258					     ?debug  L 1832
   5259	16DB  8B 5E D0			     mov     bx,word ptr [bp-48]
   5260	16DE  8B 47 08			     mov     ax,word ptr [bx+8]
   5261	16E1  89 46 CE			     mov     word ptr [bp-50],ax
   5262					;
   5263					;
   5264					;		    p2a	= ((FRAME ks_stk *)(ptcb->sp))->pksnum;
   5265					;
   5266					     ?debug  L 1834
   5267	16E4  8B 5E F6			     mov     bx,word ptr [bp-10]
   5268	16E7  C4 5F 0C			     les     bx,dword ptr [bx+12]
   5269	16EA  26: 8B 57	0E		     mov     dx,word ptr es:[bx+14]
   5270	16EE  26: 8B 47	0C		     mov     ax,word ptr es:[bx+12]
   5271	16F2  89 56 E2			     mov     word ptr [bp-30],dx
   5272	16F5  89 46 E0			     mov     word ptr [bp-32],ax
   5273					;
   5274					;
   5275					;		    ((struct qarg ks_stk *)p2a)->ksrc =	RC_GOOD;
   5276					;
   5277					     ?debug  L 1836
   5278	16F8  C4 5E E0			     les     bx,dword ptr [bp-32]
   5279	16FB  26: C7 47	02 0000		     mov     word ptr es:[bx+2],0
   5280					;
   5281					;
   5282					;    #ifdef QUEUE_MEMCPY /* { */
   5283					;		    if (width)
   5284					;		       memcpy(pqh->base	+ (qindex * width),
   5285					;			      ((struct qarg ks_stk *)p2a)->data,
   5286					;			      width);
   5287					;    #else /* }	QUEUE_MEMCPY { */
   5288					;		    switch(width)
   5289					;
   5290					     ?debug  L 1844
   5291	1701  8B 5E CA			     mov     bx,word ptr [bp-54]
   5292	1704  83 FB 04			     cmp     bx,4
   5293	1707  77 61			     ja	     short @2@10474
   5294	1709  03 DB			     add     bx,bx
   5295	170B  2E: FF A7	210Dr		     jmp     word ptr cs:@2@C14818[bx]
   5296	1710			     @2@10390:
   5297					;
   5298					;		    {
   5299					;		       case 0:
   5300					;			  break;
   5301					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 94
.\rtxc.asm



   5302					;		       case sizeof(char):
   5303					;			  *(char *)(pqh->base +	qindex)	=
   5304					;
   5305					     ?debug  L 1850
   5306					;
   5307					;				      *(char *)(((struct qarg ks_stk *)p2a)->data);
   5308					;
   5309					     ?debug  L 1851
   5310	1710  C4 5E E0			     les     bx,dword ptr [bp-32]
   5311	1713  26: C4 5F	08		     les     bx,dword ptr es:[bx+8]
   5312	1717  26: 8A 07			     mov     al,byte ptr es:[bx]
   5313	171A  8B 5E D0			     mov     bx,word ptr [bp-48]
   5314	171D  C4 1F			     les     bx,dword ptr [bx]
   5315	171F  03 5E CE			     add     bx,word ptr [bp-50]
   5316	1722  26: 88 07			     mov     byte ptr es:[bx],al
   5317					;
   5318					;			  break;
   5319					;
   5320					     ?debug  L 1852
   5321	1725  EB 6E			     jmp     short @2@10502
   5322	1727			     @2@10418:
   5323					;
   5324					;
   5325					;		       case sizeof(short):
   5326					;			  *(short *)(pqh->base + (qindex << 1))	=
   5327					;
   5328					     ?debug  L 1855
   5329					;
   5330					;				      *(short *)(((struct qarg ks_stk *)p2a)->data);
   5331					;
   5332					     ?debug  L 1856
   5333	1727  8B 5E D0			     mov     bx,word ptr [bp-48]
   5334	172A  C4 1F			     les     bx,dword ptr [bx]
   5335	172C  8B 46 CE			     mov     ax,word ptr [bp-50]
   5336	172F  03 C0			     add     ax,ax
   5337	1731  03 D8			     add     bx,ax
   5338	1733  06			     push    es
   5339	1734  C4 76 E0			     les     si,dword ptr [bp-32]
   5340	1737  26: C4 74	08		     les     si,dword ptr es:[si+8]
   5341	173B  26: 8B 04			     mov     ax,word ptr es:[si]
   5342	173E  07			     pop     es
   5343	173F  26: 89 07			     mov     word ptr es:[bx],ax
   5344					;
   5345					;			  break;
   5346					;
   5347					     ?debug  L 1857
   5348	1742  EB 51			     jmp     short @2@10502
   5349	1744			     @2@10446:
   5350					;
   5351					;
   5352					;		       case sizeof(long):
   5353					;			  *(long *)(pqh->base +	(qindex	<< 2)) =
   5354					;
   5355					     ?debug  L 1860
   5356					;
   5357					;				      *(long *)(((struct qarg ks_stk *)p2a)->data);
   5358					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 95
.\rtxc.asm



   5359					     ?debug  L 1861
   5360	1744  8B 5E D0			     mov     bx,word ptr [bp-48]
   5361	1747  C4 1F			     les     bx,dword ptr [bx]
   5362	1749  8B 46 CE			     mov     ax,word ptr [bp-50]
   5363	174C  C1 E0 02			     shl     ax,2
   5364	174F  03 D8			     add     bx,ax
   5365	1751  06			     push    es
   5366	1752  C4 76 E0			     les     si,dword ptr [bp-32]
   5367	1755  26: C4 74	08		     les     si,dword ptr es:[si+8]
   5368	1759  26: 8B 54	02		     mov     dx,word ptr es:[si+2]
   5369	175D  26: 8B 04			     mov     ax,word ptr es:[si]
   5370	1760  07			     pop     es
   5371	1761  26: 89 57	02		     mov     word ptr es:[bx+2],dx
   5372	1765  26: 89 07			     mov     word ptr es:[bx],ax
   5373					;
   5374					;			  break;
   5375					;
   5376					     ?debug  L 1862
   5377	1768  EB 2B			     jmp     short @2@10502
   5378	176A			     @2@10474:
   5379					;
   5380					;
   5381					;		       default:
   5382					;			  memcpy(pqh->base + (qindex * width),
   5383					;
   5384					     ?debug  L 1865
   5385					;
   5386					;				  ((struct qarg	ks_stk *)p2a)->data,
   5387					;				  width);
   5388					;
   5389					     ?debug  L 1867
   5390	176A  FF 76 CA			     push    word ptr [bp-54]
   5391	176D  C4 5E E0			     les     bx,dword ptr [bp-32]
   5392	1770  26: FF 77	0A		     push    word ptr es:[bx+10]
   5393	1774  26: FF 77	08		     push    word ptr es:[bx+8]
   5394	1778  8B 5E D0			     mov     bx,word ptr [bp-48]
   5395	177B  8B 07			     mov     ax,word ptr [bx]
   5396	177D  53			     push    bx
   5397	177E  50			     push    ax
   5398	177F  8B 46 CE			     mov     ax,word ptr [bp-50]
   5399	1782  F7 6E CA			     imul    word ptr [bp-54]
   5400	1785  5A			     pop     dx
   5401	1786  03 D0			     add     dx,ax
   5402	1788  5B			     pop     bx
   5403	1789  FF 77 02			     push    word ptr [bx+2]
   5404	178C  52			     push    dx
   5405	178D  9A 00000000se		     call    far ptr _memcpy
   5406	1792  83 C4 0A			     add     sp,10
   5407					;
   5408					;			 break;
   5409					;
   5410					     ?debug  L 1868
   5411	1795			     @2@10502:
   5412					;
   5413					;		    }
   5414					;    #endif /* } QUEUE_MEMCPY */
   5415					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 96
.\rtxc.asm



   5416					;    #ifdef CBUG /* { */
   5417					;		    pqh->count++; /* increment total no. of enqueues to	date */
   5418					;		    /* already past worst case */
   5419					;    #endif /* } CBUG */
   5420					;
   5421					;    #ifdef QUEUE_SEMAS	/* { */
   5422					;		    if (pqh->curndx == pqh->depth) /* queue is now full	*/
   5423					;
   5424					     ?debug  L 1878
   5425	1795  8B 5E D0			     mov     bx,word ptr [bp-48]
   5426	1798  8B 47 0A			     mov     ax,word ptr [bx+10]
   5427	179B  3B 47 06			     cmp     ax,word ptr [bx+6]
   5428	179E  75 55			     jne     short @2@10866
   5429					;
   5430					;		    {
   5431					;		       if (pqh->nfsema)
   5432					;
   5433					     ?debug  L 1880
   5434	17A0  83 7F 16 00		     cmp     word ptr [bx+22],0
   5435	17A4  74 0B			     je	     short @2@10586
   5436					;
   5437					;			  semat[pqh->nfsema] = SEMA_PENDING; /*pend not	full sema*/
   5438					;
   5439					     ?debug  L 1881
   5440	17A6  8B 5F 16			     mov     bx,word ptr [bx+22]
   5441	17A9  03 DB			     add     bx,bx
   5442	17AB  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
   5443	17B1			     @2@10586:
   5444					;
   5445					;
   5446					;		       UPDATE_SEMA(pqh->fsema);
   5447					;
   5448					     ?debug  L 1883
   5449	17B1  8B 5E D0			     mov     bx,word ptr [bp-48]
   5450	17B4  83 7F 10 00		     cmp     word ptr [bx+16],0
   5451	17B8  74 4F			     je	     short @2@10950
   5452	17BA  8B 5F 10			     mov     bx,word ptr [bx+16]
   5453	17BD  03 DB			     add     bx,bx
   5454	17BF  83 BF 0000e FF		     cmp     word ptr DGROUP:_semat[bx],-1
   5455	17C4  75 08			     jne     short @2@10670
   5456	17C6  8B 5E D0			     mov     bx,word ptr [bp-48]
   5457	17C9  8B 5F 10			     mov     bx,word ptr [bx+16]
   5458	17CC  EB 33			     jmp     short @2@10922
   5459	17CE			     @2@10670:
   5460	17CE  8B 5E D0			     mov     bx,word ptr [bp-48]
   5461	17D1  8B 5F 10			     mov     bx,word ptr [bx+16]
   5462	17D4  03 DB			     add     bx,bx
   5463	17D6  83 BF 0000e 00		     cmp     word ptr DGROUP:_semat[bx],0
   5464	17DB  75 02			     jne     short @2@10726
   5465	17DD  EB 2A			     jmp     short @2@10950
   5466	17DF			     @2@10726:
   5467	17DF  FA			     cli
   5468	17E0  90			     nop
   5469	17E1  8B 5E D0			     mov     bx,word ptr [bp-48]
   5470	17E4  8B 47 10			     mov     ax,word ptr [bx+16]
   5471	17E7  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
   5472	17EB  89 07			     mov     word ptr [bx],ax
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 97
.\rtxc.asm



   5473	17ED  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
   5474	17F2  FB			     sti
   5475					;
   5476					;		    }
   5477					;
   5478					     ?debug  L 1884
   5479	17F3  EB 14			     jmp     short @2@10950
   5480	17F5			     @2@10866:
   5481					;
   5482					;		    else			       /* still	room in	queue */
   5483					;		    {
   5484					;		       if (pqh->nfsema)
   5485					;
   5486					     ?debug  L 1887
   5487	17F5  8B 5E D0			     mov     bx,word ptr [bp-48]
   5488	17F8  83 7F 16 00		     cmp     word ptr [bx+22],0
   5489	17FC  74 0B			     je	     short @2@10950
   5490					;
   5491					;			  semat[pqh->nfsema] = SEMA_DONE;
   5492					;
   5493					     ?debug  L 1888
   5494	17FE  8B 5F 16			     mov     bx,word ptr [bx+22]
   5495	1801			     @2@10922:
   5496	1801  03 DB			     add     bx,bx
   5497	1803  C7 87 0000e 0000		     mov     word ptr DGROUP:_semat[bx],0
   5498	1809			     @2@10950:
   5499					;
   5500					;		    }
   5501					;    #endif /* } QUEUE_SEMAS */
   5502					;
   5503					;    #ifdef QUEUE_SEMAS	/* { */
   5504					;		    if (pqh->curndx == 1) /* if	was empty */
   5505					;
   5506					     ?debug  L 1893
   5507	1809  8B 5E D0			     mov     bx,word ptr [bp-48]
   5508	180C  83 7F 0A 01		     cmp     word ptr [bx+10],1
   5509	1810  74 03			     je	     @@40
   5510	1812  E9 08B9			     jmp     @2@15430
   5511	1815			     @@40:
   5512					;
   5513					;		    {
   5514					;		       UPDATE_SEMA(pqh->nesema);
   5515					;
   5516					     ?debug  L 1895
   5517	1815  83 7F 12 00		     cmp     word ptr [bx+18],0
   5518	1819  75 03			     jne     @@41
   5519	181B  E9 08B0			     jmp     @2@15430
   5520	181E			     @@41:
   5521	181E  8B 5F 12			     mov     bx,word ptr [bx+18]
   5522	1821  03 DB			     add     bx,bx
   5523	1823  83 BF 0000e FF		     cmp     word ptr DGROUP:_semat[bx],-1
   5524	1828  75 03			     jne     short @2@11062
   5525	182A  E9 0184			     jmp     @2@12182
   5526	182D			     @2@11062:
   5527	182D  8B 5E D0			     mov     bx,word ptr [bp-48]
   5528	1830  8B 5F 12			     mov     bx,word ptr [bx+18]
   5529	1833  03 DB			     add     bx,bx
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 98
.\rtxc.asm



   5530	1835  83 BF 0000e 00		     cmp     word ptr DGROUP:_semat[bx],0
   5531	183A  75 03			     jne     short @2@11118
   5532	183C  E9 088F			     jmp     @2@15430
   5533	183F			     @2@11118:
   5534	183F  FA			     cli
   5535	1840  90			     nop
   5536	1841  8B 5E D0			     mov     bx,word ptr [bp-48]
   5537	1844  8B 47 12			     mov     ax,word ptr [bx+18]
   5538	1847  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
   5539	184B  89 07			     mov     word ptr [bx],ax
   5540	184D  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
   5541	1852  FB			     sti
   5542					;
   5543					;		    }
   5544					;    #endif /* } QUEUE_SEMAS */
   5545					;		 }
   5546					;
   5547					     ?debug  L 1898
   5548	1853  E9 0878			     jmp     @2@15430
   5549	1856			     @2@11258:
   5550					;
   5551					;		 else
   5552					;		 {
   5553					;    #ifdef QUEUE_SEMAS	/* { */
   5554					;		    if (pqh->fsema)
   5555					;
   5556					     ?debug  L 1902
   5557	1856  8B 5E D0			     mov     bx,word ptr [bp-48]
   5558	1859  83 7F 10 00		     cmp     word ptr [bx+16],0
   5559	185D  74 0B			     je	     short @2@11314
   5560					;
   5561					;		       semat[pqh->fsema] = SEMA_PENDING;
   5562					;
   5563					     ?debug  L 1903
   5564	185F  8B 5F 10			     mov     bx,word ptr [bx+16]
   5565	1862  03 DB			     add     bx,bx
   5566	1864  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
   5567	186A			     @2@11314:
   5568					;
   5569					;
   5570					;		    UPDATE_SEMA(pqh->nfsema);
   5571					;
   5572					     ?debug  L 1905
   5573	186A  8B 5E D0			     mov     bx,word ptr [bp-48]
   5574	186D  83 7F 16 00		     cmp     word ptr [bx+22],0
   5575	1871  75 03			     jne     @@42
   5576	1873  E9 0858			     jmp     @2@15430
   5577	1876			     @@42:
   5578	1876  8B 5F 16			     mov     bx,word ptr [bx+22]
   5579	1879  03 DB			     add     bx,bx
   5580	187B  83 BF 0000e FF		     cmp     word ptr DGROUP:_semat[bx],-1
   5581	1880  75 03			     jne     short @2@11398
   5582	1882  E9 0163			     jmp     @2@12266
   5583	1885			     @2@11398:
   5584	1885  8B 5E D0			     mov     bx,word ptr [bp-48]
   5585	1888  8B 5F 16			     mov     bx,word ptr [bx+22]
   5586	188B  03 DB			     add     bx,bx
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 99
.\rtxc.asm



   5587	188D  83 BF 0000e 00		     cmp     word ptr DGROUP:_semat[bx],0
   5588	1892  75 03			     jne     short @2@11454
   5589	1894  E9 0837			     jmp     @2@15430
   5590	1897			     @2@11454:
   5591	1897  FA			     cli
   5592	1898  90			     nop
   5593	1899  8B 5E D0			     mov     bx,word ptr [bp-48]
   5594	189C  8B 47 16			     mov     ax,word ptr [bx+22]
   5595	189F  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
   5596	18A3  89 07			     mov     word ptr [bx],ax
   5597	18A5  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
   5598	18AA  FB			     sti
   5599					;
   5600					;    #endif /* } QUEUE_SEMAS */
   5601					;		 }
   5602					;	      }
   5603					;
   5604					     ?debug  L 1908
   5605	18AB  E9 0820			     jmp     @2@15430
   5606	18AE			     @2@11594:
   5607					;
   5608					;	      else
   5609					;    #endif /* } ENQUEUE_WAITERS */
   5610					;	      {
   5611					;    #ifdef QUEUE_SEMAS	/* { */
   5612					;		 UPDATE_SEMA(pqh->nfsema);
   5613					;
   5614					     ?debug  L 1913
   5615	18AE  8B 5E D0			     mov     bx,word ptr [bp-48]
   5616	18B1  83 7F 16 00		     cmp     word ptr [bx+22],0
   5617	18B5  75 03			     jne     @@43
   5618	18B7  E9 0814			     jmp     @2@15430
   5619	18BA			     @@43:
   5620	18BA  8B 5F 16			     mov     bx,word ptr [bx+22]
   5621	18BD  03 DB			     add     bx,bx
   5622	18BF  83 BF 0000e FF		     cmp     word ptr DGROUP:_semat[bx],-1
   5623	18C4  75 03			     jne     short @2@11678
   5624	18C6  E9 011F			     jmp     @2@12266
   5625	18C9			     @2@11678:
   5626	18C9  8B 5E D0			     mov     bx,word ptr [bp-48]
   5627	18CC  8B 5F 16			     mov     bx,word ptr [bx+22]
   5628	18CF  03 DB			     add     bx,bx
   5629	18D1  83 BF 0000e 00		     cmp     word ptr DGROUP:_semat[bx],0
   5630	18D6  75 03			     jne     short @2@11734
   5631	18D8  E9 07F3			     jmp     @2@15430
   5632	18DB			     @2@11734:
   5633	18DB  FA			     cli
   5634	18DC  90			     nop
   5635	18DD  8B 5E D0			     mov     bx,word ptr [bp-48]
   5636	18E0  8B 47 16			     mov     ax,word ptr [bx+22]
   5637	18E3  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
   5638	18E7  89 07			     mov     word ptr [bx],ax
   5639	18E9  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
   5640	18EE  FB			     sti
   5641					;
   5642					;    #endif /* } QUEUE_SEMAS */
   5643					;	      }
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 100
.\rtxc.asm



   5644					;	      break;
   5645					;
   5646					     ?debug  L 1916
   5647	18EF  E9 07DC			     jmp     @2@15430
   5648	18F2			     @2@11874:
   5649					;
   5650					;    #endif /* } HAS_DEQUEUE */
   5651					;    #endif /* } HAS_QUEUES */
   5652					;
   5653					;    #ifdef HAS_DEFQUEUE /* { */
   5654					;    /************************/
   5655					;	   case	RTXC_DEFQUEUE:
   5656					;    /************************/
   5657					;	      pqh = &qheader[((struct qdefarg ks_stk *)p2)->queue];
   5658					;
   5659					     ?debug  L 1924
   5660	18F2  C4 5E FC			     les     bx,dword ptr [bp-4]
   5661	18F5  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   5662	18F9  6B C0 18			     imul    ax,ax,24
   5663	18FC  05 0000e			     add     ax,offset DGROUP:_qheader
   5664	18FF  89 46 D0			     mov     word ptr [bp-48],ax
   5665					;
   5666					;
   5667					;	      pqh->base	  = ((struct qdefarg ks_stk *)p2)->base;
   5668					;
   5669					     ?debug  L 1926
   5670	1902  26: 8B 57	08		     mov     dx,word ptr es:[bx+8]
   5671	1906  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
   5672	190A  8B 5E D0			     mov     bx,word ptr [bp-48]
   5673	190D  89 57 02			     mov     word ptr [bx+2],dx
   5674	1910  89 07			     mov     word ptr [bx],ax
   5675					;
   5676					;	      pqh->width  = ((struct qdefarg ks_stk *)p2)->width;
   5677					;
   5678					     ?debug  L 1927
   5679	1912  8B 5E FC			     mov     bx,word ptr [bp-4]
   5680	1915  26: 8B 47	0A		     mov     ax,word ptr es:[bx+10]
   5681	1919  8B 5E D0			     mov     bx,word ptr [bp-48]
   5682	191C  89 47 04			     mov     word ptr [bx+4],ax
   5683					;
   5684					;	      pqh->depth  = ((struct qdefarg ks_stk *)p2)->depth;
   5685					;
   5686					     ?debug  L 1928
   5687	191F  8B 5E FC			     mov     bx,word ptr [bp-4]
   5688	1922  26: 8B 47	0C		     mov     ax,word ptr es:[bx+12]
   5689	1926  8B 5E D0			     mov     bx,word ptr [bp-48]
   5690	1929  89 47 06			     mov     word ptr [bx+6],ax
   5691					;
   5692					;	      cursz = ((struct qdefarg ks_stk *)p2)->current_size;
   5693					;
   5694					     ?debug  L 1929
   5695	192C  8B 5E FC			     mov     bx,word ptr [bp-4]
   5696	192F  26: 8B 47	0E		     mov     ax,word ptr es:[bx+14]
   5697	1933  89 46 C8			     mov     word ptr [bp-56],ax
   5698					;
   5699					;
   5700					;	      if (cursz	< 0 || cursz > pqh->depth)
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 101
.\rtxc.asm



   5701					;
   5702					     ?debug  L 1931
   5703	1936  83 7E C8 00		     cmp     word ptr [bp-56],0
   5704	193A  7C 0B			     jl	     short @2@11930
   5705	193C  8B 5E D0			     mov     bx,word ptr [bp-48]
   5706	193F  8B 47 06			     mov     ax,word ptr [bx+6]
   5707	1942  3B 46 C8			     cmp     ax,word ptr [bp-56]
   5708	1945  7D 0C			     jge     short @2@11958
   5709	1947			     @2@11930:
   5710					;
   5711					;		 ((struct qdefarg ks_stk *)p2)->ksrc = RC_ILLEGAL_QUEUE_SIZE;
   5712					;
   5713					     ?debug  L 1932
   5714	1947  C4 5E FC			     les     bx,dword ptr [bp-4]
   5715	194A  26: C7 47	02 0008		     mov     word ptr es:[bx+2],8
   5716	1950  E9 077B			     jmp     @2@15430
   5717	1953			     @2@11958:
   5718					;
   5719					;
   5720					;	      else if(cursz == 0)
   5721					;
   5722					     ?debug  L 1934
   5723	1953  83 7E C8 00		     cmp     word ptr [bp-56],0
   5724	1957  75 12			     jne     short @2@12014
   5725					;
   5726					;	      {
   5727					;		 pqh->putndx = pqh->depth - 1; /* purge	queue */
   5728					;
   5729					     ?debug  L 1936
   5730	1959  8B 5E D0			     mov     bx,word ptr [bp-48]
   5731	195C  8B 47 06			     mov     ax,word ptr [bx+6]
   5732	195F  48			     dec     ax
   5733	1960  89 47 08			     mov     word ptr [bx+8],ax
   5734					;
   5735					;		 pqh->curndx = 0;
   5736					;
   5737					     ?debug  L 1937
   5738	1963  C7 47 0A 0000		     mov     word ptr [bx+10],0
   5739					;
   5740					;	      }
   5741					;
   5742					     ?debug  L 1938
   5743	1968  E9 0763			     jmp     @2@15430
   5744	196B			     @2@12014:
   5745					;
   5746					;
   5747					;	      else
   5748					;	      {
   5749					;		 pqh->curndx = cursz;
   5750					;
   5751					     ?debug  L 1942
   5752	196B  8B 5E D0			     mov     bx,word ptr [bp-48]
   5753	196E  8B 46 C8			     mov     ax,word ptr [bp-56]
   5754	1971  89 47 0A			     mov     word ptr [bx+10],ax
   5755					;
   5756					;		 pqh->putndx = cursz - 1;
   5757					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 102
.\rtxc.asm



   5758					     ?debug  L 1943
   5759	1974  48			     dec     ax
   5760	1975  89 47 08			     mov     word ptr [bx+8],ax
   5761	1978  E9 0753			     jmp     @2@15430
   5762	197B			     @2@12042:
   5763					;
   5764					;	      }
   5765					;	      break;
   5766					;    #endif /* } HAS_DEFQUEUE */
   5767					;
   5768					;    #ifdef QUEUE_SEMAS	/* { */
   5769					;    #ifdef HAS_DEFQSEMA /* { */
   5770					;    /************************/
   5771					;	   case	RTXC_DEFQSEMA:
   5772					;    /************************/
   5773					;	      pqh = &qheader[((struct qdefarg ks_stk *)p2)->queue];
   5774					;
   5775					     ?debug  L 1953
   5776	197B  C4 5E FC			     les     bx,dword ptr [bp-4]
   5777	197E  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   5778	1982  6B C0 18			     imul    ax,ax,24
   5779	1985  05 0000e			     add     ax,offset DGROUP:_qheader
   5780	1988  89 46 D0			     mov     word ptr [bp-48],ax
   5781					;
   5782					;
   5783					;	      switch(((struct qdefarg ks_stk *)p2)->qcond)
   5784					;
   5785					     ?debug  L 1955
   5786	198B  26: 8B 5F	12		     mov     bx,word ptr es:[bx+18]
   5787	198F  83 FB 03			     cmp     bx,3
   5788	1992  76 03			     jbe     @@44
   5789	1994  E9 0737			     jmp     @2@15430
   5790	1997			     @@44:
   5791	1997  03 DB			     add     bx,bx
   5792	1999  2E: FF A7	2105r		     jmp     word ptr cs:@2@C14754[bx]
   5793	199E			     @2@12154:
   5794					;
   5795					;	      {
   5796					;		 /* note: semaphore is 0 == undefqsema() and harmless */
   5797					;		 case QNE:
   5798					;		    pqh->nesema	= ((struct qdefarg ks_stk *)p2)->sema;
   5799					;
   5800					     ?debug  L 1959
   5801	199E  C4 5E FC			     les     bx,dword ptr [bp-4]
   5802	19A1  26: 8B 47	10		     mov     ax,word ptr es:[bx+16]
   5803	19A5  8B 5E D0			     mov     bx,word ptr [bp-48]
   5804	19A8  89 47 12			     mov     word ptr [bx+18],ax
   5805					;
   5806					;		    if (pqh->curndx != 0) /* if	not empty */
   5807					;
   5808					     ?debug  L 1960
   5809	19AB  83 7F 0A 00		     cmp     word ptr [bx+10],0
   5810	19AF  74 11			     je	     short @2@12210
   5811	19B1			     @2@12182:
   5812					;
   5813					;		       semat[pqh->nesema] = SEMA_DONE;
   5814					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 103
.\rtxc.asm



   5815					     ?debug  L 1961
   5816	19B1  8B 5E D0			     mov     bx,word ptr [bp-48]
   5817	19B4  8B 5F 12			     mov     bx,word ptr [bx+18]
   5818	19B7  03 DB			     add     bx,bx
   5819	19B9  C7 87 0000e 0000		     mov     word ptr DGROUP:_semat[bx],0
   5820	19BF  E9 070C			     jmp     @2@15430
   5821	19C2			     @2@12210:
   5822					;
   5823					;		    else
   5824					;		       semat[pqh->nesema] = SEMA_PENDING;
   5825					;
   5826					     ?debug  L 1963
   5827	19C2  8B 5E D0			     mov     bx,word ptr [bp-48]
   5828	19C5  8B 5F 12			     mov     bx,word ptr [bx+18]
   5829	19C8  03 DB			     add     bx,bx
   5830	19CA  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
   5831	19D0  E9 06FB			     jmp     @2@15430
   5832	19D3			     @2@12238:
   5833					;
   5834					;		    break;
   5835					;
   5836					;		 case QNF:
   5837					;		    pqh->nfsema	= ((struct qdefarg ks_stk *)p2)->sema;
   5838					;
   5839					     ?debug  L 1967
   5840	19D3  C4 5E FC			     les     bx,dword ptr [bp-4]
   5841	19D6  26: 8B 47	10		     mov     ax,word ptr es:[bx+16]
   5842	19DA  8B 5E D0			     mov     bx,word ptr [bp-48]
   5843	19DD  89 47 16			     mov     word ptr [bx+22],ax
   5844					;
   5845					;		    if (pqh->curndx != pqh->depth) /* if not full */
   5846					;
   5847					     ?debug  L 1968
   5848	19E0  8B 47 0A			     mov     ax,word ptr [bx+10]
   5849	19E3  3B 47 06			     cmp     ax,word ptr [bx+6]
   5850	19E6  74 11			     je	     short @2@12294
   5851	19E8			     @2@12266:
   5852					;
   5853					;		       semat[pqh->nfsema] = SEMA_DONE;
   5854					;
   5855					     ?debug  L 1969
   5856	19E8  8B 5E D0			     mov     bx,word ptr [bp-48]
   5857	19EB  8B 5F 16			     mov     bx,word ptr [bx+22]
   5858	19EE  03 DB			     add     bx,bx
   5859	19F0  C7 87 0000e 0000		     mov     word ptr DGROUP:_semat[bx],0
   5860	19F6  E9 06D5			     jmp     @2@15430
   5861	19F9			     @2@12294:
   5862					;
   5863					;		    else
   5864					;		       semat[pqh->nfsema] = SEMA_PENDING;
   5865					;
   5866					     ?debug  L 1971
   5867	19F9  8B 5E D0			     mov     bx,word ptr [bp-48]
   5868	19FC  8B 5F 16			     mov     bx,word ptr [bx+22]
   5869	19FF  03 DB			     add     bx,bx
   5870	1A01  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
   5871	1A07  E9 06C4			     jmp     @2@15430
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 104
.\rtxc.asm



   5872	1A0A			     @2@12322:
   5873					;
   5874					;		    break;
   5875					;
   5876					;		 case QE:
   5877					;		    pqh->esema = ((struct qdefarg ks_stk *)p2)->sema;
   5878					;
   5879					     ?debug  L 1975
   5880	1A0A  C4 5E FC			     les     bx,dword ptr [bp-4]
   5881	1A0D  26: 8B 47	10		     mov     ax,word ptr es:[bx+16]
   5882	1A11  8B 5E D0			     mov     bx,word ptr [bp-48]
   5883	1A14  89 47 14			     mov     word ptr [bx+20],ax
   5884					;
   5885					;		    if (pqh->curndx == 0) /* if	empty */
   5886					;
   5887					     ?debug  L 1976
   5888	1A17  83 7F 0A 00		     cmp     word ptr [bx+10],0
   5889	1A1B  75 0E			     jne     short @2@12378
   5890					;
   5891					;		       semat[pqh->esema] = SEMA_DONE;
   5892					;
   5893					     ?debug  L 1977
   5894	1A1D  8B 5F 14			     mov     bx,word ptr [bx+20]
   5895	1A20  03 DB			     add     bx,bx
   5896	1A22  C7 87 0000e 0000		     mov     word ptr DGROUP:_semat[bx],0
   5897	1A28  E9 06A3			     jmp     @2@15430
   5898	1A2B			     @2@12378:
   5899					;
   5900					;		    else
   5901					;		       semat[pqh->esema] = SEMA_PENDING;
   5902					;
   5903					     ?debug  L 1979
   5904	1A2B  8B 5E D0			     mov     bx,word ptr [bp-48]
   5905	1A2E  8B 5F 14			     mov     bx,word ptr [bx+20]
   5906	1A31  03 DB			     add     bx,bx
   5907	1A33  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
   5908	1A39  E9 0692			     jmp     @2@15430
   5909	1A3C			     @2@12406:
   5910					;
   5911					;		    break;
   5912					;
   5913					;		 case QF:
   5914					;		    pqh->fsema = ((struct qdefarg ks_stk *)p2)->sema;
   5915					;
   5916					     ?debug  L 1983
   5917	1A3C  C4 5E FC			     les     bx,dword ptr [bp-4]
   5918	1A3F  26: 8B 47	10		     mov     ax,word ptr es:[bx+16]
   5919	1A43  8B 5E D0			     mov     bx,word ptr [bp-48]
   5920	1A46  89 47 10			     mov     word ptr [bx+16],ax
   5921					;
   5922					;		    if (pqh->curndx == pqh->depth) /* if full */
   5923					;
   5924					     ?debug  L 1984
   5925	1A49  8B 47 0A			     mov     ax,word ptr [bx+10]
   5926	1A4C  3B 47 06			     cmp     ax,word ptr [bx+6]
   5927	1A4F  75 0E			     jne     short @2@12462
   5928					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 105
.\rtxc.asm



   5929					;		       semat[pqh->fsema] = SEMA_DONE;
   5930					;
   5931					     ?debug  L 1985
   5932	1A51  8B 5F 10			     mov     bx,word ptr [bx+16]
   5933	1A54  03 DB			     add     bx,bx
   5934	1A56  C7 87 0000e 0000		     mov     word ptr DGROUP:_semat[bx],0
   5935	1A5C  E9 066F			     jmp     @2@15430
   5936	1A5F			     @2@12462:
   5937					;
   5938					;		    else
   5939					;		       semat[pqh->fsema] = SEMA_PENDING;
   5940					;
   5941					     ?debug  L 1987
   5942	1A5F  8B 5E D0			     mov     bx,word ptr [bp-48]
   5943	1A62  8B 5F 10			     mov     bx,word ptr [bx+16]
   5944	1A65  03 DB			     add     bx,bx
   5945	1A67  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
   5946	1A6D  E9 065E			     jmp     @2@15430
   5947					;
   5948					;		    break;
   5949					;	      }
   5950					;	      break;
   5951					;
   5952					     ?debug  L 1990
   5953	1A70  E9 065B			     jmp     @2@15430
   5954	1A73			     @2@12518:
   5955					;
   5956					;    #endif /* } HAS_DEFQSEMA */
   5957					;    #endif /* } QUEUE_SEMAS */
   5958					;
   5959					;    #ifdef MAILBOX_SEMAS /* { */
   5960					;    #ifdef HAS_DEFMBOXSEMA /* { */
   5961					;    /************************/
   5962					;	   case	RTXC_DEFMBOXSEMA:
   5963					;    /************************/
   5964					;	      pmh = &mheader[((struct msgarg ks_stk *)p2)->mbox];
   5965					;
   5966					     ?debug  L 1999
   5967	1A73  C4 5E FC			     les     bx,dword ptr [bp-4]
   5968	1A76  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
   5969	1A7A  6B C0 0A			     imul    ax,ax,10
   5970	1A7D  05 0000e			     add     ax,offset DGROUP:_mheader
   5971	1A80  89 46 DC			     mov     word ptr [bp-36],ax
   5972					;
   5973					;
   5974					;	      /* note: semaphore is 0 == undefmboxsema() and harmless */
   5975					;	      pmh->nesema = ((struct msgarg ks_stk *)p2)->sema;
   5976					;
   5977					     ?debug  L 2002
   5978	1A83  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   5979	1A87  8B 5E DC			     mov     bx,word ptr [bp-36]
   5980	1A8A  89 47 08			     mov     word ptr [bx+8],ax
   5981					;
   5982					;
   5983					;	      if (pmh->link == NULL)
   5984					;
   5985					     ?debug  L 2004
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 106
.\rtxc.asm



   5986	1A8D  8B 07			     mov     ax,word ptr [bx]
   5987	1A8F  0B 47 02			     or	     ax,word ptr [bx+2]
   5988	1A92  75 0E			     jne     short @2@12574
   5989					;
   5990					;		  semat[pmh->nesema] = SEMA_PENDING;
   5991					;
   5992					     ?debug  L 2005
   5993	1A94  8B 5F 08			     mov     bx,word ptr [bx+8]
   5994	1A97  03 DB			     add     bx,bx
   5995	1A99  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
   5996	1A9F  E9 062C			     jmp     @2@15430
   5997	1AA2			     @2@12574:
   5998					;
   5999					;	      else
   6000					;		  semat[pmh->nesema] = SEMA_DONE;
   6001					;
   6002					     ?debug  L 2007
   6003	1AA2  8B 5E DC			     mov     bx,word ptr [bp-36]
   6004	1AA5  8B 5F 08			     mov     bx,word ptr [bx+8]
   6005	1AA8  03 DB			     add     bx,bx
   6006	1AAA  C7 87 0000e 0000		     mov     word ptr DGROUP:_semat[bx],0
   6007	1AB0  E9 061B			     jmp     @2@15430
   6008	1AB3			     @2@12602:
   6009					;
   6010					;	      break;
   6011					;    #endif /* } HAS_DEFMBOXSEMA */
   6012					;    #endif /* } MAILBOX_SEMAS */
   6013					;
   6014					;    #ifdef HAS_PURGEQUEUE /* {	*/
   6015					;    /************************/
   6016					;	   case	RTXC_PURGEQUEUE:
   6017					;    /************************/
   6018					;	      pqh = &qheader[((struct qarg ks_stk *)p2)->queue];
   6019					;
   6020					     ?debug  L 2016
   6021	1AB3  C4 5E FC			     les     bx,dword ptr [bp-4]
   6022	1AB6  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
   6023	1ABA  6B C0 18			     imul    ax,ax,24
   6024	1ABD  05 0000e			     add     ax,offset DGROUP:_qheader
   6025	1AC0  89 46 D0			     mov     word ptr [bp-48],ax
   6026					;
   6027					;
   6028					;	      pqh->putndx = pqh->depth - 1;
   6029					;
   6030					     ?debug  L 2018
   6031	1AC3  8B 5E D0			     mov     bx,word ptr [bp-48]
   6032	1AC6  8B 47 06			     mov     ax,word ptr [bx+6]
   6033	1AC9  48			     dec     ax
   6034	1ACA  89 47 08			     mov     word ptr [bx+8],ax
   6035					;
   6036					;	      qindex = pqh->curndx; /* save original size for later use	*/
   6037					;
   6038					     ?debug  L 2019
   6039	1ACD  8B 47 0A			     mov     ax,word ptr [bx+10]
   6040	1AD0  89 46 CE			     mov     word ptr [bp-50],ax
   6041					;
   6042					;	      pqh->curndx = 0;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 107
.\rtxc.asm



   6043					;
   6044					     ?debug  L 2020
   6045	1AD3  C7 47 0A 0000		     mov     word ptr [bx+10],0
   6046					;
   6047					;
   6048					;    #ifdef QUEUE_SEMAS	/* { */
   6049					;	      UPDATE_SEMA(pqh->esema);
   6050					;
   6051					     ?debug  L 2023
   6052	1AD8  83 7F 14 00		     cmp     word ptr [bx+20],0
   6053	1ADC  74 41			     je	     short @2@12854
   6054	1ADE  8B 5F 14			     mov     bx,word ptr [bx+20]
   6055	1AE1  03 DB			     add     bx,bx
   6056	1AE3  83 BF 0000e FF		     cmp     word ptr DGROUP:_semat[bx],-1
   6057	1AE8  75 10			     jne     short @2@12686
   6058	1AEA  8B 5E D0			     mov     bx,word ptr [bp-48]
   6059	1AED  8B 5F 14			     mov     bx,word ptr [bx+20]
   6060	1AF0  03 DB			     add     bx,bx
   6061	1AF2  C7 87 0000e 0000		     mov     word ptr DGROUP:_semat[bx],0
   6062	1AF8  EB 25			     jmp     short @2@12854
   6063	1AFA			     @2@12686:
   6064	1AFA  8B 5E D0			     mov     bx,word ptr [bp-48]
   6065	1AFD  8B 5F 14			     mov     bx,word ptr [bx+20]
   6066	1B00  03 DB			     add     bx,bx
   6067	1B02  83 BF 0000e 00		     cmp     word ptr DGROUP:_semat[bx],0
   6068	1B07  75 02			     jne     short @2@12742
   6069	1B09  EB 14			     jmp     short @2@12854
   6070	1B0B			     @2@12742:
   6071	1B0B  FA			     cli
   6072	1B0C  90			     nop
   6073	1B0D  8B 5E D0			     mov     bx,word ptr [bp-48]
   6074	1B10  8B 47 14			     mov     ax,word ptr [bx+20]
   6075	1B13  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
   6076	1B17  89 07			     mov     word ptr [bx],ax
   6077	1B19  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
   6078	1B1E  FB			     sti
   6079	1B1F			     @2@12854:
   6080					;
   6081					;    #endif /* } QUEUE_SEMAS */
   6082					;
   6083					;	      depth = pqh->depth;
   6084					;
   6085					     ?debug  L 2026
   6086	1B1F  8B 5E D0			     mov     bx,word ptr [bp-48]
   6087	1B22  8B 47 06			     mov     ax,word ptr [bx+6]
   6088	1B25  89 46 CC			     mov     word ptr [bp-52],ax
   6089					;
   6090					;
   6091					;	      /* if queue was full */
   6092					;	      if (qindex == depth)
   6093					;
   6094					     ?debug  L 2029
   6095	1B28  8B 46 CE			     mov     ax,word ptr [bp-50]
   6096	1B2B  3B 46 CC			     cmp     ax,word ptr [bp-52]
   6097	1B2E  74 03			     je	     @@45
   6098	1B30  E9 059B			     jmp     @2@15430
   6099	1B33			     @@45:
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 108
.\rtxc.asm



   6100					;
   6101					;	      {
   6102					;    #ifdef QUEUE_SEMAS	/* { */
   6103					;		 UPDATE_SEMA(pqh->nfsema);
   6104					;
   6105					     ?debug  L 2032
   6106	1B33  83 7F 16 00		     cmp     word ptr [bx+22],0
   6107	1B37  74 41			     je	     short @2@13134
   6108	1B39  8B 5F 16			     mov     bx,word ptr [bx+22]
   6109	1B3C  03 DB			     add     bx,bx
   6110	1B3E  83 BF 0000e FF		     cmp     word ptr DGROUP:_semat[bx],-1
   6111	1B43  75 10			     jne     short @2@12966
   6112	1B45  8B 5E D0			     mov     bx,word ptr [bp-48]
   6113	1B48  8B 5F 16			     mov     bx,word ptr [bx+22]
   6114	1B4B  03 DB			     add     bx,bx
   6115	1B4D  C7 87 0000e 0000		     mov     word ptr DGROUP:_semat[bx],0
   6116	1B53  EB 25			     jmp     short @2@13134
   6117	1B55			     @2@12966:
   6118	1B55  8B 5E D0			     mov     bx,word ptr [bp-48]
   6119	1B58  8B 5F 16			     mov     bx,word ptr [bx+22]
   6120	1B5B  03 DB			     add     bx,bx
   6121	1B5D  83 BF 0000e 00		     cmp     word ptr DGROUP:_semat[bx],0
   6122	1B62  75 02			     jne     short @2@13022
   6123	1B64  EB 14			     jmp     short @2@13134
   6124	1B66			     @2@13022:
   6125	1B66  FA			     cli
   6126	1B67  90			     nop
   6127	1B68  8B 5E D0			     mov     bx,word ptr [bp-48]
   6128	1B6B  8B 47 16			     mov     ax,word ptr [bx+22]
   6129	1B6E  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
   6130	1B72  89 07			     mov     word ptr [bx],ax
   6131	1B74  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
   6132	1B79  FB			     sti
   6133	1B7A			     @2@13134:
   6134					;
   6135					;    #endif /* } QUEUE_SEMAS */
   6136					;
   6137					;		 width = pqh->width;
   6138					;
   6139					     ?debug  L 2035
   6140	1B7A  8B 5E D0			     mov     bx,word ptr [bp-48]
   6141	1B7D  8B 47 04			     mov     ax,word ptr [bx+4]
   6142	1B80  89 46 CA			     mov     word ptr [bp-54],ax
   6143	1B83  E9 0181			     jmp     @2@13890
   6144	1B86			     @2@13162:
   6145					;
   6146					;
   6147					;    #ifdef QUEUE_WAITERS /* { */
   6148					;		 /* might have enq or deq waiters to process */
   6149					;		 while ( (ptcb = pqh->waiters) != NULLTCB)
   6150					;		 {
   6151					;		    /* remove highest priority waiter (1st) */
   6152					;		    if ( (pqh->waiters = ptcb->flink) != NULLTCB)
   6153					;
   6154					     ?debug  L 2042
   6155	1B86  8B 5E F6			     mov     bx,word ptr [bp-10]
   6156	1B89  8B 07			     mov     ax,word ptr [bx]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 109
.\rtxc.asm



   6157	1B8B  8B 5E D0			     mov     bx,word ptr [bp-48]
   6158	1B8E  89 47 0C			     mov     word ptr [bx+12],ax
   6159	1B91  0B C0			     or	     ax,ax
   6160	1B93  74 0E			     je	     short @2@13218
   6161					;
   6162					;		       ptcb->flink->blink = (TCB near *)&pqh->waiters;
   6163					;
   6164					     ?debug  L 2043
   6165	1B95  8B 46 D0			     mov     ax,word ptr [bp-48]
   6166	1B98  05 000C			     add     ax,12
   6167	1B9B  8B 5E F6			     mov     bx,word ptr [bp-10]
   6168	1B9E  8B 1F			     mov     bx,word ptr [bx]
   6169	1BA0  89 47 02			     mov     word ptr [bx+2],ax
   6170	1BA3			     @2@13218:
   6171					;
   6172					;
   6173					;		    if ( (ptcb->status &= ~QUEUE_WAIT) == READY)
   6174					;
   6175					     ?debug  L 2045
   6176	1BA3  8B 5E F6			     mov     bx,word ptr [bp-10]
   6177	1BA6  81 67 10 FF7F		     and     word ptr [bx+16],-129
   6178	1BAB  8B 47 10			     mov     ax,word ptr [bx+16]
   6179	1BAE  0B C0			     or	     ax,ax
   6180	1BB0  75 0B			     jne     short @2@13274
   6181					;
   6182					;		    {
   6183					;		       ptcb->flink = nsrttcb;
   6184					;
   6185					     ?debug  L 2047
   6186	1BB2  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
   6187	1BB5  89 07			     mov     word ptr [bx],ax
   6188					;
   6189					;		       nsrttcb = ptcb;
   6190					;
   6191					     ?debug  L 2048
   6192	1BB7  8B 46 F6			     mov     ax,word ptr [bp-10]
   6193	1BBA  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
   6194	1BBD			     @2@13274:
   6195					;
   6196					;		    }
   6197					;
   6198					;    #ifdef QUEUE_TIMEOUTS /* {	*/
   6199					;		    /* cleanup any pending timeout */
   6200					;		    if ( (pclkblk = ptcb->pclkblk) != NULLCLK)
   6201					;
   6202					     ?debug  L 2053
   6203	1BBD  8B 5E F6			     mov     bx,word ptr [bp-10]
   6204	1BC0  8B 57 06			     mov     dx,word ptr [bx+6]
   6205	1BC3  8B 47 04			     mov     ax,word ptr [bx+4]
   6206	1BC6  89 56 F2			     mov     word ptr [bp-14],dx
   6207	1BC9  89 46 F0			     mov     word ptr [bp-16],ax
   6208	1BCC  0B C2			     or	     ax,dx
   6209	1BCE  74 17			     je	     short @2@13330
   6210					;
   6211					;		    {
   6212					;		       unlink_timer(pclkblk);
   6213					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 110
.\rtxc.asm



   6214					     ?debug  L 2055
   6215	1BD0  52			     push    dx
   6216	1BD1  FF 76 F0			     push    word ptr [bp-16]
   6217	1BD4  E8 11D8			     call    near ptr unlink_timer
   6218	1BD7  83 C4 04			     add     sp,4
   6219					;
   6220					;		       ptcb->pclkblk = NULLCLK;
   6221					;
   6222					     ?debug  L 2056
   6223	1BDA  8B 5E F6			     mov     bx,word ptr [bp-10]
   6224	1BDD  C7 47 06 0000		     mov     word ptr [bx+6],0
   6225	1BE2  C7 47 04 0000		     mov     word ptr [bx+4],0
   6226	1BE7			     @2@13330:
   6227					;
   6228					;		    }
   6229					;    #endif /* } QUEUE_TIMEOUTS	*/
   6230					;
   6231					;		    p2a	= ((FRAME ks_stk *)(ptcb->sp))->pksnum;
   6232					;
   6233					     ?debug  L 2060
   6234	1BE7  8B 5E F6			     mov     bx,word ptr [bp-10]
   6235	1BEA  C4 5F 0C			     les     bx,dword ptr [bx+12]
   6236	1BED  26: 8B 57	0E		     mov     dx,word ptr es:[bx+14]
   6237	1BF1  26: 8B 47	0C		     mov     ax,word ptr es:[bx+12]
   6238	1BF5  89 56 E2			     mov     word ptr [bp-30],dx
   6239	1BF8  89 46 E0			     mov     word ptr [bp-32],ax
   6240					;
   6241					;
   6242					;		    ((struct qarg ks_stk *)p2a)->ksrc =	RC_GOOD;
   6243					;
   6244					     ?debug  L 2062
   6245	1BFB  C4 5E E0			     les     bx,dword ptr [bp-32]
   6246	1BFE  26: C7 47	02 0000		     mov     word ptr es:[bx+2],0
   6247					;
   6248					;
   6249					;		    /* move data into queue */
   6250					;		    pqh->curndx++;
   6251					;
   6252					     ?debug  L 2065
   6253	1C04  8B 5E D0			     mov     bx,word ptr [bp-48]
   6254	1C07  FF 47 0A			     inc     word ptr [bx+10]
   6255					;
   6256					;		    if (++pqh->putndx == depth)
   6257					;
   6258					     ?debug  L 2066
   6259	1C0A  FF 47 08			     inc     word ptr [bx+8]
   6260	1C0D  8B 47 08			     mov     ax,word ptr [bx+8]
   6261	1C10  3B 46 CC			     cmp     ax,word ptr [bp-52]
   6262	1C13  75 05			     jne     short @2@13386
   6263					;
   6264					;		       pqh->putndx = 0;	 /* recycle index */
   6265					;
   6266					     ?debug  L 2067
   6267	1C15  C7 47 08 0000		     mov     word ptr [bx+8],0
   6268	1C1A			     @2@13386:
   6269					;
   6270					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 111
.\rtxc.asm



   6271					;		    qindex = pqh->putndx;
   6272					;
   6273					     ?debug  L 2069
   6274	1C1A  8B 5E D0			     mov     bx,word ptr [bp-48]
   6275	1C1D  8B 47 08			     mov     ax,word ptr [bx+8]
   6276	1C20  89 46 CE			     mov     word ptr [bp-50],ax
   6277					;
   6278					;
   6279					;    #ifdef QUEUE_MEMCPY /* { */
   6280					;		    if (width)
   6281					;		       memcpy(pqh->base	+ (qindex * width),
   6282					;			      ((struct qarg ks_stk *)p2a)->data,
   6283					;			      width);
   6284					;    #else /* }	QUEUE_MEMCPY { */
   6285					;		    switch(width)
   6286					;
   6287					     ?debug  L 2077
   6288	1C23  8B 5E CA			     mov     bx,word ptr [bp-54]
   6289	1C26  83 FB 04			     cmp     bx,4
   6290	1C29  77 61			     ja	     short @2@13582
   6291	1C2B  03 DB			     add     bx,bx
   6292	1C2D  2E: FF A7	20FBr		     jmp     word ptr cs:@2@C14546[bx]
   6293	1C32			     @2@13498:
   6294					;
   6295					;		    {
   6296					;		       case 0:
   6297					;			  break;
   6298					;
   6299					;		       case sizeof(char):
   6300					;			  *(char *)(pqh->base +	qindex)	=
   6301					;
   6302					     ?debug  L 2083
   6303					;
   6304					;				    *(char *)(((struct qarg ks_stk *)p2a)->data);
   6305					;
   6306					     ?debug  L 2084
   6307	1C32  C4 5E E0			     les     bx,dword ptr [bp-32]
   6308	1C35  26: C4 5F	08		     les     bx,dword ptr es:[bx+8]
   6309	1C39  26: 8A 07			     mov     al,byte ptr es:[bx]
   6310	1C3C  8B 5E D0			     mov     bx,word ptr [bp-48]
   6311	1C3F  C4 1F			     les     bx,dword ptr [bx]
   6312	1C41  03 5E CE			     add     bx,word ptr [bp-50]
   6313	1C44  26: 88 07			     mov     byte ptr es:[bx],al
   6314					;
   6315					;			  break;
   6316					;
   6317					     ?debug  L 2085
   6318	1C47  EB 6E			     jmp     short @2@13610
   6319	1C49			     @2@13526:
   6320					;
   6321					;
   6322					;		       case sizeof(short):
   6323					;			  *(short *)(pqh->base + (qindex << 1))	=
   6324					;
   6325					     ?debug  L 2088
   6326					;
   6327					;				    *(short *)(((struct	qarg ks_stk *)p2a)->data);
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 112
.\rtxc.asm



   6328					;
   6329					     ?debug  L 2089
   6330	1C49  8B 5E D0			     mov     bx,word ptr [bp-48]
   6331	1C4C  C4 1F			     les     bx,dword ptr [bx]
   6332	1C4E  8B 46 CE			     mov     ax,word ptr [bp-50]
   6333	1C51  03 C0			     add     ax,ax
   6334	1C53  03 D8			     add     bx,ax
   6335	1C55  06			     push    es
   6336	1C56  C4 76 E0			     les     si,dword ptr [bp-32]
   6337	1C59  26: C4 74	08		     les     si,dword ptr es:[si+8]
   6338	1C5D  26: 8B 04			     mov     ax,word ptr es:[si]
   6339	1C60  07			     pop     es
   6340	1C61  26: 89 07			     mov     word ptr es:[bx],ax
   6341					;
   6342					;			  break;
   6343					;
   6344					     ?debug  L 2090
   6345	1C64  EB 51			     jmp     short @2@13610
   6346	1C66			     @2@13554:
   6347					;
   6348					;
   6349					;		       case sizeof(long):
   6350					;			  *(long *)(pqh->base +	(qindex	<< 2)) =
   6351					;
   6352					     ?debug  L 2093
   6353					;
   6354					;				    *(long *)(((struct qarg ks_stk *)p2a)->data);
   6355					;
   6356					     ?debug  L 2094
   6357	1C66  8B 5E D0			     mov     bx,word ptr [bp-48]
   6358	1C69  C4 1F			     les     bx,dword ptr [bx]
   6359	1C6B  8B 46 CE			     mov     ax,word ptr [bp-50]
   6360	1C6E  C1 E0 02			     shl     ax,2
   6361	1C71  03 D8			     add     bx,ax
   6362	1C73  06			     push    es
   6363	1C74  C4 76 E0			     les     si,dword ptr [bp-32]
   6364	1C77  26: C4 74	08		     les     si,dword ptr es:[si+8]
   6365	1C7B  26: 8B 54	02		     mov     dx,word ptr es:[si+2]
   6366	1C7F  26: 8B 04			     mov     ax,word ptr es:[si]
   6367	1C82  07			     pop     es
   6368	1C83  26: 89 57	02		     mov     word ptr es:[bx+2],dx
   6369	1C87  26: 89 07			     mov     word ptr es:[bx],ax
   6370					;
   6371					;			  break;
   6372					;
   6373					     ?debug  L 2095
   6374	1C8A  EB 2B			     jmp     short @2@13610
   6375	1C8C			     @2@13582:
   6376					;
   6377					;
   6378					;		       default:
   6379					;			  memcpy(pqh->base + (qindex * width),
   6380					;
   6381					     ?debug  L 2098
   6382					;
   6383					;				((struct qarg ks_stk *)p2a)->data,
   6384					;				width);
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 113
.\rtxc.asm



   6385					;
   6386					     ?debug  L 2100
   6387	1C8C  FF 76 CA			     push    word ptr [bp-54]
   6388	1C8F  C4 5E E0			     les     bx,dword ptr [bp-32]
   6389	1C92  26: FF 77	0A		     push    word ptr es:[bx+10]
   6390	1C96  26: FF 77	08		     push    word ptr es:[bx+8]
   6391	1C9A  8B 5E D0			     mov     bx,word ptr [bp-48]
   6392	1C9D  8B 07			     mov     ax,word ptr [bx]
   6393	1C9F  53			     push    bx
   6394	1CA0  50			     push    ax
   6395	1CA1  8B 46 CE			     mov     ax,word ptr [bp-50]
   6396	1CA4  F7 6E CA			     imul    word ptr [bp-54]
   6397	1CA7  5A			     pop     dx
   6398	1CA8  03 D0			     add     dx,ax
   6399	1CAA  5B			     pop     bx
   6400	1CAB  FF 77 02			     push    word ptr [bx+2]
   6401	1CAE  52			     push    dx
   6402	1CAF  9A 00000000se		     call    far ptr _memcpy
   6403	1CB4  83 C4 0A			     add     sp,10
   6404					;
   6405					;			  break;
   6406					;
   6407					     ?debug  L 2101
   6408	1CB7			     @2@13610:
   6409					;
   6410					;		    }
   6411					;    #endif /* } QUEUE_MEMCPY */
   6412					;
   6413					;    #ifdef CBUG /* { */
   6414					;		    pqh->count++; /* increment total no. of enqueues to	date */
   6415					;		    if (pqh->curndx > pqh->worst) /* check for new worst case */
   6416					;		       pqh->worst = pqh->curndx;
   6417					;    #endif /* } CBUG */
   6418					;
   6419					;    #ifdef QUEUE_SEMAS	/* { */
   6420					;		    /* queue was empty - process not empty sema	for consumer */
   6421					;		    if (pqh->curndx == 1)
   6422					;
   6423					     ?debug  L 2113
   6424	1CB7  8B 5E D0			     mov     bx,word ptr [bp-48]
   6425	1CBA  83 7F 0A 01		     cmp     word ptr [bx+10],1
   6426	1CBE  75 47			     jne     short @2@13890
   6427					;
   6428					;		    {
   6429					;		       UPDATE_SEMA(pqh->nesema);
   6430					;
   6431					     ?debug  L 2115
   6432	1CC0  83 7F 12 00		     cmp     word ptr [bx+18],0
   6433	1CC4  74 41			     je	     short @2@13890
   6434	1CC6  8B 5F 12			     mov     bx,word ptr [bx+18]
   6435	1CC9  03 DB			     add     bx,bx
   6436	1CCB  83 BF 0000e FF		     cmp     word ptr DGROUP:_semat[bx],-1
   6437	1CD0  75 10			     jne     short @2@13722
   6438	1CD2  8B 5E D0			     mov     bx,word ptr [bp-48]
   6439	1CD5  8B 5F 12			     mov     bx,word ptr [bx+18]
   6440	1CD8  03 DB			     add     bx,bx
   6441	1CDA  C7 87 0000e 0000		     mov     word ptr DGROUP:_semat[bx],0
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 114
.\rtxc.asm



   6442	1CE0  EB 25			     jmp     short @2@13890
   6443	1CE2			     @2@13722:
   6444	1CE2  8B 5E D0			     mov     bx,word ptr [bp-48]
   6445	1CE5  8B 5F 12			     mov     bx,word ptr [bx+18]
   6446	1CE8  03 DB			     add     bx,bx
   6447	1CEA  83 BF 0000e 00		     cmp     word ptr DGROUP:_semat[bx],0
   6448	1CEF  75 02			     jne     short @2@13778
   6449	1CF1  EB 14			     jmp     short @2@13890
   6450	1CF3			     @2@13778:
   6451	1CF3  FA			     cli
   6452	1CF4  90			     nop
   6453	1CF5  8B 5E D0			     mov     bx,word ptr [bp-48]
   6454	1CF8  8B 47 12			     mov     ax,word ptr [bx+18]
   6455	1CFB  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
   6456	1CFF  89 07			     mov     word ptr [bx],ax
   6457	1D01  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
   6458	1D06  FB			     sti
   6459	1D07			     @2@13890:
   6460					     ?debug  L 2039
   6461	1D07  8B 5E D0			     mov     bx,word ptr [bp-48]
   6462	1D0A  8B 47 0C			     mov     ax,word ptr [bx+12]
   6463	1D0D  89 46 F6			     mov     word ptr [bp-10],ax
   6464	1D10  0B C0			     or	     ax,ax
   6465	1D12  74 03			     je	     @@46
   6466	1D14  E9 FE6F			     jmp     @2@13162
   6467	1D17			     @@46:
   6468					;
   6469					;		    }
   6470					;    #endif /* } QUEUE_SEMAS */
   6471					;
   6472					;		 } /* end of while */
   6473					;    #endif /* } QUEUE_WAITERS */
   6474					;
   6475					;	      }
   6476					;	      break;
   6477					;
   6478					     ?debug  L 2123
   6479	1D17  E9 03B4			     jmp     @2@15430
   6480	1D1A			     @2@13946:
   6481					;
   6482					;    #endif /* } HAS_PURGEQUEUE	*/
   6483					;
   6484					;    /************************/
   6485					;	   case	RTXC_EXECUTE:
   6486					;    /************************/
   6487					;	      ptcb = &rtxtcb[task = ((struct targ ks_stk *)p2)->task];
   6488					;
   6489					     ?debug  L 2129
   6490	1D1A  C4 5E FC			     les     bx,dword ptr [bp-4]
   6491	1D1D  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   6492	1D21  89 46 F4			     mov     word ptr [bp-12],ax
   6493	1D24  6B C0 28			     imul    ax,ax,40
   6494	1D27  05 0000e			     add     ax,offset DGROUP:_rtxtcb
   6495	1D2A  89 46 F6			     mov     word ptr [bp-10],ax
   6496					;
   6497					;
   6498					;	      /* if task is already executing, then stop and restart */
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 115
.\rtxc.asm



   6499					;	      if (ptcb->status == READY)
   6500					;
   6501					     ?debug  L 2132
   6502	1D2D  8B 5E F6			     mov     bx,word ptr [bp-10]
   6503	1D30  83 7F 10 00		     cmp     word ptr [bx+16],0
   6504	1D34  75 12			     jne     short @2@14002
   6505					;
   6506					;	      {
   6507					;		 ptcb->flink->blink = ptcb->blink; /* general unlink */
   6508					;
   6509					     ?debug  L 2134
   6510	1D36  8B 47 02			     mov     ax,word ptr [bx+2]
   6511	1D39  8B 1F			     mov     bx,word ptr [bx]
   6512	1D3B  89 47 02			     mov     word ptr [bx+2],ax
   6513					;
   6514					;		 ptcb->blink->flink = ptcb->flink;
   6515					;
   6516					     ?debug  L 2135
   6517	1D3E  8B 5E F6			     mov     bx,word ptr [bp-10]
   6518	1D41  8B 07			     mov     ax,word ptr [bx]
   6519	1D43  8B 5F 02			     mov     bx,word ptr [bx+2]
   6520	1D46  89 07			     mov     word ptr [bx],ax
   6521	1D48			     @2@14002:
   6522					;
   6523					;	      }
   6524					;
   6525					;    #ifdef KS_STK_FAR /* { */
   6526					;	      /* initialize stack pointer */
   6527					;	      frame = ptcb->sp = (FRAME	*)spfixup(task);
   6528					;
   6529					     ?debug  L 2140
   6530	1D48  FF 76 F4			     push    word ptr [bp-12]
   6531	1D4B  E8 E2B2			     call    near ptr spfixup
   6532	1D4E  83 C4 02			     add     sp,2
   6533	1D51  8B 5E F6			     mov     bx,word ptr [bp-10]
   6534	1D54  89 57 0E			     mov     word ptr [bx+14],dx
   6535	1D57  89 47 0C			     mov     word ptr [bx+12],ax
   6536	1D5A  89 56 FA			     mov     word ptr [bp-6],dx
   6537	1D5D  89 46 F8			     mov     word ptr [bp-8],ax
   6538					;
   6539					;    #else /* }	KS_STK_FAR { */
   6540					;	      /* initialize task stack pointer */
   6541					;	      frame = (FRAME ks_stk *)(ptcb->stackbase +
   6542					;				    ptcb->stacksize - sizeof(FRAME));
   6543					;	      ptcb->sp = (FRAME	*)frame;
   6544					;    #endif /* } KS_STK_FAR */
   6545					;
   6546					;	      frame->pc	= ptcb->pc_t0; /* initialize program counter */
   6547					;
   6548					     ?debug  L 2148
   6549	1D60  8B 57 14			     mov     dx,word ptr [bx+20]
   6550	1D63  8B 47 12			     mov     ax,word ptr [bx+18]
   6551	1D66  C4 5E F8			     les     bx,dword ptr [bp-8]
   6552	1D69  26: 89 57	16		     mov     word ptr es:[bx+22],dx
   6553	1D6D  26: 89 47	14		     mov     word ptr es:[bx+20],ax
   6554					;
   6555					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 116
.\rtxc.asm



   6556					;	      frame->ccr = CCR_T0; /* initialize status	register at task startup */
   6557					;
   6558					     ?debug  L 2150
   6559	1D71  26: C7 47	18 0200		     mov     word ptr es:[bx+24],512
   6560					;
   6561					;
   6562					;	      frame->ds	= frame->es = _DS; /* initialize segment regs to DGROUP	*/
   6563					;
   6564					     ?debug  L 2152
   6565	1D77  8C D8			     mov     ax,ds
   6566	1D79  26: 89 47	10		     mov     word ptr es:[bx+16],ax
   6567	1D7D  26: 89 47	12		     mov     word ptr es:[bx+18],ax
   6568					;
   6569					;
   6570					;    #ifdef TIME_SLICE /* { */
   6571					;	      ptcb->tslice = 0;
   6572					;
   6573					     ?debug  L 2155
   6574	1D81  8B 5E F6			     mov     bx,word ptr [bp-10]
   6575	1D84  C7 47 1E 0000		     mov     word ptr [bx+30],0
   6576	1D89  C7 47 1C 0000		     mov     word ptr [bx+28],0
   6577					;
   6578					;	      ptcb->newslice = 0;
   6579					;
   6580					     ?debug  L 2156
   6581	1D8E  C7 47 22 0000		     mov     word ptr [bx+34],0
   6582	1D93  C7 47 20 0000		     mov     word ptr [bx+32],0
   6583					;
   6584					;    #endif /* } TIME_SLICE */
   6585					;
   6586					;    #ifdef SYNC_START /* { */
   6587					;	      if (hipritsk->task == 0)
   6588					;		 ptcb->status =	BLOCK_WAIT; /* mark task blocked */
   6589					;	      else
   6590					;		 ptcb->status =	READY; /* mark task runnable */
   6591					;    #else /* }	SYNC_START { */
   6592					;	      ptcb->status = READY; /* mark task runnable */
   6593					;
   6594					     ?debug  L 2165
   6595	1D98  C7 47 10 0000		     mov     word ptr [bx+16],0
   6596					;
   6597					;    #endif /* } SYNC_START */
   6598					;
   6599					;    #ifdef FPU	/* { */
   6600					;	       /* if fpregs area allocated */
   6601					;	      if ( (fpregs = rtxtcb[task].fpregs) != NULLFPREGS)
   6602					;	      {
   6603					;		       /* init fpu to known state */
   6604					;
   6605					;		 /* processor dependent	fpu initialization goes	here */
   6606					;			    /* fpregs->? = ?; */
   6607					;
   6608					;		 fpregs->control = 0x1370;  /* see hw manual */
   6609					;		 fpregs->status	= 0x4100;  /* for more details */
   6610					;		 fpregs->tag = 0xffff;	    /* all regs	empty */
   6611					;
   6612					;		 ptcb->fpumode = 1;	    /* mark task as fpu	user */
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 117
.\rtxc.asm



   6613					;	      }
   6614					;    #ifdef BSS_NOT_ZERO /* { */
   6615					;	      else
   6616					;	      {
   6617					;		 ptcb->fpumode = 0;	    /* mark task as non	fpu user */
   6618					;	      }
   6619					;    #endif /* } BSS_NOT_ZERO */
   6620					;    #endif /* } FPU */
   6621					;
   6622					;    #ifdef SYNC_START /* { */
   6623					;	      if (ptcb->status == READY)
   6624					;	      {
   6625					;		 /* insert new task into list for later	*/
   6626					;		 ptcb->flink = nsrttcb;
   6627					;		 nsrttcb = ptcb;
   6628					;	      }
   6629					;    #else /* }	SYNC_START { */
   6630					;	      /* insert	new task into list for later */
   6631					;	      ptcb->flink = nsrttcb;
   6632					;
   6633					     ?debug  L 2200
   6634	1D9D  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
   6635	1DA0  89 07			     mov     word ptr [bx],ax
   6636					;
   6637					;	      nsrttcb =	ptcb;
   6638					;
   6639					     ?debug  L 2201
   6640	1DA2  8B 46 F6			     mov     ax,word ptr [bp-10]
   6641	1DA5  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
   6642					;
   6643					;    #endif /* } SYNC_START */
   6644					;
   6645					;	      break;
   6646					;
   6647					     ?debug  L 2204
   6648	1DA8  E9 0323			     jmp     @2@15430
   6649	1DAB			     @2@14030:
   6650					;
   6651					;
   6652					;    #ifdef HAS_DEFTASK	/* { */
   6653					;    /************************/
   6654					;	   case	RTXC_DEFTASK:
   6655					;    /************************/
   6656					;	      if ( (task = ((struct deftaskarg ks_stk *)p2)->task) == SELFTASK)
   6657					;
   6658					     ?debug  L 2210
   6659	1DAB  C4 5E FC			     les     bx,dword ptr [bp-4]
   6660	1DAE  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   6661	1DB2  89 46 F4			     mov     word ptr [bp-12],ax
   6662	1DB5  0B C0			     or	     ax,ax
   6663	1DB7  75 09			     jne     short @2@14086
   6664					;
   6665					;	      {
   6666					;		 ((struct deftaskarg ks_stk *)p2)->ksrc	= RC_ILLEGAL_TASK;
   6667					;
   6668					     ?debug  L 2212
   6669	1DB9  26: C7 47	02 000B		     mov     word ptr es:[bx+2],11
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 118
.\rtxc.asm



   6670					;
   6671					;		 break;
   6672					;
   6673					     ?debug  L 2213
   6674	1DBF  E9 030C			     jmp     @2@15430
   6675	1DC2			     @2@14086:
   6676					;
   6677					;	      }
   6678					;
   6679					;	      ptcb = &rtxtcb[task];
   6680					;
   6681					     ?debug  L 2216
   6682	1DC2  8B 46 F4			     mov     ax,word ptr [bp-12]
   6683	1DC5  6B C0 28			     imul    ax,ax,40
   6684	1DC8  05 0000e			     add     ax,offset DGROUP:_rtxtcb
   6685	1DCB  89 46 F6			     mov     word ptr [bp-10],ax
   6686					;
   6687					;
   6688					;	      /* if task is "active", then abort deftask operation */
   6689					;	      if ( (ptcb->status & INACTIVE) !=	INACTIVE)
   6690					;
   6691					     ?debug  L 2219
   6692	1DCE  8B 5E F6			     mov     bx,word ptr [bp-10]
   6693	1DD1  8B 47 10			     mov     ax,word ptr [bx+16]
   6694	1DD4  25 0100			     and     ax,256
   6695	1DD7  3D 0100			     cmp     ax,256
   6696	1DDA  74 0C			     je	     short @2@14142
   6697					;
   6698					;	      {
   6699					;		 ((struct deftaskarg ks_stk *)p2)->ksrc	= RC_ACTIVE_TASK;
   6700					;
   6701					     ?debug  L 2221
   6702	1DDC  C4 5E FC			     les     bx,dword ptr [bp-4]
   6703	1DDF  26: C7 47	02 000C		     mov     word ptr es:[bx+2],12
   6704					;
   6705					;		 break;
   6706					;
   6707					     ?debug  L 2222
   6708	1DE5  E9 02E6			     jmp     @2@15430
   6709	1DE8			     @2@14142:
   6710					;
   6711					;	      }
   6712					;
   6713					;	      ptcb->priority =	((struct deftaskarg ks_stk *)p2)->priority;
   6714					;
   6715					     ?debug  L 2225
   6716	1DE8  C4 5E FC			     les     bx,dword ptr [bp-4]
   6717	1DEB  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
   6718	1DEF  8B 5E F6			     mov     bx,word ptr [bp-10]
   6719	1DF2  89 47 0A			     mov     word ptr [bx+10],ax
   6720					;
   6721					;
   6722					;	      if ( ((struct deftaskarg ks_stk *)p2)->stackbase)	/* new stack */
   6723					;
   6724					     ?debug  L 2227
   6725	1DF5  8B 5E FC			     mov     bx,word ptr [bp-4]
   6726	1DF8  26: 8B 47	08		     mov     ax,word ptr es:[bx+8]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 119
.\rtxc.asm



   6727	1DFC  26: 0B 47	0A		     or	     ax,word ptr es:[bx+10]
   6728	1E00  74 1E			     je	     short @2@14198
   6729					;
   6730					;	      {
   6731					;		 ptcb->stackbase = ((struct deftaskarg ks_stk *)p2)->stackbase;
   6732					;
   6733					     ?debug  L 2229
   6734	1E02  26: 8B 57	0A		     mov     dx,word ptr es:[bx+10]
   6735	1E06  26: 8B 47	08		     mov     ax,word ptr es:[bx+8]
   6736	1E0A  8B 5E F6			     mov     bx,word ptr [bp-10]
   6737	1E0D  89 57 18			     mov     word ptr [bx+24],dx
   6738	1E10  89 47 16			     mov     word ptr [bx+22],ax
   6739					;
   6740					;		 ptcb->stacksize = ((struct deftaskarg ks_stk *)p2)->stacksize;
   6741					;
   6742					     ?debug  L 2230
   6743	1E13  8B 5E FC			     mov     bx,word ptr [bp-4]
   6744	1E16  26: 8B 47	0C		     mov     ax,word ptr es:[bx+12]
   6745	1E1A  8B 5E F6			     mov     bx,word ptr [bp-10]
   6746	1E1D  89 47 1A			     mov     word ptr [bx+26],ax
   6747	1E20			     @2@14198:
   6748					;
   6749					;	      }
   6750					;
   6751					;	      ptcb->pc_t0 =  ((struct deftaskarg ks_stk	*)p2)->entry;
   6752					;
   6753					     ?debug  L 2233
   6754	1E20  C4 5E FC			     les     bx,dword ptr [bp-4]
   6755	1E23  26: 8B 57	10		     mov     dx,word ptr es:[bx+16]
   6756	1E27  26: 8B 47	0E		     mov     ax,word ptr es:[bx+14]
   6757	1E2B  8B 5E F6			     mov     bx,word ptr [bp-10]
   6758	1E2E  89 57 14			     mov     word ptr [bx+20],dx
   6759	1E31  89 47 12			     mov     word ptr [bx+18],ax
   6760					;
   6761					;
   6762					;	      ptcb->pclkblk = NULLCLK;
   6763					;
   6764					     ?debug  L 2235
   6765	1E34  C7 47 06 0000		     mov     word ptr [bx+6],0
   6766	1E39  C7 47 04 0000		     mov     word ptr [bx+4],0
   6767					;
   6768					;
   6769					;    #ifdef TIME_SLICE /* { */
   6770					;	      ptcb->tslice = 0;
   6771					;
   6772					     ?debug  L 2238
   6773	1E3E  C7 47 1E 0000		     mov     word ptr [bx+30],0
   6774	1E43  C7 47 1C 0000		     mov     word ptr [bx+28],0
   6775					;
   6776					;	      ptcb->newslice = 0;
   6777					;
   6778					     ?debug  L 2239
   6779	1E48  C7 47 22 0000		     mov     word ptr [bx+34],0
   6780	1E4D  C7 47 20 0000		     mov     word ptr [bx+32],0
   6781					;
   6782					;    #endif /* } TIME_SLICE */
   6783					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 120
.\rtxc.asm



   6784					;	      break;
   6785					;
   6786					     ?debug  L 2242
   6787	1E52  E9 0279			     jmp     @2@15430
   6788	1E55			     @2@14226:
   6789					;
   6790					;    #endif /* } HAS_DEFTASK */
   6791					;
   6792					;    #ifdef HAS_INQTASK_ARG /* { */
   6793					;    /************************/
   6794					;	   case	RTXC_INQTASK_ARG:
   6795					;    /************************/
   6796					;	      if ( (task = ((struct deftaskarg ks_stk *)p2)->task) == SELFTASK)
   6797					;
   6798					     ?debug  L 2249
   6799	1E55  C4 5E FC			     les     bx,dword ptr [bp-4]
   6800	1E58  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   6801	1E5C  89 46 F4			     mov     word ptr [bp-12],ax
   6802	1E5F  0B C0			     or	     ax,ax
   6803	1E61  75 0A			     jne     short @2@14282
   6804					;
   6805					;		 task =	hipritsk->task;
   6806					;
   6807					     ?debug  L 2250
   6808	1E63  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   6809	1E67  8B 47 08			     mov     ax,word ptr [bx+8]
   6810	1E6A  89 46 F4			     mov     word ptr [bp-12],ax
   6811	1E6D			     @2@14282:
   6812					;
   6813					;	      ((struct deftaskarg ks_stk *)p2)->arg = rtxtcb[task].arg;
   6814					;
   6815					     ?debug  L 2251
   6816	1E6D  8B 5E F4			     mov     bx,word ptr [bp-12]
   6817	1E70  6B DB 28			     imul    bx,bx,40
   6818	1E73  8B 97 0026e		     mov     dx,word ptr DGROUP:_rtxtcb[bx+38]
   6819	1E77  8B 87 0024e		     mov     ax,word ptr DGROUP:_rtxtcb[bx+36]
   6820	1E7B  C4 5E FC			     les     bx,dword ptr [bp-4]
   6821	1E7E  26: 89 57	14		     mov     word ptr es:[bx+20],dx
   6822	1E82  26: 89 47	12		     mov     word ptr es:[bx+18],ax
   6823					;
   6824					;	      break;
   6825					;
   6826					     ?debug  L 2252
   6827	1E86  E9 0245			     jmp     @2@15430
   6828	1E89			     @2@14310:
   6829					;
   6830					;    #endif /* } HAS_INQTASK_ARG */
   6831					;
   6832					;    #ifdef HAS_DEFTASK_ARG /* { */
   6833					;    /************************/
   6834					;	   case	RTXC_DEFTASK_ARG:
   6835					;    /************************/
   6836					;	      if ( (task = ((struct deftaskarg ks_stk *)p2)->task) == SELFTASK)
   6837					;
   6838					     ?debug  L 2259
   6839	1E89  C4 5E FC			     les     bx,dword ptr [bp-4]
   6840	1E8C  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 121
.\rtxc.asm



   6841	1E90  89 46 F4			     mov     word ptr [bp-12],ax
   6842	1E93  0B C0			     or	     ax,ax
   6843	1E95  75 0A			     jne     short @2@14366
   6844					;
   6845					;		 task =	hipritsk->task;
   6846					;
   6847					     ?debug  L 2260
   6848	1E97  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   6849	1E9B  8B 47 08			     mov     ax,word ptr [bx+8]
   6850	1E9E  89 46 F4			     mov     word ptr [bp-12],ax
   6851	1EA1			     @2@14366:
   6852					;
   6853					;	      rtxtcb[task].arg = ((struct deftaskarg ks_stk *)p2)->arg;
   6854					;
   6855					     ?debug  L 2261
   6856	1EA1  C4 5E FC			     les     bx,dword ptr [bp-4]
   6857	1EA4  26: 8B 57	14		     mov     dx,word ptr es:[bx+20]
   6858	1EA8  26: 8B 47	12		     mov     ax,word ptr es:[bx+18]
   6859	1EAC  8B 5E F4			     mov     bx,word ptr [bp-12]
   6860	1EAF  6B DB 28			     imul    bx,bx,40
   6861	1EB2  89 97 0026e		     mov     word ptr DGROUP:_rtxtcb[bx+38],dx
   6862	1EB6  89 87 0024e		     mov     word ptr DGROUP:_rtxtcb[bx+36],ax
   6863					;
   6864					;	      break;
   6865					;
   6866					     ?debug  L 2262
   6867	1EBA  E9 0211			     jmp     @2@15430
   6868	1EBD			     @2@14394:
   6869					;
   6870					;    #endif /* } HAS_DEFTASK_ARG */
   6871					;
   6872					;    #ifdef HAS_ALLOC_TASK /* {	*/
   6873					;    /************************/
   6874					;	   case	RTXC_ALLOC_TASK:
   6875					;    /************************/
   6876					;	      if ( (ptcb = dtcbfl) != NULLTCB) /* allocate tcb */
   6877					;
   6878					     ?debug  L 2269
   6879	1EBD  A1 0008r			     mov     ax,word ptr DGROUP:_dtcbfl
   6880	1EC0  89 46 F6			     mov     word ptr [bp-10],ax
   6881	1EC3  0B C0			     or	     ax,ax
   6882	1EC5  74 18			     je	     short @2@14450
   6883					;
   6884					;	      {
   6885					;		 dtcbfl	= ptcb->flink; /* by removing 1st from free list */
   6886					;
   6887					     ?debug  L 2271
   6888	1EC7  8B 5E F6			     mov     bx,word ptr [bp-10]
   6889	1ECA  8B 07			     mov     ax,word ptr [bx]
   6890	1ECC  A3 0008r			     mov     word ptr DGROUP:_dtcbfl,ax
   6891					;
   6892					;		 ((struct targ ks_stk *)p2)->task = ptcb->task;
   6893					;
   6894					     ?debug  L 2272
   6895	1ECF  C4 5E FC			     les     bx,dword ptr [bp-4]
   6896	1ED2  8B 76 F6			     mov     si,word ptr [bp-10]
   6897	1ED5  8B 44 08			     mov     ax,word ptr [si+8]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 122
.\rtxc.asm



   6898	1ED8  26: 89 47	04		     mov     word ptr es:[bx+4],ax
   6899					;
   6900					;	      }
   6901					;
   6902					     ?debug  L 2273
   6903	1EDC  E9 01EF			     jmp     @2@15430
   6904	1EDF			     @2@14450:
   6905	1EDF  C4 5E FC			     les     bx,dword ptr [bp-4]
   6906	1EE2  26: C7 47	04 0000		     mov     word ptr es:[bx+4],0
   6907	1EE8  E9 01E3			     jmp     @2@15430
   6908	1EEB			     @2@14478:
   6909					;
   6910					;	      else
   6911					;		 ((struct targ ks_stk *)p2)->task = (TASK)0;
   6912					;	      break;
   6913					;    #endif /* } HAS_ALLOC_TASK	*/
   6914					;
   6915					;    #ifdef HAS_TERMINATE /* { */
   6916					;    /************************/
   6917					;	   case	RTXC_TERMINATE:
   6918					;    /************************/
   6919					;	      if ( (task = ((struct targ *)p2)->task) == SELFTASK)
   6920					;
   6921					     ?debug  L 2283
   6922	1EEB  C4 5E FC			     les     bx,dword ptr [bp-4]
   6923	1EEE  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   6924	1EF2  89 46 F4			     mov     word ptr [bp-12],ax
   6925	1EF5  0B C0			     or	     ax,ax
   6926	1EF7  75 12			     jne     short @2@14534
   6927					;
   6928					;	      {
   6929					;		 ptcb =	hipritsk;
   6930					;
   6931					     ?debug  L 2285
   6932	1EF9  A1 0000r			     mov     ax,word ptr DGROUP:_hipritsk
   6933	1EFC  89 46 F6			     mov     word ptr [bp-10],ax
   6934					;
   6935					;		 task =	hipritsk->task;
   6936					;
   6937					     ?debug  L 2286
   6938	1EFF  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   6939	1F03  8B 47 08			     mov     ax,word ptr [bx+8]
   6940	1F06  89 46 F4			     mov     word ptr [bp-12],ax
   6941					;
   6942					;	      }
   6943					;
   6944					     ?debug  L 2287
   6945	1F09  EB 0C			     jmp     short @2@14562
   6946	1F0B			     @2@14534:
   6947					;
   6948					;	      else
   6949					;		 ptcb =	&rtxtcb[task];
   6950					;
   6951					     ?debug  L 2289
   6952	1F0B  8B 46 F4			     mov     ax,word ptr [bp-12]
   6953	1F0E  6B C0 28			     imul    ax,ax,40
   6954	1F11  05 0000e			     add     ax,offset DGROUP:_rtxtcb
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 123
.\rtxc.asm



   6955	1F14  89 46 F6			     mov     word ptr [bp-10],ax
   6956	1F17			     @2@14562:
   6957					;
   6958					;
   6959					;	      /* if task has a timeout timer */
   6960					;	      if ( (pclkblk = ptcb->pclkblk) !=	NULLCLK)
   6961					;
   6962					     ?debug  L 2292
   6963	1F17  8B 5E F6			     mov     bx,word ptr [bp-10]
   6964	1F1A  8B 57 06			     mov     dx,word ptr [bx+6]
   6965	1F1D  8B 47 04			     mov     ax,word ptr [bx+4]
   6966	1F20  89 56 F2			     mov     word ptr [bp-14],dx
   6967	1F23  89 46 F0			     mov     word ptr [bp-16],ax
   6968	1F26  0B C2			     or	     ax,dx
   6969	1F28  74 1F			     je	     short @2@14674
   6970					;
   6971					;	      {
   6972					;		 /* if timeout is still	active */
   6973					;		 if (pclkblk->state == TIMER_ACTIVE)
   6974					;
   6975					     ?debug  L 2295
   6976	1F2A  C4 5E F0			     les     bx,dword ptr [bp-16]
   6977	1F2D  26: 80 7F	12 01		     cmp     byte ptr es:[bx+18],1
   6978	1F32  75 08			     jne     short @2@14646
   6979					;
   6980					;		 {
   6981					;		    unlink_timer(pclkblk);
   6982					;
   6983					     ?debug  L 2297
   6984	1F34  52			     push    dx
   6985	1F35  53			     push    bx
   6986	1F36  E8 0E76			     call    near ptr unlink_timer
   6987	1F39  83 C4 04			     add     sp,4
   6988	1F3C			     @2@14646:
   6989					;
   6990					;		 }
   6991					;		 ptcb->pclkblk = NULLCLK;
   6992					;
   6993					     ?debug  L 2299
   6994	1F3C  8B 5E F6			     mov     bx,word ptr [bp-10]
   6995	1F3F  C7 47 06 0000		     mov     word ptr [bx+6],0
   6996	1F44  C7 47 04 0000		     mov     word ptr [bx+4],0
   6997	1F49			     @2@14674:
   6998					;
   6999					;	      }
   7000					;
   7001					;    #ifdef FPU	/* { */
   7002					;	      if ((ptcb->fpumode == 1) && (fputask == ptcb))
   7003					;		 fputask = NULLTCB;
   7004					;
   7005					;    #endif /* } FPU */
   7006					;
   7007					;	      if (ptcb->status & SEMAPHORE_WAIT)
   7008					;
   7009					     ?debug  L 2308
   7010	1F49  8B 5E F6			     mov     bx,word ptr [bp-10]
   7011	1F4C  F6 47 10 40		     test    byte ptr [bx+16],64
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 124
.\rtxc.asm



   7012	1F50  74 62			     je	     short @2@14898
   7013					;
   7014					;	      {
   7015					;		 p2a = ptcb->sp->pksnum;
   7016					;
   7017					     ?debug  L 2310
   7018	1F52  C4 5F 0C			     les     bx,dword ptr [bx+12]
   7019	1F55  26: 8B 57	0E		     mov     dx,word ptr es:[bx+14]
   7020	1F59  26: 8B 47	0C		     mov     ax,word ptr es:[bx+12]
   7021	1F5D  89 56 E2			     mov     word ptr [bp-30],dx
   7022	1F60  89 46 E0			     mov     word ptr [bp-32],ax
   7023					;
   7024					;		 if ((*p2a == RTXC_WAIT) || (*p2a == RTXC_SEND))
   7025					;
   7026					     ?debug  L 2311
   7027	1F63  C4 5E E0			     les     bx,dword ptr [bp-32]
   7028	1F66  26: 83 3F	01		     cmp     word ptr es:[bx],1
   7029	1F6A  74 06			     je	     short @2@14758
   7030	1F6C  26: 83 3F	04		     cmp     word ptr es:[bx],4
   7031	1F70  75 11			     jne     short @2@14786
   7032	1F72			     @2@14758:
   7033					;
   7034					;		    semat[((struct sarg	*)p2a)->sema] =	SEMA_PENDING;
   7035					;
   7036					     ?debug  L 2312
   7037	1F72  C4 5E E0			     les     bx,dword ptr [bp-32]
   7038	1F75  26: 8B 5F	04		     mov     bx,word ptr es:[bx+4]
   7039	1F79  03 DB			     add     bx,bx
   7040	1F7B  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
   7041	1F81  EB 59			     jmp     short @2@15010
   7042	1F83			     @2@14786:
   7043					;
   7044					;		 else  /* is RTXC_WAITM	*/
   7045					;		 {
   7046					;		    semalist = ((struct	sargm *)p2a)->list;
   7047					;
   7048					     ?debug  L 2315
   7049	1F83  C4 5E E0			     les     bx,dword ptr [bp-32]
   7050	1F86  26: 8B 57	08		     mov     dx,word ptr es:[bx+8]
   7051	1F8A  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
   7052	1F8E  89 56 E8			     mov     word ptr [bp-24],dx
   7053	1F91  89 46 E6			     mov     word ptr [bp-26],ax
   7054	1F94  EB 0B			     jmp     short @2@14842
   7055	1F96			     @2@14814:
   7056					;
   7057					;		    while ((sema = *semalist++)	!= NULLSEMA)
   7058					;		       semat[sema] = SEMA_PENDING;
   7059					;
   7060					     ?debug  L 2317
   7061	1F96  8B 5E EA			     mov     bx,word ptr [bp-22]
   7062	1F99  03 DB			     add     bx,bx
   7063	1F9B  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
   7064	1FA1			     @2@14842:
   7065					     ?debug  L 2316
   7066	1FA1  C4 5E E6			     les     bx,dword ptr [bp-26]
   7067	1FA4  83 46 E6 02		     add     word ptr [bp-26],2
   7068	1FA8  26: 8B 07			     mov     ax,word ptr es:[bx]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 125
.\rtxc.asm



   7069	1FAB  89 46 EA			     mov     word ptr [bp-22],ax
   7070	1FAE  0B C0			     or	     ax,ax
   7071	1FB0  75 E4			     jne     short @2@14814
   7072					;
   7073					;		 }
   7074					;	      }
   7075					;
   7076					     ?debug  L 2319
   7077	1FB2  EB 28			     jmp     short @2@15010
   7078	1FB4			     @2@14898:
   7079					;
   7080					;
   7081					;	      else if (	(ptcb->status == READY)
   7082					;
   7083					     ?debug  L 2321
   7084					;
   7085					;
   7086					;    #if defined(MAILBOX_WAITERS)   || \
   7087					;	 defined(PARTITION_WAITERS) || \
   7088					;	 defined(RESOURCE_WAITERS)  || \
   7089					;	 defined(QUEUE_WAITERS)	/* { */
   7090					;		|| (ptcb->status & COMBO_WAIT)
   7091					;    #endif /* } - MAILBOX_ || PARTITION_ || QUEUE_ || RESOURCE_WAITERS	*/
   7092					;
   7093					;					   )
   7094					;
   7095					     ?debug  L 2330
   7096	1FB4  8B 5E F6			     mov     bx,word ptr [bp-10]
   7097	1FB7  83 7F 10 00		     cmp     word ptr [bx+16],0
   7098	1FBB  74 06			     je	     short @2@14954
   7099	1FBD  F6 47 10 AA		     test    byte ptr [bx+16],170
   7100	1FC1  74 19			     je	     short @2@15010
   7101	1FC3			     @2@14954:
   7102					;
   7103					;	      {
   7104					;		 /* unlink task	from a WAITER or the READY list	(all cases have	same format)+
   7105				     */
   7106					;		 if((ptcb->blink->flink	= ptcb->flink) != NULLTCB)
   7107					;
   7108					     ?debug  L 2333
   7109	1FC3  8B 5E F6			     mov     bx,word ptr [bp-10]
   7110	1FC6  8B 07			     mov     ax,word ptr [bx]
   7111	1FC8  8B 5F 02			     mov     bx,word ptr [bx+2]
   7112	1FCB  89 07			     mov     word ptr [bx],ax
   7113	1FCD  0B C0			     or	     ax,ax
   7114	1FCF  74 0B			     je	     short @2@15010
   7115					;
   7116					;		    ptcb->flink->blink = ptcb->blink;
   7117					;
   7118					     ?debug  L 2334
   7119	1FD1  8B 5E F6			     mov     bx,word ptr [bp-10]
   7120	1FD4  8B 47 02			     mov     ax,word ptr [bx+2]
   7121	1FD7  8B 1F			     mov     bx,word ptr [bx]
   7122	1FD9  89 47 02			     mov     word ptr [bx+2],ax
   7123	1FDC			     @2@15010:
   7124					;
   7125					;	      }
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 126
.\rtxc.asm



   7126					;
   7127					;	      /* set task INACTIVE, awaiting next KS_execute() */
   7128					;	      ptcb->status = INACTIVE;
   7129					;
   7130					     ?debug  L 2338
   7131	1FDC  8B 5E F6			     mov     bx,word ptr [bp-10]
   7132	1FDF  C7 47 10 0100		     mov     word ptr [bx+16],256
   7133					;
   7134					;
   7135					;	      if (task <= ntasks)
   7136					;
   7137					     ?debug  L 2340
   7138	1FE4  8B 46 F4			     mov     ax,word ptr [bp-12]
   7139	1FE7  3B 06 0000e		     cmp     ax,word ptr DGROUP:_ntasks
   7140	1FEB  7F 13			     jg	     short @2@15066
   7141					;
   7142					;		 ptcb->priority	= rtxktcb[task].priority; /* reset priority */
   7143					;
   7144					     ?debug  L 2341
   7145	1FED  8B 5E F4			     mov     bx,word ptr [bp-12]
   7146	1FF0  6B DB 0C			     imul    bx,bx,12
   7147	1FF3  8B 87 000Ae		     mov     ax,word ptr DGROUP:_rtxktcb[bx+10]
   7148	1FF7  8B 5E F6			     mov     bx,word ptr [bp-10]
   7149	1FFA  89 47 0A			     mov     word ptr [bx+10],ax
   7150	1FFD  E9 00CE			     jmp     @2@15430
   7151	2000			     @2@15066:
   7152					;
   7153					;    #ifdef DYNAMIC_TASKS /* { */
   7154					;	      else
   7155					;	      {
   7156					;		 ptcb->priority	= NULLTASK_PRIORITY - 1; /* reset priority */
   7157					;
   7158					     ?debug  L 2345
   7159	2000  8B 5E F6			     mov     bx,word ptr [bp-10]
   7160	2003  C7 47 0A 007E		     mov     word ptr [bx+10],126
   7161					;
   7162					;
   7163					;		 /* re-insert tcb into tcb free	list for dynamic tasks */
   7164					;		 ptcb->flink = dtcbfl;
   7165					;
   7166					     ?debug  L 2348
   7167	2008  A1 0008r			     mov     ax,word ptr DGROUP:_dtcbfl
   7168	200B  89 07			     mov     word ptr [bx],ax
   7169					;
   7170					;		 dtcbfl	= ptcb;
   7171					;
   7172					     ?debug  L 2349
   7173	200D  8B 46 F6			     mov     ax,word ptr [bp-10]
   7174	2010  A3 0008r			     mov     word ptr DGROUP:_dtcbfl,ax
   7175	2013  E9 00B8			     jmp     @2@15430
   7176	2016			     @2@15094:
   7177					;
   7178					;	      }
   7179					;    #endif /* } DYNAMIC_TASKS */
   7180					;
   7181					;	      break;
   7182					;    #endif /* } HAS_TERMINATE */
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 127
.\rtxc.asm



   7183					;
   7184					;    #ifdef HAS_YIELD /* { */
   7185					;    /************************/
   7186					;	   case	RTXC_YIELD:
   7187					;    /************************/
   7188					;	      /* yield is NOP unless next READY	task at	same priority */
   7189					;	      if (hipritsk->flink->priority != hipritsk->priority)
   7190					;
   7191					     ?debug  L 2361
   7192	2016  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   7193	201A  8B 1F			     mov     bx,word ptr [bx]
   7194	201C  8B 47 0A			     mov     ax,word ptr [bx+10]
   7195	201F  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   7196	2023  3B 47 0A			     cmp     ax,word ptr [bx+10]
   7197	2026  74 03			     je	     short @2@15150
   7198					;
   7199					;		 break;
   7200					;
   7201					     ?debug  L 2362
   7202	2028  E9 00A3			     jmp     @2@15430
   7203	202B			     @2@15150:
   7204					;
   7205					;
   7206					;	      ((struct targ ks_stk *)p2)->ksrc = RC_GOOD;
   7207					;
   7208					     ?debug  L 2364
   7209	202B  C4 5E FC			     les     bx,dword ptr [bp-4]
   7210	202E  26: C7 47	02 0000		     mov     word ptr es:[bx+2],0
   7211					;
   7212					;
   7213					;	      ptcb = hipritsk; /* save */
   7214					;
   7215					     ?debug  L 2366
   7216	2034  A1 0000r			     mov     ax,word ptr DGROUP:_hipritsk
   7217	2037  89 46 F6			     mov     word ptr [bp-10],ax
   7218					;
   7219					;
   7220					;    #ifdef TIME_SLICE /* { */
   7221					;	      ptcb->tslice = ptcb->newslice; /*	reset time allotment */
   7222					;
   7223					     ?debug  L 2369
   7224	203A  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   7225	203E  8B 57 22			     mov     dx,word ptr [bx+34]
   7226	2041  8B 47 20			     mov     ax,word ptr [bx+32]
   7227	2044  89 57 1E			     mov     word ptr [bx+30],dx
   7228	2047  89 47 1C			     mov     word ptr [bx+28],ax
   7229					;
   7230					;    #endif /* } TIME_SLICE */
   7231					;
   7232					;	      UNLINK_HIPRITSK(); /* unlink first tcb */
   7233					;
   7234					     ?debug  L 2372
   7235	204A  8B 07			     mov     ax,word ptr [bx]
   7236	204C  A3 0000r			     mov     word ptr DGROUP:_hipritsk,ax
   7237	204F  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   7238	2053  C7 47 02 0000r		     mov     word ptr [bx+2],offset DGROUP:_hipritsk
   7239					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 128
.\rtxc.asm



   7240					;
   7241					;	      /* re-insert task	*/
   7242					;	      ptcb->flink = nsrttcb;
   7243					;
   7244					     ?debug  L 2375
   7245	2058  8B 5E F6			     mov     bx,word ptr [bp-10]
   7246	205B  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
   7247	205E  89 07			     mov     word ptr [bx],ax
   7248					;
   7249					;	      nsrttcb =	ptcb;
   7250					;
   7251					     ?debug  L 2376
   7252	2060  8B 46 F6			     mov     ax,word ptr [bp-10]
   7253	2063  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
   7254					;
   7255					;
   7256					;	      break;
   7257					;
   7258					     ?debug  L 2378
   7259	2066  EB 66			     jmp     short @2@15430
   7260	2068			     @2@15178:
   7261					;
   7262					;    #endif /* } HAS_YIELD */
   7263					;
   7264					;    #ifdef HAS_DEFPRIORITY /* { */
   7265					;    /************************/
   7266					;	   case	RTXC_DEFPRIORITY:
   7267					;    /************************/
   7268					;	      /* limit priority	to reasonable value, else real low priority */
   7269					;	      if ( ((struct targ ks_stk	*)p2)->priority	< 1 ||
   7270					;
   7271					     ?debug  L 2386
   7272					;
   7273					;		   ((struct targ ks_stk	*)p2)->priority	>= NULLTASK_PRIORITY )
   7274					;
   7275					     ?debug  L 2387
   7276	2068  C4 5E FC			     les     bx,dword ptr [bp-4]
   7277	206B  26: 83 7F	06 01		     cmp     word ptr es:[bx+6],1
   7278	2070  7C 07			     jl	     short @2@15234
   7279	2072  26: 83 7F	06 7F		     cmp     word ptr es:[bx+6],127
   7280	2077  7C 09			     jl	     short @2@15262
   7281	2079			     @2@15234:
   7282					;
   7283					;		   ((struct targ ks_stk	*)p2)->priority	= NULLTASK_PRIORITY - 1;
   7284					;
   7285					     ?debug  L 2388
   7286	2079  C4 5E FC			     les     bx,dword ptr [bp-4]
   7287	207C  26: C7 47	06 007E		     mov     word ptr es:[bx+6],126
   7288	2082			     @2@15262:
   7289					;
   7290					;
   7291					;	      if ( (task = ((struct targ ks_stk	*)p2)->task) ==	SELFTASK)
   7292					;
   7293					     ?debug  L 2390
   7294	2082  C4 5E FC			     les     bx,dword ptr [bp-4]
   7295	2085  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   7296	2089  89 46 F4			     mov     word ptr [bp-12],ax
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 129
.\rtxc.asm



   7297	208C  0B C0			     or	     ax,ax
   7298	208E  75 05			     jne     short @2@15318
   7299					;
   7300					;		 ptcb =	hipritsk;
   7301					;
   7302					     ?debug  L 2391
   7303	2090  A1 0000r			     mov     ax,word ptr DGROUP:_hipritsk
   7304	2093  EB 09			     jmp     short @2@15346
   7305	2095			     @2@15318:
   7306					;
   7307					;	      else
   7308					;		 ptcb =	&rtxtcb[task];
   7309					;
   7310					     ?debug  L 2393
   7311	2095  8B 46 F4			     mov     ax,word ptr [bp-12]
   7312	2098  6B C0 28			     imul    ax,ax,40
   7313	209B  05 0000e			     add     ax,offset DGROUP:_rtxtcb
   7314	209E			     @2@15346:
   7315	209E  89 46 F6			     mov     word ptr [bp-10],ax
   7316					;
   7317					;
   7318					;	      chgpriority(ptcb,	((struct targ ks_stk *)p2)->priority);
   7319					;
   7320					     ?debug  L 2395
   7321	20A1  C4 5E FC			     les     bx,dword ptr [bp-4]
   7322	20A4  26: FF 77	06		     push    word ptr es:[bx+6]
   7323	20A8  FF 76 F6			     push    word ptr [bp-10]
   7324	20AB  E8 0F04			     call    near ptr chgpriority
   7325	20AE  83 C4 04			     add     sp,4
   7326					;
   7327					;	      break;
   7328					;
   7329					     ?debug  L 2396
   7330	20B1  EB 1B			     jmp     short @2@15430
   7331	20B3			     @2@15402:
   7332					;
   7333					;    #endif /* } HAS_DEFPRIORITY */
   7334					;
   7335					;    #ifdef HAS_USER /*	{ */
   7336					;    /************************/
   7337					;	   case	RTXC_USER:
   7338					;    /************************/
   7339					;	      /* call function passing &arg packet */
   7340					;	      ((struct userarg ks_stk *)p2)->val =
   7341					;
   7342					     ?debug  L 2404
   7343					;
   7344					;		 (*((struct userarg ks_stk *)p2)->fun)
   7345					;		 (((struct userarg ks_stk *)p2)->arg);
   7346					;
   7347					     ?debug  L 2406
   7348	20B3  C4 5E FC			     les     bx,dword ptr [bp-4]
   7349	20B6  26: FF 77	04		     push    word ptr es:[bx+4]
   7350	20BA  26: FF 77	02		     push    word ptr es:[bx+2]
   7351	20BE  26: FF 5F	06		     call    dword ptr es:[bx+6]
   7352	20C2  83 C4 04			     add     sp,4
   7353	20C5  C4 5E FC			     les     bx,dword ptr [bp-4]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 130
.\rtxc.asm



   7354	20C8  26: 89 47	0A		     mov     word ptr es:[bx+10],ax
   7355					;
   7356					;	      break;
   7357					;
   7358					     ?debug  L 2407
   7359	20CC  EB 00			     jmp     short @2@15430
   7360	20CE			     @2@15430:
   7361					;
   7362					;    #endif /* } HAS_USER */
   7363					;
   7364					;    #ifdef HAS_NOP /* { */
   7365					;    /************************/
   7366					;	   case	RTXC_NOP:
   7367					;    /************************/
   7368					;	      break;
   7369					;    #endif /* } HAS_NOP */
   7370					;
   7371					;    /************************/
   7372					;	   default:
   7373					;    /************************/
   7374					;	      break;
   7375					;
   7376					     ?debug  L 2420
   7377					;
   7378					;	}
   7379					;
   7380					;	DISABLE;
   7381					;
   7382					     ?debug  L 2423
   7383	20CE  FA			     cli
   7384	20CF  90			     nop
   7385					;
   7386					;
   7387					;	if ( (nsrttcb == NULLTCB) && (semaput == semaget) && (t_expired	== 0) )
   7388					;
   7389					     ?debug  L 2425
   7390	20D0  83 3E 0002r 00		     cmp     word ptr DGROUP:_nsrttcb,0
   7391	20D5  75 1C			     jne     short @2@15598
   7392	20D7  A1 0004r			     mov     ax,word ptr DGROUP:_semaput
   7393	20DA  3B 06 0006r		     cmp     ax,word ptr DGROUP:_semaget
   7394	20DE  75 13			     jne     short @2@15598
   7395	20E0  80 3E 0021r 00		     cmp     byte ptr DGROUP:t_expired,0
   7396	20E5  75 0C			     jne     short @2@15598
   7397					;
   7398					;	{
   7399					;    #ifdef FPU	/* { */
   7400					;	   if (	(hipritsk->fpumode == 1) && (fputask !=	hipritsk) )
   7401					;	   {
   7402					;	      /* swap fpu regs */
   7403					;	      fpuswap(fputask->fpregs, hipritsk->fpregs);
   7404					;	      fputask =	hipritsk; /* update new	user of	fpu */
   7405					;	   }
   7406					;    #endif /* } FPU */
   7407					;	   return(hipritsk->sp); /* exit to hipritsk via tcb.sp	*/
   7408					;
   7409					     ?debug  L 2435
   7410	20E7  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 131
.\rtxc.asm



   7411	20EB  8B 57 0E			     mov     dx,word ptr [bx+14]
   7412	20EE  8B 47 0C			     mov     ax,word ptr [bx+12]
   7413	20F1  EB 04			     jmp     short @2@15654
   7414	20F3			     @2@15598:
   7415					;
   7416					;	}
   7417					;
   7418					;	     ENABLE;
   7419					;
   7420					     ?debug  L 2438
   7421	20F3  FB			     sti
   7422					;
   7423					;	return(postem());
   7424					;
   7425					     ?debug  L 2439
   7426	20F4  E8 06F8			     call    near ptr postem
   7427	20F7			     @2@15654:
   7428					;
   7429					;    }
   7430					;
   7431					     ?debug  L 2440
   7432	20F7  5E			     pop     si
   7433	20F8  C9			     leave
   7434	20F9  C3			     ret
   7435					     ?debug  C E32807726865616465720C001E2C
   7436					     ?debug  C E3290752455341545452020022000080FF7F33
   7437					     ?debug  C E327000200152804
   7438					     ?debug  C E32C077168656164657218001E35
   7439					     ?debug  C E32B000200152C04
   7440					     ?debug  C E32E04786D617004001E41
   7441					     ?debug  C E32D000400162E00
   7442					     ?debug  C E330077068656164657212001E43
   7443					     ?debug  C E32F000200153004
   7444					     ?debug  C E33207727478636D73670A001E4B
   7445					     ?debug  C E331000400163200
   7446					     ?debug  C E334076D6865616465720A001E50
   7447					     ?debug  C E333000200153404
   7448					     ?debug  C E335000200150404
   7449					     ?debug  C E336000400160400
   7450					     ?debug  C E6037072682702C6FF000005637572737A0402C8+
   7451					     ?debug  C FF00000577696474680A02CAFF00000564657074+
   7452					     ?debug  C 680402CCFF00000671696E6465780402CEFF0000+
   7453					     ?debug  C 037071682B02D0FF000001712D02D2FF00000370+
   7454					     ?debug  C 70682F02D6FF00000870727478636D73673102D8+
   7455					     ?debug  C FF000003706D683302DCFF000007656E64746173+
   7456					     ?debug  C 6B0402DEFF0000037032612102E0FF0000087365+
   7457					     ?debug  C 6D615F7074723502E4FF00000873656D616C6973+
   7458					     ?debug  C 743602E6FF00000473656D610402EAFF00000474+
   7459					     ?debug  C 636E740602ECFF00000770636C6B626C6B1B02F0+
   7460					     ?debug  C FF0000047461736B0402F4FF0000047074636219+
   7461					     ?debug  C 02F6FF0000056672616D651F02F8FF0000027032+
   7462					     ?debug  C 2102FCFF000001701F0A04000000
   7463					     ?debug  E
   7464					     ?debug  E
   7465	20FA			     _rtxc   endp
   7466	20FA  01*(??)			     db	     1 dup (?)
   7467	20FB			     @2@C14546	     label   word
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 132
.\rtxc.asm



   7468	20FB  1CB7r			     dw	     @2@13610
   7469	20FD  1C32r			     dw	     @2@13498
   7470	20FF  1C49r			     dw	     @2@13526
   7471	2101  1C8Cr			     dw	     @2@13582
   7472	2103  1C66r			     dw	     @2@13554
   7473	2105			     @2@C14754	     label   word
   7474	2105  199Er			     dw	     @2@12154
   7475	2107  19D3r			     dw	     @2@12238
   7476	2109  1A3Cr			     dw	     @2@12406
   7477	210B  1A0Ar			     dw	     @2@12322
   7478	210D			     @2@C14818	     label   word
   7479	210D  1795r			     dw	     @2@10502
   7480	210F  1710r			     dw	     @2@10390
   7481	2111  1727r			     dw	     @2@10418
   7482	2113  176Ar			     dw	     @2@10474
   7483	2115  1744r			     dw	     @2@10446
   7484	2117			     @2@C14914	     label   word
   7485	2117  15D3r			     dw	     @2@9550
   7486	2119  1552r			     dw	     @2@9438
   7487	211B  1569r			     dw	     @2@9466
   7488	211D  15A8r			     dw	     @2@9522
   7489	211F  1584r			     dw	     @2@9494
   7490	2121			     @2@C14994	     label   word
   7491	2121  137Cr			     dw	     @2@8318
   7492	2123  12F7r			     dw	     @2@8206
   7493	2125  130Er			     dw	     @2@8234
   7494	2127  1351r			     dw	     @2@8290
   7495	2129  132Br			     dw	     @2@8262
   7496	212B			     @2@C15170	     label   word
   7497	212B  1270r			     dw	     @2@7730
   7498	212D  1205r			     dw	     @2@7618
   7499	212F  121Br			     dw	     @2@7646
   7500	2131  124Fr			     dw	     @2@7702
   7501	2133  1231r			     dw	     @2@7674
   7502	2135			     @2@C82  label   word
   7503	2135  20CEr			     dw	     @2@15430
   7504	2137  0115r			     dw	     @2@590
   7505	2139  0096r			     dw	     @2@142
   7506	213B  0290r			     dw	     @2@1178
   7507	213D  0DBAr			     dw	     @2@6106
   7508	213F  0FE4r			     dw	     @2@6918
   7509	2141  0378r			     dw	     @2@1626
   7510	2143  045Br			     dw	     @2@1766
   7511	2145  051Dr			     dw	     @2@1990
   7512	2147  0563r			     dw	     @2@2102
   7513	2149  0551r			     dw	     @2@2074
   7514	214B  0588r			     dw	     @2@2158
   7515	214D  10F6r			     dw	     @2@7170
   7516	214F  1451r			     dw	     @2@9130
   7517	2151  05D1r			     dw	     @2@2186
   7518	2153  073Er			     dw	     @2@2634
   7519	2155  09D9r			     dw	     @2@4006
   7520	2157  09EAr			     dw	     @2@4034
   7521	2159  0A2Er			     dw	     @2@4118
   7522	215B  0A2Er			     dw	     @2@4118
   7523	215D  0BD4r			     dw	     @2@5098
   7524	215F  1D1Ar			     dw	     @2@13946
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 133
.\rtxc.asm



   7525	2161  1DABr			     dw	     @2@14030
   7526	2163  1EBDr			     dw	     @2@14394
   7527	2165  1EEBr			     dw	     @2@14478
   7528	2167  02F2r			     dw	     @2@1402
   7529	2169  0340r			     dw	     @2@1542
   7530	216B  2068r			     dw	     @2@15178
   7531	216D  2016r			     dw	     @2@15094
   7532	216F  08E5r			     dw	     @2@3306
   7533	2171  0965r			     dw	     @2@3670
   7534	2173  1A73r			     dw	     @2@12518
   7535	2175  1AB3r			     dw	     @2@12602
   7536	2177  197Br			     dw	     @2@12042
   7537	2179  01F7r			     dw	     @2@814
   7538	217B  0CE2r			     dw	     @2@5490
   7539	217D  0D76r			     dw	     @2@5826
   7540	217F  0D9Cr			     dw	     @2@5966
   7541	2181  088Dr			     dw	     @2@3194
   7542	2183  08BAr			     dw	     @2@3250
   7543	2185  1E55r			     dw	     @2@14226
   7544	2187  1E89r			     dw	     @2@14310
   7545	2189  0D25r			     dw	     @2@5630
   7546	218B  00CCr			     dw	     @2@338
   7547	218D  02B7r			     dw	     @2@1234
   7548	218F  0A2Er			     dw	     @2@4118
   7549	2191  18F2r			     dw	     @2@11874
   7550	2193  20B3r			     dw	     @2@15402
   7551					;
   7552					;    static void insert_message(MHEADER	near *pmh, RTXCMSG *prtxcmsg)
   7553					;
   7554					     ?debug  L 2449
   7555					     assume  cs:RTXC_TEXT,ds:DGROUP
   7556	2195			     insert_message  proc    near
   7557					     ?debug  B
   7558	2195  55			     push    bp
   7559	2196  8B EC			     mov     bp,sp
   7560	2198  83 EC 0A			     sub     sp,10
   7561					     ?debug  C E60870727478636D7367310A0600000003706D68+
   7562					     ?debug  C 330A04000000
   7563					     ?debug  B
   7564					;
   7565					;    /************************/
   7566					;    {
   7567					;	RTXCMSG	*prev, *next;
   7568					;	PRIORITY priority;
   7569					;
   7570					;	/* see if the degenerate case exists, i.e., the	mailbox	is empty */
   7571					;	if ( (next = pmh->link)	== NULL)
   7572					;
   7573					     ?debug  L 2456
   7574	219B  8B 5E 04			     mov     bx,word ptr [bp+4]
   7575	219E  8B 57 02			     mov     dx,word ptr [bx+2]
   7576	21A1  8B 07			     mov     ax,word ptr [bx]
   7577	21A3  89 56 FA			     mov     word ptr [bp-6],dx
   7578	21A6  89 46 F8			     mov     word ptr [bp-8],ax
   7579	21A9  0B C2			     or	     ax,dx
   7580	21AB  75 0D			     jne     short @3@86
   7581					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 134
.\rtxc.asm



   7582					;	   pmh->link = prtxcmsg;
   7583					;
   7584					     ?debug  L 2457
   7585	21AD  8B 56 08			     mov     dx,word ptr [bp+8]
   7586	21B0  8B 46 06			     mov     ax,word ptr [bp+6]
   7587	21B3  89 57 02			     mov     word ptr [bx+2],dx
   7588	21B6  89 07			     mov     word ptr [bx],ax
   7589	21B8  EB 4E			     jmp     short @3@254
   7590	21BA			     @3@86:
   7591					;
   7592					;	else /*	mailbox	is not empty, search for insertion point */
   7593					;	{
   7594					;	   priority = prtxcmsg->priority;
   7595					;
   7596					     ?debug  L 2460
   7597	21BA  C4 5E 06			     les     bx,dword ptr [bp+6]
   7598	21BD  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
   7599	21C1  89 46 F6			     mov     word ptr [bp-10],ax
   7600					;
   7601					;
   7602					;	   prev	= (RTXCMSG *)pmh;
   7603					;
   7604					     ?debug  L 2462
   7605	21C4  8B 46 04			     mov     ax,word ptr [bp+4]
   7606	21C7  8C 5E FE			     mov     word ptr [bp-2],ds
   7607	21CA  EB 09			     jmp     short @3@142
   7608	21CC			     @3@114:
   7609					;
   7610					;
   7611					;	   while( ((next = prev->link) != NULL)	&& (next->priority <= priority)	)
   7612					;	      prev = next;
   7613					;
   7614					     ?debug  L 2465
   7615	21CC  8B 56 FA			     mov     dx,word ptr [bp-6]
   7616	21CF  8B 46 F8			     mov     ax,word ptr [bp-8]
   7617	21D2  89 56 FE			     mov     word ptr [bp-2],dx
   7618	21D5			     @3@142:
   7619	21D5  89 46 FC			     mov     word ptr [bp-4],ax
   7620					     ?debug  L 2464
   7621	21D8  C4 5E FC			     les     bx,dword ptr [bp-4]
   7622	21DB  26: 8B 57	02		     mov     dx,word ptr es:[bx+2]
   7623	21DF  26: 8B 07			     mov     ax,word ptr es:[bx]
   7624	21E2  89 56 FA			     mov     word ptr [bp-6],dx
   7625	21E5  89 46 F8			     mov     word ptr [bp-8],ax
   7626	21E8  0B C2			     or	     ax,dx
   7627	21EA  74 0C			     je	     short @3@226
   7628	21EC  C4 5E F8			     les     bx,dword ptr [bp-8]
   7629	21EF  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
   7630	21F3  3B 46 F6			     cmp     ax,word ptr [bp-10]
   7631	21F6  7E D4			     jle     short @3@114
   7632	21F8			     @3@226:
   7633					;
   7634					;
   7635					;	   prev->link =	prtxcmsg;
   7636					;
   7637					     ?debug  L 2467
   7638	21F8  C4 5E FC			     les     bx,dword ptr [bp-4]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 135
.\rtxc.asm



   7639	21FB  8B 56 08			     mov     dx,word ptr [bp+8]
   7640	21FE  8B 46 06			     mov     ax,word ptr [bp+6]
   7641	2201  26: 89 57	02		     mov     word ptr es:[bx+2],dx
   7642	2205  26: 89 07			     mov     word ptr es:[bx],ax
   7643	2208			     @3@254:
   7644					;
   7645					;	}
   7646					;
   7647					;	prtxcmsg->link = next;
   7648					;
   7649					     ?debug  L 2470
   7650	2208  C4 5E 06			     les     bx,dword ptr [bp+6]
   7651	220B  8B 56 FA			     mov     dx,word ptr [bp-6]
   7652	220E  8B 46 F8			     mov     ax,word ptr [bp-8]
   7653	2211  26: 89 57	02		     mov     word ptr es:[bx+2],dx
   7654	2215  26: 89 07			     mov     word ptr es:[bx],ax
   7655					;
   7656					;    }
   7657					;
   7658					     ?debug  L 2471
   7659	2218  C9			     leave
   7660	2219  C3			     ret
   7661					     ?debug  C E6087072696F726974790402F6FF0000046E6578+
   7662					     ?debug  C 743102F8FF000004707265763102FCFF00000370+
   7663					     ?debug  C 6D68330A040000000870727478636D7367310A06+
   7664					     ?debug  C 000000
   7665					     ?debug  E
   7666					     ?debug  E
   7667	221A			     insert_message  endp
   7668					;
   7669					;    static RTXCMSG *remove_message(MHEADER near *pmh, TASK task)
   7670					;
   7671					     ?debug  L 2475
   7672					     assume  cs:RTXC_TEXT,ds:DGROUP
   7673	221A			     remove_message  proc    near
   7674					     ?debug  B
   7675	221A  55			     push    bp
   7676	221B  8B EC			     mov     bp,sp
   7677	221D  83 EC 08			     sub     sp,8
   7678					     ?debug  C E6047461736B040A0600000003706D68330A0400+
   7679					     ?debug  C 0000
   7680					     ?debug  B
   7681					;
   7682					;    /************************/
   7683					;    {
   7684					;	RTXCMSG	*lptr, *nptr;
   7685					;
   7686					;	if ( (nptr = pmh->link)	== NULL)
   7687					;
   7688					     ?debug  L 2480
   7689	2220  8B 5E 04			     mov     bx,word ptr [bp+4]
   7690	2223  8B 57 02			     mov     dx,word ptr [bx+2]
   7691	2226  8B 07			     mov     ax,word ptr [bx]
   7692	2228  89 56 FA			     mov     word ptr [bp-6],dx
   7693	222B  89 46 F8			     mov     word ptr [bp-8],ax
   7694	222E  0B C2			     or	     ax,dx
   7695	2230  74 79			     je	     short @4@282
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 136
.\rtxc.asm



   7696					;
   7697					;	   return(NULL);
   7698					;
   7699					;	if ( (task == (TASK)0) || (nptr->task == task) )
   7700					;
   7701					     ?debug  L 2483
   7702	2232  83 7E 06 00		     cmp     word ptr [bp+6],0
   7703	2236  74 0C			     je	     short @4@114
   7704	2238  C4 5E F8			     les     bx,dword ptr [bp-8]
   7705	223B  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   7706	223F  3B 46 06			     cmp     ax,word ptr [bp+6]
   7707	2242  75 5B			     jne     short @4@254
   7708	2244			     @4@114:
   7709					;
   7710					;	{
   7711					;	   pmh->link = nptr->link;
   7712					;
   7713					     ?debug  L 2485
   7714	2244  C4 5E F8			     les     bx,dword ptr [bp-8]
   7715	2247  26: 8B 57	02		     mov     dx,word ptr es:[bx+2]
   7716	224B  26: 8B 07			     mov     ax,word ptr es:[bx]
   7717	224E  8B 5E 04			     mov     bx,word ptr [bp+4]
   7718	2251  89 57 02			     mov     word ptr [bx+2],dx
   7719	2254  89 07			     mov     word ptr [bx],ax
   7720					;
   7721					;	   return(nptr);
   7722					;
   7723					     ?debug  L 2486
   7724	2256  8B 56 FA			     mov     dx,word ptr [bp-6]
   7725	2259  8B 46 F8			     mov     ax,word ptr [bp-8]
   7726	225C  C9			     leave
   7727	225D  C3			     ret
   7728	225E			     @4@170:
   7729					;
   7730					;	}
   7731					;
   7732					;	while (nptr->link != NULL)
   7733					;	{
   7734					;	   lptr	= nptr;
   7735					;
   7736					     ?debug  L 2491
   7737	225E  8B 56 FA			     mov     dx,word ptr [bp-6]
   7738	2261  8B 46 F8			     mov     ax,word ptr [bp-8]
   7739	2264  89 56 FE			     mov     word ptr [bp-2],dx
   7740	2267  89 46 FC			     mov     word ptr [bp-4],ax
   7741					;
   7742					;	   nptr	= lptr->link;
   7743					;
   7744					     ?debug  L 2492
   7745	226A  C4 5E FC			     les     bx,dword ptr [bp-4]
   7746	226D  26: 8B 57	02		     mov     dx,word ptr es:[bx+2]
   7747	2271  26: 8B 07			     mov     ax,word ptr es:[bx]
   7748	2274  89 56 FA			     mov     word ptr [bp-6],dx
   7749	2277  89 46 F8			     mov     word ptr [bp-8],ax
   7750					;
   7751					;	   if (nptr->task == task)
   7752					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 137
.\rtxc.asm



   7753					     ?debug  L 2493
   7754	227A  C4 5E F8			     les     bx,dword ptr [bp-8]
   7755	227D  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   7756	2281  3B 46 06			     cmp     ax,word ptr [bp+6]
   7757	2284  75 19			     jne     short @4@254
   7758					;
   7759					;	   {
   7760					;	      lptr->link = nptr->link;
   7761					;
   7762					     ?debug  L 2495
   7763	2286  26: 8B 57	02		     mov     dx,word ptr es:[bx+2]
   7764	228A  26: 8B 07			     mov     ax,word ptr es:[bx]
   7765	228D  C4 5E FC			     les     bx,dword ptr [bp-4]
   7766	2290  26: 89 57	02		     mov     word ptr es:[bx+2],dx
   7767	2294  26: 89 07			     mov     word ptr es:[bx],ax
   7768					;
   7769					;	      return(nptr);
   7770					;
   7771					     ?debug  L 2496
   7772	2297  8B 56 FA			     mov     dx,word ptr [bp-6]
   7773	229A  8B 46 F8			     mov     ax,word ptr [bp-8]
   7774	229D  C9			     leave
   7775	229E  C3			     ret
   7776	229F			     @4@254:
   7777					     ?debug  L 2489
   7778	229F  C4 5E F8			     les     bx,dword ptr [bp-8]
   7779	22A2  26: 8B 07			     mov     ax,word ptr es:[bx]
   7780	22A5  26: 0B 47	02		     or	     ax,word ptr es:[bx+2]
   7781	22A9  75 B3			     jne     short @4@170
   7782	22AB			     @4@282:
   7783					;
   7784					;	   }
   7785					;	}
   7786					;
   7787					;	return(NULL);
   7788					;
   7789					     ?debug  L 2500
   7790	22AB  33 D2			     xor     dx,dx
   7791	22AD  33 C0			     xor     ax,ax
   7792					;
   7793					;    }
   7794					;
   7795					     ?debug  L 2501
   7796	22AF  C9			     leave
   7797	22B0  C3			     ret
   7798					     ?debug  C E6046E7074723102F8FF0000046C7074723102FC+
   7799					     ?debug  C FF000003706D68330A04000000047461736B040A+
   7800					     ?debug  C 06000000
   7801					     ?debug  E
   7802					     ?debug  E
   7803	22B1			     remove_message  endp
   7804					;
   7805					;    void taskinit(void)
   7806					;
   7807					     ?debug  L 2506
   7808					     assume  cs:RTXC_TEXT,ds:DGROUP
   7809	22B1			     _taskinit	     proc    near
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 138
.\rtxc.asm



   7810					     ?debug  B
   7811	22B1  55			     push    bp
   7812	22B2  8B EC			     mov     bp,sp
   7813	22B4  83 EC 06			     sub     sp,6
   7814					     ?debug  B
   7815					;
   7816					;    /************************/
   7817					;    {
   7818					;	REGISTER TASK i;
   7819					;	REGISTER TCB near *ptcb;
   7820					;
   7821					;    #ifdef FPU	/* { */
   7822					;	fputask	=
   7823					;    #endif /* } FPU */
   7824					;	hipritsk = &rtxtcb[0];
   7825					;
   7826					     ?debug  L 2515
   7827	22B7  C7 06 0000r 0000e		     mov     word ptr DGROUP:_hipritsk,offset DGROUP:_rtxtcb
   7828					;
   7829					;
   7830					;	hipritsk->blink	= (TCB near *)&hipritsk;
   7831					;
   7832					     ?debug  L 2517
   7833	22BD  C7 06 0002e 0000r		     mov     word ptr DGROUP:_rtxtcb+2,offset DGROUP:_hipritsk
   7834					;
   7835					;
   7836					;	hipritsk->priority = NULLTASK_PRIORITY;
   7837					;
   7838					     ?debug  L 2519
   7839	22C3  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   7840	22C7  C7 47 0A 007F		     mov     word ptr [bx+10],127
   7841					;
   7842					;
   7843					;    #ifdef BSS_NOT_ZERO /* { */
   7844					;	hipritsk->task = 0;
   7845					;
   7846					     ?debug  L 2522
   7847	22CC  C7 47 08 0000		     mov     word ptr [bx+8],0
   7848					;
   7849					;	hipritsk->flink	= NULLTCB;
   7850					;
   7851					     ?debug  L 2523
   7852	22D1  C7 07 0000		     mov     word ptr [bx],0
   7853					;
   7854					;	hipritsk->status = READY; /* mark null task READY */
   7855					;
   7856					     ?debug  L 2524
   7857	22D5  C7 47 10 0000		     mov     word ptr [bx+16],0
   7858					;
   7859					;    #ifdef FPU	/* { */
   7860					;	hipritsk->fpregs = NULLFPREGS;
   7861					;	hipritsk->fpumode = 0;
   7862					;    #endif /* } FPU */
   7863					;	nsrttcb	= NULLTCB;
   7864					;
   7865					     ?debug  L 2529
   7866	22DA  C7 06 0002r 0000		     mov     word ptr DGROUP:_nsrttcb,0
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 139
.\rtxc.asm



   7867					;
   7868					;    #endif /* } BSS_NOT_ZERO */
   7869					;
   7870					;	for (i = 1, ptcb = &rtxtcb[1]; i <= ntasks; i++, ptcb++)
   7871					;
   7872					     ?debug  L 2532
   7873	22E0  C7 46 FE 0001		     mov     word ptr [bp-2],1
   7874	22E5  C7 46 FC 0028e		     mov     word ptr [bp-4],offset DGROUP:_rtxtcb+40
   7875	22EA  E9 0085			     jmp     @5@114
   7876	22ED			     @5@58:
   7877					;
   7878					;	{
   7879					;	   ptcb->status	= INACTIVE; /* mark each task inactive */
   7880					;
   7881					     ?debug  L 2534
   7882	22ED  8B 5E FC			     mov     bx,word ptr [bp-4]
   7883	22F0  C7 47 10 0100		     mov     word ptr [bx+16],256
   7884					;
   7885					;	   ptcb->task =	i; /* set each task no.	*/
   7886					;
   7887					     ?debug  L 2535
   7888	22F5  8B 46 FE			     mov     ax,word ptr [bp-2]
   7889	22F8  89 47 08			     mov     word ptr [bx+8],ax
   7890					;
   7891					;
   7892					;    #ifdef BSS_NOT_ZERO /* { */
   7893					;	   ptcb->pclkblk = NULLCLK;
   7894					;
   7895					     ?debug  L 2538
   7896	22FB  C7 47 06 0000		     mov     word ptr [bx+6],0
   7897	2300  C7 47 04 0000		     mov     word ptr [bx+4],0
   7898					;
   7899					;    #endif /* } BSS_NOT_ZERO */
   7900					;
   7901					;	   ptcb->priority = rtxktcb[i].priority; /* initial priority */
   7902					;
   7903					     ?debug  L 2541
   7904	2305  8B 5E FE			     mov     bx,word ptr [bp-2]
   7905	2308  6B DB 0C			     imul    bx,bx,12
   7906	230B  89 5E FA			     mov     word ptr [bp-6],bx
   7907	230E  8B 87 000Ae		     mov     ax,word ptr DGROUP:_rtxktcb[bx+10]
   7908	2312  8B 5E FC			     mov     bx,word ptr [bp-4]
   7909	2315  89 47 0A			     mov     word ptr [bx+10],ax
   7910					;
   7911					;
   7912					;    #ifdef FPU	/* { */
   7913					;	   ptcb->fpregs	= rtxktcb[i].fpregs;
   7914					;    #ifdef BSS_NOT_ZERO /* { */
   7915					;	   ptcb->fpumode = 0;
   7916					;    #endif /* } BSS_NOT_ZERO */
   7917					;    #endif /* } FPU */
   7918					;
   7919					;    #ifdef TIME_SLICE /* { */
   7920					;    #ifdef BSS_NOT_ZERO /* { */
   7921					;	   ptcb->tslice	= 0;
   7922					;
   7923					     ?debug  L 2552
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 140
.\rtxc.asm



   7924	2318  C7 47 1E 0000		     mov     word ptr [bx+30],0
   7925	231D  C7 47 1C 0000		     mov     word ptr [bx+28],0
   7926					;
   7927					;	   ptcb->newslice = 0;
   7928					;
   7929					     ?debug  L 2553
   7930	2322  C7 47 22 0000		     mov     word ptr [bx+34],0
   7931	2327  C7 47 20 0000		     mov     word ptr [bx+32],0
   7932					;
   7933					;    #endif /* } BSS_NOT_ZERO */
   7934					;    #endif /* } TIME_SLICE */
   7935					;
   7936					;	   /* copy stackbase, stacksize	and entry point	from KTCB to TCB */
   7937					;	   ptcb->stackbase = rtxktcb[i].stackbase;
   7938					;
   7939					     ?debug  L 2558
   7940	232C  8B 5E FA			     mov     bx,word ptr [bp-6]
   7941	232F  8B 97 0006e		     mov     dx,word ptr DGROUP:_rtxktcb[bx+6]
   7942	2333  8B 87 0004e		     mov     ax,word ptr DGROUP:_rtxktcb[bx+4]
   7943	2337  8B 5E FC			     mov     bx,word ptr [bp-4]
   7944	233A  89 57 18			     mov     word ptr [bx+24],dx
   7945	233D  89 47 16			     mov     word ptr [bx+22],ax
   7946					;
   7947					;	   ptcb->stacksize = rtxktcb[i].stacksize;
   7948					;
   7949					     ?debug  L 2559
   7950	2340  8B 5E FA			     mov     bx,word ptr [bp-6]
   7951	2343  8B 87 0008e		     mov     ax,word ptr DGROUP:_rtxktcb[bx+8]
   7952	2347  8B 5E FC			     mov     bx,word ptr [bp-4]
   7953	234A  89 47 1A			     mov     word ptr [bx+26],ax
   7954					;
   7955					;
   7956					;    #ifdef CBUG /* { */
   7957					;	   stkinit((int	ks_stk *)ptcb->stackbase, ptcb->stacksize);
   7958					;    #endif /* } CBUG */
   7959					;
   7960					;	   ptcb->pc_t0 = rtxktcb[i].pc_t0;
   7961					;
   7962					     ?debug  L 2565
   7963	234D  8B 5E FA			     mov     bx,word ptr [bp-6]
   7964	2350  8B 97 0002e		     mov     dx,word ptr DGROUP:_rtxktcb[bx+2]
   7965	2354  8B 87 0000e		     mov     ax,word ptr DGROUP:_rtxktcb[bx]
   7966	2358  8B 5E FC			     mov     bx,word ptr [bp-4]
   7967	235B  89 57 14			     mov     word ptr [bx+20],dx
   7968	235E  89 47 12			     mov     word ptr [bx+18],ax
   7969					;
   7970					;
   7971					;    #ifdef HAS_INQTASK_ARG /* { */
   7972					;    #ifdef BSS_NOT_ZERO /* { */
   7973					;	   ptcb->arg = NULL;
   7974					;
   7975					     ?debug  L 2569
   7976	2361  C7 47 26 0000		     mov     word ptr [bx+38],0
   7977	2366  C7 47 24 0000		     mov     word ptr [bx+36],0
   7978					     ?debug  L 2532
   7979	236B  FF 46 FE			     inc     word ptr [bp-2]
   7980	236E  83 46 FC 28		     add     word ptr [bp-4],40
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 141
.\rtxc.asm



   7981	2372			     @5@114:
   7982	2372  8B 46 FE			     mov     ax,word ptr [bp-2]
   7983	2375  3B 06 0000e		     cmp     ax,word ptr DGROUP:_ntasks
   7984	2379  7F 03			     jg	     @@47
   7985	237B  E9 FF6F			     jmp     @5@58
   7986	237E			     @@47:
   7987					;
   7988					;    #endif /* } BSS_NOT_ZERO */
   7989					;    #endif /* } HAS_INQTASK_ARG */
   7990					;	}
   7991					;
   7992					;    #ifdef DYNAMIC_TASKS /* { */
   7993					;	/* thread dynamic task TCB free	pool - possibly	dntasks	== 0 */
   7994					;	if (dntasks)
   7995					;
   7996					     ?debug  L 2576
   7997	237E  83 3E 0000e 00		     cmp     word ptr DGROUP:_dntasks,0
   7998	2383  74 0E			     je	     short @5@198
   7999					;
   8000					;	  dtcbfl = &rtxtcb[ntasks + 1];
   8001					;
   8002					     ?debug  L 2577
   8003	2385  A1 0000e			     mov     ax,word ptr DGROUP:_ntasks
   8004	2388  6B C0 28			     imul    ax,ax,40
   8005	238B  05 0028e			     add     ax,offset DGROUP:_rtxtcb+40
   8006	238E  A3 0008r			     mov     word ptr DGROUP:_dtcbfl,ax
   8007	2391  EB 06			     jmp     short @5@226
   8008	2393			     @5@198:
   8009					;
   8010					;	else
   8011					;	  dtcbfl = NULLTCB;
   8012					;
   8013					     ?debug  L 2579
   8014	2393  C7 06 0008r 0000		     mov     word ptr DGROUP:_dtcbfl,0
   8015	2399			     @5@226:
   8016					;
   8017					;
   8018					;	for (i = 1, ptcb = dtcbfl; i <=	dntasks; i++, ptcb++)
   8019					;
   8020					     ?debug  L 2581
   8021	2399  C7 46 FE 0001		     mov     word ptr [bp-2],1
   8022	239E  A1 0008r			     mov     ax,word ptr DGROUP:_dtcbfl
   8023	23A1  89 46 FC			     mov     word ptr [bp-4],ax
   8024	23A4  EB 43			     jmp     short @5@310
   8025	23A6			     @5@254:
   8026					;
   8027					;	{
   8028					;	   ptcb->flink = ptcb +	1; /* insert tcb into linked list */
   8029					;
   8030					     ?debug  L 2583
   8031	23A6  8B 46 FC			     mov     ax,word ptr [bp-4]
   8032	23A9  05 0028			     add     ax,40
   8033	23AC  8B 5E FC			     mov     bx,word ptr [bp-4]
   8034	23AF  89 07			     mov     word ptr [bx],ax
   8035					;
   8036					;
   8037					;	   ptcb->status	= INACTIVE; /* mark each task inactive */
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 142
.\rtxc.asm



   8038					;
   8039					     ?debug  L 2585
   8040	23B1  C7 47 10 0100		     mov     word ptr [bx+16],256
   8041					;
   8042					;	   ptcb->task =	ntasks + i; /* set each	task no. */
   8043					;
   8044					     ?debug  L 2586
   8045	23B6  A1 0000e			     mov     ax,word ptr DGROUP:_ntasks
   8046	23B9  03 46 FE			     add     ax,word ptr [bp-2]
   8047	23BC  89 47 08			     mov     word ptr [bx+8],ax
   8048					;
   8049					;
   8050					;    #ifdef BSS_NOT_ZERO /* { */
   8051					;	   ptcb->pclkblk = NULLCLK;
   8052					;
   8053					     ?debug  L 2589
   8054	23BF  C7 47 06 0000		     mov     word ptr [bx+6],0
   8055	23C4  C7 47 04 0000		     mov     word ptr [bx+4],0
   8056					;
   8057					;    #endif /* } BSS_NOT_ZERO */
   8058					;
   8059					;	   ptcb->priority = NULLTASK_PRIORITY -	1; /* initial priority (low) */
   8060					;
   8061					     ?debug  L 2592
   8062	23C9  C7 47 0A 007E		     mov     word ptr [bx+10],126
   8063					;
   8064					;
   8065					;    #ifdef FPU	/* { */
   8066					;    #ifdef BSS_NOT_ZERO /* { */
   8067					;	   ptcb->fpregs	= NULLFPREGS;
   8068					;	   ptcb->fpumode = 0;
   8069					;    #endif /* } BSS_NOT_ZERO */
   8070					;    #endif /* } FPU */
   8071					;
   8072					;    #ifdef TIME_SLICE /* { */
   8073					;    #ifdef BSS_NOT_ZERO /* { */
   8074					;	   ptcb->tslice	= 0;
   8075					;
   8076					     ?debug  L 2603
   8077	23CE  C7 47 1E 0000		     mov     word ptr [bx+30],0
   8078	23D3  C7 47 1C 0000		     mov     word ptr [bx+28],0
   8079					;
   8080					;	   ptcb->newslice = 0;
   8081					;
   8082					     ?debug  L 2604
   8083	23D8  C7 47 22 0000		     mov     word ptr [bx+34],0
   8084	23DD  C7 47 20 0000		     mov     word ptr [bx+32],0
   8085					     ?debug  L 2581
   8086	23E2  FF 46 FE			     inc     word ptr [bp-2]
   8087	23E5  83 46 FC 28		     add     word ptr [bp-4],40
   8088	23E9			     @5@310:
   8089	23E9  8B 46 FE			     mov     ax,word ptr [bp-2]
   8090	23EC  3B 06 0000e		     cmp     ax,word ptr DGROUP:_dntasks
   8091	23F0  7E B4			     jle     short @5@254
   8092					;
   8093					;    #endif /* } BSS_NOT_ZERO */
   8094					;    #endif /* } TIME_SLICE */
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 143
.\rtxc.asm



   8095					;	}
   8096					;
   8097					;	if (dntasks)
   8098					;
   8099					     ?debug  L 2609
   8100	23F2  83 3E 0000e 00		     cmp     word ptr DGROUP:_dntasks,0
   8101	23F7  74 0B			     je	     short @5@394
   8102					;
   8103					;	{
   8104					;	   --ptcb;
   8105					;
   8106					     ?debug  L 2611
   8107	23F9  83 6E FC 28		     sub     word ptr [bp-4],40
   8108					;
   8109					;	   ptcb->flink = NULLTCB; /* null last link */
   8110					;
   8111					     ?debug  L 2612
   8112	23FD  8B 5E FC			     mov     bx,word ptr [bp-4]
   8113	2400  C7 07 0000		     mov     word ptr [bx],0
   8114	2404			     @5@394:
   8115					;
   8116					;	}
   8117					;    #endif /* } DYNAMIC_TASKS */
   8118					;
   8119					;    #ifdef CBUG /* { */
   8120					;	/* init	kernel stack */
   8121					;	stkinit((int ks_stk *)&rtxctos[0], RTXCSTKSZ);
   8122					;    #endif /* } CBUG */
   8123					;
   8124					;    #ifdef BSS_NOT_ZERO /* { */
   8125					;	isrcnt = 0;
   8126					;
   8127					     ?debug  L 2622
   8128	2404  C6 06 0020r 00		     mov     byte ptr DGROUP:_isrcnt,0
   8129					;
   8130					;    #ifdef CBUG /* { */
   8131					;	isrmax = 0;
   8132					;    #endif /* } CBUG */
   8133					;
   8134					;    #endif /* } BSS_NOT_ZERO */
   8135					;
   8136					;    #ifdef KA_SUPPORT /* { */
   8137					;	init_flags |= T_INIT;
   8138					;
   8139					     ?debug  L 2630
   8140	2409  80 0E 0000r 01		     or	     byte ptr DGROUP:_init_flags,1
   8141					;
   8142					;    #endif /* } KA_SUPPORT */
   8143					;    }
   8144					;
   8145					     ?debug  L 2632
   8146	240E  C9			     leave
   8147	240F  C3			     ret
   8148					     ?debug  C E604707463621902FCFF000001690402FEFF0000
   8149					     ?debug  E
   8150					     ?debug  E
   8151	2410			     _taskinit	     endp
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 144
.\rtxc.asm



   8152					;
   8153					;    void resinit(void)
   8154					;
   8155					     ?debug  L 2637
   8156					     assume  cs:RTXC_TEXT,ds:DGROUP
   8157	2410			     _resinit	     proc    near
   8158					     ?debug  B
   8159	2410  55			     push    bp
   8160	2411  8B EC			     mov     bp,sp
   8161	2413  83 EC 04			     sub     sp,4
   8162					     ?debug  B
   8163					;
   8164					;    /************************/
   8165					;    {
   8166					;	REGISTER RESOURCE i;
   8167					;	REGISTER RHEADER near *prh;
   8168					;
   8169					;	for (i = 1, prh	= &rheader[1]; i <= nres; i++, prh++)
   8170					;
   8171					     ?debug  L 2643
   8172	2416  C7 46 FE 0001		     mov     word ptr [bp-2],1
   8173	241B  C7 46 FC 000Ce		     mov     word ptr [bp-4],offset DGROUP:_rheader+12
   8174	2420  EB 27			     jmp     short @6@114
   8175	2422			     @6@58:
   8176					;
   8177					;	{
   8178					;    #ifdef BSS_NOT_ZERO /* { */
   8179					;	   prh->owner =	NULLTCB;
   8180					;
   8181					     ?debug  L 2646
   8182	2422  8B 5E FC			     mov     bx,word ptr [bp-4]
   8183	2425  C7 07 0000		     mov     word ptr [bx],0
   8184					;
   8185					;
   8186					;    #ifdef RESOURCE_WAITERS /*	{ */
   8187					;	   prh->waiters	= NULLTCB;
   8188					;
   8189					     ?debug  L 2649
   8190	2429  C7 47 04 0000		     mov     word ptr [bx+4],0
   8191					;
   8192					;	   prh->dummy =	NULLTCB;
   8193					;
   8194					     ?debug  L 2650
   8195	242E  C7 47 06 0000		     mov     word ptr [bx+6],0
   8196					;
   8197					;    #ifdef PRIORITY_INVERSION /* { */
   8198					;	   prh->priority = 0;
   8199					;
   8200					     ?debug  L 2652
   8201	2433  C7 47 08 0000		     mov     word ptr [bx+8],0
   8202					;
   8203					;    #endif /* } PRIORITY_INVERSION */
   8204					;    #endif /* } RESOURCE_WAITERS */
   8205					;
   8206					;	   prh->level =	0;
   8207					;
   8208					     ?debug  L 2656
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 145
.\rtxc.asm



   8209	2438  C7 47 02 0000		     mov     word ptr [bx+2],0
   8210					;
   8211					;
   8212					;    #ifdef CBUG /* { */
   8213					;	   prh->count =	0;
   8214					;	   prh->conflict = 0;
   8215					;    #endif /* } CBUG */
   8216					;    #endif /* } BSS_NOT_ZERO */
   8217					;
   8218					;    #ifdef PRIORITY_INVERSION /* { */
   8219					;	   prh->resattr	= PRIORITY_INVERSION_T0;
   8220					;
   8221					     ?debug  L 2665
   8222	243D  C7 47 0A 0000		     mov     word ptr [bx+10],0
   8223					     ?debug  L 2643
   8224	2442  FF 46 FE			     inc     word ptr [bp-2]
   8225	2445  83 46 FC 0C		     add     word ptr [bp-4],12
   8226	2449			     @6@114:
   8227	2449  8B 46 FE			     mov     ax,word ptr [bp-2]
   8228	244C  3B 06 0000e		     cmp     ax,word ptr DGROUP:_nres
   8229	2450  7E D0			     jle     short @6@58
   8230					;
   8231					;    #endif /* } PRIORITY_INVERSION */
   8232					;	}
   8233					;
   8234					;    #ifdef KA_SUPPORT /* { */
   8235					;	init_flags |= R_INIT;
   8236					;
   8237					     ?debug  L 2670
   8238	2452  80 0E 0000r 20		     or	     byte ptr DGROUP:_init_flags,32
   8239					;
   8240					;    #endif /* } KA_SUPPORT */
   8241					;    }
   8242					;
   8243					     ?debug  L 2672
   8244	2457  C9			     leave
   8245	2458  C3			     ret
   8246					     ?debug  C E6037072682702FCFF000001690402FEFF0000
   8247					     ?debug  E
   8248					     ?debug  E
   8249	2459			     _resinit	     endp
   8250					;
   8251					;    void mboxinit(void)
   8252					;
   8253					     ?debug  L 2678
   8254					     assume  cs:RTXC_TEXT,ds:DGROUP
   8255	2459			     _mboxinit	     proc    near
   8256					     ?debug  B
   8257	2459  55			     push    bp
   8258	245A  8B EC			     mov     bp,sp
   8259	245C  83 EC 04			     sub     sp,4
   8260					     ?debug  B
   8261					;
   8262					;    /************************/
   8263					;    {
   8264					;    #ifdef BSS_NOT_ZERO /* { */
   8265					;	REGISTER MBOX i;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 146
.\rtxc.asm



   8266					;	REGISTER MHEADER near *pmh;
   8267					;
   8268					;	for (i = 1, pmh	= &mheader[1]; i <= nmboxes; i++, pmh++)
   8269					;
   8270					     ?debug  L 2685
   8271	245F  C7 46 FE 0001		     mov     word ptr [bp-2],1
   8272	2464  C7 46 FC 000Ae		     mov     word ptr [bp-4],offset DGROUP:_mheader+10
   8273	2469  EB 22			     jmp     short @7@114
   8274	246B			     @7@58:
   8275					;
   8276					;	{
   8277					;	   pmh->link = NULL;
   8278					;
   8279					     ?debug  L 2687
   8280	246B  8B 5E FC			     mov     bx,word ptr [bp-4]
   8281	246E  C7 47 02 0000		     mov     word ptr [bx+2],0
   8282	2473  C7 07 0000		     mov     word ptr [bx],0
   8283					;
   8284					;
   8285					;    #ifdef MAILBOX_WAITERS /* { */
   8286					;	   pmh->waiters	= NULLTCB;
   8287					;
   8288					     ?debug  L 2690
   8289	2477  C7 47 04 0000		     mov     word ptr [bx+4],0
   8290					;
   8291					;	   pmh->dummy =	NULLTCB;
   8292					;
   8293					     ?debug  L 2691
   8294	247C  C7 47 06 0000		     mov     word ptr [bx+6],0
   8295					;
   8296					;    #endif /* } MAILBOX_WAITERS */
   8297					;
   8298					;    #ifdef MAILBOX_SEMAS /* { */
   8299					;	   pmh->nesema = 0;
   8300					;
   8301					     ?debug  L 2695
   8302	2481  C7 47 08 0000		     mov     word ptr [bx+8],0
   8303					     ?debug  L 2685
   8304	2486  FF 46 FE			     inc     word ptr [bp-2]
   8305	2489  83 46 FC 0A		     add     word ptr [bp-4],10
   8306	248D			     @7@114:
   8307	248D  8B 46 FE			     mov     ax,word ptr [bp-2]
   8308	2490  3B 06 0000e		     cmp     ax,word ptr DGROUP:_nmboxes
   8309	2494  7E D5			     jle     short @7@58
   8310					;
   8311					;    #endif /* } MAILBOX_SEMAS */
   8312					;
   8313					;    #ifdef CBUG /* { */
   8314					;	   pmh->count =	0;
   8315					;    #endif /* } CBUG */
   8316					;	}
   8317					;    #endif /* } BSS_NOT_ZERO */
   8318					;
   8319					;    #ifdef KA_SUPPORT /* { */
   8320					;	init_flags |= M_INIT;
   8321					;
   8322					     ?debug  L 2705
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 147
.\rtxc.asm



   8323	2496  80 0E 0000r 04		     or	     byte ptr DGROUP:_init_flags,4
   8324					;
   8325					;    #endif /* } KA_SUPPORT */
   8326					;
   8327					;    }
   8328					;
   8329					     ?debug  L 2708
   8330	249B  C9			     leave
   8331	249C  C3			     ret
   8332					     ?debug  C E603706D683302FCFF000001690402FEFF0000
   8333					     ?debug  E
   8334					     ?debug  E
   8335	249D			     _mboxinit	     endp
   8336					;
   8337					;    void partinit(void)
   8338					;
   8339					     ?debug  L 2714
   8340					     assume  cs:RTXC_TEXT,ds:DGROUP
   8341	249D			     _partinit	     proc    near
   8342					     ?debug  B
   8343	249D  55			     push    bp
   8344	249E  8B EC			     mov     bp,sp
   8345	24A0  83 EC 0C			     sub     sp,12
   8346					     ?debug  B
   8347					;
   8348					;    /************************/
   8349					;    {
   8350					;	MAP i;
   8351					;	int j;
   8352					;    #ifdef HUGE_PARTITIONS /* { */
   8353					;	char huge * huge * next;
   8354					;    #else /* }	HUGE_PARTITIONS	{ */
   8355					;	char **next;
   8356					;    #endif /* } HUGE_PARTITIONS */
   8357					;	REGISTER PHEADER near *pph;
   8358					;	REGISTER const PKHEADER	near *ppkh;
   8359					;
   8360					;	for (i = 1, ppkh = &pkheader[1], pph = &pheader[1]; i <= nparts;
   8361					;
   8362					     ?debug  L 2727
   8363	24A3  C7 46 FE 0001		     mov     word ptr [bp-2],1
   8364	24A8  C7 46 F4 0008e		     mov     word ptr [bp-12],offset DGROUP:_pkheader+8
   8365	24AD  C7 46 F6 0012e		     mov     word ptr [bp-10],offset DGROUP:_pheader+18
   8366	24B2  E9 0092			     jmp     @8@282
   8367	24B5			     @8@58:
   8368					;
   8369					;	     i++,   ppkh++,		 pph++)
   8370					;	{
   8371					;	   pph->next = ppkh->next;
   8372					;
   8373					     ?debug  L 2730
   8374	24B5  8B 5E F4			     mov     bx,word ptr [bp-12]
   8375	24B8  8B 57 02			     mov     dx,word ptr [bx+2]
   8376	24BB  8B 07			     mov     ax,word ptr [bx]
   8377	24BD  8B 5E F6			     mov     bx,word ptr [bp-10]
   8378	24C0  89 57 02			     mov     word ptr [bx+2],dx
   8379	24C3  89 07			     mov     word ptr [bx],ax
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 148
.\rtxc.asm



   8380					;
   8381					;
   8382					;    #ifdef HUGE_PARTITIONS /* { */
   8383					;	   if (	(next =	(char huge * huge *)pph->next) != (void	huge *)0)
   8384					;	   {
   8385					;	      for (j = 1; j < ppkh->count; j++,	next = (char huge * huge *)*next)
   8386					;		 *next = (char huge *)next + ppkh->size;
   8387					;    #else /* }	HUGE_PARTITIONS	{ */
   8388					;	   if (	(next =	(char **)pph->next) != NULL)
   8389					;
   8390					     ?debug  L 2738
   8391	24C5  8B 57 02			     mov     dx,word ptr [bx+2]
   8392	24C8  8B 07			     mov     ax,word ptr [bx]
   8393	24CA  89 56 FA			     mov     word ptr [bp-6],dx
   8394	24CD  89 46 F8			     mov     word ptr [bp-8],ax
   8395	24D0  0B C2			     or	     ax,dx
   8396	24D2  74 46			     je	     short @8@226
   8397					;
   8398					;	   {
   8399					;	      for (j = 1; j < ppkh->count; j++,	next = (char **)*next)
   8400					;
   8401					     ?debug  L 2740
   8402	24D4  C7 46 FC 0001		     mov     word ptr [bp-4],1
   8403	24D9  EB 26			     jmp     short @8@170
   8404	24DB			     @8@114:
   8405					;
   8406					;		 *next = (char *)next +	ppkh->size;
   8407					;
   8408					     ?debug  L 2741
   8409	24DB  8B 5E F4			     mov     bx,word ptr [bp-12]
   8410	24DE  8B 56 FA			     mov     dx,word ptr [bp-6]
   8411	24E1  8B 46 F8			     mov     ax,word ptr [bp-8]
   8412	24E4  03 47 04			     add     ax,word ptr [bx+4]
   8413	24E7  C4 5E F8			     les     bx,dword ptr [bp-8]
   8414	24EA  26: 89 57	02		     mov     word ptr es:[bx+2],dx
   8415	24EE  26: 89 07			     mov     word ptr es:[bx],ax
   8416					     ?debug  L 2740
   8417	24F1  FF 46 FC			     inc     word ptr [bp-4]
   8418	24F4  26: 8B 57	02		     mov     dx,word ptr es:[bx+2]
   8419	24F8  26: 8B 07			     mov     ax,word ptr es:[bx]
   8420	24FB  89 56 FA			     mov     word ptr [bp-6],dx
   8421	24FE  89 46 F8			     mov     word ptr [bp-8],ax
   8422	2501			     @8@170:
   8423	2501  8B 5E F4			     mov     bx,word ptr [bp-12]
   8424	2504  8B 47 06			     mov     ax,word ptr [bx+6]
   8425	2507  3B 46 FC			     cmp     ax,word ptr [bp-4]
   8426	250A  7F CF			     jg	     short @8@114
   8427					;
   8428					;    #endif /* } HUGE_PARTITIONS */
   8429					;
   8430					;    #ifdef BSS_NOT_ZERO /* { */
   8431					;	      *next = NULL; /* null last link */
   8432					;
   8433					     ?debug  L 2745
   8434	250C  C4 5E F8			     les     bx,dword ptr [bp-8]
   8435	250F  26: C7 47	02 0000		     mov     word ptr es:[bx+2],0
   8436	2515  26: C7 07	0000		     mov     word ptr es:[bx],0
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 149
.\rtxc.asm



   8437	251A			     @8@226:
   8438					;
   8439					;    #endif /* } BSS_NOT_ZERO */
   8440					;	   }
   8441					;
   8442					;	   pph->size = ppkh->size;
   8443					;
   8444					     ?debug  L 2749
   8445	251A  8B 5E F4			     mov     bx,word ptr [bp-12]
   8446	251D  8B 47 04			     mov     ax,word ptr [bx+4]
   8447	2520  8B 5E F6			     mov     bx,word ptr [bp-10]
   8448	2523  89 47 04			     mov     word ptr [bx+4],ax
   8449					;
   8450					;	   pph->count =	ppkh->count;
   8451					;
   8452					     ?debug  L 2750
   8453	2526  8B 5E F4			     mov     bx,word ptr [bp-12]
   8454	2529  8B 47 06			     mov     ax,word ptr [bx+6]
   8455	252C  8B 5E F6			     mov     bx,word ptr [bp-10]
   8456	252F  89 47 06			     mov     word ptr [bx+6],ax
   8457					;
   8458					;
   8459					;    #ifdef BSS_NOT_ZERO /* { */
   8460					;    #ifdef PARTITION_WAITERS /* { */
   8461					;	   pph->waiters	= NULLTCB;
   8462					;
   8463					     ?debug  L 2754
   8464	2532  C7 47 08 0000		     mov     word ptr [bx+8],0
   8465					;
   8466					;	   pph->dummy =	NULLTCB;
   8467					;
   8468					     ?debug  L 2755
   8469	2537  C7 47 0A 0000		     mov     word ptr [bx+10],0
   8470					     ?debug  L 2728
   8471	253C  FF 46 FE			     inc     word ptr [bp-2]
   8472	253F  83 46 F4 08		     add     word ptr [bp-12],8
   8473	2543  83 46 F6 12		     add     word ptr [bp-10],18
   8474	2547			     @8@282:
   8475	2547  8B 46 FE			     mov     ax,word ptr [bp-2]
   8476	254A  3B 06 0000e		     cmp     ax,word ptr DGROUP:_nparts
   8477	254E  7F 03			     jg	     @@48
   8478	2550  E9 FF62			     jmp     @8@58
   8479	2553			     @@48:
   8480					;
   8481					;    #endif /* } PARTITION_WAITERS */
   8482					;
   8483					;    #ifdef CBUG /* { */
   8484					;	   pph->cur = 0;
   8485					;	   pph->worst =	0;
   8486					;	   pph->usage =	0;
   8487					;    #endif /* } CBUG */
   8488					;    #endif /* } BSS_NOT_ZERO */
   8489					;	}
   8490					;
   8491					;    #ifdef DYNAMIC_PARTS /* { */
   8492					;	/* thread dynamic partition PHEADER free pool -	possibly dnparts == 0 */
   8493					;	if (dnparts)
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 150
.\rtxc.asm



   8494					;
   8495					     ?debug  L 2768
   8496	2553  83 3E 0000e 00		     cmp     word ptr DGROUP:_dnparts,0
   8497	2558  74 0E			     je	     short @8@366
   8498					;
   8499					;	  dphfl	= &pheader[nparts + 1];
   8500					;
   8501					     ?debug  L 2769
   8502	255A  A1 0000e			     mov     ax,word ptr DGROUP:_nparts
   8503	255D  6B C0 12			     imul    ax,ax,18
   8504	2560  05 0012e			     add     ax,offset DGROUP:_pheader+18
   8505	2563  A3 000Ar			     mov     word ptr DGROUP:_dphfl,ax
   8506	2566  EB 06			     jmp     short @8@394
   8507	2568			     @8@366:
   8508					;
   8509					;	else
   8510					;	  dphfl	= NULLMAP;
   8511					;
   8512					     ?debug  L 2771
   8513	2568  C7 06 000Ar 0000		     mov     word ptr DGROUP:_dphfl,0
   8514	256E			     @8@394:
   8515					;
   8516					;
   8517					;	for (i = 1, j =	nparts+1, pph =	dphfl; i < dnparts; i++, j++, pph++)
   8518					;
   8519					     ?debug  L 2773
   8520	256E  C7 46 FE 0001		     mov     word ptr [bp-2],1
   8521	2573  A1 0000e			     mov     ax,word ptr DGROUP:_nparts
   8522	2576  40			     inc     ax
   8523	2577  89 46 FC			     mov     word ptr [bp-4],ax
   8524	257A  A1 000Ar			     mov     ax,word ptr DGROUP:_dphfl
   8525	257D  89 46 F6			     mov     word ptr [bp-10],ax
   8526	2580  EB 21			     jmp     short @8@478
   8527	2582			     @8@422:
   8528					;
   8529					;	{
   8530					;	   pph->next = (struct xmap *)&pheader[j+1]; /*	insert pheader into linked list	*/
   8531					;
   8532					     ?debug  L 2775
   8533	2582  8B 46 FC			     mov     ax,word ptr [bp-4]
   8534	2585  6B C0 12			     imul    ax,ax,18
   8535	2588  05 0012e			     add     ax,offset DGROUP:_pheader+18
   8536	258B  8B 5E F6			     mov     bx,word ptr [bp-10]
   8537	258E  8C 5F 02			     mov     word ptr [bx+2],ds
   8538	2591  89 07			     mov     word ptr [bx],ax
   8539					;
   8540					;	   pph->map = j;	/* set map number for return to	definer	*/
   8541					;
   8542					     ?debug  L 2776
   8543	2593  8B 46 FC			     mov     ax,word ptr [bp-4]
   8544	2596  89 47 0C			     mov     word ptr [bx+12],ax
   8545					     ?debug  L 2773
   8546	2599  FF 46 FE			     inc     word ptr [bp-2]
   8547	259C  FF 46 FC			     inc     word ptr [bp-4]
   8548	259F  83 46 F6 12		     add     word ptr [bp-10],18
   8549	25A3			     @8@478:
   8550	25A3  8B 46 FE			     mov     ax,word ptr [bp-2]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 151
.\rtxc.asm



   8551	25A6  3B 06 0000e		     cmp     ax,word ptr DGROUP:_dnparts
   8552	25AA  7C D6			     jl	     short @8@422
   8553					;
   8554					;	}
   8555					;
   8556					;	if (dnparts)
   8557					;
   8558					     ?debug  L 2779
   8559	25AC  83 3E 0000e 00		     cmp     word ptr DGROUP:_dnparts,0
   8560	25B1  74 12			     je	     short @8@562
   8561					;
   8562					;	{
   8563					;	   pph->next = NULL; /*	null last link */
   8564					;
   8565					     ?debug  L 2781
   8566	25B3  8B 5E F6			     mov     bx,word ptr [bp-10]
   8567	25B6  C7 47 02 0000		     mov     word ptr [bx+2],0
   8568	25BB  C7 07 0000		     mov     word ptr [bx],0
   8569					;
   8570					;	   pph->map = j;
   8571					;
   8572					     ?debug  L 2782
   8573	25BF  8B 46 FC			     mov     ax,word ptr [bp-4]
   8574	25C2  89 47 0C			     mov     word ptr [bx+12],ax
   8575	25C5			     @8@562:
   8576					;
   8577					;	}
   8578					;    #endif /* } DYNAMIC_PARTS */
   8579					;
   8580					;    #ifdef KA_SUPPORT /* { */
   8581					;	init_flags |= P_INIT;
   8582					;
   8583					     ?debug  L 2787
   8584	25C5  80 0E 0000r 08		     or	     byte ptr DGROUP:_init_flags,8
   8585					;
   8586					;    #endif /* } KA_SUPPORT */
   8587					;    }
   8588					;
   8589					     ?debug  L 2789
   8590	25CA  C9			     leave
   8591	25CB  C3			     ret
   8592					     ?debug  C E33808706B68656164657208001E55
   8593					     ?debug  C E337000200153804
   8594					     ?debug  C E339000400161800
   8595					     ?debug  C E60470706B683702F4FF0000037070682F02F6FF+
   8596					     ?debug  C 0000046E6578743902F8FF0000016A0402FCFF00+
   8597					     ?debug  C 0001690402FEFF0000
   8598					     ?debug  E
   8599					     ?debug  E
   8600	25CC			     _partinit	     endp
   8601					;
   8602					;    void queueinit(void)
   8603					;
   8604					     ?debug  L 2795
   8605					     assume  cs:RTXC_TEXT,ds:DGROUP
   8606	25CC			     _queueinit	     proc    near
   8607					     ?debug  B
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 152
.\rtxc.asm



   8608	25CC  55			     push    bp
   8609	25CD  8B EC			     mov     bp,sp
   8610	25CF  83 EC 06			     sub     sp,6
   8611					     ?debug  B
   8612					;
   8613					;    /************************/
   8614					;    {
   8615					;	QUEUE i;
   8616					;	REGISTER QHEADER near *pqh;
   8617					;	REGISTER const QKHEADER	near *pqkh;
   8618					;
   8619					;	for (i = 1, pqkh = &qkheader[1], pqh = &qheader[1]; i <= nqueues;
   8620					;
   8621					     ?debug  L 2802
   8622	25D2  C7 46 FE 0001		     mov     word ptr [bp-2],1
   8623	25D7  C7 46 FA 0008e		     mov     word ptr [bp-6],offset DGROUP:_qkheader+8
   8624	25DC  C7 46 FC 0018e		     mov     word ptr [bp-4],offset DGROUP:_qheader+24
   8625	25E1  EB 5D			     jmp     short @9@114
   8626	25E3			     @9@58:
   8627					;
   8628					;	     i++,   pqkh++,		 pqh++)
   8629					;	{
   8630					;	   pqh->base = pqkh->base;
   8631					;
   8632					     ?debug  L 2805
   8633	25E3  8B 5E FA			     mov     bx,word ptr [bp-6]
   8634	25E6  8B 57 02			     mov     dx,word ptr [bx+2]
   8635	25E9  8B 07			     mov     ax,word ptr [bx]
   8636	25EB  8B 5E FC			     mov     bx,word ptr [bp-4]
   8637	25EE  89 57 02			     mov     word ptr [bx+2],dx
   8638	25F1  89 07			     mov     word ptr [bx],ax
   8639					;
   8640					;	   pqh->width =	pqkh->width;
   8641					;
   8642					     ?debug  L 2806
   8643	25F3  8B 5E FA			     mov     bx,word ptr [bp-6]
   8644	25F6  8B 47 04			     mov     ax,word ptr [bx+4]
   8645	25F9  8B 5E FC			     mov     bx,word ptr [bp-4]
   8646	25FC  89 47 04			     mov     word ptr [bx+4],ax
   8647					;
   8648					;	   pqh->depth =	pqkh->depth;
   8649					;
   8650					     ?debug  L 2807
   8651	25FF  8B 5E FA			     mov     bx,word ptr [bp-6]
   8652	2602  8B 47 06			     mov     ax,word ptr [bx+6]
   8653	2605  8B 5E FC			     mov     bx,word ptr [bp-4]
   8654	2608  89 47 06			     mov     word ptr [bx+6],ax
   8655					;
   8656					;	   pqh->putndx = pqh->depth - 1;
   8657					;
   8658					     ?debug  L 2808
   8659	260B  8B 47 06			     mov     ax,word ptr [bx+6]
   8660	260E  48			     dec     ax
   8661	260F  89 47 08			     mov     word ptr [bx+8],ax
   8662					;
   8663					;    #ifdef BSS_NOT_ZERO /* { */
   8664					;	   pqh->curndx = 0;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 153
.\rtxc.asm



   8665					;
   8666					     ?debug  L 2810
   8667	2612  C7 47 0A 0000		     mov     word ptr [bx+10],0
   8668					;
   8669					;
   8670					;    #ifdef QUEUE_SEMAS	/* { */
   8671					;	   pqh->nesema = 0;
   8672					;
   8673					     ?debug  L 2813
   8674	2617  C7 47 12 0000		     mov     word ptr [bx+18],0
   8675					;
   8676					;	   pqh->fsema =	0;
   8677					;
   8678					     ?debug  L 2814
   8679	261C  C7 47 10 0000		     mov     word ptr [bx+16],0
   8680					;
   8681					;	   pqh->nfsema = 0;
   8682					;
   8683					     ?debug  L 2815
   8684	2621  C7 47 16 0000		     mov     word ptr [bx+22],0
   8685					;
   8686					;	   pqh->esema =	0;
   8687					;
   8688					     ?debug  L 2816
   8689	2626  C7 47 14 0000		     mov     word ptr [bx+20],0
   8690					;
   8691					;    #endif /* } QUEUE_SEMAS */
   8692					;
   8693					;    #ifdef QUEUE_WAITERS /* { */
   8694					;	   pqh->waiters	= NULLTCB;
   8695					;
   8696					     ?debug  L 2820
   8697	262B  C7 47 0C 0000		     mov     word ptr [bx+12],0
   8698					;
   8699					;	   pqh->dummy =	NULLTCB;
   8700					;
   8701					     ?debug  L 2821
   8702	2630  C7 47 0E 0000		     mov     word ptr [bx+14],0
   8703					     ?debug  L 2803
   8704	2635  FF 46 FE			     inc     word ptr [bp-2]
   8705	2638  83 46 FA 08		     add     word ptr [bp-6],8
   8706	263C  83 46 FC 18		     add     word ptr [bp-4],24
   8707	2640			     @9@114:
   8708	2640  8B 46 FE			     mov     ax,word ptr [bp-2]
   8709	2643  3B 06 0000e		     cmp     ax,word ptr DGROUP:_nqueues
   8710	2647  7E 9A			     jle     short @9@58
   8711					;
   8712					;    #endif /* } QUEUE_WAITERS */
   8713					;
   8714					;    #ifdef CBUG /* { */
   8715					;	   pqh->count =	0;
   8716					;	   pqh->worst =	0;
   8717					;    #endif /* } CBUG */
   8718					;    #endif /* } BSS_NOT_ZERO */
   8719					;	}
   8720					;    #ifdef KA_SUPPORT /* { */
   8721					;	init_flags |= Q_INIT;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 154
.\rtxc.asm



   8722					;
   8723					     ?debug  L 2831
   8724	2649  80 0E 0000r 10		     or	     byte ptr DGROUP:_init_flags,16
   8725					;
   8726					;    #endif /* } KA_SUPPORT */
   8727					;    }
   8728					;
   8729					     ?debug  L 2833
   8730	264E  C9			     leave
   8731	264F  C3			     ret
   8732					     ?debug  C E33B08716B68656164657208001E59
   8733					     ?debug  C E33A000200153B04
   8734					     ?debug  C E60470716B683A02FAFF0000037071682B02FCFF+
   8735					     ?debug  C 000001690402FEFF0000
   8736					     ?debug  E
   8737					     ?debug  E
   8738	2650			     _queueinit	     endp
   8739					;
   8740					;    void semainit(void)
   8741					;
   8742					     ?debug  L 2838
   8743					     assume  cs:RTXC_TEXT,ds:DGROUP
   8744	2650			     _semainit	     proc    near
   8745					     ?debug  B
   8746	2650  55			     push    bp
   8747	2651  8B EC			     mov     bp,sp
   8748	2653  83 EC 08			     sub     sp,8
   8749					     ?debug  B
   8750					;
   8751					;    /************************/
   8752					;    {
   8753					;	REGISTER SEMA i;
   8754					;	REGISTER SSTATE	near *s;
   8755					;    #ifdef BSS_NOT_ZERO /* { */
   8756					;	int j;
   8757					;    #endif /* } BSS_NOT_ZERO */
   8758					;
   8759					;	for (i = 1, s =	&semat[1]; i <=	nsemas;	i++, s++)
   8760					;
   8761					     ?debug  L 2847
   8762	2656  C7 46 FE 0001		     mov     word ptr [bp-2],1
   8763	265B  C7 46 FC 0002e		     mov     word ptr [bp-4],offset DGROUP:_semat+2
   8764	2660  EB 0E			     jmp     short @10@114
   8765	2662			     @10@58:
   8766					;
   8767					;	   *s =	SEMA_PENDING;
   8768					;
   8769					     ?debug  L 2848
   8770	2662  8B 5E FC			     mov     bx,word ptr [bp-4]
   8771	2665  C7 07 FFFF		     mov     word ptr [bx],-1
   8772					     ?debug  L 2847
   8773	2669  FF 46 FE			     inc     word ptr [bp-2]
   8774	266C  83 46 FC 02		     add     word ptr [bp-4],2
   8775	2670			     @10@114:
   8776	2670  8B 46 FE			     mov     ax,word ptr [bp-2]
   8777	2673  3B 06 0000e		     cmp     ax,word ptr DGROUP:_nsemas
   8778	2677  7E E9			     jle     short @10@58
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 155
.\rtxc.asm



   8779					;
   8780					;
   8781					;	semaput	= semaget = &siglist[0]; /* init empty sema deque */
   8782					;
   8783					     ?debug  L 2850
   8784	2679  B8 0000e			     mov     ax,offset DGROUP:_siglist
   8785	267C  A3 0006r			     mov     word ptr DGROUP:_semaget,ax
   8786	267F  A3 0004r			     mov     word ptr DGROUP:_semaput,ax
   8787					;
   8788					;
   8789					;    #ifdef BSS_NOT_ZERO /* { */
   8790					;	for (j = 0; j <	siglistsize; j++)
   8791					;
   8792					     ?debug  L 2853
   8793	2682  C7 46 FA 0000		     mov     word ptr [bp-6],0
   8794	2687  C7 46 F8 0000e		     mov     word ptr [bp-8],offset DGROUP:_siglist
   8795	268C  EB 0E			     jmp     short @10@282
   8796	268E			     @10@198:
   8797					;
   8798					;	   siglist[j] =	0;
   8799					;
   8800					     ?debug  L 2854
   8801	268E  8B 5E F8			     mov     bx,word ptr [bp-8]
   8802	2691  C7 07 0000		     mov     word ptr [bx],0
   8803					     ?debug  L 2853
   8804	2695  83 46 F8 02		     add     word ptr [bp-8],2
   8805	2699  FF 46 FA			     inc     word ptr [bp-6]
   8806	269C			     @10@282:
   8807	269C  8B 46 FA			     mov     ax,word ptr [bp-6]
   8808	269F  3B 06 0000e		     cmp     ax,word ptr DGROUP:_siglistsize
   8809	26A3  7C E9			     jl	     short @10@198
   8810					;
   8811					;
   8812					;    #endif /* } BSS_NOT_ZERO */
   8813					;    #ifdef KA_SUPPORT /* { */
   8814					;	init_flags |= S_INIT;
   8815					;
   8816					     ?debug  L 2858
   8817	26A5  80 0E 0000r 02		     or	     byte ptr DGROUP:_init_flags,2
   8818					;
   8819					;    #endif /* } KA_SUPPORT */
   8820					;    }
   8821					;
   8822					     ?debug  L 2860
   8823	26AA  C9			     leave
   8824	26AB  C3			     ret
   8825					     ?debug  C E6016A0402FAFF000001733502FCFF0000016904+
   8826					     ?debug  C 02FEFF0000
   8827					     ?debug  E
   8828					     ?debug  E
   8829	26AC			     _semainit	     endp
   8830					;
   8831					;    void clockinit(void)
   8832					;
   8833					     ?debug  L 2864
   8834					     assume  cs:RTXC_TEXT,ds:DGROUP
   8835	26AC			     _clockinit	     proc    near
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 156
.\rtxc.asm



   8836					     ?debug  B
   8837	26AC  55			     push    bp
   8838	26AD  8B EC			     mov     bp,sp
   8839	26AF  83 EC 06			     sub     sp,6
   8840					     ?debug  B
   8841					;
   8842					;    /************************/
   8843					;    {
   8844					;	REGISTER int i;
   8845					;	REGISTER CLKBLK	ks_clk *link;
   8846					;
   8847					;	/* note, RTXCgen guarantees at least 1 timer */
   8848					;
   8849					;	link = clkqfl =	&clkq[0];
   8850					;
   8851					     ?debug  L 2872
   8852	26B2  B8 0000s			     mov     ax,seg _clkq
   8853	26B5  BA 0000e			     mov     dx,offset _clkq
   8854	26B8  A3 0016r			     mov     word ptr DGROUP:_clkqfl+2,ax
   8855	26BB  89 16 0014r		     mov     word ptr DGROUP:_clkqfl,dx
   8856	26BF  89 46 FC			     mov     word ptr [bp-4],ax
   8857	26C2  89 56 FA			     mov     word ptr [bp-6],dx
   8858					;
   8859					;
   8860					;	for (i = 1; i <	ntmrs; i++, link++)
   8861					;
   8862					     ?debug  L 2874
   8863	26C5  C7 46 FE 0001		     mov     word ptr [bp-2],1
   8864	26CA  EB 1A			     jmp     short @11@114
   8865	26CC			     @11@58:
   8866					;
   8867					;	   link->flink = link +	1;
   8868					;
   8869					     ?debug  L 2875
   8870	26CC  8B 56 FC			     mov     dx,word ptr [bp-4]
   8871	26CF  8B 46 FA			     mov     ax,word ptr [bp-6]
   8872	26D2  05 0018			     add     ax,24
   8873	26D5  C4 5E FA			     les     bx,dword ptr [bp-6]
   8874	26D8  26: 89 57	02		     mov     word ptr es:[bx+2],dx
   8875	26DC  26: 89 07			     mov     word ptr es:[bx],ax
   8876					     ?debug  L 2874
   8877	26DF  FF 46 FE			     inc     word ptr [bp-2]
   8878	26E2  83 46 FA 18		     add     word ptr [bp-6],24
   8879	26E6			     @11@114:
   8880	26E6  8B 46 FE			     mov     ax,word ptr [bp-2]
   8881	26E9  3B 06 0000e		     cmp     ax,word ptr DGROUP:_ntmrs
   8882	26ED  7C DD			     jl	     short @11@58
   8883					;
   8884					;
   8885					;    #ifdef BSS_NOT_ZERO /* { */
   8886					;	link->flink = NULLCLK;
   8887					;
   8888					     ?debug  L 2878
   8889	26EF  C4 5E FA			     les     bx,dword ptr [bp-6]
   8890	26F2  26: C7 47	02 0000		     mov     word ptr es:[bx+2],0
   8891	26F8  26: C7 07	0000		     mov     word ptr es:[bx],0
   8892					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 157
.\rtxc.asm



   8893					;
   8894					;	clkqptr	= NULLCLK;
   8895					;
   8896					     ?debug  L 2880
   8897	26FD  C7 06 001Ar 0000		     mov     word ptr DGROUP:_clkqptr+2,0
   8898	2703  C7 06 0018r 0000		     mov     word ptr DGROUP:_clkqptr,0
   8899					;
   8900					;
   8901					;	rtctick	= (TICKS)0;
   8902					;
   8903					     ?debug  L 2882
   8904	2709  C7 06 000Er 0000		     mov     word ptr DGROUP:_rtctick+2,0
   8905	270F  C7 06 000Cr 0000		     mov     word ptr DGROUP:_rtctick,0
   8906					;
   8907					;	t_expired = 0;
   8908					;
   8909					     ?debug  L 2883
   8910	2715  C6 06 0021r 00		     mov     byte ptr DGROUP:t_expired,0
   8911					;
   8912					;
   8913					;    #ifdef HAS_INQTIME	/* { */
   8914					;	rtctime	= (time_t)0;
   8915					;
   8916					     ?debug  L 2886
   8917	271A  C7 06 0012r 0000		     mov     word ptr DGROUP:_rtctime+2,0
   8918	2720  C7 06 0010r 0000		     mov     word ptr DGROUP:_rtctime,0
   8919					;
   8920					;	ratecnt	= 0;
   8921					;
   8922					     ?debug  L 2887
   8923	2726  C7 06 001Er 0000		     mov     word ptr DGROUP:ratecnt,0
   8924					;
   8925					;    #endif /* } HAS_INQTIME */
   8926					;
   8927					;    #ifdef TIME_SLICE /* { */
   8928					;	sliceup	= NULLTCB;
   8929					;
   8930					     ?debug  L 2891
   8931	272C  C7 06 001Cr 0000		     mov     word ptr DGROUP:_sliceup,0
   8932					;
   8933					;    #endif /* } TIME_SLICE */
   8934					;
   8935					;    #endif /* } BSS_NOT_ZERO */
   8936					;    #ifdef KA_SUPPORT /* { */
   8937					;	init_flags |= C_INIT;
   8938					;
   8939					     ?debug  L 2896
   8940	2732  80 0E 0000r 40		     or	     byte ptr DGROUP:_init_flags,64
   8941					;
   8942					;    #endif /* } KA_SUPPORT */
   8943					;    }
   8944					;
   8945					     ?debug  L 2898
   8946	2737  C9			     leave
   8947	2738  C3			     ret
   8948					     ?debug  C E6046C696E6B1B02FAFF000001690402FEFF0000
   8949					     ?debug  E
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 158
.\rtxc.asm



   8950					     ?debug  E
   8951	2739			     _clockinit	     endp
   8952					;
   8953					;    void * far	KSAPI KS_ISRalloc(MAP map)
   8954					;
   8955					     ?debug  L 2903
   8956					     assume  cs:RTXC_TEXT,ds:DGROUP
   8957	2739			     _KS_ISRalloc    proc    far
   8958					     ?debug  B
   8959	2739  55			     push    bp
   8960	273A  8B EC			     mov     bp,sp
   8961	273C  83 EC 08			     sub     sp,8
   8962					     ?debug  C E6036D6170040A06000000
   8963					     ?debug  B
   8964					;
   8965					;    /************************/
   8966					;    {
   8967					;	PHEADER	near *pph;
   8968					;	struct xmap *q;
   8969					;	FLAG_STORAGE;
   8970					;
   8971					;	pph = &pheader[map];
   8972					;
   8973					     ?debug  L 2910
   8974	273F  8B 46 06			     mov     ax,word ptr [bp+6]
   8975	2742  6B C0 12			     imul    ax,ax,18
   8976	2745  05 0000e			     add     ax,offset DGROUP:_pheader
   8977	2748  89 46 FE			     mov     word ptr [bp-2],ax
   8978					;
   8979					;
   8980					;	SAVE_FLAGS;
   8981					;
   8982					     ?debug  L 2912
   8983	274B  9C			     pushf
   8984	274C  8F 46 F8			     pop      [bp-8]
   8985					;
   8986					;	DISABLE;   /* in case called from isr */
   8987					;
   8988					     ?debug  L 2913
   8989	274F  FA			     cli
   8990	2750  90			     nop
   8991					;
   8992					;		   /* can also be called from RTXC_ALLOC code */
   8993					;
   8994					;	if ( (q	= pph->next) !=	NULL) /* if any	avail, return 1st */
   8995					;
   8996					     ?debug  L 2916
   8997	2751  8B 5E FE			     mov     bx,word ptr [bp-2]
   8998	2754  8B 57 02			     mov     dx,word ptr [bx+2]
   8999	2757  8B 07			     mov     ax,word ptr [bx]
   9000	2759  89 56 FC			     mov     word ptr [bp-4],dx
   9001	275C  89 46 FA			     mov     word ptr [bp-6],ax
   9002	275F  0B C2			     or	     ax,dx
   9003	2761  74 12			     je	     short @12@226
   9004					;
   9005					;	{
   9006					;	   pph->next = q->link;	/* unlink 1st one from list */
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 159
.\rtxc.asm



   9007					;
   9008					     ?debug  L 2918
   9009	2763  C4 5E FA			     les     bx,dword ptr [bp-6]
   9010	2766  26: 8B 57	02		     mov     dx,word ptr es:[bx+2]
   9011	276A  26: 8B 07			     mov     ax,word ptr es:[bx]
   9012	276D  8B 5E FE			     mov     bx,word ptr [bp-2]
   9013	2770  89 57 02			     mov     word ptr [bx+2],dx
   9014	2773  89 07			     mov     word ptr [bx],ax
   9015	2775			     @12@226:
   9016					;
   9017					;    #ifdef CBUG /* { */
   9018					;	   if (++pph->cur > pph->worst)	/* check for new worst case */
   9019					;	      pph->worst = pph->cur;	      /* usage level */
   9020					;    #endif /* } CBUG */
   9021					;	}
   9022					;	RESTORE_FLAGS;
   9023					;
   9024					     ?debug  L 2924
   9025	2775  FF 76 F8			     push     [bp-8]
   9026	2778  9D			     popf
   9027					;
   9028					;
   9029					;	return(q);
   9030					;
   9031					     ?debug  L 2926
   9032	2779  8B 56 FC			     mov     dx,word ptr [bp-4]
   9033	277C  8B 46 FA			     mov     ax,word ptr [bp-6]
   9034					;
   9035					;    }
   9036					;
   9037					     ?debug  L 2927
   9038	277F  C9			     leave
   9039	2780  CB			     ret
   9040					     ?debug  C E605666C6167730A02F8FF000001712D02FAFF00+
   9041					     ?debug  C 00037070682F02FEFF0000036D6170040A060000+
   9042					     ?debug  C 00
   9043					     ?debug  E
   9044					     ?debug  E
   9045	2781			     _KS_ISRalloc    endp
   9046					;
   9047					;    void far KSAPI KS_ISRsignal(SEMA sema)
   9048					;
   9049					     ?debug  L 2932
   9050					     assume  cs:RTXC_TEXT,ds:DGROUP
   9051	2781			     _KS_ISRsignal   proc    far
   9052					     ?debug  B
   9053	2781  55			     push    bp
   9054	2782  8B EC			     mov     bp,sp
   9055	2784  83 EC 02			     sub     sp,2
   9056					     ?debug  C E60473656D61040A06000000
   9057					     ?debug  B
   9058					;
   9059					;    /************************/
   9060					;    {
   9061					;	FLAG_STORAGE;
   9062					;	SAVE_FLAGS;   /* Save state of interrupts */
   9063					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 160
.\rtxc.asm



   9064					     ?debug  L 2936
   9065	2787  9C			     pushf
   9066	2788  8F 46 FE			     pop      [bp-2]
   9067					;
   9068					;	DISABLE;
   9069					;
   9070					     ?debug  L 2937
   9071	278B  FA			     cli
   9072	278C  90			     nop
   9073					;
   9074					;	*semaput++ = sema;
   9075					;
   9076					     ?debug  L 2938
   9077	278D  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
   9078	2791  8B 46 06			     mov     ax,word ptr [bp+6]
   9079	2794  89 07			     mov     word ptr [bx],ax
   9080	2796  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
   9081					;
   9082					;	RESTORE_FLAGS; /* Restore state	of interrupts */
   9083					;
   9084					     ?debug  L 2939
   9085	279B  FF 76 FE			     push     [bp-2]
   9086	279E  9D			     popf
   9087					;
   9088					;    }
   9089					;
   9090					     ?debug  L 2940
   9091	279F  C9			     leave
   9092	27A0  CB			     ret
   9093					     ?debug  C E605666C6167730A02FEFF00000473656D61040A+
   9094					     ?debug  C 06000000
   9095					     ?debug  E
   9096					     ?debug  E
   9097	27A1			     _KS_ISRsignal   endp
   9098					;
   9099					;    FRAME * far KSAPI KS_ISRexit(FRAME	*frame,	SEMA sema)
   9100					;
   9101					     ?debug  L 2944
   9102					     assume  cs:RTXC_TEXT,ds:DGROUP
   9103	27A1			     _KS_ISRexit     proc    far
   9104					     ?debug  B
   9105	27A1  55			     push    bp
   9106	27A2  8B EC			     mov     bp,sp
   9107					     ?debug  C E60473656D61040A0A000000056672616D651F0A+
   9108					     ?debug  C 06000000
   9109					     ?debug  B
   9110					;
   9111					;    /************************/
   9112					;    {
   9113					;    #ifdef CBUG /* { */
   9114					;	if (isrcnt > isrmax) /*	audit worst case interrupt depth */
   9115					;	   isrmax = isrcnt;
   9116					;    #endif /* } CBUG */
   9117					;
   9118					;	DISABLE; /* turn off interrupts	briefly	while checking nest level */
   9119					;
   9120					     ?debug  L 2952
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 161
.\rtxc.asm



   9121	27A4  FA			     cli
   9122	27A5  90			     nop
   9123					;
   9124					;
   9125					;	if (sema) /* if	non-zero sema passed */
   9126					;
   9127					     ?debug  L 2954
   9128	27A6  83 7E 0A 00		     cmp     word ptr [bp+10],0
   9129	27AA  74 0E			     je	     short @14@142
   9130					;
   9131					;	{
   9132					;	      *semaput++ = sema; /* put	sema in	post list */
   9133					;
   9134					     ?debug  L 2956
   9135	27AC  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
   9136	27B0  8B 46 0A			     mov     ax,word ptr [bp+10]
   9137	27B3  89 07			     mov     word ptr [bx],ax
   9138	27B5  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
   9139	27BA			     @14@142:
   9140					;
   9141					;	}
   9142					;
   9143					;	if (isrcnt == 1)  /* interrupted a task, not RTXC or another isr */
   9144					;
   9145					     ?debug  L 2959
   9146	27BA  80 3E 0020r 01		     cmp     byte ptr DGROUP:_isrcnt,1
   9147	27BF  75 26			     jne     short @14@310
   9148					;
   9149					;
   9150					;	{
   9151					;	   if (	(semaput == semaget) &&	(t_expired == 0) )
   9152					;
   9153					     ?debug  L 2962
   9154	27C1  A1 0004r			     mov     ax,word ptr DGROUP:_semaput
   9155	27C4  3B 06 0006r		     cmp     ax,word ptr DGROUP:_semaget
   9156	27C8  75 07			     jne     short @14@226
   9157	27CA  80 3E 0021r 00		     cmp     byte ptr DGROUP:t_expired,0
   9158	27CF  74 16			     je	     short @14@310
   9159	27D1			     @14@226:
   9160					;
   9161					;	   {
   9162					;	      return(frame);
   9163					;	   }
   9164					;
   9165					;	   hipritsk->sp	= frame;
   9166					;
   9167					     ?debug  L 2967
   9168	27D1  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
   9169	27D5  8B 56 08			     mov     dx,word ptr [bp+8]
   9170	27D8  8B 46 06			     mov     ax,word ptr [bp+6]
   9171	27DB  89 57 0E			     mov     word ptr [bx+14],dx
   9172	27DE  89 47 0C			     mov     word ptr [bx+12],ax
   9173					;
   9174					;
   9175					;	   ENABLE;
   9176					;
   9177					     ?debug  L 2969
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 162
.\rtxc.asm



   9178	27E1  FB			     sti
   9179					;
   9180					;
   9181					;	   return(postem());
   9182					;
   9183					     ?debug  L 2971
   9184	27E2  E8 000A			     call    near ptr postem
   9185	27E5  5D			     pop     bp
   9186	27E6  CB			     ret
   9187	27E7			     @14@310:
   9188	27E7  8B 56 08			     mov     dx,word ptr [bp+8]
   9189	27EA  8B 46 06			     mov     ax,word ptr [bp+6]
   9190					;
   9191					;	}
   9192					;	else /*	return to rtxc or isr, postem()	will be	performed later	*/
   9193					;	{
   9194					;	   return(frame); /* return to rtxc or isr */
   9195					;	}
   9196					;    }
   9197					;
   9198					     ?debug  L 2977
   9199	27ED  5D			     pop     bp
   9200	27EE  CB			     ret
   9201					     ?debug  C E6056672616D651F0A060000000473656D61040A+
   9202					     ?debug  C 0A000000
   9203					     ?debug  E
   9204					     ?debug  E
   9205	27EF			     _KS_ISRexit     endp
   9206					;
   9207					;    static FRAME *postem(void)	/* returns with	interrupts disabled */
   9208					;
   9209					     ?debug  L 2980
   9210					     assume  cs:RTXC_TEXT,ds:DGROUP
   9211	27EF			     postem  proc    near
   9212					     ?debug  B
   9213	27EF  55			     push    bp
   9214	27F0  8B EC			     mov     bp,sp
   9215	27F2  83 EC 2C			     sub     sp,44
   9216	27F5			     @15@30:
   9217					     ?debug  B
   9218					;
   9219					;    /************************/
   9220					;    {
   9221					;	TICKS tcnt, xx;
   9222					;	SEMA sema;
   9223					;	TASK task;
   9224					;	SSTATE near *sema_ptr;
   9225					;	TCB near *ptcb,	near *prev;
   9226					;	KSNUM ks_stk *p2a;
   9227					;	CLKBLK ks_clk *pclkblk;
   9228					;    #ifdef HAS_WAITM /* { */
   9229					;	const SEMA *list;
   9230					;    #endif /* } HAS_WAITM */
   9231					;    #ifdef RESOURCE_TIMEOUTS /* { */
   9232					;	KSNUM ks_stk *p2;
   9233					;    #ifdef PRIORITY_INVERSION /* { */
   9234					;	 RESOURCE resource;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 163
.\rtxc.asm



   9235					;	 RHEADER near *prh;
   9236					;	 PRIORITY priority;
   9237					;    #endif /* } PRIORITY_INVERSION */
   9238					;    #endif /* } RESOURCE_TIMEOUTS */
   9239					;
   9240					;	for(;;)
   9241					;	{
   9242					;	   ENABLE;
   9243					;
   9244					     ?debug  L 3004
   9245	27F5  FB			     sti
   9246					;
   9247					;
   9248					;	   if (t_expired) /* if	timer expired with last	clock interrupt	... */
   9249					;
   9250					     ?debug  L 3006
   9251	27F6  80 3E 0021r 00		     cmp     byte ptr DGROUP:t_expired,0
   9252	27FB  75 03			     jne     @@49
   9253	27FD  E9 026D			     jmp     @15@1374
   9254	2800			     @@49:
   9255					;
   9256					;	   {
   9257					;
   9258					;	      DISABLE;
   9259					;
   9260					     ?debug  L 3009
   9261	2800  FA			     cli
   9262	2801  90			     nop
   9263					;
   9264					;	      tcnt = rtctick; /* local copy of rtctick */
   9265					;
   9266					     ?debug  L 3010
   9267	2802  8B 16 000Er		     mov     dx,word ptr DGROUP:_rtctick+2
   9268	2806  A1 000Cr			     mov     ax,word ptr DGROUP:_rtctick
   9269	2809  89 56 FE			     mov     word ptr [bp-2],dx
   9270	280C  89 46 FC			     mov     word ptr [bp-4],ax
   9271					;
   9272					;	      ENABLE;
   9273					;
   9274					     ?debug  L 3011
   9275	280F  FB			     sti
   9276	2810  E9 01DD			     jmp     @15@1094
   9277	2813			     @15@226:
   9278					;
   9279					;
   9280					;    /*
   9281					;     *	xx is used in the following statement because some compilers can't
   9282					;     *	properly handle	the arithmetic when negative values are	involved
   9283					;     */
   9284					;	      while ( (clkqptr != NULLCLK) && ((xx = tcnt-clkqptr->remain) >= 0) )
   9285					;	      {
   9286					;		 pclkblk = clkqptr; /* save address of expired timer */
   9287					;
   9288					     ?debug  L 3019
   9289	2813  8B 16 001Ar		     mov     dx,word ptr DGROUP:_clkqptr+2
   9290	2817  A1 0018r			     mov     ax,word ptr DGROUP:_clkqptr
   9291	281A  89 56 E8			     mov     word ptr [bp-24],dx
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 164
.\rtxc.asm



   9292	281D  89 46 E6			     mov     word ptr [bp-26],ax
   9293					;
   9294					;		 xx++;		    /* bumped here to eliminate	compiler warning */
   9295					;
   9296					     ?debug  L 3020
   9297	2820  83 46 F8 01		     add     word ptr [bp-8],1
   9298	2824  83 56 FA 00		     adc     word ptr [bp-6],0
   9299					;
   9300					;
   9301					;		 DISABLE;
   9302					;
   9303					     ?debug  L 3022
   9304	2828  FA			     cli
   9305	2829  90			     nop
   9306					;
   9307					;		 /* unlink expired timer with interrupts disabled */
   9308					;		 if ( (clkqptr = clkqptr->flink) != NULLCLK)
   9309					;
   9310					     ?debug  L 3024
   9311	282A  C4 1E 0018r		     les     bx,dword ptr DGROUP:_clkqptr
   9312	282E  26: 8B 57	02		     mov     dx,word ptr es:[bx+2]
   9313	2832  26: 8B 07			     mov     ax,word ptr es:[bx]
   9314	2835  89 16 001Ar		     mov     word ptr DGROUP:_clkqptr+2,dx
   9315	2839  A3 0018r			     mov     word ptr DGROUP:_clkqptr,ax
   9316	283C  0B C2			     or	     ax,dx
   9317	283E  74 0E			     je	     short @15@366
   9318					;
   9319					;		     clkqptr->blink = (CLKBLK ks_clk *)&clkqptr;
   9320					;
   9321					     ?debug  L 3025
   9322	2840  C4 1E 0018r		     les     bx,dword ptr DGROUP:_clkqptr
   9323	2844  26: 8C 5F	06		     mov     word ptr es:[bx+6],ds
   9324	2848  26: C7 47	04 0018r	     mov     word ptr es:[bx+4],offset DGROUP:_clkqptr
   9325	284E			     @15@366:
   9326					;
   9327					;		 ENABLE;
   9328					;
   9329					     ?debug  L 3026
   9330	284E  FB			     sti
   9331					;
   9332					;
   9333					;		 pclkblk->state	= TIMER_DONE;
   9334					;
   9335					     ?debug  L 3028
   9336	284F  C4 5E E6			     les     bx,dword ptr [bp-26]
   9337	2852  26: C6 47	12 00		     mov     byte ptr es:[bx+18],0
   9338					;
   9339					;
   9340					;		 switch(pclkblk->objtype)
   9341					;
   9342					     ?debug  L 3030
   9343	2857  26: 8B 5F	14		     mov     bx,word ptr es:[bx+20]
   9344	285B  83 FB 06			     cmp     bx,6
   9345	285E  76 03			     jbe     @@50
   9346	2860  E9 018D			     jmp     @15@1094
   9347	2863			     @@50:
   9348	2863  03 DB			     add     bx,bx
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 165
.\rtxc.asm



   9349	2865  2E: FF A7	2C09r		     jmp     word ptr cs:@15@C2274[bx]
   9350	286A			     @15@506:
   9351					;
   9352					;		 {
   9353					;		    case TIMER_OBJ:
   9354					;			  SIGNAL(pclkblk->objid); /* put semaphore in signal list */
   9355					;
   9356					     ?debug  L 3033
   9357	286A  FA			     cli
   9358	286B  90			     nop
   9359	286C  C4 5E E6			     les     bx,dword ptr [bp-26]
   9360	286F  26: 8B 47	16		     mov     ax,word ptr es:[bx+22]
   9361	2873  8B 1E 0004r		     mov     bx,word ptr DGROUP:_semaput
   9362	2877  89 07			     mov     word ptr [bx],ax
   9363	2879  83 06 0004r 02		     add     word ptr DGROUP:_semaput,2
   9364	287E  FB			     sti
   9365					;
   9366					;
   9367					;		       if (pclkblk->recycle)	     /*	if timer is cyclic */
   9368					;
   9369					     ?debug  L 3035
   9370	287F  C4 5E E6			     les     bx,dword ptr [bp-26]
   9371	2882  26: 8B 47	0C		     mov     ax,word ptr es:[bx+12]
   9372	2886  26: 0B 47	0E		     or	     ax,word ptr es:[bx+14]
   9373	288A  75 03			     jne     @@51
   9374	288C  E9 0161			     jmp     @15@1094
   9375	288F			     @@51:
   9376					;
   9377					;		       {
   9378					;			  pclkblk->remain = pclkblk->recycle; /* reset counts */
   9379					;
   9380					     ?debug  L 3037
   9381	288F  26: 8B 57	0E		     mov     dx,word ptr es:[bx+14]
   9382	2893  26: 8B 47	0C		     mov     ax,word ptr es:[bx+12]
   9383	2897  26: 89 57	0A		     mov     word ptr es:[bx+10],dx
   9384	289B  26: 89 47	08		     mov     word ptr es:[bx+8],ax
   9385					;
   9386					;
   9387					;			  /* insert clk	timer */
   9388					;			  insert_timer(pclkblk);
   9389					;
   9390					     ?debug  L 3040
   9391	289F  FF 76 E8			     push    word ptr [bp-24]
   9392	28A2  53			     push    bx
   9393	28A3  E8 044E			     call    near ptr insert_timer
   9394	28A6  83 C4 04			     add     sp,4
   9395	28A9  E9 0144			     jmp     @15@1094
   9396	28AC			     @15@674:
   9397					;
   9398					;		       }
   9399					;		       break;
   9400					;
   9401					;		    case DELAY_OBJ:
   9402					;		       ptcb = &rtxtcb[pclkblk->task];
   9403					;
   9404					     ?debug  L 3045
   9405	28AC  C4 5E E6			     les     bx,dword ptr [bp-26]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 166
.\rtxc.asm



   9406	28AF  26: 8B 47	10		     mov     ax,word ptr es:[bx+16]
   9407	28B3  6B C0 28			     imul    ax,ax,40
   9408	28B6  05 0000e			     add     ax,offset DGROUP:_rtxtcb
   9409	28B9  89 46 F0			     mov     word ptr [bp-16],ax
   9410					;
   9411					;
   9412					;		       ptcb->pclkblk = NULLCLK;
   9413					;
   9414					     ?debug  L 3047
   9415	28BC  8B 5E F0			     mov     bx,word ptr [bp-16]
   9416	28BF  C7 47 06 0000		     mov     word ptr [bx+6],0
   9417	28C4  C7 47 04 0000		     mov     word ptr [bx+4],0
   9418					;
   9419					;
   9420					;		       if ( (ptcb->status &= ~DELAY_WAIT) == READY)
   9421					;
   9422					     ?debug  L 3049
   9423	28C9  83 67 10 FB		     and     word ptr [bx+16],-5
   9424	28CD  8B 47 10			     mov     ax,word ptr [bx+16]
   9425	28D0  0B C0			     or	     ax,ax
   9426	28D2  74 03			     je	     @@52
   9427	28D4  E9 0119			     jmp     @15@1094
   9428	28D7			     @@52:
   9429	28D7  EB 3A			     jmp     short @15@758
   9430	28D9			     @15@730:
   9431					;
   9432					;		       {
   9433					;			  /* insert task into insert list */
   9434					;			  ptcb->flink =	nsrttcb;
   9435					;			  nsrttcb = ptcb;
   9436					;		       }
   9437					;		       break;
   9438					;
   9439					;    #ifdef SEMAPHORE_TIMEOUTS /* { */
   9440					;		    case SEMAPHORE_OBJ:	/* KS_waitt() and KS_sendt() */
   9441					;		       semat[pclkblk->objid] = SEMA_PENDING;
   9442					;
   9443					     ?debug  L 3059
   9444	28D9  C4 5E E6			     les     bx,dword ptr [bp-26]
   9445	28DC  26: 8B 5F	16		     mov     bx,word ptr es:[bx+22]
   9446	28E0  03 DB			     add     bx,bx
   9447	28E2  C7 87 0000e FFFF		     mov     word ptr DGROUP:_semat[bx],-1
   9448					;
   9449					;
   9450					;		       ptcb = &rtxtcb[pclkblk->task];
   9451					;
   9452					     ?debug  L 3061
   9453	28E8  8B 5E E6			     mov     bx,word ptr [bp-26]
   9454	28EB  26: 8B 47	10		     mov     ax,word ptr es:[bx+16]
   9455	28EF  6B C0 28			     imul    ax,ax,40
   9456	28F2  05 0000e			     add     ax,offset DGROUP:_rtxtcb
   9457	28F5  89 46 F0			     mov     word ptr [bp-16],ax
   9458					;
   9459					;
   9460					;		       ptcb->pclkblk = NULLCLK;
   9461					;
   9462					     ?debug  L 3063
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 167
.\rtxc.asm



   9463	28F8  8B 5E F0			     mov     bx,word ptr [bp-16]
   9464	28FB  C7 47 06 0000		     mov     word ptr [bx+6],0
   9465	2900  C7 47 04 0000		     mov     word ptr [bx+4],0
   9466					;
   9467					;
   9468					;		       if ( (ptcb->status &= ~SEMAPHORE_WAIT) == READY)
   9469					;
   9470					     ?debug  L 3065
   9471	2905  83 67 10 BF		     and     word ptr [bx+16],-65
   9472	2909  8B 47 10			     mov     ax,word ptr [bx+16]
   9473	290C  0B C0			     or	     ax,ax
   9474	290E  74 03			     je	     @@53
   9475	2910  E9 00DD			     jmp     @15@1094
   9476	2913			     @@53:
   9477	2913			     @15@758:
   9478					;
   9479					;		       {
   9480					;			  /* insert task into insert list */
   9481					;			  ptcb->flink =	nsrttcb;
   9482					;
   9483					     ?debug  L 3068
   9484	2913  8B 5E F0			     mov     bx,word ptr [bp-16]
   9485	2916  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
   9486	2919  89 07			     mov     word ptr [bx],ax
   9487					;
   9488					;			  nsrttcb = ptcb;
   9489					;
   9490					     ?debug  L 3069
   9491	291B  8B 46 F0			     mov     ax,word ptr [bp-16]
   9492	291E  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
   9493	2921  E9 00CC			     jmp     @15@1094
   9494	2924			     @15@786:
   9495					;
   9496					;		       }
   9497					;		       break;
   9498					;    #endif /* } SEMAPHORE_TIMEOUTS */
   9499					;
   9500					;    #ifdef QUEUE_TIMEOUTS /* {	*/
   9501					;		    case QUEUE_OBJ:	/* KS_enqueuet() and KS_dequeuet() */
   9502					;		       /* fall into common code	*/
   9503					;    #endif /* } QUEUE_TIMEOUTS	*/
   9504					;
   9505					;    #ifdef PARTITION_TIMEOUTS /* { */
   9506					;		    case PARTITION_OBJ:	/* KS_alloct() */
   9507					;		       /* fall into common code	*/
   9508					;    #endif /* } PARTITION_TIMEOUTS */
   9509					;
   9510					;    #ifdef RESOURCE_TIMEOUTS /* { */
   9511					;		    case RESOURCE_OBJ:	/* KS_lockt() */
   9512					;		       /* fall into common code	*/
   9513					;    #endif /* } RESOURCE_TIMEOUTS */
   9514					;
   9515					;    #ifdef MAILBOX_TIMEOUTS /*	{ */
   9516					;		    case MAILBOX_OBJ:	/* KS_receivet() */
   9517					;		       /* fall into common code	*/
   9518					;    #endif /* } MAILBOX_TIMEOUTS */
   9519					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 168
.\rtxc.asm



   9520					;    #if defined(MAILBOX_TIMEOUTS)   ||	\
   9521					;	 defined(PARTITION_TIMEOUTS) ||	\
   9522					;	 defined(QUEUE_TIMEOUTS)     ||	\
   9523					;	 defined(RESOURCE_TIMEOUTS) /* { */
   9524					;		       /* common code */
   9525					;		       ptcb = &rtxtcb[pclkblk->task];
   9526					;
   9527					     ?debug  L 3099
   9528	2924  C4 5E E6			     les     bx,dword ptr [bp-26]
   9529	2927  26: 8B 47	10		     mov     ax,word ptr es:[bx+16]
   9530	292B  6B C0 28			     imul    ax,ax,40
   9531	292E  05 0000e			     add     ax,offset DGROUP:_rtxtcb
   9532	2931  89 46 F0			     mov     word ptr [bp-16],ax
   9533					;
   9534					;
   9535					;    #ifdef RESOURCE_TIMEOUTS /* { */
   9536					;		       if (pclkblk->objtype == RESOURCE_OBJ)
   9537					;
   9538					     ?debug  L 3102
   9539	2934  26: 83 7F	14 04		     cmp     word ptr es:[bx+20],4
   9540	2939  75 76			     jne     short @15@982
   9541					;
   9542					;		       {
   9543					;			  /* mark KS_lockt() failure */
   9544					;			  p2 = ((FRAME ks_stk *)(ptcb->sp))->pksnum;
   9545					;
   9546					     ?debug  L 3105
   9547	293B  8B 5E F0			     mov     bx,word ptr [bp-16]
   9548	293E  C4 5F 0C			     les     bx,dword ptr [bx+12]
   9549	2941  26: 8B 57	0E		     mov     dx,word ptr es:[bx+14]
   9550	2945  26: 8B 47	0C		     mov     ax,word ptr es:[bx+12]
   9551	2949  89 56 E0			     mov     word ptr [bp-32],dx
   9552	294C  89 46 DE			     mov     word ptr [bp-34],ax
   9553					;
   9554					;			  ((struct larg	ks_stk *)p2)->ksrc = RC_TIMEOUT;
   9555					;
   9556					     ?debug  L 3106
   9557	294F  C4 5E DE			     les     bx,dword ptr [bp-34]
   9558	2952  26: C7 47	02 0005		     mov     word ptr es:[bx+2],5
   9559					;
   9560					;
   9561					;    #ifdef PRIORITY_INVERSION /* { */
   9562					;			  resource = ((struct larg ks_stk *)p2)->resource;
   9563					;
   9564					     ?debug  L 3109
   9565	2958  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
   9566	295C  89 46 DC			     mov     word ptr [bp-36],ax
   9567					;
   9568					;			  prh =	&rheader[resource];
   9569					;
   9570					     ?debug  L 3110
   9571	295F  6B C0 0C			     imul    ax,ax,12
   9572	2962  05 0000e			     add     ax,offset DGROUP:_rheader
   9573	2965  89 46 DA			     mov     word ptr [bp-38],ax
   9574					;
   9575					;
   9576					;			  /* if	task that owns resource	is priority inverted */
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 169
.\rtxc.asm



   9577					;			  if (prh->priority != (PRIORITY)0)
   9578					;
   9579					     ?debug  L 3113
   9580	2968  8B 5E DA			     mov     bx,word ptr [bp-38]
   9581	296B  83 7F 08 00		     cmp     word ptr [bx+8],0
   9582	296F  74 40			     je	     short @15@982
   9583					;
   9584					;			  {
   9585					;			     /*
   9586					;			      *	then determine if the task was inverted	because
   9587					;			      *	of the lockt() that just timed-out. If so, then
   9588					;			      *	determine what priority	to change to.  The new
   9589					;			      *	priority will be either	the original or	that of
   9590					;			      *	the next task waiting on the resource (if any).
   9591					;			     */
   9592					;
   9593					;			     if	(prh->waiters == ptcb)
   9594					;
   9595					     ?debug  L 3123
   9596	2971  8B 47 04			     mov     ax,word ptr [bx+4]
   9597	2974  3B 46 F0			     cmp     ax,word ptr [bp-16]
   9598	2977  75 38			     jne     short @15@982
   9599					;
   9600					;			     {
   9601					;				if (prh->waiters->flink	!= NULLTCB)
   9602					;
   9603					     ?debug  L 3125
   9604	2979  8B 5F 04			     mov     bx,word ptr [bx+4]
   9605	297C  83 3F 00			     cmp     word ptr [bx],0
   9606	297F  74 19			     je	     short @15@926
   9607					;
   9608					;				{
   9609					;				   priority = prh->waiters->flink->priority;
   9610					;
   9611					     ?debug  L 3127
   9612	2981  8B 5E DA			     mov     bx,word ptr [bp-38]
   9613	2984  8B 5F 04			     mov     bx,word ptr [bx+4]
   9614	2987  8B 1F			     mov     bx,word ptr [bx]
   9615	2989  8B 47 0A			     mov     ax,word ptr [bx+10]
   9616	298C  89 46 D8			     mov     word ptr [bp-40],ax
   9617					;
   9618					;				   if (priority	> prh->priority)
   9619					;
   9620					     ?debug  L 3128
   9621	298F  8B 5E DA			     mov     bx,word ptr [bp-38]
   9622	2992  8B 47 08			     mov     ax,word ptr [bx+8]
   9623	2995  3B 46 D8			     cmp     ax,word ptr [bp-40]
   9624	2998  7D 09			     jge     short @15@954
   9625	299A			     @15@926:
   9626	299A  8B 5E DA			     mov     bx,word ptr [bp-38]
   9627	299D  8B 47 08			     mov     ax,word ptr [bx+8]
   9628	29A0  89 46 D8			     mov     word ptr [bp-40],ax
   9629	29A3			     @15@954:
   9630					;
   9631					;				      priority = prh->priority;
   9632					;				}
   9633					;				else
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 170
.\rtxc.asm



   9634					;				   priority = prh->priority;
   9635					;
   9636					;				chgpriority(prh->owner,	priority);
   9637					;
   9638					     ?debug  L 3134
   9639	29A3  FF 76 D8			     push    word ptr [bp-40]
   9640	29A6  8B 5E DA			     mov     bx,word ptr [bp-38]
   9641	29A9  FF 37			     push    word ptr [bx]
   9642	29AB  E8 0604			     call    near ptr chgpriority
   9643	29AE  83 C4 04			     add     sp,4
   9644	29B1			     @15@982:
   9645					;
   9646					;			     }
   9647					;			  }
   9648					;    #endif /* } PRIORITY_INVERSION */
   9649					;		       }
   9650					;    #endif /* } RESOURCE_TIMEOUTS */
   9651					;
   9652					;		       ptcb->pclkblk = NULLCLK;
   9653					;
   9654					     ?debug  L 3141
   9655	29B1  8B 5E F0			     mov     bx,word ptr [bp-16]
   9656	29B4  C7 47 06 0000		     mov     word ptr [bx+6],0
   9657	29B9  C7 47 04 0000		     mov     word ptr [bx+4],0
   9658					;
   9659					;
   9660					;		       /* remove tcb from 2-way	waiter list */
   9661					;		       if ( (ptcb->blink->flink	= ptcb->flink) != NULLTCB)
   9662					;
   9663					     ?debug  L 3144
   9664	29BE  8B 07			     mov     ax,word ptr [bx]
   9665	29C0  8B 5F 02			     mov     bx,word ptr [bx+2]
   9666	29C3  89 07			     mov     word ptr [bx],ax
   9667	29C5  0B C0			     or	     ax,ax
   9668	29C7  74 0B			     je	     short @15@1038
   9669					;
   9670					;			  ptcb->flink->blink = ptcb->blink;
   9671					;
   9672					     ?debug  L 3145
   9673	29C9  8B 5E F0			     mov     bx,word ptr [bp-16]
   9674	29CC  8B 47 02			     mov     ax,word ptr [bx+2]
   9675	29CF  8B 1F			     mov     bx,word ptr [bx]
   9676	29D1  89 47 02			     mov     word ptr [bx+2],ax
   9677	29D4			     @15@1038:
   9678					;
   9679					;
   9680					;		       if ( (ptcb->status &= ~COMBO_WAIT) == READY)
   9681					;
   9682					     ?debug  L 3147
   9683	29D4  8B 5E F0			     mov     bx,word ptr [bp-16]
   9684	29D7  81 67 10 FF55		     and     word ptr [bx+16],-171
   9685	29DC  8B 47 10			     mov     ax,word ptr [bx+16]
   9686	29DF  0B C0			     or	     ax,ax
   9687	29E1  75 0D			     jne     short @15@1094
   9688					;
   9689					;		       {
   9690					;			  /* insert task into insert list */
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 171
.\rtxc.asm



   9691					;			  ptcb->flink =	nsrttcb;
   9692					;
   9693					     ?debug  L 3150
   9694	29E3  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
   9695	29E6  89 07			     mov     word ptr [bx],ax
   9696					;
   9697					;			  nsrttcb = ptcb;
   9698					;
   9699					     ?debug  L 3151
   9700	29E8  8B 46 F0			     mov     ax,word ptr [bp-16]
   9701	29EB  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
   9702	29EE  EB 00			     jmp     short @15@1094
   9703	29F0			     @15@1094:
   9704					;
   9705					;		       }
   9706					;		       break;
   9707					;    #endif /* } - MAILBOX_ || PARTITION_ || QUEUE_ || RESOURCE_TIMEOUTS */
   9708					;
   9709					;		    default: /*	serious	trouble	here - undefined type */
   9710					;		       break;
   9711					;
   9712					     ?debug  L 3157
   9713					     ?debug  L 3017
   9714	29F0  A1 0018r			     mov     ax,word ptr DGROUP:_clkqptr
   9715	29F3  0B 06 001Ar		     or	     ax,word ptr DGROUP:_clkqptr+2
   9716	29F7  74 28			     je	     short @15@1206
   9717	29F9  C4 1E 0018r		     les     bx,dword ptr DGROUP:_clkqptr
   9718	29FD  8B 56 FE			     mov     dx,word ptr [bp-2]
   9719	2A00  8B 46 FC			     mov     ax,word ptr [bp-4]
   9720	2A03  26: 2B 47	08		     sub     ax,word ptr es:[bx+8]
   9721	2A07  26: 1B 57	0A		     sbb     dx,word ptr es:[bx+10]
   9722	2A0B  89 56 FA			     mov     word ptr [bp-6],dx
   9723	2A0E  89 46 F8			     mov     word ptr [bp-8],ax
   9724	2A11  0B D2			     or	     dx,dx
   9725	2A13  7E 03			     jle     @@54
   9726	2A15  E9 FDFB			     jmp     @15@226
   9727	2A18			     @@54:
   9728	2A18  7C 07			     jl	     short @15@1206
   9729	2A1A  0B C0			     or	     ax,ax
   9730	2A1C  72 03			     jb	     @@55
   9731	2A1E  E9 FDF2			     jmp     @15@226
   9732	2A21			     @@55:
   9733	2A21			     @15@1206:
   9734					;
   9735					;		 }
   9736					;	      }
   9737					;
   9738					;    #ifdef TIME_SLICE /* { */
   9739					;	      if (sliceup != NULLTCB)
   9740					;
   9741					     ?debug  L 3162
   9742	2A21  83 3E 001Cr 00		     cmp     word ptr DGROUP:_sliceup,0
   9743	2A26  74 40			     je	     short @15@1346
   9744					;
   9745					;	      {
   9746					;		 if (sliceup->status ==	READY)
   9747					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 172
.\rtxc.asm



   9748					     ?debug  L 3164
   9749	2A28  8B 1E 001Cr		     mov     bx,word ptr DGROUP:_sliceup
   9750	2A2C  83 7F 10 00		     cmp     word ptr [bx+16],0
   9751	2A30  75 30			     jne     short @15@1318
   9752					;
   9753					;		 {
   9754					;		    if (sliceup->priority == sliceup->flink->priority)
   9755					;
   9756					     ?debug  L 3166
   9757	2A32  8B 47 0A			     mov     ax,word ptr [bx+10]
   9758	2A35  8B 1F			     mov     bx,word ptr [bx]
   9759	2A37  3B 47 0A			     cmp     ax,word ptr [bx+10]
   9760	2A3A  75 26			     jne     short @15@1318
   9761					;
   9762					;		    {
   9763					;		       /* yield	sliceup	to next	task in	list */
   9764					;
   9765					;		       /* unlink tcb */
   9766					;		       sliceup->flink->blink = sliceup->blink;
   9767					;
   9768					     ?debug  L 3171
   9769	2A3C  8B 1E 001Cr		     mov     bx,word ptr DGROUP:_sliceup
   9770	2A40  8B 47 02			     mov     ax,word ptr [bx+2]
   9771	2A43  8B 1F			     mov     bx,word ptr [bx]
   9772	2A45  89 47 02			     mov     word ptr [bx+2],ax
   9773					;
   9774					;		       sliceup->blink->flink = sliceup->flink;
   9775					;
   9776					     ?debug  L 3172
   9777	2A48  8B 1E 001Cr		     mov     bx,word ptr DGROUP:_sliceup
   9778	2A4C  8B 07			     mov     ax,word ptr [bx]
   9779	2A4E  8B 5F 02			     mov     bx,word ptr [bx+2]
   9780	2A51  89 07			     mov     word ptr [bx],ax
   9781					;
   9782					;
   9783					;		       /* re-insert task */
   9784					;		       sliceup->flink =	nsrttcb;
   9785					;
   9786					     ?debug  L 3175
   9787	2A53  8B 1E 001Cr		     mov     bx,word ptr DGROUP:_sliceup
   9788	2A57  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
   9789	2A5A  89 07			     mov     word ptr [bx],ax
   9790					;
   9791					;		       nsrttcb = sliceup;
   9792					;
   9793					     ?debug  L 3176
   9794	2A5C  A1 001Cr			     mov     ax,word ptr DGROUP:_sliceup
   9795	2A5F  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
   9796	2A62			     @15@1318:
   9797					;
   9798					;		    }
   9799					;		 }
   9800					;		 sliceup = NULLTCB;
   9801					;
   9802					     ?debug  L 3179
   9803	2A62  C7 06 001Cr 0000		     mov     word ptr DGROUP:_sliceup,0
   9804	2A68			     @15@1346:
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 173
.\rtxc.asm



   9805					;
   9806					;	      }
   9807					;    #endif /* } TIME_SLICE */
   9808					;
   9809					;	      /* clear expired timer switch */
   9810					;	      t_expired	= 0;
   9811					;
   9812					     ?debug  L 3184
   9813	2A68  C6 06 0021r 00		     mov     byte ptr DGROUP:t_expired,0
   9814	2A6D			     @15@1374:
   9815					;
   9816					;	   }
   9817					;
   9818					;	   DISABLE;
   9819					;
   9820					     ?debug  L 3187
   9821	2A6D  FA			     cli
   9822	2A6E  90			     nop
   9823	2A6F  E9 0104			     jmp     @15@1990
   9824	2A72			     @15@1458:
   9825					;
   9826					;
   9827					;	   /* check to see if any semaphores to	process	*/
   9828					;	   while (semaput != semaget)
   9829					;	   {
   9830					;	      ENABLE;
   9831					;
   9832					     ?debug  L 3192
   9833	2A72  FB			     sti
   9834					;
   9835					;
   9836					;	      sema = *semaget++;     /*	get sema from siglist ... */
   9837					;
   9838					     ?debug  L 3194
   9839	2A73  8B 1E 0006r		     mov     bx,word ptr DGROUP:_semaget
   9840	2A77  8B 07			     mov     ax,word ptr [bx]
   9841	2A79  89 46 F6			     mov     word ptr [bp-10],ax
   9842	2A7C  83 06 0006r 02		     add     word ptr DGROUP:_semaget,2
   9843					;
   9844					;	      sema_ptr = &semat[sema];
   9845					;
   9846					     ?debug  L 3195
   9847	2A81  03 C0			     add     ax,ax
   9848	2A83  05 0000e			     add     ax,offset DGROUP:_semat
   9849	2A86  89 46 F2			     mov     word ptr [bp-14],ax
   9850					;
   9851					;
   9852					;	      if ( (*sema_ptr == SEMA_PENDING) || (*sema_ptr ==	SEMA_DONE) )
   9853					;
   9854					     ?debug  L 3197
   9855	2A89  8B 5E F2			     mov     bx,word ptr [bp-14]
   9856	2A8C  83 3F FF			     cmp     word ptr [bx],-1
   9857	2A8F  74 05			     je	     short @15@1542
   9858	2A91  83 3F 00			     cmp     word ptr [bx],0
   9859	2A94  75 0A			     jne     short @15@1570
   9860	2A96			     @15@1542:
   9861					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 174
.\rtxc.asm



   9862					;		 *sema_ptr = SEMA_DONE;
   9863					;
   9864					     ?debug  L 3198
   9865	2A96  8B 5E F2			     mov     bx,word ptr [bp-14]
   9866	2A99  C7 07 0000		     mov     word ptr [bx],0
   9867	2A9D  E9 00D4			     jmp     @15@1934
   9868	2AA0			     @15@1570:
   9869					;
   9870					;	      else /* sema was found in	wait state */
   9871					;	      {
   9872					;		 task =	*sema_ptr; /* extract waiting task no. */
   9873					;
   9874					     ?debug  L 3201
   9875	2AA0  8B 5E F2			     mov     bx,word ptr [bp-14]
   9876	2AA3  8B 07			     mov     ax,word ptr [bx]
   9877	2AA5  89 46 F4			     mov     word ptr [bp-12],ax
   9878					;
   9879					;
   9880					;		 *sema_ptr = SEMA_PENDING; /* reset semaphore pending */
   9881					;
   9882					     ?debug  L 3203
   9883	2AA8  C7 07 FFFF		     mov     word ptr [bx],-1
   9884					;
   9885					;
   9886					;		 ptcb =	&rtxtcb[task];
   9887					;
   9888					     ?debug  L 3205
   9889	2AAC  6B C0 28			     imul    ax,ax,40
   9890	2AAF  05 0000e			     add     ax,offset DGROUP:_rtxtcb
   9891	2AB2  89 46 F0			     mov     word ptr [bp-16],ax
   9892					;
   9893					;
   9894					;		 p2a = ((FRAME ks_stk *)(ptcb->sp))->pksnum;
   9895					;
   9896					     ?debug  L 3207
   9897	2AB5  8B 5E F0			     mov     bx,word ptr [bp-16]
   9898	2AB8  C4 5F 0C			     les     bx,dword ptr [bx+12]
   9899	2ABB  26: 8B 57	0E		     mov     dx,word ptr es:[bx+14]
   9900	2ABF  26: 8B 47	0C		     mov     ax,word ptr es:[bx+12]
   9901	2AC3  89 56 EC			     mov     word ptr [bp-20],dx
   9902	2AC6  89 46 EA			     mov     word ptr [bp-22],ax
   9903					;
   9904					;
   9905					;    #ifdef SEMAPHORE_TIMEOUTS /* { */
   9906					;		 /* if timer associated	with semaphore */
   9907					;		 if ( ((pclkblk	= ptcb->pclkblk) != NULLCLK) &&
   9908					;
   9909					     ?debug  L 3211
   9910					;
   9911					;		       (pclkblk->objtype == SEMAPHORE_OBJ) &&
   9912					;		       (pclkblk->objid == sema)	)
   9913					;
   9914					     ?debug  L 3213
   9915	2AC9  8B 5E F0			     mov     bx,word ptr [bp-16]
   9916	2ACC  8B 57 06			     mov     dx,word ptr [bx+6]
   9917	2ACF  8B 47 04			     mov     ax,word ptr [bx+4]
   9918	2AD2  89 56 E8			     mov     word ptr [bp-24],dx
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 175
.\rtxc.asm



   9919	2AD5  89 46 E6			     mov     word ptr [bp-26],ax
   9920	2AD8  0B C2			     or	     ax,dx
   9921	2ADA  74 33			     je	     short @15@1682
   9922	2ADC  C4 5E E6			     les     bx,dword ptr [bp-26]
   9923	2ADF  26: 83 7F	14 01		     cmp     word ptr es:[bx+20],1
   9924	2AE4  75 29			     jne     short @15@1682
   9925	2AE6  26: 8B 47	16		     mov     ax,word ptr es:[bx+22]
   9926	2AEA  3B 46 F6			     cmp     ax,word ptr [bp-10]
   9927	2AED  75 20			     jne     short @15@1682
   9928					;
   9929					;		 {
   9930					;		    ((struct sarg ks_stk *)p2a)->ksrc =	RC_GOOD;
   9931					;
   9932					     ?debug  L 3215
   9933	2AEF  C4 5E EA			     les     bx,dword ptr [bp-22]
   9934	2AF2  26: C7 47	02 0000		     mov     word ptr es:[bx+2],0
   9935					;
   9936					;
   9937					;		    unlink_timer(pclkblk);
   9938					;
   9939					     ?debug  L 3217
   9940	2AF8  52			     push    dx
   9941	2AF9  FF 76 E6			     push    word ptr [bp-26]
   9942	2AFC  E8 02B0			     call    near ptr unlink_timer
   9943	2AFF  83 C4 04			     add     sp,4
   9944					;
   9945					;		    ptcb->pclkblk = NULLCLK;
   9946					;
   9947					     ?debug  L 3218
   9948	2B02  8B 5E F0			     mov     bx,word ptr [bp-16]
   9949	2B05  C7 47 06 0000		     mov     word ptr [bx+6],0
   9950	2B0A  C7 47 04 0000		     mov     word ptr [bx+4],0
   9951	2B0F			     @15@1682:
   9952					;
   9953					;		 }
   9954					;    #endif /* } SEMAPHORE_TIMEOUTS */
   9955					;
   9956					;    #ifdef HAS_WAITM /* { */
   9957					;		 if ( ((struct sarg ks_stk *)p2a)->ksnum == RTXC_WAITM)
   9958					;
   9959					     ?debug  L 3223
   9960	2B0F  C4 5E EA			     les     bx,dword ptr [bp-22]
   9961	2B12  26: 83 3F	22		     cmp     word ptr es:[bx],34
   9962	2B16  75 43			     jne     short @15@1878
   9963					;
   9964					;		 {
   9965					;		    /* pass sema back via task stack arg packet	*/
   9966					;		    ((struct sarg ks_stk *)p2a)->sema =	sema;
   9967					;
   9968					     ?debug  L 3226
   9969	2B18  8B 46 F6			     mov     ax,word ptr [bp-10]
   9970	2B1B  26: 89 47	04		     mov     word ptr es:[bx+4],ax
   9971					;
   9972					;
   9973					;		    for	(list =	((struct sargm ks_stk *)p2a)->list;
   9974					;
   9975					     ?debug  L 3228
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 176
.\rtxc.asm



   9976	2B1F  26: 8B 57	08		     mov     dx,word ptr es:[bx+8]
   9977	2B23  26: 8B 47	06		     mov     ax,word ptr es:[bx+6]
   9978	2B27  89 56 E4			     mov     word ptr [bp-28],dx
   9979	2B2A  89 46 E2			     mov     word ptr [bp-30],ax
   9980	2B2D  EB 23			     jmp     short @15@1850
   9981	2B2F			     @15@1738:
   9982					;
   9983					;			 *list != NULLSEMA; list++)
   9984					;		    {
   9985					;		       sema_ptr	= &semat[*list]; /* get	ptr to sema */
   9986					;
   9987					     ?debug  L 3231
   9988	2B2F  C4 5E E2			     les     bx,dword ptr [bp-30]
   9989	2B32  26: 8B 07			     mov     ax,word ptr es:[bx]
   9990	2B35  03 C0			     add     ax,ax
   9991	2B37  05 0000e			     add     ax,offset DGROUP:_semat
   9992	2B3A  89 46 F2			     mov     word ptr [bp-14],ax
   9993					;
   9994					;		       if ( (*sema_ptr != SEMA_PENDING)	&&
   9995					;
   9996					     ?debug  L 3232
   9997					;
   9998					;			    (*sema_ptr != SEMA_DONE) )
   9999					;
  10000					     ?debug  L 3233
  10001	2B3D  8B 5E F2			     mov     bx,word ptr [bp-14]
  10002	2B40  83 3F FF			     cmp     word ptr [bx],-1
  10003	2B43  74 09			     je	     short @15@1822
  10004	2B45  83 3F 00			     cmp     word ptr [bx],0
  10005	2B48  74 04			     je	     short @15@1822
  10006					;
  10007					;			  *sema_ptr = SEMA_PENDING;
  10008					;
  10009					     ?debug  L 3234
  10010	2B4A  C7 07 FFFF		     mov     word ptr [bx],-1
  10011	2B4E			     @15@1822:
  10012					     ?debug  L 3229
  10013	2B4E  83 46 E2 02		     add     word ptr [bp-30],2
  10014	2B52			     @15@1850:
  10015	2B52  C4 5E E2			     les     bx,dword ptr [bp-30]
  10016	2B55  26: 83 3F	00		     cmp     word ptr es:[bx],0
  10017	2B59  75 D4			     jne     short @15@1738
  10018	2B5B			     @15@1878:
  10019					;
  10020					;		    }
  10021					;		 }
  10022					;    #endif /* } HAS_WAITM */
  10023					;
  10024					;		 if ( (ptcb->status &= ~SEMAPHORE_WAIT)	== READY)
  10025					;
  10026					     ?debug  L 3239
  10027	2B5B  8B 5E F0			     mov     bx,word ptr [bp-16]
  10028	2B5E  83 67 10 BF		     and     word ptr [bx+16],-65
  10029	2B62  8B 47 10			     mov     ax,word ptr [bx+16]
  10030	2B65  0B C0			     or	     ax,ax
  10031	2B67  75 0B			     jne     short @15@1934
  10032					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 177
.\rtxc.asm



  10033					;		 {
  10034					;		    ptcb->flink	= nsrttcb;
  10035					;
  10036					     ?debug  L 3241
  10037	2B69  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
  10038	2B6C  89 07			     mov     word ptr [bx],ax
  10039					;
  10040					;		    nsrttcb = ptcb;
  10041					;
  10042					     ?debug  L 3242
  10043	2B6E  8B 46 F0			     mov     ax,word ptr [bp-16]
  10044	2B71  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
  10045	2B74			     @15@1934:
  10046					;
  10047					;		 }
  10048					;	      }
  10049					;
  10050					;	      DISABLE;
  10051					;
  10052					     ?debug  L 3246
  10053	2B74  FA			     cli
  10054	2B75  90			     nop
  10055	2B76			     @15@1990:
  10056					     ?debug  L 3190
  10057	2B76  A1 0004r			     mov     ax,word ptr DGROUP:_semaput
  10058	2B79  3B 06 0006r		     cmp     ax,word ptr DGROUP:_semaget
  10059	2B7D  74 03			     je	     @@56
  10060	2B7F  E9 FEF0			     jmp     @15@1458
  10061	2B82			     @@56:
  10062					;
  10063					;
  10064					;	   }
  10065					;	   /* loop exited with interrupts disabled, all	semaphores processed */
  10066					;
  10067					;	   semaput = semaget = &siglist[0]; /* reset sema signal list empty */
  10068					;
  10069					     ?debug  L 3251
  10070	2B82  B8 0000e			     mov     ax,offset DGROUP:_siglist
  10071	2B85  A3 0006r			     mov     word ptr DGROUP:_semaget,ax
  10072	2B88  A3 0004r			     mov     word ptr DGROUP:_semaput,ax
  10073					;
  10074					;
  10075					;	   ENABLE;
  10076					;
  10077					     ?debug  L 3253
  10078	2B8B  FB			     sti
  10079	2B8C  EB 4C			     jmp     short @15@2242
  10080	2B8E			     @15@2102:
  10081					;
  10082					;
  10083					;	   /* process task list	now with interrupts on */
  10084					;	   while ( (ptcb = nsrttcb) != NULLTCB)
  10085					;	   {
  10086					;	      /* unlink	first tcb in thread and	insert in READY	list */
  10087					;	      nsrttcb =	ptcb->flink;
  10088					;
  10089					     ?debug  L 3259
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 178
.\rtxc.asm



  10090	2B8E  8B 5E F0			     mov     bx,word ptr [bp-16]
  10091	2B91  8B 07			     mov     ax,word ptr [bx]
  10092	2B93  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
  10093					;
  10094					;
  10095					;	      /* insert	ptcb in	priority order in READY	list */
  10096					;	      prev = (TCB near *)&hipritsk;
  10097					;
  10098					     ?debug  L 3262
  10099	2B96  C7 46 EE 0000r		     mov     word ptr [bp-18],offset DGROUP:_hipritsk
  10100	2B9B  8B 47 0A			     mov     ax,word ptr [bx+10]
  10101	2B9E  89 46 D6			     mov     word ptr [bp-42],ax
  10102	2BA1  EB 06			     jmp     short @15@2186
  10103	2BA3			     @15@2158:
  10104					;
  10105					;
  10106					;	      while(ptcb->priority >= prev->flink->priority)
  10107					;		 prev =	prev->flink;
  10108					;
  10109					     ?debug  L 3265
  10110	2BA3  8B 46 D4			     mov     ax,word ptr [bp-44]
  10111	2BA6  89 46 EE			     mov     word ptr [bp-18],ax
  10112	2BA9			     @15@2186:
  10113					     ?debug  L 3264
  10114	2BA9  8B 46 D6			     mov     ax,word ptr [bp-42]
  10115	2BAC  8B 5E EE			     mov     bx,word ptr [bp-18]
  10116	2BAF  8B 1F			     mov     bx,word ptr [bx]
  10117	2BB1  89 5E D4			     mov     word ptr [bp-44],bx
  10118	2BB4  3B 47 0A			     cmp     ax,word ptr [bx+10]
  10119	2BB7  7D EA			     jge     short @15@2158
  10120					;
  10121					;
  10122					;	      ptcb->flink = prev->flink;
  10123					;
  10124					     ?debug  L 3267
  10125	2BB9  8B 46 D4			     mov     ax,word ptr [bp-44]
  10126	2BBC  8B 5E F0			     mov     bx,word ptr [bp-16]
  10127	2BBF  89 07			     mov     word ptr [bx],ax
  10128					;
  10129					;	      ptcb->blink = prev;
  10130					;
  10131					     ?debug  L 3268
  10132	2BC1  8B 46 EE			     mov     ax,word ptr [bp-18]
  10133	2BC4  89 47 02			     mov     word ptr [bx+2],ax
  10134					;
  10135					;	      prev->flink->blink = ptcb;
  10136					;
  10137					     ?debug  L 3269
  10138	2BC7  8B 5E EE			     mov     bx,word ptr [bp-18]
  10139	2BCA  8B 1F			     mov     bx,word ptr [bx]
  10140	2BCC  89 5E D4			     mov     word ptr [bp-44],bx
  10141	2BCF  8B 46 F0			     mov     ax,word ptr [bp-16]
  10142	2BD2  89 47 02			     mov     word ptr [bx+2],ax
  10143					;
  10144					;	      prev->flink = ptcb;
  10145					;
  10146					     ?debug  L 3270
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 179
.\rtxc.asm



  10147	2BD5  8B 5E EE			     mov     bx,word ptr [bp-18]
  10148	2BD8  89 07			     mov     word ptr [bx],ax
  10149	2BDA			     @15@2242:
  10150					     ?debug  L 3256
  10151	2BDA  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
  10152	2BDD  89 46 F0			     mov     word ptr [bp-16],ax
  10153	2BE0  0B C0			     or	     ax,ax
  10154	2BE2  75 AA			     jne     short @15@2102
  10155					;
  10156					;	   }
  10157					;
  10158					;	   DISABLE;
  10159					;
  10160					     ?debug  L 3273
  10161	2BE4  FA			     cli
  10162	2BE5  90			     nop
  10163					;
  10164					;	   /* check to see if any semaphores were posted while processing tasks	*/
  10165					;	   if (semaput == semaget && t_expired == 0)
  10166					;
  10167					     ?debug  L 3275
  10168	2BE6  A1 0004r			     mov     ax,word ptr DGROUP:_semaput
  10169	2BE9  3B 06 0006r		     cmp     ax,word ptr DGROUP:_semaget
  10170	2BED  74 03			     je	     @@57
  10171	2BEF  E9 FC03			     jmp     @15@30
  10172	2BF2			     @@57:
  10173	2BF2  80 3E 0021r 00		     cmp     byte ptr DGROUP:t_expired,0
  10174	2BF7  74 03			     je	     @@58
  10175	2BF9  E9 FBF9			     jmp     @15@30
  10176	2BFC			     @@58:
  10177					;
  10178					;	      break;	/* if not, then	all done - exit	as fast	as possible */
  10179					;
  10180					     ?debug  L 3276
  10181					;
  10182					;	}
  10183					;
  10184					;    #ifdef FPU	/* { */
  10185					;	if ( (hipritsk->fpumode	== 1) && (fputask != hipritsk) )
  10186					;	{
  10187					;	   /* swap fpu regs */
  10188					;	   fpuswap(fputask->fpregs, hipritsk->fpregs);
  10189					;	   fputask = hipritsk; /* update new user of fpu */
  10190					;	}
  10191					;    #endif /* } FPU */
  10192					;	return(hipritsk->sp); /* exit to hipritsk via tcb.sp */
  10193					;
  10194					     ?debug  L 3287
  10195	2BFC  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
  10196	2C00  8B 57 0E			     mov     dx,word ptr [bx+14]
  10197	2C03  8B 47 0C			     mov     ax,word ptr [bx+12]
  10198					;
  10199					;    }
  10200					;
  10201					     ?debug  L 3288
  10202	2C06  C9			     leave
  10203	2C07  C3			     ret
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 180
.\rtxc.asm



  10204					     ?debug  C E6087072696F726974790402D8FF000003707268+
  10205					     ?debug  C 2702DAFF0000087265736F757263650402DCFF00+
  10206					     ?debug  C 000270322102DEFF0000046C6973743602E2FF00+
  10207					     ?debug  C 000770636C6B626C6B1B02E6FF00000370326121+
  10208					     ?debug  C 02EAFF000004707265761902EEFF000004707463+
  10209					     ?debug  C 621902F0FF00000873656D615F7074723502F2FF+
  10210					     ?debug  C 0000047461736B0402F4FF00000473656D610402+
  10211					     ?debug  C F6FF00000278780602F8FF00000474636E740602+
  10212					     ?debug  C FCFF0000
  10213					     ?debug  E
  10214					     ?debug  E
  10215	2C08			     postem  endp
  10216	2C08  01*(??)			     db	     1 dup (?)
  10217	2C09			     @15@C2274	     label   word
  10218	2C09  28ACr			     dw	     @15@674
  10219	2C0B  28D9r			     dw	     @15@730
  10220	2C0D  2924r			     dw	     @15@786
  10221	2C0F  2924r			     dw	     @15@786
  10222	2C11  2924r			     dw	     @15@786
  10223	2C13  2924r			     dw	     @15@786
  10224	2C15  286Ar			     dw	     @15@506
  10225					;
  10226					;    static CLKBLK ks_clk *get_clkblk(void)
  10227					;
  10228					     ?debug  L 3291
  10229					     assume  cs:RTXC_TEXT,ds:DGROUP
  10230	2C17			     get_clkblk	     proc    near
  10231					     ?debug  B
  10232	2C17  55			     push    bp
  10233	2C18  8B EC			     mov     bp,sp
  10234	2C1A  83 EC 04			     sub     sp,4
  10235					     ?debug  B
  10236					;
  10237					;    /************************/
  10238					;    {
  10239					;	CLKBLK ks_clk *pclkblk;
  10240					;
  10241					;	if ( (pclkblk =	clkqfl)	!= NULLCLK) /* allocate	timer block */
  10242					;
  10243					     ?debug  L 3296
  10244	2C1D  8B 16 0016r		     mov     dx,word ptr DGROUP:_clkqfl+2
  10245	2C21  A1 0014r			     mov     ax,word ptr DGROUP:_clkqfl
  10246	2C24  89 56 FE			     mov     word ptr [bp-2],dx
  10247	2C27  89 46 FC			     mov     word ptr [bp-4],ax
  10248	2C2A  0B C2			     or	     ax,dx
  10249	2C2C  74 16			     je	     short @16@86
  10250					;
  10251					;	{
  10252					;	   clkqfl = pclkblk->flink; /* by removing 1st from free list */
  10253					;
  10254					     ?debug  L 3298
  10255	2C2E  C4 5E FC			     les     bx,dword ptr [bp-4]
  10256	2C31  26: 8B 57	02		     mov     dx,word ptr es:[bx+2]
  10257	2C35  26: 8B 07			     mov     ax,word ptr es:[bx]
  10258	2C38  89 16 0016r		     mov     word ptr DGROUP:_clkqfl+2,dx
  10259	2C3C  A3 0014r			     mov     word ptr DGROUP:_clkqfl,ax
  10260					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 181
.\rtxc.asm



  10261					;	   pclkblk->state = TIMER_DONE;
  10262					;
  10263					     ?debug  L 3299
  10264	2C3F  26: C6 47	12 00		     mov     byte ptr es:[bx+18],0
  10265	2C44			     @16@86:
  10266					;
  10267					;	}
  10268					;	return(pclkblk);
  10269					;
  10270					     ?debug  L 3301
  10271	2C44  8B 56 FE			     mov     dx,word ptr [bp-2]
  10272	2C47  8B 46 FC			     mov     ax,word ptr [bp-4]
  10273					;
  10274					;    }
  10275					;
  10276					     ?debug  L 3302
  10277	2C4A  C9			     leave
  10278	2C4B  C3			     ret
  10279					     ?debug  C E60770636C6B626C6B1B02FCFF0000
  10280					     ?debug  E
  10281					     ?debug  E
  10282	2C4C			     get_clkblk	     endp
  10283					;
  10284					;    int far KSAPI KS_ISRtick(void)
  10285					;
  10286					     ?debug  L 3311
  10287					     assume  cs:RTXC_TEXT,ds:DGROUP
  10288	2C4C			     _KS_ISRtick     proc    far
  10289					     ?debug  B
  10290	2C4C  55			     push    bp
  10291	2C4D  8B EC			     mov     bp,sp
  10292	2C4F  83 EC 04			     sub     sp,4
  10293					     ?debug  B
  10294					;
  10295					;    {
  10296					;	TICKS xx;
  10297					;
  10298					;    #ifdef CBUG /* { */
  10299					;	if (cbugflag) /* no clock ticks	while RTXCbug active */
  10300					;	   return(0);	 /* just return	*/
  10301					;    #endif /* } CBUG */
  10302					;
  10303					;	rtctick++; /* update tick counter */
  10304					;
  10305					     ?debug  L 3320
  10306	2C52  83 06 000Cr 01		     add     word ptr DGROUP:_rtctick,1
  10307	2C57  83 16 000Er 00		     adc     word ptr DGROUP:_rtctick+2,0
  10308					;
  10309					;
  10310					;    #ifdef HAS_INQTIME	/* { */
  10311					;	if (++ratecnt >= clkrate)
  10312					;
  10313					     ?debug  L 3323
  10314	2C5C  FF 06 001Er		     inc     word ptr DGROUP:ratecnt
  10315	2C60  A1 001Er			     mov     ax,word ptr DGROUP:ratecnt
  10316	2C63  3B 06 0000e		     cmp     ax,word ptr DGROUP:_clkrate
  10317	2C67  7C 10			     jl	     short @17@86
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 182
.\rtxc.asm



  10318					;
  10319					;	{
  10320					;	   ratecnt = 0;	/* reset rate counter (0 - CLKRATE-1) */
  10321					;
  10322					     ?debug  L 3325
  10323	2C69  C7 06 001Er 0000		     mov     word ptr DGROUP:ratecnt,0
  10324					;
  10325					;	   rtctime++; /* update	second counter */
  10326					;
  10327					     ?debug  L 3326
  10328	2C6F  83 06 0010r 01		     add     word ptr DGROUP:_rtctime,1
  10329	2C74  83 16 0012r 00		     adc     word ptr DGROUP:_rtctime+2,0
  10330	2C79			     @17@86:
  10331					;
  10332					;	}
  10333					;    #endif /* } HAS_INQTIME */
  10334					;
  10335					;    #ifdef TIME_SLICE /* { */
  10336					;	if (hipritsk->newslice)	/* if time slicing enabled for running task */
  10337					;
  10338					     ?debug  L 3331
  10339	2C79  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
  10340	2C7D  8B 47 20			     mov     ax,word ptr [bx+32]
  10341	2C80  0B 47 22			     or	     ax,word ptr [bx+34]
  10342	2C83  74 24			     je	     short @17@170
  10343					;
  10344					;	{
  10345					;	   if (--hipritsk->tslice == (TICKS)0) /* if time slice	is up */
  10346					;
  10347					     ?debug  L 3333
  10348	2C85  83 6F 1C 01		     sub     word ptr [bx+28],1
  10349	2C89  8B 47 1C			     mov     ax,word ptr [bx+28]
  10350	2C8C  83 5F 1E 00		     sbb     word ptr [bx+30],0
  10351	2C90  8B 57 1E			     mov     dx,word ptr [bx+30]
  10352	2C93  0B C2			     or	     ax,dx
  10353	2C95  75 12			     jne     short @17@170
  10354					;
  10355					;	   {
  10356					;	      sliceup =	hipritsk; /* save tcb of task that timed out */
  10357					;
  10358					     ?debug  L 3335
  10359	2C97  A1 0000r			     mov     ax,word ptr DGROUP:_hipritsk
  10360	2C9A  A3 001Cr			     mov     word ptr DGROUP:_sliceup,ax
  10361					;
  10362					;	      sliceup->tslice =	sliceup->newslice; /* reset next slice amount */
  10363					;
  10364					     ?debug  L 3336
  10365	2C9D  8B 57 22			     mov     dx,word ptr [bx+34]
  10366	2CA0  8B 47 20			     mov     ax,word ptr [bx+32]
  10367	2CA3  89 57 1E			     mov     word ptr [bx+30],dx
  10368	2CA6  89 47 1C			     mov     word ptr [bx+28],ax
  10369	2CA9			     @17@170:
  10370					;
  10371					;	   }
  10372					;	}
  10373					;    #endif /* } TIME_SLICE */
  10374					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 183
.\rtxc.asm



  10375					;    /*
  10376					;     *	xx is used in the following statement because some compilers can't
  10377					;     *	properly handle	the arithmetic when negative values are	involved
  10378					;     */
  10379					;	if ( (clkqptr != NULLCLK) && ((xx = rtctick - clkqptr->remain) >= 0) )
  10380					;
  10381					     ?debug  L 3345
  10382	2CA9  A1 0018r			     mov     ax,word ptr DGROUP:_clkqptr
  10383	2CAC  0B 06 001Ar		     or	     ax,word ptr DGROUP:_clkqptr+2
  10384	2CB0  74 2D			     je	     short @17@338
  10385	2CB2  C4 1E 0018r		     les     bx,dword ptr DGROUP:_clkqptr
  10386	2CB6  8B 16 000Er		     mov     dx,word ptr DGROUP:_rtctick+2
  10387	2CBA  A1 000Cr			     mov     ax,word ptr DGROUP:_rtctick
  10388	2CBD  26: 2B 47	08		     sub     ax,word ptr es:[bx+8]
  10389	2CC1  26: 1B 57	0A		     sbb     dx,word ptr es:[bx+10]
  10390	2CC5  89 56 FE			     mov     word ptr [bp-2],dx
  10391	2CC8  89 46 FC			     mov     word ptr [bp-4],ax
  10392	2CCB  0B D2			     or	     dx,dx
  10393	2CCD  7C 10			     jl	     short @17@338
  10394	2CCF  75 04			     jne     short @17@282
  10395	2CD1  0B C0			     or	     ax,ax
  10396	2CD3  72 0A			     jb	     short @17@338
  10397	2CD5			     @17@282:
  10398					;
  10399					;	{
  10400					;	   xx++;	      /* bumped	here to	eliminate compiler warning */
  10401					;
  10402					     ?debug  L 3347
  10403					;
  10404					;	   t_expired = 1;
  10405					;
  10406					     ?debug  L 3348
  10407	2CD5  C6 06 0021r 01		     mov     byte ptr DGROUP:t_expired,1
  10408					;
  10409					;	   return(1);
  10410					;
  10411					     ?debug  L 3349
  10412	2CDA  B8 0001			     mov     ax,1
  10413	2CDD  C9			     leave
  10414	2CDE  CB			     ret
  10415	2CDF			     @17@338:
  10416					;
  10417					;	}
  10418					;
  10419					;    #ifdef TIME_SLICE /* { */
  10420					;	if (sliceup != (TCB near *)0)
  10421					;
  10422					     ?debug  L 3353
  10423	2CDF  83 3E 001Cr 00		     cmp     word ptr DGROUP:_sliceup,0
  10424	2CE4  74 0A			     je	     short @17@422
  10425					;
  10426					;	{
  10427					;	   t_expired = 1;
  10428					;
  10429					     ?debug  L 3355
  10430	2CE6  C6 06 0021r 01		     mov     byte ptr DGROUP:t_expired,1
  10431					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 184
.\rtxc.asm



  10432					;	   return(1);
  10433					;
  10434					     ?debug  L 3356
  10435	2CEB  B8 0001			     mov     ax,1
  10436	2CEE  C9			     leave
  10437	2CEF  CB			     ret
  10438	2CF0			     @17@422:
  10439					;
  10440					;	}
  10441					;    #endif /* } TIME_SLICE */
  10442					;
  10443					;	return(0);
  10444					;
  10445					     ?debug  L 3360
  10446	2CF0  33 C0			     xor     ax,ax
  10447					;
  10448					;    }
  10449					;
  10450					     ?debug  L 3361
  10451	2CF2  C9			     leave
  10452	2CF3  CB			     ret
  10453					     ?debug  C E60278780602FCFF0000
  10454					     ?debug  E
  10455					     ?debug  E
  10456	2CF4			     _KS_ISRtick     endp
  10457					;
  10458					;    static void insert_timer(CLKBLK ks_clk *pclkblk)
  10459					;
  10460					     ?debug  L 3391
  10461					     assume  cs:RTXC_TEXT,ds:DGROUP
  10462	2CF4			     insert_timer    proc    near
  10463					     ?debug  B
  10464	2CF4  55			     push    bp
  10465	2CF5  8B EC			     mov     bp,sp
  10466	2CF7  83 EC 0C			     sub     sp,12
  10467	2CFA  56			     push    si
  10468					     ?debug  C E60770636C6B626C6B1B0A04000000
  10469					     ?debug  B
  10470					;
  10471					;    /************************/
  10472					;    {
  10473					;	TICKS xx;
  10474					;	CLKBLK ks_clk *lclkptr,	ks_clk *nclkptr;
  10475					;
  10476					;	pclkblk->state = TIMER_ACTIVE;
  10477					;
  10478					     ?debug  L 3397
  10479	2CFB  C4 5E 04			     les     bx,dword ptr [bp+4]
  10480	2CFE  26: C6 47	12 01		     mov     byte ptr es:[bx+18],1
  10481					;
  10482					;
  10483					;	lclkptr	= (CLKBLK ks_clk *)&clkqptr;
  10484					;
  10485					     ?debug  L 3399
  10486	2D03  8C 5E FA			     mov     word ptr [bp-6],ds
  10487	2D06  C7 46 F8 0018r		     mov     word ptr [bp-8],offset DGROUP:_clkqptr
  10488	2D0B  EB 0C			     jmp     short @18@86
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 185
.\rtxc.asm



  10489	2D0D			     @18@58:
  10490					;
  10491					;
  10492					;	/* find	point of insertion */
  10493					;    /*
  10494					;     *	xx is used in the following statement because some compilers can't
  10495					;     *	properly handle	the arithmetic when negative values are	involved
  10496					;     */
  10497					;	while (	((nclkptr = lclkptr->flink) != NULLCLK)	&&
  10498					;		       (pclkblk->remain	>= (xx = nclkptr->remain - rtctick)) )
  10499					;	   lclkptr = nclkptr;
  10500					;
  10501					     ?debug  L 3408
  10502	2D0D  8B 56 F6			     mov     dx,word ptr [bp-10]
  10503	2D10  8B 46 F4			     mov     ax,word ptr [bp-12]
  10504	2D13  89 56 FA			     mov     word ptr [bp-6],dx
  10505	2D16  89 46 F8			     mov     word ptr [bp-8],ax
  10506	2D19			     @18@86:
  10507					     ?debug  L 3406
  10508					     ?debug  L 3407
  10509	2D19  C4 5E F8			     les     bx,dword ptr [bp-8]
  10510	2D1C  26: 8B 57	02		     mov     dx,word ptr es:[bx+2]
  10511	2D20  26: 8B 07			     mov     ax,word ptr es:[bx]
  10512	2D23  89 56 F6			     mov     word ptr [bp-10],dx
  10513	2D26  89 46 F4			     mov     word ptr [bp-12],ax
  10514	2D29  0B C2			     or	     ax,dx
  10515	2D2B  74 2C			     je	     short @18@198
  10516	2D2D  C4 5E 04			     les     bx,dword ptr [bp+4]
  10517	2D30  06			     push    es
  10518	2D31  C4 76 F4			     les     si,dword ptr [bp-12]
  10519	2D34  26: 8B 54	0A		     mov     dx,word ptr es:[si+10]
  10520	2D38  26: 8B 44	08		     mov     ax,word ptr es:[si+8]
  10521	2D3C  2B 06 000Cr		     sub     ax,word ptr DGROUP:_rtctick
  10522	2D40  1B 16 000Er		     sbb     dx,word ptr DGROUP:_rtctick+2
  10523	2D44  89 56 FE			     mov     word ptr [bp-2],dx
  10524	2D47  89 46 FC			     mov     word ptr [bp-4],ax
  10525	2D4A  07			     pop     es
  10526	2D4B  26: 39 57	0A		     cmp     word ptr es:[bx+10],dx
  10527	2D4F  7F BC			     jg	     short @18@58
  10528	2D51  7C 06			     jl	     short @18@198
  10529	2D53  26: 39 47	08		     cmp     word ptr es:[bx+8],ax
  10530	2D57  73 B4			     jae     short @18@58
  10531	2D59			     @18@198:
  10532					;
  10533					;
  10534					;	xx++;		   /* bumped here to eliminate compiler	warning	*/
  10535					;
  10536					     ?debug  L 3410
  10537					;
  10538					;
  10539					;	/* insert timer	between	lptr and nptr */
  10540					;	pclkblk->remain	+= rtctick;
  10541					;
  10542					     ?debug  L 3413
  10543	2D59  C4 5E 04			     les     bx,dword ptr [bp+4]
  10544	2D5C  8B 16 000Er		     mov     dx,word ptr DGROUP:_rtctick+2
  10545	2D60  A1 000Cr			     mov     ax,word ptr DGROUP:_rtctick
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 186
.\rtxc.asm



  10546	2D63  26: 01 47	08		     add     word ptr es:[bx+8],ax
  10547	2D67  26: 11 57	0A		     adc     word ptr es:[bx+10],dx
  10548					;
  10549					;	pclkblk->flink = nclkptr;
  10550					;
  10551					     ?debug  L 3414
  10552	2D6B  8B 56 F6			     mov     dx,word ptr [bp-10]
  10553	2D6E  8B 46 F4			     mov     ax,word ptr [bp-12]
  10554	2D71  26: 89 57	02		     mov     word ptr es:[bx+2],dx
  10555	2D75  26: 89 07			     mov     word ptr es:[bx],ax
  10556					;
  10557					;	pclkblk->blink = lclkptr;
  10558					;
  10559					     ?debug  L 3415
  10560	2D78  8B 56 FA			     mov     dx,word ptr [bp-6]
  10561	2D7B  8B 46 F8			     mov     ax,word ptr [bp-8]
  10562	2D7E  26: 89 57	06		     mov     word ptr es:[bx+6],dx
  10563	2D82  26: 89 47	04		     mov     word ptr es:[bx+4],ax
  10564					;
  10565					;	lclkptr->flink = pclkblk;
  10566					;
  10567					     ?debug  L 3416
  10568	2D86  C4 5E F8			     les     bx,dword ptr [bp-8]
  10569	2D89  8B 56 06			     mov     dx,word ptr [bp+6]
  10570	2D8C  8B 46 04			     mov     ax,word ptr [bp+4]
  10571	2D8F  26: 89 57	02		     mov     word ptr es:[bx+2],dx
  10572	2D93  26: 89 07			     mov     word ptr es:[bx],ax
  10573					;
  10574					;	if (nclkptr != NULLCLK)
  10575					;
  10576					     ?debug  L 3417
  10577	2D96  8B 46 F4			     mov     ax,word ptr [bp-12]
  10578	2D99  0B 46 F6			     or	     ax,word ptr [bp-10]
  10579	2D9C  74 0E			     je	     short @18@254
  10580					;
  10581					;	   nclkptr->blink = pclkblk;
  10582					;
  10583					     ?debug  L 3418
  10584	2D9E  C4 5E F4			     les     bx,dword ptr [bp-12]
  10585	2DA1  8B 46 04			     mov     ax,word ptr [bp+4]
  10586	2DA4  26: 89 57	06		     mov     word ptr es:[bx+6],dx
  10587	2DA8  26: 89 47	04		     mov     word ptr es:[bx+4],ax
  10588	2DAC			     @18@254:
  10589					;
  10590					;    }
  10591					;
  10592					     ?debug  L 3419
  10593	2DAC  5E			     pop     si
  10594	2DAD  C9			     leave
  10595	2DAE  C3			     ret
  10596					     ?debug  C E6076E636C6B7074721B02F4FF0000076C636C6B+
  10597					     ?debug  C 7074721B02F8FF00000278780602FCFF00000770+
  10598					     ?debug  C 636C6B626C6B1B0A04000000
  10599					     ?debug  E
  10600					     ?debug  E
  10601	2DAF			     insert_timer    endp
  10602					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 187
.\rtxc.asm



  10603					;    static void unlink_timer(CLKBLK ks_clk *pclkblk)
  10604					;
  10605					     ?debug  L 3425
  10606					     assume  cs:RTXC_TEXT,ds:DGROUP
  10607	2DAF			     unlink_timer    proc    near
  10608					     ?debug  B
  10609	2DAF  55			     push    bp
  10610	2DB0  8B EC			     mov     bp,sp
  10611					     ?debug  C E60770636C6B626C6B1B0A04000000
  10612					     ?debug  B
  10613					;
  10614					;    /************************/
  10615					;    {
  10616					;	pclkblk->state = TIMER_DONE;  /* mark timer done */
  10617					;
  10618					     ?debug  L 3428
  10619	2DB2  C4 5E 04			     les     bx,dword ptr [bp+4]
  10620	2DB5  26: C6 47	12 00		     mov     byte ptr es:[bx+18],0
  10621					;
  10622					;
  10623					;	DISABLE;
  10624					;
  10625					     ?debug  L 3430
  10626	2DBA  FA			     cli
  10627	2DBB  90			     nop
  10628					;
  10629					;	/* simply remove block from list */
  10630					;	if ( (pclkblk->blink->flink = pclkblk->flink) != NULLCLK)
  10631					;
  10632					     ?debug  L 3432
  10633	2DBC  C4 5E 04			     les     bx,dword ptr [bp+4]
  10634	2DBF  26: 8B 57	02		     mov     dx,word ptr es:[bx+2]
  10635	2DC3  26: 8B 07			     mov     ax,word ptr es:[bx]
  10636	2DC6  26: C4 5F	04		     les     bx,dword ptr es:[bx+4]
  10637	2DCA  26: 89 57	02		     mov     word ptr es:[bx+2],dx
  10638	2DCE  26: 89 07			     mov     word ptr es:[bx],ax
  10639	2DD1  0B C2			     or	     ax,dx
  10640	2DD3  74 16			     je	     short @19@170
  10641					;
  10642					;	{
  10643					;	   pclkblk->flink->blink = pclkblk->blink;
  10644					;
  10645					     ?debug  L 3434
  10646	2DD5  C4 5E 04			     les     bx,dword ptr [bp+4]
  10647	2DD8  26: 8B 57	06		     mov     dx,word ptr es:[bx+6]
  10648	2DDC  26: 8B 47	04		     mov     ax,word ptr es:[bx+4]
  10649	2DE0  26: C4 1F			     les     bx,dword ptr es:[bx]
  10650	2DE3  26: 89 57	06		     mov     word ptr es:[bx+6],dx
  10651	2DE7  26: 89 47	04		     mov     word ptr es:[bx+4],ax
  10652	2DEB			     @19@170:
  10653					;
  10654					;	}
  10655					;	ENABLE;
  10656					;
  10657					     ?debug  L 3436
  10658	2DEB  FB			     sti
  10659					;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 188
.\rtxc.asm



  10660					;    }
  10661					;
  10662					     ?debug  L 3437
  10663	2DEC  5D			     pop     bp
  10664	2DED  C3			     ret
  10665					     ?debug  C E60770636C6B626C6B1B0A04000000
  10666					     ?debug  E
  10667					     ?debug  E
  10668	2DEE			     unlink_timer    endp
  10669					;
  10670					;    static void porder(TCB near *prev)
  10671					;
  10672					     ?debug  L 3451
  10673					     assume  cs:RTXC_TEXT,ds:DGROUP
  10674	2DEE			     porder  proc    near
  10675					     ?debug  B
  10676	2DEE  55			     push    bp
  10677	2DEF  8B EC			     mov     bp,sp
  10678	2DF1  83 EC 06			     sub     sp,6
  10679					     ?debug  C E60470726576190A04000000
  10680					     ?debug  B
  10681					;
  10682					;    /************************/
  10683					;    {
  10684					;	TCB near *next,	near *save;
  10685					;	PRIORITY priority;
  10686					;
  10687					;	save = hipritsk;
  10688					;
  10689					     ?debug  L 3457
  10690	2DF4  A1 0000r			     mov     ax,word ptr DGROUP:_hipritsk
  10691	2DF7  89 46 FC			     mov     word ptr [bp-4],ax
  10692					;
  10693					;	priority = save->priority;
  10694					;
  10695					     ?debug  L 3458
  10696	2DFA  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
  10697	2DFE  8B 47 0A			     mov     ax,word ptr [bx+10]
  10698	2E01  89 46 FA			     mov     word ptr [bp-6],ax
  10699					;
  10700					;
  10701					;	/* remove task from READY list (it is ALWAYS first in list) */
  10702					;	UNLINK_HIPRITSK();
  10703					;
  10704					     ?debug  L 3461
  10705	2E04  8B 07			     mov     ax,word ptr [bx]
  10706	2E06  A3 0000r			     mov     word ptr DGROUP:_hipritsk,ax
  10707	2E09  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
  10708	2E0D  C7 47 02 0000r		     mov     word ptr [bx+2],offset DGROUP:_hipritsk
  10709	2E12  EB 06			     jmp     short @20@86
  10710	2E14			     @20@58:
  10711					;
  10712					;
  10713					;	/* search and insert in	priority order */
  10714					;	while( ((next =	prev->flink) !=	NULLTCB) &&
  10715					;	       (next->priority <= priority) )
  10716					;	   prev	= next;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 189
.\rtxc.asm



  10717					;
  10718					     ?debug  L 3466
  10719	2E14  8B 46 FE			     mov     ax,word ptr [bp-2]
  10720	2E17  89 46 04			     mov     word ptr [bp+4],ax
  10721	2E1A			     @20@86:
  10722					     ?debug  L 3464
  10723					     ?debug  L 3465
  10724	2E1A  8B 5E 04			     mov     bx,word ptr [bp+4]
  10725	2E1D  8B 07			     mov     ax,word ptr [bx]
  10726	2E1F  89 46 FE			     mov     word ptr [bp-2],ax
  10727	2E22  0B C0			     or	     ax,ax
  10728	2E24  74 0B			     je	     short @20@142
  10729	2E26  8B 5E FE			     mov     bx,word ptr [bp-2]
  10730	2E29  8B 47 0A			     mov     ax,word ptr [bx+10]
  10731	2E2C  3B 46 FA			     cmp     ax,word ptr [bp-6]
  10732	2E2F  7E E3			     jle     short @20@58
  10733	2E31			     @20@142:
  10734					;
  10735					;
  10736					;	prev->flink = save;
  10737					;
  10738					     ?debug  L 3468
  10739	2E31  8B 5E 04			     mov     bx,word ptr [bp+4]
  10740	2E34  8B 46 FC			     mov     ax,word ptr [bp-4]
  10741	2E37  89 07			     mov     word ptr [bx],ax
  10742					;
  10743					;	save->blink = prev;
  10744					;
  10745					     ?debug  L 3469
  10746	2E39  8B 5E FC			     mov     bx,word ptr [bp-4]
  10747	2E3C  8B 46 04			     mov     ax,word ptr [bp+4]
  10748	2E3F  89 47 02			     mov     word ptr [bx+2],ax
  10749					;
  10750					;
  10751					;	if ( (save->flink = next) != NULLTCB)
  10752					;
  10753					     ?debug  L 3471
  10754	2E42  8B 46 FE			     mov     ax,word ptr [bp-2]
  10755	2E45  89 07			     mov     word ptr [bx],ax
  10756	2E47  0B C0			     or	     ax,ax
  10757	2E49  74 09			     je	     short @20@198
  10758					;
  10759					;	   next->blink = save;
  10760					;
  10761					     ?debug  L 3472
  10762	2E4B  8B 5E FE			     mov     bx,word ptr [bp-2]
  10763	2E4E  8B 46 FC			     mov     ax,word ptr [bp-4]
  10764	2E51  89 47 02			     mov     word ptr [bx+2],ax
  10765	2E54			     @20@198:
  10766					;
  10767					;    }
  10768					;
  10769					     ?debug  L 3473
  10770	2E54  C9			     leave
  10771	2E55  C3			     ret
  10772					     ?debug  C E6087072696F726974790402FAFF000004736176+
  10773					     ?debug  C 651902FCFF0000046E6578741902FEFF00000470+
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 190
.\rtxc.asm



  10774					     ?debug  C 726576190A04000000
  10775					     ?debug  E
  10776					     ?debug  E
  10777	2E56			     porder  endp
  10778					;
  10779					;    static void reorder_waiters(TCB near *ptcb)
  10780					;
  10781					     ?debug  L 3480
  10782					     assume  cs:RTXC_TEXT,ds:DGROUP
  10783	2E56			     reorder_waiters proc    near
  10784					     ?debug  B
  10785	2E56  55			     push    bp
  10786	2E57  8B EC			     mov     bp,sp
  10787					     ?debug  C E60470746362190A04000000
  10788					     ?debug  B
  10789					;
  10790					;    {
  10791					;	/*
  10792					;	 *
  10793					;	 * The cases get a little nastier here than with simply	reordering the
  10794					;	 * READY list since there may be no tasks of lower and/or higher priority
  10795					;	 * in the list.	 Each case is handled separately (and optimized	for speed).
  10796					;	 *
  10797					;	*/
  10798					;
  10799					;	/* if task is the first	waiter in the list */
  10800					;	if (ptcb->blink->blink == NULLTCB)
  10801					;
  10802					     ?debug  L 3491
  10803	2E59  8B 5E 04			     mov     bx,word ptr [bp+4]
  10804	2E5C  8B 5F 02			     mov     bx,word ptr [bx+2]
  10805	2E5F  83 7F 02 00		     cmp     word ptr [bx+2],0
  10806	2E63  75 17			     jne     short @21@142
  10807					;
  10808					;	{
  10809					;	   /* if (first	and) also last waiter in list */
  10810					;	   if (ptcb->flink == NULLTCB)
  10811					;
  10812					     ?debug  L 3494
  10813	2E65  8B 5E 04			     mov     bx,word ptr [bp+4]
  10814	2E68  83 3F 00			     cmp     word ptr [bx],0
  10815	2E6B  74 64			     je	     short @21@366
  10816					;
  10817					;	   {
  10818					;	      /* fast return since no shuffling	necessary */
  10819					;	      return;
  10820					;	   }
  10821					;
  10822					;	   /* if (first	and) still higher priority than	next waiter */
  10823					;	   if (ptcb->priority <= ptcb->flink->priority)
  10824					;
  10825					     ?debug  L 3501
  10826	2E6D  8B 5E 04			     mov     bx,word ptr [bp+4]
  10827	2E70  8B 47 0A			     mov     ax,word ptr [bx+10]
  10828	2E73  8B 1F			     mov     bx,word ptr [bx]
  10829	2E75  3B 47 0A			     cmp     ax,word ptr [bx+10]
  10830	2E78  7E 57			     jle     short @21@366
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 191
.\rtxc.asm



  10831	2E7A  EB 4C			     jmp     short @21@338
  10832	2E7C			     @21@142:
  10833					;
  10834					;	   {
  10835					;	      /* fast return since no shuffling	necessary */
  10836					;	      return;
  10837					;	   }
  10838					;
  10839					;	   /* insert by	walking	forward	*/
  10840					;	   fwd_insert(ptcb);
  10841					;	   return;
  10842					;	}
  10843					;
  10844					;	/* if last waiter in list (and not also	first) */
  10845					;	if (ptcb->flink	== NULLTCB)
  10846					;
  10847					     ?debug  L 3513
  10848	2E7C  8B 5E 04			     mov     bx,word ptr [bp+4]
  10849	2E7F  83 3F 00			     cmp     word ptr [bx],0
  10850	2E82  75 10			     jne     short @21@226
  10851					;
  10852					;	{
  10853					;	   /* if (last and) still lower	priority than next to last */
  10854					;	   if (ptcb->blink->priority <=	ptcb->priority)
  10855					;
  10856					     ?debug  L 3516
  10857	2E84  8B 5F 02			     mov     bx,word ptr [bx+2]
  10858	2E87  8B 47 0A			     mov     ax,word ptr [bx+10]
  10859	2E8A  8B 5E 04			     mov     bx,word ptr [bp+4]
  10860	2E8D  3B 47 0A			     cmp     ax,word ptr [bx+10]
  10861	2E90  7E 3F			     jle     short @21@366
  10862	2E92  EB 29			     jmp     short @21@310
  10863	2E94			     @21@226:
  10864					;
  10865					;	   {
  10866					;	      /* fast return since no shuffling	necessary */
  10867					;	      return;
  10868					;	   }
  10869					;
  10870					;	   /* insert by	walking	backwards */
  10871					;	   bwd_insert(ptcb);
  10872					;	   return;
  10873					;	}
  10874					;
  10875					;	/* else	task is	somewhere in middle of list */
  10876					;
  10877					;	/* if relative priorities are unchanged	*/
  10878					;	if ( (ptcb->blink->priority <= ptcb->priority) &&
  10879					;
  10880					     ?debug  L 3530
  10881					;
  10882					;	     (ptcb->priority <=	ptcb->flink->priority) )
  10883					;
  10884					     ?debug  L 3531
  10885	2E94  8B 5E 04			     mov     bx,word ptr [bp+4]
  10886	2E97  8B 5F 02			     mov     bx,word ptr [bx+2]
  10887	2E9A  8B 47 0A			     mov     ax,word ptr [bx+10]
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 192
.\rtxc.asm



  10888	2E9D  8B 5E 04			     mov     bx,word ptr [bp+4]
  10889	2EA0  3B 47 0A			     cmp     ax,word ptr [bx+10]
  10890	2EA3  7F 0A			     jg	     short @21@282
  10891	2EA5  8B 47 0A			     mov     ax,word ptr [bx+10]
  10892	2EA8  8B 1F			     mov     bx,word ptr [bx]
  10893	2EAA  3B 47 0A			     cmp     ax,word ptr [bx+10]
  10894	2EAD  7E 22			     jle     short @21@366
  10895	2EAF			     @21@282:
  10896					;
  10897					;	{
  10898					;	   /* fast return since	no shuffling necessary */
  10899					;	   return;
  10900					;	}
  10901					;
  10902					;	/* if new priority < left-side */
  10903					;	if (ptcb->priority < ptcb->blink->priority)
  10904					;
  10905					     ?debug  L 3538
  10906	2EAF  8B 5E 04			     mov     bx,word ptr [bp+4]
  10907	2EB2  8B 47 0A			     mov     ax,word ptr [bx+10]
  10908	2EB5  8B 5F 02			     mov     bx,word ptr [bx+2]
  10909	2EB8  3B 47 0A			     cmp     ax,word ptr [bx+10]
  10910	2EBB  7D 0B			     jge     short @21@338
  10911	2EBD			     @21@310:
  10912					;
  10913					;	{
  10914					;	   bwd_insert(ptcb);
  10915					;
  10916					     ?debug  L 3540
  10917	2EBD  FF 76 04			     push    word ptr [bp+4]
  10918	2EC0  E8 007E			     call    near ptr bwd_insert
  10919	2EC3  83 C4 02			     add     sp,2
  10920					;
  10921					;	}
  10922					;
  10923					     ?debug  L 3541
  10924	2EC6  5D			     pop     bp
  10925	2EC7  C3			     ret
  10926	2EC8			     @21@338:
  10927	2EC8  FF 76 04			     push    word ptr [bp+4]
  10928	2ECB  E8 0005			     call    near ptr fwd_insert
  10929	2ECE  83 C4 02			     add     sp,2
  10930	2ED1			     @21@366:
  10931					;
  10932					;	else
  10933					;	{
  10934					;	   fwd_insert(ptcb);
  10935					;	}
  10936					;    }
  10937					;
  10938					     ?debug  L 3546
  10939	2ED1  5D			     pop     bp
  10940	2ED2  C3			     ret
  10941					     ?debug  C E60470746362190A04000000
  10942					     ?debug  E
  10943					     ?debug  E
  10944	2ED3			     reorder_waiters endp
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 193
.\rtxc.asm



  10945					;
  10946					;    static void fwd_insert(TCB	near *ptcb)
  10947					;
  10948					     ?debug  L 3553
  10949					     assume  cs:RTXC_TEXT,ds:DGROUP
  10950	2ED3			     fwd_insert	     proc    near
  10951					     ?debug  B
  10952	2ED3  55			     push    bp
  10953	2ED4  8B EC			     mov     bp,sp
  10954	2ED6  83 EC 08			     sub     sp,8
  10955					     ?debug  C E60470746362190A04000000
  10956					     ?debug  B
  10957					;
  10958					;    {
  10959					;	TCB near *prev,	near *next;
  10960					;	PRIORITY priority;
  10961					;
  10962					;	priority = ptcb->priority;
  10963					;
  10964					     ?debug  L 3558
  10965	2ED9  8B 5E 04			     mov     bx,word ptr [bp+4]
  10966	2EDC  8B 47 0A			     mov     ax,word ptr [bx+10]
  10967	2EDF  89 46 FA			     mov     word ptr [bp-6],ax
  10968					;
  10969					;
  10970					;	prev = ptcb->flink;
  10971					;
  10972					     ?debug  L 3560
  10973	2EE2  8B 07			     mov     ax,word ptr [bx]
  10974	2EE4  89 46 F8			     mov     word ptr [bp-8],ax
  10975	2EE7  89 46 FE			     mov     word ptr [bp-2],ax
  10976					;
  10977					;
  10978					;	/* unlink task from respective WAITER list */
  10979					;	ptcb->flink->blink = ptcb->blink;
  10980					;
  10981					     ?debug  L 3563
  10982	2EEA  8B 47 02			     mov     ax,word ptr [bx+2]
  10983	2EED  8B 5E F8			     mov     bx,word ptr [bp-8]
  10984	2EF0  89 47 02			     mov     word ptr [bx+2],ax
  10985					;
  10986					;	ptcb->blink->flink = ptcb->flink;
  10987					;
  10988					     ?debug  L 3564
  10989	2EF3  8B 5E 04			     mov     bx,word ptr [bp+4]
  10990	2EF6  8B 07			     mov     ax,word ptr [bx]
  10991	2EF8  8B 5F 02			     mov     bx,word ptr [bx+2]
  10992	2EFB  89 07			     mov     word ptr [bx],ax
  10993	2EFD  EB 06			     jmp     short @22@86
  10994	2EFF			     @22@58:
  10995					;
  10996					;
  10997					;	while( ((next =	prev->flink) !=	NULLTCB) &&
  10998					;	       (next->priority <= priority) )
  10999					;	   prev	= next;
  11000					;
  11001					     ?debug  L 3568
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 194
.\rtxc.asm



  11002	2EFF  8B 46 FC			     mov     ax,word ptr [bp-4]
  11003	2F02  89 46 FE			     mov     word ptr [bp-2],ax
  11004	2F05			     @22@86:
  11005					     ?debug  L 3566
  11006					     ?debug  L 3567
  11007	2F05  8B 5E FE			     mov     bx,word ptr [bp-2]
  11008	2F08  8B 07			     mov     ax,word ptr [bx]
  11009	2F0A  89 46 FC			     mov     word ptr [bp-4],ax
  11010	2F0D  0B C0			     or	     ax,ax
  11011	2F0F  74 0B			     je	     short @22@142
  11012	2F11  8B 5E FC			     mov     bx,word ptr [bp-4]
  11013	2F14  8B 47 0A			     mov     ax,word ptr [bx+10]
  11014	2F17  3B 46 FA			     cmp     ax,word ptr [bp-6]
  11015	2F1A  7E E3			     jle     short @22@58
  11016	2F1C			     @22@142:
  11017					;
  11018					;
  11019					;	prev->flink = ptcb;
  11020					;
  11021					     ?debug  L 3570
  11022	2F1C  8B 5E FE			     mov     bx,word ptr [bp-2]
  11023	2F1F  8B 46 04			     mov     ax,word ptr [bp+4]
  11024	2F22  89 07			     mov     word ptr [bx],ax
  11025					;
  11026					;	ptcb->blink = prev;
  11027					;
  11028					     ?debug  L 3571
  11029	2F24  8B 5E 04			     mov     bx,word ptr [bp+4]
  11030	2F27  8B 46 FE			     mov     ax,word ptr [bp-2]
  11031	2F2A  89 47 02			     mov     word ptr [bx+2],ax
  11032					;
  11033					;
  11034					;	if ( (ptcb->flink = next) != NULLTCB)
  11035					;
  11036					     ?debug  L 3573
  11037	2F2D  8B 46 FC			     mov     ax,word ptr [bp-4]
  11038	2F30  89 07			     mov     word ptr [bx],ax
  11039	2F32  0B C0			     or	     ax,ax
  11040	2F34  74 09			     je	     short @22@198
  11041					;
  11042					;	   next->blink = ptcb;
  11043					;
  11044					     ?debug  L 3574
  11045	2F36  8B 5E FC			     mov     bx,word ptr [bp-4]
  11046	2F39  8B 46 04			     mov     ax,word ptr [bp+4]
  11047	2F3C  89 47 02			     mov     word ptr [bx+2],ax
  11048	2F3F			     @22@198:
  11049					;
  11050					;    }
  11051					;
  11052					     ?debug  L 3575
  11053	2F3F  C9			     leave
  11054	2F40  C3			     ret
  11055					     ?debug  C E6087072696F726974790402FAFF0000046E6578+
  11056					     ?debug  C 741902FCFF000004707265761902FEFF00000470+
  11057					     ?debug  C 746362190A04000000
  11058					     ?debug  E
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 195
.\rtxc.asm



  11059					     ?debug  E
  11060	2F41			     fwd_insert	     endp
  11061					;
  11062					;    static void bwd_insert(TCB	near *ptcb)
  11063					;
  11064					     ?debug  L 3582
  11065					     assume  cs:RTXC_TEXT,ds:DGROUP
  11066	2F41			     bwd_insert	     proc    near
  11067					     ?debug  B
  11068	2F41  55			     push    bp
  11069	2F42  8B EC			     mov     bp,sp
  11070	2F44  83 EC 06			     sub     sp,6
  11071					     ?debug  C E60470746362190A04000000
  11072					     ?debug  B
  11073					;
  11074					;    {
  11075					;	TCB near *prev,	near *next;
  11076					;	PRIORITY priority;
  11077					;
  11078					;	priority = ptcb->priority;
  11079					;
  11080					     ?debug  L 3587
  11081	2F47  8B 5E 04			     mov     bx,word ptr [bp+4]
  11082	2F4A  8B 47 0A			     mov     ax,word ptr [bx+10]
  11083	2F4D  89 46 FA			     mov     word ptr [bp-6],ax
  11084					;
  11085					;
  11086					;	prev = ptcb->blink;
  11087					;
  11088					     ?debug  L 3589
  11089	2F50  8B 47 02			     mov     ax,word ptr [bx+2]
  11090	2F53  89 46 FE			     mov     word ptr [bp-2],ax
  11091					;
  11092					;
  11093					;	/* unlink task from respective WAITER list */
  11094					;	if ( (ptcb->blink->flink = ptcb->flink)	!= NULLTCB)
  11095					;
  11096					     ?debug  L 3592
  11097	2F56  8B 07			     mov     ax,word ptr [bx]
  11098	2F58  8B 5F 02			     mov     bx,word ptr [bx+2]
  11099	2F5B  89 07			     mov     word ptr [bx],ax
  11100	2F5D  0B C0			     or	     ax,ax
  11101	2F5F  74 0B			     je	     short @23@86
  11102					;
  11103					;		ptcb->flink->blink = ptcb->blink;
  11104					;
  11105					     ?debug  L 3593
  11106	2F61  8B 5E 04			     mov     bx,word ptr [bp+4]
  11107	2F64  8B 47 02			     mov     ax,word ptr [bx+2]
  11108	2F67  8B 1F			     mov     bx,word ptr [bx]
  11109	2F69  89 47 02			     mov     word ptr [bx+2],ax
  11110	2F6C			     @23@86:
  11111					;
  11112					;
  11113					;	for (next = prev->blink;
  11114					;
  11115					     ?debug  L 3595
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 196
.\rtxc.asm



  11116	2F6C  8B 5E FE			     mov     bx,word ptr [bp-2]
  11117	2F6F  EB 09			     jmp     short @23@142
  11118	2F71			     @23@114:
  11119					;
  11120					;	   (next->blink	!= NULLTCB) && (priority < next->priority);
  11121					;	   prev	= next,	next = prev->blink)
  11122					;
  11123					     ?debug  L 3597
  11124	2F71  8B 46 FC			     mov     ax,word ptr [bp-4]
  11125	2F74  89 46 FE			     mov     word ptr [bp-2],ax
  11126	2F77  8B 5E FC			     mov     bx,word ptr [bp-4]
  11127	2F7A			     @23@142:
  11128	2F7A  8B 47 02			     mov     ax,word ptr [bx+2]
  11129	2F7D  89 46 FC			     mov     word ptr [bp-4],ax
  11130					     ?debug  L 3596
  11131	2F80  8B 5E FC			     mov     bx,word ptr [bp-4]
  11132	2F83  83 7F 02 00		     cmp     word ptr [bx+2],0
  11133	2F87  74 08			     je	     short @23@226
  11134	2F89  8B 47 0A			     mov     ax,word ptr [bx+10]
  11135	2F8C  3B 46 FA			     cmp     ax,word ptr [bp-6]
  11136	2F8F  7F E0			     jg	     short @23@114
  11137	2F91			     @23@226:
  11138					;
  11139					;	   ; /*	yes - a	null loop is intended here */
  11140					;
  11141					;	prev->blink = ptcb;
  11142					;
  11143					     ?debug  L 3600
  11144	2F91  8B 5E FE			     mov     bx,word ptr [bp-2]
  11145	2F94  8B 46 04			     mov     ax,word ptr [bp+4]
  11146	2F97  89 47 02			     mov     word ptr [bx+2],ax
  11147					;
  11148					;	ptcb->flink = prev;
  11149					;
  11150					     ?debug  L 3601
  11151	2F9A  8B 5E 04			     mov     bx,word ptr [bp+4]
  11152	2F9D  8B 46 FE			     mov     ax,word ptr [bp-2]
  11153	2FA0  89 07			     mov     word ptr [bx],ax
  11154					;
  11155					;
  11156					;	ptcb->blink = next;
  11157					;
  11158					     ?debug  L 3603
  11159	2FA2  8B 46 FC			     mov     ax,word ptr [bp-4]
  11160	2FA5  89 47 02			     mov     word ptr [bx+2],ax
  11161					;
  11162					;	next->flink = ptcb;
  11163					;
  11164					     ?debug  L 3604
  11165	2FA8  8B 5E FC			     mov     bx,word ptr [bp-4]
  11166	2FAB  8B 46 04			     mov     ax,word ptr [bp+4]
  11167	2FAE  89 07			     mov     word ptr [bx],ax
  11168					;
  11169					;    }
  11170					;
  11171					     ?debug  L 3605
  11172	2FB0  C9			     leave
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 197
.\rtxc.asm



  11173	2FB1  C3			     ret
  11174					     ?debug  C E6087072696F726974790402FAFF0000046E6578+
  11175					     ?debug  C 741902FCFF000004707265761902FEFF00000470+
  11176					     ?debug  C 746362190A04000000
  11177					     ?debug  E
  11178					     ?debug  E
  11179	2FB2			     bwd_insert	     endp
  11180					;
  11181					;    static void chgpriority(TCB near *ptcb, PRIORITY priority)
  11182					;
  11183					     ?debug  L 3613
  11184					     assume  cs:RTXC_TEXT,ds:DGROUP
  11185	2FB2			     chgpriority     proc    near
  11186					     ?debug  B
  11187	2FB2  55			     push    bp
  11188	2FB3  8B EC			     mov     bp,sp
  11189					     ?debug  C E6087072696F72697479040A0600000004707463+
  11190					     ?debug  C 62190A04000000
  11191					     ?debug  B
  11192					;
  11193					;    {
  11194					;	/* set new priority */
  11195					;	ptcb->priority = priority;
  11196					;
  11197					     ?debug  L 3616
  11198	2FB5  8B 5E 04			     mov     bx,word ptr [bp+4]
  11199	2FB8  8B 46 06			     mov     ax,word ptr [bp+6]
  11200	2FBB  89 47 0A			     mov     word ptr [bx+10],ax
  11201					;
  11202					;
  11203					;	/* if current task is changing its own priority	*/
  11204					;	if (hipritsk->task == ptcb->task)
  11205					;
  11206					     ?debug  L 3619
  11207	2FBE  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
  11208	2FC2  8B 47 08			     mov     ax,word ptr [bx+8]
  11209	2FC5  8B 5E 04			     mov     bx,word ptr [bp+4]
  11210	2FC8  3B 47 08			     cmp     ax,word ptr [bx+8]
  11211	2FCB  75 2C			     jne     short @24@114
  11212					;
  11213					;	{
  11214					;	   /* if relative priorities are unchanged */
  11215					;	   if (ptcb->priority <= ptcb->flink->priority)
  11216					;
  11217					     ?debug  L 3622
  11218	2FCD  8B 47 0A			     mov     ax,word ptr [bx+10]
  11219	2FD0  8B 1F			     mov     bx,word ptr [bx]
  11220	2FD2  3B 47 0A			     cmp     ax,word ptr [bx+10]
  11221	2FD5  7E 78			     jle     short @24@282
  11222					;
  11223					;	   {
  11224					;	      /* fast return since no shuffling	necessary */
  11225					;	      return;
  11226					;	   }
  11227					;
  11228					;	   /* remove task from READY list (it is ALWAYS	first in list) */
  11229					;	   UNLINK_HIPRITSK();
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 198
.\rtxc.asm



  11230					;
  11231					     ?debug  L 3629
  11232	2FD7  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
  11233	2FDB  8B 07			     mov     ax,word ptr [bx]
  11234	2FDD  A3 0000r			     mov     word ptr DGROUP:_hipritsk,ax
  11235	2FE0  8B 1E 0000r		     mov     bx,word ptr DGROUP:_hipritsk
  11236	2FE4  C7 47 02 0000r		     mov     word ptr [bx+2],offset DGROUP:_hipritsk
  11237					;
  11238					;
  11239					;	   /* re-insert	task */
  11240					;	   ptcb->flink = nsrttcb;
  11241					;
  11242					     ?debug  L 3632
  11243	2FE9  8B 5E 04			     mov     bx,word ptr [bp+4]
  11244	2FEC  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
  11245	2FEF  89 07			     mov     word ptr [bx],ax
  11246					;
  11247					;	   nsrttcb = ptcb;
  11248					;
  11249					     ?debug  L 3633
  11250	2FF1  8B 46 04			     mov     ax,word ptr [bp+4]
  11251	2FF4  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
  11252	2FF7  5D			     pop     bp
  11253	2FF8  C3			     ret
  11254	2FF9			     @24@114:
  11255					;
  11256					;
  11257					;	   return;
  11258					;	}
  11259					;
  11260					;	/* if task being changed is RUNnable */
  11261					;	if (ptcb->status == READY)
  11262					;
  11263					     ?debug  L 3639
  11264	2FF9  8B 5E 04			     mov     bx,word ptr [bp+4]
  11265	2FFC  83 7F 10 00		     cmp     word ptr [bx+16],0
  11266	3000  75 3D			     jne     short @24@226
  11267					;
  11268					;	{
  11269					;	   /* if relative priorities are unchanged */
  11270					;	   if (	(ptcb->blink->priority <= ptcb->priority) &&
  11271					;
  11272					     ?debug  L 3642
  11273					;
  11274					;		(ptcb->priority	<= ptcb->flink->priority) )
  11275					;
  11276					     ?debug  L 3643
  11277	3002  8B 5F 02			     mov     bx,word ptr [bx+2]
  11278	3005  8B 47 0A			     mov     ax,word ptr [bx+10]
  11279	3008  8B 5E 04			     mov     bx,word ptr [bp+4]
  11280	300B  3B 47 0A			     cmp     ax,word ptr [bx+10]
  11281	300E  7F 0A			     jg	     short @24@198
  11282	3010  8B 47 0A			     mov     ax,word ptr [bx+10]
  11283	3013  8B 1F			     mov     bx,word ptr [bx]
  11284	3015  3B 47 0A			     cmp     ax,word ptr [bx+10]
  11285	3018  7E 35			     jle     short @24@282
  11286	301A			     @24@198:
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 199
.\rtxc.asm



  11287					;
  11288					;	   {
  11289					;	      /* fast return since no shuffling	necessary */
  11290					;	      return;
  11291					;	   }
  11292					;
  11293					;	   /* else unlink task from RUN	list */
  11294					;	   ptcb->flink->blink =	ptcb->blink;
  11295					;
  11296					     ?debug  L 3650
  11297	301A  8B 5E 04			     mov     bx,word ptr [bp+4]
  11298	301D  8B 47 02			     mov     ax,word ptr [bx+2]
  11299	3020  8B 1F			     mov     bx,word ptr [bx]
  11300	3022  89 47 02			     mov     word ptr [bx+2],ax
  11301					;
  11302					;	   ptcb->blink->flink =	ptcb->flink;
  11303					;
  11304					     ?debug  L 3651
  11305	3025  8B 5E 04			     mov     bx,word ptr [bp+4]
  11306	3028  8B 07			     mov     ax,word ptr [bx]
  11307	302A  8B 5F 02			     mov     bx,word ptr [bx+2]
  11308	302D  89 07			     mov     word ptr [bx],ax
  11309					;
  11310					;
  11311					;	   /* re-insert	task */
  11312					;	   ptcb->flink = nsrttcb;
  11313					;
  11314					     ?debug  L 3654
  11315	302F  8B 5E 04			     mov     bx,word ptr [bp+4]
  11316	3032  A1 0002r			     mov     ax,word ptr DGROUP:_nsrttcb
  11317	3035  89 07			     mov     word ptr [bx],ax
  11318					;
  11319					;	   nsrttcb = ptcb;
  11320					;
  11321					     ?debug  L 3655
  11322	3037  8B 46 04			     mov     ax,word ptr [bp+4]
  11323	303A  A3 0002r			     mov     word ptr DGROUP:_nsrttcb,ax
  11324	303D  5D			     pop     bp
  11325	303E  C3			     ret
  11326	303F			     @24@226:
  11327					;
  11328					;
  11329					;	   return;
  11330					;	}
  11331					;
  11332					;    #if defined(MAILBOX_WAITERS)   || \
  11333					;	 defined(PARTITION_WAITERS) || \
  11334					;	 defined(QUEUE_WAITERS)	    || \
  11335					;	 defined(RESOURCE_WAITERS)  /* { */
  11336					;
  11337					;	/* if task being changed is in a WAITER	list */
  11338					;	if (ptcb->status & COMBO_WAIT)
  11339					;
  11340					     ?debug  L 3666
  11341	303F  8B 5E 04			     mov     bx,word ptr [bp+4]
  11342	3042  F6 47 10 AA		     test    byte ptr [bx+16],170
  11343	3046  74 07			     je	     short @24@282
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 200
.\rtxc.asm



  11344					;
  11345					;	{
  11346					;	   reorder_waiters(ptcb);
  11347					;
  11348					     ?debug  L 3668
  11349	3048  53			     push    bx
  11350	3049  E8 FE0A			     call    near ptr reorder_waiters
  11351	304C  83 C4 02			     add     sp,2
  11352	304F			     @24@282:
  11353					;
  11354					;	}
  11355					;    #endif /* } - MAILBOX_ || PARTITION_ || QUEUE_ || RESOURCE_WAITERS	*/
  11356					;
  11357					;	return;
  11358					;    }
  11359					;
  11360					     ?debug  L 3673
  11361	304F  5D			     pop     bp
  11362	3050  C3			     ret
  11363					     ?debug  C E60470746362190A04000000087072696F726974+
  11364					     ?debug  C 79040A06000000
  11365					     ?debug  E
  11366					     ?debug  E
  11367	3051			     chgpriority     endp
  11368					;
  11369					;    static void dn_defpart(PHEADER near *pph, KSNUM ks_stk *p2)
  11370					;
  11371					     ?debug  L 3677
  11372					     assume  cs:RTXC_TEXT,ds:DGROUP
  11373	3051			     dn_defpart	     proc    near
  11374					     ?debug  B
  11375	3051  55			     push    bp
  11376	3052  8B EC			     mov     bp,sp
  11377	3054  83 EC 0A			     sub     sp,10
  11378					     ?debug  C E6027032210A06000000037070682F0A04000000
  11379					     ?debug  B
  11380					;
  11381					;    {
  11382					;	size_t count, blksize;
  11383					;    #ifdef HUGE_PARTITIONS /* { */
  11384					;	char huge * huge * next;
  11385					;    #else /* }	HUGE_PARTITIONS	{ */
  11386					;	char **next;
  11387					;    #endif /* } HUGE_PARTITIONS { */
  11388					;	int j;
  11389					;
  11390					;	pph->addr = ((struct parg ks_stk *)p2)->addr;
  11391					;
  11392					     ?debug  L 3687
  11393	3057  C4 5E 06			     les     bx,dword ptr [bp+6]
  11394	305A  26: 8B 57	18		     mov     dx,word ptr es:[bx+24]
  11395	305E  26: 8B 47	16		     mov     ax,word ptr es:[bx+22]
  11396	3062  8B 5E 04			     mov     bx,word ptr [bp+4]
  11397	3065  89 57 10			     mov     word ptr [bx+16],dx
  11398	3068  89 47 0E			     mov     word ptr [bx+14],ax
  11399					;
  11400					;	blksize	= ((struct parg	ks_stk *)p2)->size;
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 201
.\rtxc.asm



  11401					;
  11402					     ?debug  L 3688
  11403	306B  8B 5E 06			     mov     bx,word ptr [bp+6]
  11404	306E  26: 8B 47	0A		     mov     ax,word ptr es:[bx+10]
  11405	3072  89 46 FC			     mov     word ptr [bp-4],ax
  11406					;
  11407					;	count =	((struct parg ks_stk *)p2)->nblocks;
  11408					;
  11409					     ?debug  L 3689
  11410	3075  26: 8B 47	1A		     mov     ax,word ptr es:[bx+26]
  11411	3079  89 46 FE			     mov     word ptr [bp-2],ax
  11412					;
  11413					;
  11414					;	pph->next = (struct xmap *)pph->addr;
  11415					;
  11416					     ?debug  L 3691
  11417	307C  8B 5E 04			     mov     bx,word ptr [bp+4]
  11418	307F  8B 57 10			     mov     dx,word ptr [bx+16]
  11419	3082  8B 47 0E			     mov     ax,word ptr [bx+14]
  11420	3085  89 57 02			     mov     word ptr [bx+2],dx
  11421	3088  89 07			     mov     word ptr [bx],ax
  11422					;
  11423					;
  11424					;    #ifdef HUGE_PARTITIONS /* { */
  11425					;	next = (char huge * huge *)pph->next;
  11426					;	for (j = 1; j <	count; j++, next = (char huge *	huge *)*next)
  11427					;	   *next = (char huge *)next + blksize;
  11428					;    #else /* }	HUGE_PARTITIONS	{ */
  11429					;	next = (char **)pph->next;
  11430					;
  11431					     ?debug  L 3698
  11432	308A  8B 57 02			     mov     dx,word ptr [bx+2]
  11433	308D  8B 07			     mov     ax,word ptr [bx]
  11434	308F  89 56 FA			     mov     word ptr [bp-6],dx
  11435	3092  89 46 F8			     mov     word ptr [bp-8],ax
  11436					;
  11437					;	for (j = 1; j <	count; j++, next = (char **)*next)
  11438					;
  11439					     ?debug  L 3699
  11440	3095  C7 46 F6 0001		     mov     word ptr [bp-10],1
  11441	309A  EB 23			     jmp     short @25@114
  11442	309C			     @25@58:
  11443					;
  11444					;	   *next = (char *)next	+ blksize;
  11445					;
  11446					     ?debug  L 3700
  11447	309C  8B 56 FA			     mov     dx,word ptr [bp-6]
  11448	309F  8B 46 F8			     mov     ax,word ptr [bp-8]
  11449	30A2  03 46 FC			     add     ax,word ptr [bp-4]
  11450	30A5  C4 5E F8			     les     bx,dword ptr [bp-8]
  11451	30A8  26: 89 57	02		     mov     word ptr es:[bx+2],dx
  11452	30AC  26: 89 07			     mov     word ptr es:[bx],ax
  11453					     ?debug  L 3699
  11454	30AF  FF 46 F6			     inc     word ptr [bp-10]
  11455	30B2  26: 8B 57	02		     mov     dx,word ptr es:[bx+2]
  11456	30B6  26: 8B 07			     mov     ax,word ptr es:[bx]
  11457	30B9  89 56 FA			     mov     word ptr [bp-6],dx
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 202
.\rtxc.asm



  11458	30BC  89 46 F8			     mov     word ptr [bp-8],ax
  11459	30BF			     @25@114:
  11460	30BF  8B 46 F6			     mov     ax,word ptr [bp-10]
  11461	30C2  3B 46 FE			     cmp     ax,word ptr [bp-2]
  11462	30C5  72 D5			     jb	     short @25@58
  11463					;
  11464					;    #endif /* } HUGE_PARTITIONS */
  11465					;
  11466					;	*next =	NULL; /* null last link	*/
  11467					;
  11468					     ?debug  L 3703
  11469	30C7  C4 5E F8			     les     bx,dword ptr [bp-8]
  11470	30CA  26: C7 47	02 0000		     mov     word ptr es:[bx+2],0
  11471	30D0  26: C7 07	0000		     mov     word ptr es:[bx],0
  11472					;
  11473					;	pph->size = blksize;
  11474					;
  11475					     ?debug  L 3704
  11476	30D5  8B 5E 04			     mov     bx,word ptr [bp+4]
  11477	30D8  8B 46 FC			     mov     ax,word ptr [bp-4]
  11478	30DB  89 47 04			     mov     word ptr [bx+4],ax
  11479					;
  11480					;	pph->count = count;
  11481					;
  11482					     ?debug  L 3705
  11483	30DE  8B 46 FE			     mov     ax,word ptr [bp-2]
  11484	30E1  89 47 06			     mov     word ptr [bx+6],ax
  11485					;
  11486					;
  11487					;    #ifdef PARTITION_WAITERS /* { */
  11488					;	pph->waiters = NULLTCB;
  11489					;
  11490					     ?debug  L 3708
  11491	30E4  C7 47 08 0000		     mov     word ptr [bx+8],0
  11492					;
  11493					;	pph->dummy = NULLTCB;
  11494					;
  11495					     ?debug  L 3709
  11496	30E9  C7 47 0A 0000		     mov     word ptr [bx+10],0
  11497					;
  11498					;    #endif /* } PARTITION_WAITERS */
  11499					;
  11500					;    #ifdef CBUG /* { */
  11501					;	pph->cur = 0;
  11502					;	pph->worst = 0;
  11503					;	pph->usage = 0;
  11504					;    #endif /* } CBUG */
  11505					;
  11506					;	return;
  11507					;    }
  11508					;
  11509					     ?debug  L 3719
  11510	30EE  C9			     leave
  11511	30EF  C3			     ret
  11512					     ?debug  C E6016A0402F6FF0000046E6578743902F8FF0000+
  11513					     ?debug  C 07626C6B73697A650A02FCFF000005636F756E74+
  11514					     ?debug  C 0A02FEFF0000037070682F0A0400000002703221+
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 203
.\rtxc.asm



  11515					     ?debug  C 0A06000000
  11516					     ?debug  E
  11517					     ?debug  E
  11518	30F0			     dn_defpart	     endp
  11519	30F0			     RTXC_TEXT	     ends
  11520	0000			     _BSS    segment word public 'BSS'
  11521	0000			     _hipritsk	     label   word
  11522	0000  02*(??)			     db	     2 dup (?)
  11523	0002			     _nsrttcb	     label   word
  11524	0002  02*(??)			     db	     2 dup (?)
  11525	0004			     _semaput	     label   word
  11526	0004  02*(??)			     db	     2 dup (?)
  11527	0006			     _semaget	     label   word
  11528	0006  02*(??)			     db	     2 dup (?)
  11529	0008			     _dtcbfl label   word
  11530	0008  02*(??)			     db	     2 dup (?)
  11531	000A			     _dphfl  label   word
  11532	000A  02*(??)			     db	     2 dup (?)
  11533	000C			     _rtctick	     label   word
  11534	000C  04*(??)			     db	     4 dup (?)
  11535	0010			     _rtctime	     label   word
  11536	0010  04*(??)			     db	     4 dup (?)
  11537	0014			     _clkqfl label   dword
  11538	0014  04*(??)			     db	     4 dup (?)
  11539	0018			     _clkqptr	     label   dword
  11540	0018  04*(??)			     db	     4 dup (?)
  11541	001C			     _sliceup	     label   word
  11542	001C  02*(??)			     db	     2 dup (?)
  11543	001E			     ratecnt label   word
  11544	001E  02*(??)			     db	     2 dup (?)
  11545	0020			     _BSS    ends
  11546	0000			     RTXC5_DATA	     segment para public 'FAR_DATA'
  11547	0000			     _rtctimetick    label   word
  11548	0000  02*(??)			     db	     2 dup (?)
  11549	0002			     RTXC5_DATA	     ends
  11550	0020			     _BSS    segment word public 'BSS'
  11551	0020			     _isrcnt label   byte
  11552	0020  01*(??)			     db	     1 dup (?)
  11553	0021			     t_expired	     label   byte
  11554	0021  01*(??)			     db	     1 dup (?)
  11555					     ?debug  C E9
  11556					     ?debug  C FA0D030000
  11557	0022			     _BSS    ends
  11558	0001			     _DATA   segment word public 'DATA'
  11559	0001			     s@	     label   byte
  11560	0001			     _DATA   ends
  11561	30F0			     RTXC_TEXT	     segment byte public 'CODE'
  11562	30F0			     RTXC_TEXT	     ends
  11563				     _s@     equ     s@
  11564					     public  _init_flags
  11565					     extrn   _memcpy:far
  11566					     extrn   _rtxtcb:word
  11567					     extrn   _rtxktcb:word
  11568					     extrn   _ntasks:word
  11569					     extrn   _dntasks:word
  11570					     extrn   _semat:word
  11571					     extrn   _siglist:word
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 204
.\rtxc.asm



  11572					     extrn   _nsemas:word
  11573					     extrn   _siglistsize:word
  11574					     extrn   _clkq:word
  11575					     extrn   _ntmrs:word
  11576					     extrn   _mheader:word
  11577					     extrn   _nmboxes:word
  11578					     extrn   _pheader:word
  11579					     extrn   _pkheader:word
  11580					     extrn   _nparts:word
  11581					     extrn   _dnparts:word
  11582					     extrn   _qheader:word
  11583					     extrn   _qkheader:word
  11584					     extrn   _nqueues:word
  11585					     extrn   _rheader:word
  11586					     extrn   _nres:word
  11587					     public  _hipritsk
  11588					     public  _nsrttcb
  11589					     public  _semaput
  11590					     public  _semaget
  11591					     public  _dtcbfl
  11592					     public  _dphfl
  11593				     _dn_defpart     equ     dn_defpart
  11594					     public  _KS_ISRalloc
  11595					     public  _rtctick
  11596					     public  _rtctime
  11597					     public  _clkqfl
  11598					     public  _clkqptr
  11599					     public  _sliceup
  11600					     extrn   _clkrate:word
  11601				     _ratecnt	     equ     ratecnt
  11602					     public  _rtctimetick
  11603					     public  _isrcnt
  11604				     _t_expired	     equ     t_expired
  11605				     _postem equ     postem
  11606				     _insert_message equ     insert_message
  11607				     _remove_message equ     remove_message
  11608				     _get_clkblk     equ     get_clkblk
  11609				     _insert_timer   equ     insert_timer
  11610				     _unlink_timer   equ     unlink_timer
  11611				     _porder equ     porder
  11612				     _reorder_waiters	     equ     reorder_waiters
  11613				     _fwd_insert     equ     fwd_insert
  11614				     _bwd_insert     equ     bwd_insert
  11615				     _chgpriority    equ     chgpriority
  11616				     _spfixup	     equ     spfixup
  11617					     public  _rtxc
  11618					     public  _taskinit
  11619					     public  _resinit
  11620					     public  _mboxinit
  11621					     public  _partinit
  11622					     public  _queueinit
  11623					     public  _semainit
  11624					     public  _clockinit
  11625					     public  _KS_ISRsignal
  11626					     public  _KS_ISRexit
  11627					     public  _KS_ISRtick
  11628					     ?debug  C EA010B
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 205
.\rtxc.asm



  11629					     ?debug  C EC0B5F696E69745F666C61677302000000
  11630					     ?debug  C E33C00000023260400
  11631					     ?debug  C EB075F6D656D6370793C0000
  11632					     ?debug  C E33D0000001A1A
  11633					     ?debug  C EB075F7274787463623D0000
  11634					     ?debug  C E33F046B7463620C001E5D
  11635					     ?debug  C E34100000023010400
  11636					     ?debug  C E340000400164100
  11637					     ?debug  C E33E0000001A3F
  11638					     ?debug  C EB085F7274786B7463623E0000
  11639					     ?debug  C EB075F6E7461736B73040000
  11640					     ?debug  C EB085F646E7461736B73040000
  11641					     ?debug  C E3420000001A04
  11642					     ?debug  C EB065F73656D6174420000
  11643					     ?debug  C E3430000001A04
  11644					     ?debug  C EB085F7369676C697374430000
  11645					     ?debug  C EB075F6E73656D6173040000
  11646					     ?debug  C EB0C5F7369676C69737473697A65040000
  11647					     ?debug  C E3440000001A1C
  11648					     ?debug  C EB055F636C6B71440000
  11649					     ?debug  C EB065F6E746D7273040000
  11650					     ?debug  C E3450000001A34
  11651					     ?debug  C EB085F6D686561646572450000
  11652					     ?debug  C EB085F6E6D626F786573040000
  11653					     ?debug  C E3460000001A30
  11654					     ?debug  C EB085F70686561646572460000
  11655					     ?debug  C E3470000001A38
  11656					     ?debug  C EB095F706B686561646572470000
  11657					     ?debug  C EB075F6E7061727473040000
  11658					     ?debug  C EB085F646E7061727473040000
  11659					     ?debug  C E3480000001A2C
  11660					     ?debug  C EB085F71686561646572480000
  11661					     ?debug  C E3490000001A3B
  11662					     ?debug  C EB095F716B686561646572490000
  11663					     ?debug  C EB085F6E717565756573040000
  11664					     ?debug  C E34A0000001A28
  11665					     ?debug  C EB085F726865616465724A0000
  11666					     ?debug  C EB055F6E726573040000
  11667					     ?debug  C EC095F686970726974736B19000000
  11668					     ?debug  C EC085F6E73727474636219000000
  11669					     ?debug  C E34B000200150404
  11670					     ?debug  C EC085F73656D617075744B000000
  11671					     ?debug  C EC085F73656D6167657435000000
  11672					     ?debug  C EC075F64746362666C19000000
  11673					     ?debug  C EC065F647068666C2F000000
  11674					     ?debug  C E34C00000023010000
  11675					     ?debug  C E34D00000023260400
  11676					     ?debug  C EC0C5F4B535F495352616C6C6F634D180000
  11677					     ?debug  C EC085F7274637469636B06000000
  11678					     ?debug  C EC085F72746374696D6506000000
  11679					     ?debug  C EC075F636C6B71666C1B000000
  11680					     ?debug  C EC085F636C6B717074721B000000
  11681					     ?debug  C EC085F736C696365757019000000
  11682					     ?debug  C EB085F636C6B72617465040000
  11683					     ?debug  C EC0C5F72746374696D657469636B04000000
  11684					     ?debug  C EC075F697372636E7402000000
  11685					     ?debug  C E34E000000231F0000
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 206
.\rtxc.asm



  11686					     ?debug  C E34F00000023010000
  11687					     ?debug  C E35000000023310000
  11688					     ?debug  C E351000000231B0000
  11689					     ?debug  C E35200000023010000
  11690					     ?debug  C E35300000023010000
  11691					     ?debug  C E35400000023010000
  11692					     ?debug  C E35500000023010000
  11693					     ?debug  C E35600000023010000
  11694					     ?debug  C E35700000023010000
  11695					     ?debug  C E35800000023010000
  11696					     ?debug  C E35900000023180000
  11697					     ?debug  C E35A000000231F0000
  11698					     ?debug  C EC055F727478635A180000
  11699					     ?debug  C E35B00000023010000
  11700					     ?debug  C EC095F7461736B696E69745B180000
  11701					     ?debug  C E35C00000023010000
  11702					     ?debug  C EC085F726573696E69745C180000
  11703					     ?debug  C E35D00000023010000
  11704					     ?debug  C EC095F6D626F78696E69745D180000
  11705					     ?debug  C E35E00000023010000
  11706					     ?debug  C EC095F70617274696E69745E180000
  11707					     ?debug  C E35F00000023010000
  11708					     ?debug  C EC0A5F7175657565696E69745F180000
  11709					     ?debug  C E36000000023010000
  11710					     ?debug  C EC095F73656D61696E697460180000
  11711					     ?debug  C E36100000023010000
  11712					     ?debug  C EC0A5F636C6F636B696E697461180000
  11713					     ?debug  C E36200000023010400
  11714					     ?debug  C EC0D5F4B535F4953527369676E616C62180000
  11715					     ?debug  C E363000000231F0400
  11716					     ?debug  C EC0B5F4B535F4953526578697463180000
  11717					     ?debug  C E36400000023040400
  11718					     ?debug  C EC0B5F4B535F4953527469636B64180000
  11719					     ?debug  C E60772617465636E74040000031E00000009745F+
  11720					     ?debug  C 6578706972656402000003210000000673697A65+
  11721					     ?debug  C 5F740A060000064F424A4E554D04060000044D42+
  11722					     ?debug  C 4F5804060000034D415004060000055155455545+
  11723					     ?debug  C 04060000085245534F5552434504060000045441+
  11724					     ?debug  C 534B040600000453454D4104060000055449434B+
  11725					     ?debug  C 53060600000674696D655F740606000008505249+
  11726					     ?debug  C 4F5249545904060000065453544154450A060000+
  11727					     ?debug  C 0653535441544504060000074F424A545950451D+
  11728					     ?debug  C 060000075245534154545229060000054B534E55+
  11729					     ?debug  C 4D04060000054652414D4520060000035443421A+
  11730					     ?debug  C 060000044B5443423F0600000751484541444552+
  11731					     ?debug  C 2C06000008514B4845414445523B060000075048+
  11732					     ?debug  C 45414445523006000008504B4845414445523806+
  11733					     ?debug  C 000007525458434D534732060000074D48454144+
  11734					     ?debug  C 45523406000006434C4B424C4B1C060000075248+
  11735					     ?debug  C 454144455228060000056672616D652007000003+
  11736					     ?debug  C 7463621A07000006636C6B626C6B1C070000046B+
  11737					     ?debug  C 7463623F07000007716865616465722C07000008+
  11738					     ?debug  C 716B6865616465723B07000004786D61702E0700+
  11739					     ?debug  C 0007706865616465723007000008706B68656164+
  11740					     ?debug  C 65723807000007727478636D736732070000076D+
  11741					     ?debug  C 6865616465723407000007726865616465722807+
  11742					     ?debug  C 0000
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 207
.\rtxc.asm



  11743					     ?debug  F dn_defpart 76 24	0    0
  11744					     ?debug  F postem 78 24 0	     0
  11745					     ?debug  F insert_message 79 24 0	     0
  11746					     ?debug  F remove_message 80 24 0	     0
  11747					     ?debug  F get_clkblk 81 24	0    0
  11748					     ?debug  F insert_timer 82 24 0  0
  11749					     ?debug  F unlink_timer 83 24 0  0
  11750					     ?debug  F porder 84 24 0	     0
  11751					     ?debug  F reorder_waiters 85 24 0	     0
  11752					     ?debug  F fwd_insert 86 24	0    0
  11753					     ?debug  F bwd_insert 87 24	0    0
  11754					     ?debug  F chgpriority 88 24 0   0
  11755					     ?debug  F spfixup 89 24 0	     0
  11756					     ?debug  C E20005666C696E6B190005626C696E6B19000770+
  11757					     ?debug  C 636C6B626C6B1B00047461736B0400087072696F+
  11758					     ?debug  C 7269747904000273701F00067374617475730A00+
  11759					     ?debug  C 0570635F7430240009737461636B626173651800+
  11760					     ?debug  C 09737461636B73697A650A000674736C69636506+
  11761					     ?debug  C 00086E6577736C69636506000361726726C02800+
  11762					     ?debug  C 0000
  11763					     ?debug  C E20005666C696E6B1B0005626C696E6B1B000672+
  11764					     ?debug  C 656D61696E06000772656379636C650600047461+
  11765					     ?debug  C 736B04000573746174650208000000076F626A74+
  11766					     ?debug  C 7970651D00056F626A696404C018000000
  11767					     ?debug  C E4000944454C41595F4F424A0000000D53454D41+
  11768					     ?debug  C 50484F52455F4F424A0100000D50415254495449+
  11769					     ?debug  C 4F4E5F4F424A0200000951554555455F4F424A03+
  11770					     ?debug  C 00000C5245534F555243455F4F424A0400000B4D+
  11771					     ?debug  C 41494C424F585F4F424A0500800954494D45525F+
  11772					     ?debug  C 4F424A0600
  11773					     ?debug  C E2000264690A000273690A000262700A00027370+
  11774					     ?debug  C 0A000262780A000264780A0006706B736E756D21+
  11775					     ?debug  C 000265730A000264730A00027063220003636372+
  11776					     ?debug  C 0AC01A000000
  11777					     ?debug  C E200056F776E65721900056C6576656C04000777+
  11778					     ?debug  C 61697465727319000564756D6D79190008707269+
  11779					     ?debug  C 6F726974790400077265736174747229C00C0000+
  11780					     ?debug  C 00
  11781					     ?debug  C E400165052494F524954595F494E56455253494F+
  11782					     ?debug  C 4E5F4F4646000080155052494F524954595F494E+
  11783					     ?debug  C 56455253494F4E5F4F4E0100
  11784					     ?debug  C E200046261736518000577696474680A00056465+
  11785					     ?debug  C 7074680400067075746E64780400066375726E64+
  11786					     ?debug  C 780400077761697465727319000564756D6D7919+
  11787					     ?debug  C 00056673656D610400066E6573656D6104000565+
  11788					     ?debug  C 73656D610400066E6673656D6104C018000000
  11789					     ?debug  C E200046C696E6B2DC004000000
  11790					     ?debug  C E200046E6578742D000473697A650A0005636F75+
  11791					     ?debug  C 6E740400077761697465727319000564756D6D79+
  11792					     ?debug  C 1900036D61700400046164647218C012000000
  11793					     ?debug  C E200046C696E6B3100047461736B040008707269+
  11794					     ?debug  C 6F7269747904000473656D6104C00A000000
  11795					     ?debug  C E200046C696E6B31000777616974657273190005+
  11796					     ?debug  C 64756D6D791900066E6573656D6104C00A000000
  11797					     ?debug  C E200046E6578742D000473697A650A0005636F75+
  11798					     ?debug  C 6E7404C008000000
  11799					     ?debug  C E200046261736518000577696474680A00056465+
Turbo Assembler	 Version 3.0	    03/06/99 13:37:53	    Page 208
.\rtxc.asm



  11800					     ?debug  C 70746804C008000000
  11801					     ?debug  C E2000570635F7430400009737461636B62617365+
  11802					     ?debug  C 180009737461636B73697A650A00087072696F72+
  11803					     ?debug  C 69747904C00C000000
  11804					     end
