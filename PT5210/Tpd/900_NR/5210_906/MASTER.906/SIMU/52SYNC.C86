/***************************************************************************/
/*	Copyright PHILIPS TV TEST EQUIPMENT A/S, BRONDBY 1996							*/
/*	Project:		PT5210 VariTime digital sync generator, front plate			*/
/*	Module:		52SYNC.C51																	*/
/*	Author:		Kim Engedahl, DEV															*/
/*	Org. date:	960613																		*/
/*	Rev. date:	960613, KEn	DEV															*/
/*	Status:		Version 0.00																*/
/*																									*/
/*	This module contains the following functions:									*/
/*																									*/
/*		int main();																				*/
/*																									*/
/*	The complete source for the PT5210 NICAM monitor, front plate consists	*/
/*	of n C-modules:																			*/
/*																									*/
/*	and nn include-files:																	*/
/*																									*/
/*																									*/
/*	For information about compiling the source etc. see:	README				*/
/*																									*/
/*	Changes:																						*/
/***************************************************************************/

#include <xa.h>
#include <dos.h>

#include "mas.h"

#include "piic.h"
#include "iniic.h"
#include "serial1.h"
#include "52sync.h"
#include "sw5210.h"
#include "cont_drv.h"
#include "keyb_drv.h"
#include "disp_drv.h"
#include "text.h"
#include "menu.h"
#include "menuhlp.h"
#include "menutree.h"
#include "message.h"
#include "xaexprt.h"
#include "xadrivr.h"
#include "rs232par.h"
//#include "util.h"
#include "unit_drv.h"
#include "tables.h"

#define ErrorDisplayTimeout	25

#define xtal 29491200				// Crystal frequency for the mainboard


// *************************************************************************
// PORT CONTROL:
// RAM has address-space 0-0x1fff
// *************************************************************************
volatile UC  ind1;// @ 0x2001;		// input port 1
volatile UC  ind2;//  @ 0x4001;		// input port 2

volatile UC  ud1;//  @ 0x2001;			// output port 1
volatile UC  ud2;//  @ 0x4001;			// output port 2
volatile UC  ud3;//  @ 0x6001;			// output port 3
volatile UC  ud4;//  @ 0x8001;			// output port 4
volatile UC  ud5;//  @ 0xA001;			// output port 5

near UC ud1buf;						// buffer for output port 1
near UC ud4buf;						// buffer for output port 4
near UC ud5buf;						// buffer for output port 5


// *************************************************************************
// CONTROL OF OPTIONAL UNITS:
// Resets:
// *************************************************************************
#define    MRES1_on	{ ud4buf &= ~0x20; ud4 = ud4buf;}
#define    MRES1_off	{ ud4buf |= 0x20; ud4 = ud4buf;}
#define    MRES2_on	{ ud4buf &= ~0x40; ud4 = ud4buf;}
#define    MRES2_off	{ ud4buf |= 0x40; ud4 = ud4buf;}
#define    MRES3_on	{ ud4buf &= ~0x80; ud4 = ud4buf;}
#define    MRES3_off	{ ud4buf |= 0x80; ud4 = ud4buf;}


// *************************************************************************
// CONTROL OF FAN (BLOWER)
// *************************************************************************
#define fan_on		{ ud1buf |= 16; ud1 = ud1buf;}
#define fan_off	{ ud1buf &= ~16; ud1 = ud1buf;}
 
near int temp;						// Temperature
near UI oldtemp, grense;	 	// Temperature stores
near UC tempcnt;					// Counter for speed change filter
bit shotdown;						// Flag for very hot apparatus
near UC tempwarn;					// Flag for hot apparatus


// *************************************************************************
// LEVEL DETECTOR
// *************************************************************************
near UI LevelStatus;				// Status of level detectors 1-9, (bit 8-0)


// *************************************************************************
// A/D CONVERSION VARIABLES
// *************************************************************************
near UC TempMeas;					// Temperature read from AD converter
near UC Volt5Meas;				// 5 volt read from AD converter

near UC VoltN5Meas;				// -5 volt read from AD converter
UC VoltN5Min;						// Min. value for -5 volt
UC VoltN5Max;						// Max. value for -5 volt

near UC Volt12Meas;				// 12 volt read from AD converter
UC Volt12Min;						// Min. value for 12 volt
UC Volt12Max;						// Max. value for 12 volt

bit VoltCalib;						// 1: Power has been calibrated


// *************************************************************************
// SYSTEM VARIABLES
// *************************************************************************
near UC syncstatus;
near int RS232Char;
near UC slicer;					// Time window counter
bit Timer_flag;					// Control bit for 21 ms timing

// *************************************************************************
// FACTORY VALUES, IE. VALUES BEING DOWNLOADED DURING FACTORY PRESET
// *************************************************************************
code struct ANLBLK_STRUCTURE AnlBlkConfigFactory[NoOfAnlBlkUnits] = {
	// System, ScHPhase, Delay

	{ PAL, 0, 0},					// Black Burst 1
	{ PAL, 0, 0},					// Black Burst 2
	{ PAL, 0, 0},					// Black Burst 3
	{ PAL, 0, 0},					// Black Burst 4
	{ PAL, 0, 0},					// Black Burst 5
	{ PAL, 0, 0},					// Black Burst 6
	{ PAL, 0, 0},					// Black Burst 7
	{ PAL, 0, 0}					// Black Burst 8
};

code struct SDIBLK_STRUCTURE SDIBlkConfigFactory[NoOfSDIBlkUnits] = {
	// System, Pattern, EDH, EMBAudio, Delay

	{ SDI625, SBBlack, OFF, OFF, 0},		// Serial Black 3-4
	{ SDI625, SBBlack, OFF, OFF, 0},		// Serial Black 5-6
	{ SDI625, SBBlack, OFF, OFF, 0}		// Serial Black 7-8
};

code struct ANALOG_STRUCTURE AnalogConfigFactory = {
	PAL,								// TV System
	EBUCBar,							// Test signal pattern
	OFF,								// Text insertion ON/OFF
	"ANALOG  ",						// Text to be inserted
	0,									// ScH-Phase
	0									// Delay
};

code struct SDI_STRUCTURE SDIConfigFactory = {
	SDI625,							// TV System
	EBUCBar,							// Test signal pattern
	OFF,								// Text insertion ON/OFF
	"DIGITAL ",						// Text to be inserted
	OFF,								// EDH insertion ON/OFF
	AudioSignalOff,				// Embedded audio signal
	AudioSilence,					// Embedded audio level
	0									// Delay
};

code struct AES_EBU_STRUCTURE AES_EBUConfigFactory = {
	AudioStereo800Hz,				// AES-EBU signal
	AudioSilence,					// AES-EBU level
	AudioPAL							// AES-EBU Timing
};

code struct GENLOCK_STRUCTURE GenlockConfigFactory[NoOfGenlockUnits] = {
	{ BurstLockPAL, 0 },			// Genlock A
	{ BurstLockPAL, 0 },			// Genlock B
	{ BurstLockPAL, 0 },			// Loop through
	{ SDI625Lock, 0 },			// Option PT8607 SDI Genlock
	{ NA, 0 },						// Internal genlock
	{ NA, 0 }						// Option PT8610 Internal OCXO genlock
};

code struct RS232_STRUCTURE RS232ConfigFactory = {
	UDR_BAUD_9600,					// Baudrate
	UDR_DATA8,						// Databit
	UDR_NONE,						// Parity
	UDR_RTS_CTS						// Handshake
};


// *************************************************************************
// STATIC VARIABLES
// *************************************************************************

struct CONN_STRUCTURE Connectors[NoOfConnectors] = {
	// Present, HWType, HWVersion, KUNumber, SWVersion

	{ TRUE, NA, 0, 0, 0},				// Mainboard, ALWAYS present
	{ TRUE, NA, 0, 0, 0},				// OSC, (ie. SPG), ALWAYS present
	{ TRUE, NA, 0, 0, 0},				// BB 12, ALWAYS present
	{ FALSE, 0, 0, 0, 0},				// BB34 or SB34
	{ FALSE, 0, 0, 0, 0},				// BB56 or SB78
	{ FALSE, 0, 0, 0, 0},				// BB78 or SB78 or Analog test signal
	{ FALSE, 0, 0, 0, 0},				// SDI Genlock unit
	{ FALSE, 0, 0, 0, 0},				// AES/EBU sound unit
	{ FALSE, 0, 0, 0, 0},				// SDI Test signal
	{ FALSE, 0, 0, 0, 0}					// Time code unit
};

struct PNP_STRUCTURE AnlBlkUnit[NoOfAnlBlkUnits] = {
	{ TRUE, bbu0_addr},
	{ TRUE, bbu0_addr},
	{ FALSE, bbu1_addr},
	{ FALSE, bbu1_addr},
	{ FALSE, bbu3_addr},
	{ FALSE, bbu3_addr},
	{ FALSE, bbu2_addr},
	{ FALSE, bbu2_addr}
};

struct PNP_STRUCTURE SDIBlkUnit[NoOfSDIBlkUnits] = {
	{ FALSE, bbu1_addr},
	{ FALSE, bbu3_addr},
	{ FALSE, bbu2_addr}
};

struct PNP_STRUCTURE AnalogSignalUnit = {
	FALSE, AnlSig_addr
};

struct PNP_STRUCTURE SDISignalUnit = {
	FALSE, SDISig_addr
};

struct PNP_STRUCTURE AES_EBUUnit = {
	FALSE, NA
};

struct PNP_STRUCTURE SDIGenlockUnit = {
	FALSE, NA
};

struct PNP_STRUCTURE Int2GenlockUnit = {
	FALSE, NA
};

struct PNP_STRUCTURE TimeCodeUnit = {
	FALSE, NA
};


// *************************************************************************
// DYNAMIC VARIABLES, IE. VARIABLES "CONTINUOSLY" BEING UPDATED.
// *************************************************************************

persistent struct ANLBLK_STRUCTURE AnlBlkConfig[NoOfAnlBlkUnits];
persistent struct SDIBLK_STRUCTURE SDIBlkConfig[NoOfSDIBlkUnits];
persistent struct ANALOG_STRUCTURE AnalogConfig;
persistent struct SDI_STRUCTURE SDIConfig;
persistent struct AES_EBU_STRUCTURE AES_EBUConfig;
persistent struct GENLOCK_STRUCTURE GenlockConfig[NoOfGenlockUnits];
persistent struct RS232_STRUCTURE RS232Config;
persistent struct PRESET_STRUCTURE Preset[NoOfPresets];
persistent struct STATUS_FLAGS Flags;

persistent UC ActivePresetNo;		// Currently active preset, (0 = NONE)

persistent UC ExternalGenlockNo;	// Last selected EXTERNAL genlock
persistent UC ActiveGenlockNo;	// Currently active genlock

persistent UC ActiveOutputNo;		// Currently active output, ie. OUTPUT BUTTON

persistent UC LCDContrast;			// Contrast on LCD-display

persistent UC PasswordState;		// OFF: Apparatus is NOT password protected

code struct MENU_ITEM* near Ptr;
code struct MENU_ITEM* near PrevPtr;

UC ErrorCode;							// Temporary error code, 8 BIT
											// 8 BIT
											// ErrorType+ErrorNo

UI ErrorStatus;						// Last active global error code, 16 BIT
											// 8 MSB 	8 LSB
											// [index]	ErrorType+ErrorNo

UL ErrorQueue[NoInErrorQueue] = {// Global error code queue, 32 BIT
	0, 0, 0, 0, 0						// 16 MSB			8 BIT		8 LSB
};											// leveldetector	[Index]	ErrorType+ErrorNo

UC ErrorQueuePtr = NoInErrorQueue-1;
bit ErrorWindowOn;					// 1: indicates display of an "error" window

bit MessageWindowOn;					// 1: indicates display of a "message" window
near UC MessageCntDwn;				// Counter for display of message

volatile near UC SecTimer;			// Seconds timer: updated every second
volatile near UC AutoESCTimer;	// Timer for auto return to status display
volatile near UC UserTimer;		// Generel user timer: updated every 20ms
volatile near UC DisplayTimer;	// Error display timer: updated every 20ms

UC UpdateTimer;						// Timer for display animation
UC UpdateFrequency;					// Frequency for the above
bit UpdateEnable;						// 1: Display animation is active
bit UpdateSignal;						// 1: Display animatino caused the call

bit AutoESCSignal;					// 1: Return to status display

bit Do_Keyboard_Scan;				// 1:	Scan the keyboard

bit TestModeEnable;					// 1: Enable test mode

bit MenuModeOn;						// 1: Menu mode active
bit SelectModeOn;						// 1: Selection mode active

bit Warning_LED;						// 1: Illumination of the WARNING LED
bit Unlocked_LED;						// 1: Illumination of the UNLOCKED LED
bit Genlock_LED;						// 1: Illumination of the GENLOCK LED

bit SerialRemotePresent;			// 1: Remote cable mounted in serial conn.
bit SerialRemoteActive;  			// 1: Serial remote active
bit SerialRemoteLockoutOn;			// 1: Serial remote lockout ( ctrl-L)

bit ParallelRemotePresent;			// 1: Remote cable mounted in parallel conn.
bit ParallelRemoteActive;			// 1: Parallel remote active
UC ParallelRemoteStatus;

bit RS232DiagnoseMode;				// 1: RS232 Loopback test in progress

// END OF KIM's DEFINITIONS
// ******************************************************************

void waitus( UI time) {
}

void waitms( UI time) {
}

void Timer0_Interrupt( void) {
	static near UC ticker;

	if ( ++ticker > 1) {
		ticker = 0;
		Timer_flag = 1;

		if ( !--SecTimer)	{				// This routine is executed each second.
//			SecTimer = 50;					// Reload seconds timer.
			SecTimer = 1;					// Reload seconds timer.
				// IN PC Version SecTimer = 5 instead of 50

			if ( Flags.AutoESCEnable)						// If auto escape is ON
				if ( ++AutoESCTimer > AutoESCTimeOut)	// and time-out reached
					AutoESCSignal = TRUE;					// set time-out flag
		}

		if ( UserTimer)					// UserTimer is decremented each 20 ms.
			UserTimer--;

		if ( DisplayTimer)				// UserTimer is decremented each 20 ms.
			DisplayTimer--;

		Do_Keyboard_Scan = TRUE;		// Set flag for keyboard-scan
	}
}

/***************************************************************************/
/*	PowerOn_Reset																				*/
/*																									*/
/* Written by:	Kim Engedahl, DEV     													*/
/*	Revised by:	Kim Engedahl, DEV															*/
/*	Date:			950509																		*/
/*	Revised:		951031																		*/
/*																									*/
/* Module:		RESET.C51																	*/
/*	Function:	Initialize the front plate                     					*/
/*	Syntax:		void PowerOn_Reset();						      					*/
/*	Remarks:		The display is initialized SEVERAL times. This is necessary	*/
/*					according to the display data-sheet									*/
/*	Returns:		----                                           					*/
/*	Updates:		T.B.D																			*/
/***************************************************************************/
void PowerOn_Reset( int Startup) {

	UC Options, InternalError, ExternalError;
	char TextBuffer[9];
	char* StrTmp;
	int i, j;
	char UnitH0, UnitH1;

	/************************************************************************/
	/*                      HARDWARE INITIALIZATION 								*/
	/************************************************************************/

	Init_Display();				/* Initialize display */

//	IP = 0;							/* ALL interrupts at priority level low */

//	TMOD = 0x11;					/* Timer 0: mode 1, 16-bit timer */
										/* Timer 1: mode 1, 16-bit timer */

//	TL0 = Timer0_Load_Low;		/* Reload value for Timer 0, ie. */
//	TH0 = Timer0_Load_High;		/* generate an interrupt each 10 ms */

//	TCON |= 0x11;					/* Start Timer 0 */
										/* Edge triggered interrupt for the external */
										/* interrupts */

//	Enable_Timer0_Interrupt;	/* Enable Timer 0 interrupt */
//	Enable_Serial_Interrupt;	/* Enable interrupt from serial communication */

//	Serial_Init();					/* Initialize serial communication */

//	Init_Display();				/* Initialize display */

//	Init_Disp_IIC();				/* Initialize display IIC, (CONTRAST, RAM) */
										/* Does return an error u-integer */

//	Init_Keyb_IIC();				/* Initialize keyboard IIC, (KEYBOARD, LEDs) */
										/* Does return an error u-integer */

//	Init_Contrast();				/* Initialize the IIC ADC, (CONTRAST) */
										/* Send default contrast to display */
										/* Does return an error u-integer */

//	Init_Display();				/* Initialize display */


	/************************************************************************/
	/* 						INTERNAL VARIABLES INITIALIZATION 						*/
	/************************************************************************/

	SecTimer = 50;
	UserTimer = UpdateTimer = 0;

//	UpdateSignal = OFF;
	AutoESCSignal = OFF;

	Old_Button_Command = Button_Command = NO_Command;

	TestModeEnable = FALSE;

	Init_Display();						/* Initialize display */

//	Enable_Interrupts;					/* Enable ALL "enabled" interrupts */


// ******************************************************************
/* Reset all units. There are 3 resets to options, MRES1 to MRES3.
	In order to identify the position of the options, one reset is
	released at a time and an option address is send to this option.
	If the option then answers back its address, the Master then
	knows the presence of this option.
	to allow all units to do their own initialisation.
	Variable 'options' (for Test purposes)  has a bit for each option.*/
// ******************************************************************

	feed_dog;						// Watch-dog feed

	MRES1_on;						// Reset all options
	MRES2_on;
	MRES3_on;

	UserTimer = i = 10;			// Reset for 80-100 ms
//	while ( UserTimer)
		if ( i == UserTimer) {
			Init_Display();		// Initialize display, this is done 4 or 5 times
			feed_dog;				// Watch-dog feed
			i--;
		}

//	i = ~ind1;							// Detect type of remote connector
	i = 0;

	if ( i & SerialRemoteMask)		// RS232 remote installed
		SerialRemotePresent = TRUE;

	if ( i & ParallelRemoteMask)	// Parallel remote installed
		ParallelRemotePresent = TRUE;

	Warning_LED = ON;					// Switch ON all LEDs during power-up
	Unlocked_LED = ON;
	Genlock_LED = ON;

	Update_LEDs();

	Warning_LED = OFF;				// Switch OFF all LEDs after LED testing
	Unlocked_LED = OFF;
	Genlock_LED = OFF;

	Init_Contrast();					// Initialize the display contrast

											// Test buttons during power-on
	switch ( Startup) {
		case FACTORY_Button:
			WriteCodeLN1( 0, PowerUp_FactResetTxt);

			// CONFIGURE PRESET 1-8 (-2) TO PAL
			
			for ( j = 0; j < 17; j++)
				Preset[0].Name[j] = ' ';

			Preset[0].Name[16] = 0;

			for ( j=0; j < NoOfAnlBlkUnits; j++) {
				Cmemcpy( &Preset[0].AnlBlkStore[j], &AnlBlkConfigFactory[j], sizeof( AnlBlkConfig[0]));
				Cmemcpy( &AnlBlkConfig[j], &AnlBlkConfigFactory[j], sizeof( AnlBlkConfig[0]));

				if ( j < NoOfSDIBlkUnits) {
					Cmemcpy( &Preset[0].SDIBlkStore[j], &SDIBlkConfigFactory[j], sizeof( SDIBlkConfig[0]));
					Cmemcpy( &SDIBlkConfig[j], &SDIBlkConfigFactory[j], sizeof( SDIBlkConfig[0]));
				}
			}
			Cmemcpy( &Preset[0].AnalogStore, &AnalogConfigFactory, sizeof( AnalogConfig));
			Cmemcpy( &AnalogConfig, &AnalogConfigFactory, sizeof( AnalogConfig));

			Cmemcpy( &Preset[0].SDIStore, &SDIConfigFactory, sizeof( SDIConfig));
			Cmemcpy( &SDIConfig,  &SDIConfigFactory, sizeof( SDIConfig));

			Cmemcpy( &Preset[0].AES_EBUStore, &AES_EBUConfigFactory, sizeof( AES_EBUConfig));
			Cmemcpy( &AES_EBUConfig, &AES_EBUConfigFactory, sizeof( AES_EBUConfig));

			for ( j=0; j < NoOfGenlockUnits; j++) {
				Cmemcpy( &Preset[0].GenlockStore[j], &GenlockConfigFactory[j], sizeof( GenlockConfig[0]));
				Cmemcpy( &GenlockConfig[j], &GenlockConfigFactory[j], sizeof( GenlockConfig[0]));
			}

			Preset[0].ActiveGenlockNo = ActiveGenlockNo = Internal;
			Preset[0].ExternalGenlockNo = ExternalGenlockNo = GenlockA;


			for ( i=1; i < NoOfPresets; i++)
				memcpy( &Preset[i], &Preset[0], sizeof( Preset[0]));


			// CONFIGURE PRESET 2 TO NTSC, IE. CHANGE ONLY THE DIFFERENCES

			for ( j=0; j < NoOfAnlBlkUnits; j++) {
				Preset[1].AnlBlkStore[j].System = NTSC;

				if ( j < NoOfSDIBlkUnits)
					Preset[1].SDIBlkStore[j].System = SDI525;
			}

			Preset[1].AnalogStore.System = NTSC;
			Preset[1].AnalogStore.Pattern = SMPTECBar;

			Preset[1].SDIStore.System = SDI525;
			Preset[1].SDIStore.Pattern = SDISMPTECBar;

			Preset[1].AES_EBUStore.Timing = AudioNTSCPhase1;

			for ( i=0; i < SDIGenlock; i++)
				Preset[1].GenlockStore[i].System = BurstLockNTSC;

			Preset[1].GenlockStore[SDIGenlock].System = SDI525Lock;

			Cmemcpy( &RS232Config, &RS232ConfigFactory, sizeof( RS232Config));

			LCDContrast = Def_Contrast;

			ActiveOutputNo = AES_EBUItem;
			ActivePresetNo = 0;

			Flags.NormalLockOn = OFF;
			Flags.PanelLockOn = OFF;
			Flags.DownloadLockOn = OFF;
			Flags.DiagnoseLockOn = OFF;

			Flags.AutoESCEnable = ON;
			Flags.AutoESCToStatus = ON;

			PasswordState = ON;

			IIC2_Write2( mainram1_addr, RAMCheckOK_addr, TRUE);
			break;

		case MASTER_Button:
			WriteCodeLN1( 0, PowerUp_MasterResetTxt);

			for ( i=0; i < NoOfAnlBlkUnits; i++) {
				AnlBlkUnit[i].Present = TRUE;

				if ( i < NoOfSDIBlkUnits)
					SDIBlkUnit[i].Present = TRUE;
			}

			AnalogSignalUnit.Present = TRUE;
			SDISignalUnit.Present = TRUE;
			AES_EBUUnit.Present = TRUE;
			SDIGenlockUnit.Present = TRUE;
			Int2GenlockUnit.Present = TRUE;
			TimeCodeUnit.Present = TRUE;

			Cmemcpy( &RS232Config, &RS232ConfigFactory, sizeof( RS232Config));

			LCDContrast = Def_Contrast;

			ActiveOutputNo = AES_EBUItem;
			ActivePresetNo = 0;

			Flags.NormalLockOn = OFF;
			Flags.PanelLockOn = OFF;
			Flags.DownloadLockOn = OFF;
			Flags.DiagnoseLockOn = OFF;

			Flags.AutoESCEnable = ON;
			Flags.AutoESCToStatus = ON;

			TestModeEnable = ON;

			PasswordState = ON;

			IIC2_Write2( mainram1_addr, RAMCheckOK_addr, TRUE);
			break;

		default:
			WriteCodeLN1( 0, PowerUp_DefaultTxt);
			break;
	}

	GetIICVersion( IICBus2, mainram1_addr, ProductKUNo_addr, &Connectors[MainConn].KUNumber);
	Connectors[MainConn].SWVersion = PT5210SWVersion;

	UserTimer = 20;					// Set timer to 380-400ms

	IIC2_Write( mainram1_addr, VoltCalib_addr);	// Get powersupply limits
	VoltCalib = ( IIC2_Read( mainram1_addr) == ON);			// Calibration
	VoltN5Min = IIC2_Read( mainram1_addr);		// Min. -5 volt
	VoltN5Max = IIC2_Read( mainram1_addr);		// Max. -5 volt
	Volt12Min = IIC2_Read( mainram1_addr);		// Min. 12 volt
	Volt12Max = IIC2_Read( mainram1_addr);		// Max. 12 volt

	UserTimer = 20;					// Set timer to 380-400ms
//	while ( UserTimer)				// Short delay for the eye
		feed_dog;						//  feed the watch-dog

	WriteCharLN2( 0, ' ');
	ClearRestLN2();
	WriteCodeLN2( 8, SelfTestTxt);// Write Selftest in progress

	MRES1_off;							// Release reset 1
	UserTimer = 11;					// Set timer to 200-220ms
	feed_dog;							// Watch-dog feed

											// Initialize the remote RS232
	Udr_InitializeUart( RS232Config.Baudrate, RS232Config.Databit,\
								 RS232Config.Parity, RS232Config.Handshake);


											// Initialize mainboard BB's
	for ( AnlBlkNdx = BB1Item; AnlBlkNdx < BB3Item; AnlBlkNdx++)
		if ( ErrorCode = ConfigureAnlBlkUnit( AnlBlkNdx))
			DisplayErrorLine( ErrorCode, ErrorDisplayTimeout);

//	while ( UserTimer)				// While waiting for BBU_1 unit to initialize
		feed_dog;						//  feed the watch-dog

	SndChar( default_addr, "HA", bbu1_addr);
	waitms( 10);						// Wait for an answer from the unit
//	i = S1BUF;

	MRES2_off;							// Release reset 2
	UserTimer = 13;					// Set timer to 240-260ms

	if ( i == bbu1_addr) {
		for ( i = BB3Item; i < BB5Item; i++) {
			AnlBlkUnit[i].Present = TRUE;

			if ( ErrorCode = ConfigureAnlBlkUnit( i))
				DisplayErrorLine( 256*i + ErrorCode, ErrorDisplayTimeout);
		}
	}
	else
		if ( i == bbu1_addr+64) {
			SDIBlkUnit[SB34Item].Present = TRUE;

			if ( ErrorCode = ConfigureSDIBlkUnit( SB34Item))
				DisplayErrorLine( 256*SB34Item + ErrorCode, ErrorDisplayTimeout);
		}

//	while ( UserTimer)				// While waiting for BBU_2 unit to initialize
		feed_dog;						//  feed the watch-dog

											// Change V24 address on unit
	SndChar( default_addr, "HA", bbu2_addr);
	waitms( 10);						// Wait for an answer from the unit
//	i = S1BUF;

/*	MRES3_off;							// Release reset 3
	UserTimer = 13;					// Set timer to 240-260ms

	if ( i == bbu2_addr) {
		for ( i = BB7Item; i < BB8Item+1; i++) {
			AnlBlkUnit[i].Present = TRUE;

			if ( ErrorCode = ConfigureAnlBlkUnit( i))
				DisplayErrorLine( 256*i + ErrorCode, ErrorDisplayTimeout);
		}
	}
	else
		if ( i == bbu2_addr+64) {
			SDIBlkUnit[SB78Item].Present = TRUE;

			if ( ErrorCode = ConfigureSDIBlkUnit( SB78Item))
				DisplayErrorLine( 256*SB78Item + ErrorCode, ErrorDisplayTimeout);
		}

//	while ( UserTimer)				// While waiting for BBU_3 unit to initialize
		feed_dog;						//  feed the watch-dog

											// Change V24 address on unit
	SndChar( default_addr, "HA", bbu3_addr);
	waitms( 10);						// Wait for an answer from the unit
//	i = S1BUF;

	if ( i == bbu3_addr) {
		for ( i = BB5Item; i < BB7Item; i++) {
			AnlBlkUnit[i].Present = TRUE;

			if ( ErrorCode = ConfigureAnlBlkUnit( i))
				DisplayErrorLine( 256*i + ErrorCode, ErrorDisplayTimeout);
		}
	}
	else
		if ( i == bbu3_addr+64) {
			SDIBlkUnit[SB56Item].Present = TRUE;

			if ( ErrorCode = ConfigureSDIBlkUnit( SB56Item))
				DisplayErrorLine( 256*SB56Item + ErrorCode, ErrorDisplayTimeout);
		}

	feed_dog;												// Watch-dog feed
																// Analog test signal
	if ( SndChar( AnlSig_addr, "AI", 0)==v24ok) {
		AnalogSignalUnit.Present = TRUE;

		if ( ErrorCode = ConfigureAnalogSignalUnit())
			DisplayErrorLine( ErrorCode, ErrorDisplayTimeout);
	}

	feed_dog;												// Watch-dog feed

	if ( SndChar( SDISig_addr, "SI", 0)==v24ok) {// PT8602/PT8603
		SDISignalUnit.Present = TRUE;					// SDI test signal generator

		if ( ErrorCode = ConfigureSDISignalUnit())
			DisplayErrorLine( ErrorCode, ErrorDisplayTimeout);
	}

	feed_dog;												// Watch-dog feed

	if ( IIC1_Write( multibb_addr, 0xff)) {		// Option PT8605
		Connectors[BB34Conn].Present = TRUE;
		Connectors[BB34Conn].HWType = PT8604;

		GetIICVersion( IICBus1, multibb_addr, &Connectors[BB34Conn].KUNumber);
	}

	feed_dog;												// Watch-dog feed

	if ( IIC2_Write( sound1_addr, 0xff)) {			// Option PT8605
		AES_EBUUnit.Present = TRUE;					// AES/EBU audio generator

		Connectors[AESConn].Present = TRUE;

		GetIICVersion( IICBus2, soundram_addr, &Connectors[AESConn].KUNumber);

		if ( ErrorCode = AES_EBUUnitDrv( AES_EBUConfig.Signal, AES_EBUConfig.Level, AES_EBUConfig.Timing))
			DisplayErrorLine( ErrorCode, ErrorDisplayTimeout);
	}

	feed_dog;												// Watch-dog feed

	if ( IIC1_Write( d1ram_addr, 0xff))	{			// Option PT8606
		SDIGenlockUnit.Present = TRUE;				// SDI Genlock unit

		Connectors[SDIGConn].Present = TRUE;

		GetIICVersion( IICBus1, d1ram_addr, &Connectors[SDIGConn].KUNumber);
	}
	else {
		if ( ActiveGenlockNo == SDIGenlock)
			DisplayErrorLine( SystemErrorType + ConfigurationError, ErrorDisplayTimeout);
	}

	feed_dog;												// Watch-dog feed
																// Oven unit PT8610
	if (( ErrorCode = SndRequest( sync_addr, "GS")) == 0) {
		if (( ErrorCode = AnswerCheck()) == 0) {
			feed_dog;

			syncstatus = (UC) atoi( AnswerBuf);

			if ( syncstatus & OvenMask)
				Int2GenlockUnit.Present = TRUE;
			else
				if ( ActiveGenlockNo == Internal2)
					DisplayErrorLine( SystemErrorType + ConfigurationError, ErrorDisplayTimeout);
		}
	}
	if ( ErrorCode)									// Error for SPG
		DisplayErrorLine( OSCErrorType + ErrorCode, ErrorDisplayTimeout);

	feed_dog;										// Watch-dog feed

	if ( IIC1_Write( time_addr, 0xff)) {	// Option PT86
		TimeCodeUnit.Present = TRUE;			// Time code unit, (MUST initialize
														//  BEFORE GenlockUnitDrv)
		Connectors[TimeConn].Present = TRUE;

		GetIICVersion( IICBus1, timeram_addr, &Connectors[TimeConn].KUNumber);
	}

	feed_dog;										// Watch-dog feed

	if ( ErrorCode = GenlockUnitDrv( ActiveGenlockNo, GenlockConfig[ActiveGenlockNo].System))
		DisplayErrorLine( ErrorCode, ErrorDisplayTimeout);

	feed_dog;										// Watch-dog feed

														// Download calibration data to SPG
	if ( ErrorCode = ConfigureSPG())
		DisplayErrorLine( OSCErrorType + ErrorCode, ErrorDisplayTimeout);
*/
// ******************************************************************
// RECALL OLD SETTINGS
// ******************************************************************
	grense = templimit - 2;		// limit for blower (high temp.)
	feed_dog;

	Update_LEDs();

	UserTimer = 75;						// Start delay for 1.5 second

	// ramcheck();							// TBD
	// romcheck();							// TBD

//	while ( UserTimer)					// Simulates delay for internal test
		feed_dog;

	if ( !ErrorStatus) {
		WriteCodeLN2( 8, InternalTestTxt);
		ClearRestLN2();
	}

	UserTimer = 100;						// Start delay 2 second

	BaseNdx = 0;							// Reset base menu
	AnlBlkNdx = 0;							// Reset last active Analog Black menu item

												// Reset last active SDI Black menu item
	for ( SDIBlkNdx = 0; SDIBlkNdx < NoOfSDIBlkUnits; SDIBlkNdx++)
		if ( SDIBlkUnit[SDIBlkNdx].Present)
			break;
												// Reset last active Analog Black items
	for ( i = 0; i < NoOfAnlBlkUnits; i++)
		BBNdx[i] = 0;
												// Reset last active SDI Black items
	for ( i = 0; i < NoOfSDIBlkUnits; i++)
		SBNdx[i] = 0;

	AnlSigNdx = 0;		   				// Reset last active Analog-signal item
	SDISigNdx = 0;	  						// Reset last active SDI-signal item
	AES_EBUNdx = 0;	  					// Reset last active AES-EBU out item
	PresetNdx = 0;	  						// Reset last active Preset item
	ConfigNdx = 0;	  						// Reset last active Config item
	RS232Ndx = 0; 							// Reset last active RS232 item
	DiagnoseNdx = 0; 						// Reset last active Diagnose item

//	while ( UserTimer)					// Delay to show internal test passed
		feed_dog;

	WriteCodeLN1( 0, PT5210HeadlineTxt);
	ClearRestLN1();

	GetPT5210SWVersion( TextBuffer);
	WriteCharLN2( 0, ' ');
	ClearToPosLN2( 8);
	WriteCode2( VersionHdrTxt);		// Write software version
	WriteTxt2( TextBuffer);
	ClearRestLN2();

	UserTimer = 250;						// Delay 5.0 second or until key pressed
	while ( UserTimer != 0)
		if ( Button_Ready())
			break;

	Send_Contrast( LCDContrast);

	MenuModeOn = SelectModeOn = OFF;

	if ( ErrorStatus)							// If any errors during powerUP
		StatusNdx = StatusErrorItem;		//  start in Error/Warnings display
	else {
		if ( ActivePresetNo)
			StatusNdx = StatusPresetItem;
		else
			StatusNdx = StatusGenlockItem;
	}

	Ptr = &status_menu[StatusNdx];

	Ptr->DispFunct();

	// ******************************************************************
	// ENDLESS LOOP
	// ******************************************************************
}

/***************************************************************************/
/*	main																							*/
/*																									*/
/* Written by:	Kim Engedahl, DEV															*/
/* Revised by:	Kim Engedahl, DEV															*/
/*	Date:			960603																		*/
/*	Revised:		960603																		*/
/*																									*/
/* Module:		52SYNC.C51																	*/
/*	Function:	Main program																*/
/*	Syntax:     int main();																	*/
/*	Remarks:		----																			*/
/*	Returns:    ----																			*/
/* Updates:		----																			*/
/***************************************************************************/

int main( void) {
/*
	UC i;

	UC TheEnd = 0;
	struct dostime_t t, t_old;
	extern void Timer0_Interrupt();

//	char* Txt = "SYSTEM;:Status1:oper: event\x0a\x0a\x0a";
//	char* Txt = "OUTPUT:BB8:delayaaaaaaaaaa:lin 1;ftim 2";
//	char* Txt = ":outp:bb8:lin? 12,'asd';*Sre;ftim 12,as;:system\x0a\x0a\x0a";
//	char* Txt = "Outp:SB2:pattern;\x0a";
//	char* Txt = "*IDN?\x0a   ";
//	char* Txt = "status:preset;ftim;:system;\x0a";
//	DELAY:FIELD 12,1;:OUTPUT;BB4\x0aOUTPUT:BB2:DELAY\x0a";
//	char* Txt = "*TEST?    \x0a";
//	char* Txt = "*test?aq qweryqeeeewerty   \x0a";
//	char* Txt = "TEST:h 'ki''m';:iiikk  \x0a";
//	char* Txt = "TEST:hej #13123,   a ;";
//	char* Txt = "system:version .1234E-12 , 12;  ";
//	char* Txt = "fact:V24c:address 21;addr?;comm 'gg',123;\x0atest:v24c:comm \"sn\",50,'1qw';:syst:error?;error?;error?;error?;error?;\x0a";
//	char* Txt = "TaEST;:V24c;:addres;:syst:err?;err?;asd,asdf;ad;s h;comm 'qa','1qw';:syst:error?;error?;error?;error?;error?;\x0a";
//	char* Txt = "fact:spg:store? 2;address bbu_2;addr?;:syst:error?;error?;error?;error?;error?;\x0a";
//	char* Txt = ":output:bb3:lin?;:outp:sb:syst?; #212NA? qw123456\x0A";
//	char* Txt = "system:err?;err?;err?;err?;\x0a";
//	char* Txt = "system:version?;\x0asystem:version?;\x0a";
//	char* Txt = "outp:audio:signal s800hz;signal?;text?\x0aoutp:sdi:patt?;\x0a";
//	char* Txt = "input:genlock:input A_B;input?;syst SDI525;syst?\x0A";
//	char* Txt = "fact:ldetector:read?;text?8;store?;syst SDI525;syst?\x0A";
//	char* Txt = "fact:main:text 1,'wer'\x0A";
//	char* Txt = ":outp:aud:timing fs; pattern?;schphase 3;:syst:err?;\x0A";
//	char* Txt = "outp:sDIS:text 'hej kim'; pattern?;schphase 3;:syst:err?;\x0A";
//	char* Txt = "fact:password 'ENGEDAHl'\x0A";

//	char* Txt = "outp:bb1:delay -2,-623,-54322.4;";

//	char* Txt = "system:pres3:recall;";

	char* Ptr = Txt;

	clrscr();
	printf( "%s\n", Txt);

	while ( *Ptr)
		CmdHandler( *Ptr++);

	i=0;
}*/

	UC i, j;
	UL kim;
	char test;

	UC TheEnd = 0;
	struct dostime_t t, t_old;
	extern void Timer0_Interrupt();

	char* Ptr1;

//	char* Txt = "#32090mmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm1234\n";

//	char* Txt = ":SYST:PRES:UPL 5,#212433435454534\n";
//	char* Txt = "PHILIPS,PT5210,KU341265,01.9-01.1\x0A";
//	char* Txt = "FACT:V24C:ADDR 23;COMM 'HI?;COMM 'HI?';\n";
//	char* Txt = "Syst:pres:name 3,'kim';\n";
//	char* Txt = "Syst:vers?;";
//	char* Txt = "status:pt5210?;\n";
//	char* Txt = "*rst;\n";

	char* Txt = "SYST:DOWN;\n";

	if (( kim = sizeof( Preset[0])) > 256)
		kim = 3;

	PowerON_Reset( FACTORY_Button);

	PasswordState = OFF;

	while ( *Txt)
		CmdHandler( *Txt++);

//	strcpy( Txt, "*SRE?;");
//	while ( *Txt)
//		CmdHandler( *Txt++);

//	ResponseHandler( ":SYST:down;");

	test = 'c';
								 //data par
	Udr_InitializeUart(0,    8,    2, 0);

	Set_8bit_parity( test);

	Connectors[SDISConn].HWVersion = 5;

	while ( !TheEnd) {

		_dos_gettime( &t);
		if ( t.hsecond != t_old.hsecond) {
			Timer0_Interrupt();
			t_old = t;
		}

		while( !Timer_flag) {					// While waiting for timer flag..

			_dos_gettime( &t);
			if ( t.hsecond != t_old.hsecond) {
				Timer0_Interrupt();
				t_old = t;
			}

			// ****************************************************************
			// HANDLE SERIAL REMOTE INTERFACE, IF PRESENT
			// ****************************************************************
			if ( SerialRemotePresent) {	// If serial remote interface enabled..

				if ( !RS232DiagnoseMode)	// Do not respond if in diagnose mode
					while (( RS232Char = Udr_InChar()) != UDR_EOF) {
						CmdHandler((UC) RS232Char);

						if ( SerialRemoteActive == FALSE) {
							SerialRemoteActive = TRUE;		// Set serial remote flag
							SetupRS232GotoLocalMessage();	// Prepare for "Goto.." display
						}
					}
			}
		}
		Timer_flag = 0;									// 20 ms timer expired

		// *******************************************************************
		// HANDLE KEYBOARD SCANNING AND DECODING EVERY 20 ms
		// *******************************************************************
		if ( Button_Ready()) {

			if ( ParallelRemoteActive || SerialRemoteLockoutOn) {
				if ( ParallelRemoteActive)
					MessageHandling( ParallelLockoutMessage);
				else
					MessageHandling( SerialLockoutMessage);
			}
			else {
				if ( ErrorWindowOn)			// If error window on..
					ErrorWindowOn = FALSE;	//  pressing a button will close display
				else {
					if ( SerialRemoteActive && !MenuModeOn)
						Ptr = &RS232local_menu;
					else
						switch ( Button_Command) {
							case UP_Button:
								Ptr->UpBut();
								break;

							case DOWN_Button:
								Ptr->DownBut();
								break;

							case RIGHT_Button:
								Ptr->RightBut();
								break;

							case LEFT_Button:
								Ptr->LeftBut();
								break;

							case EXEC_Button:
								Ptr->ExecBut();
								break;

							case PRESET_Button:
								if ( !SerialRemoteActive)
									if ( Ptr != &diagnose_submenu[DiagKeyboardItem])
										PresetButtonSelect();
								break;

							case OUTPUT_Button:
								if ( !SerialRemoteActive)
									if ( Ptr != &diagnose_submenu[DiagKeyboardItem])
										OutputButtonSelect();
								break;

							case GENLOCK_Button:
								if ( !SerialRemoteActive)
									if ( Ptr != &diagnose_submenu[DiagKeyboardItem])
										GenlockButtonSelect();
								break;

							case 250:
								TheEnd = 1;
								break;
						}
				}
				Ptr->DispFunct();
			}
		}
		feed_dog;

		// ***********************************************************
		// SLICER HANDLING
		// ***********************************************************
		if ( ++slicer > 10)							// Divide in 10 windows
			slicer = 1;

		// ***********************************************************
		// HANDLE AUTO ESCAPE FROM MENUMODE							WINDOW 1
		// ***********************************************************
		if ( slicer == 1) {

			if ( Flags.AutoESCEnable) {
				if ( MenuModeOn) {
					if ( AutoESCSignal) {

						AutoESCSignal = FALSE;
						AutoESCTimer = 0;				// Reset Escape timer
			
						if ( SelectModeOn) {			// If in selection mode ..
							Ptr->EscapeFct();			//  be sure to terminate NICELY!!
							Ptr->DispFunct();
						}

						if ( Flags.AutoESCToStatus) {
							UpToStatus();				// Update ptr to status-display
							Ptr->DispFunct();			// Display status-display
						}
					}
				}
			}
		}

		// ***********************************************************
		// HANDLE MESSAGE WINDOWS AND RS232 WINDOWS UPDATE		WINDOW 2
		// ***********************************************************
		if ( slicer == 2) {

			// Message windows:
			// Presently only two windows messages are used: Local lockout
			//  for both parallel and serial remote.

			// RS232 windows update:
			// This "routine" is ONLY used when in serial remote. If a serial
			//  command alters the content of a variable, and this variable
			//  presently is shown in the status display, the display must be
			//  updated in order to show the new value. NO update should occur
			//  if a message window is presently displayed.

			if ( MessageWindowOn) {					// Message windows..
				if ( MessageCntDwn-- == 0) {
					MessageWindowOn = OFF;			// Remove message window flag and
					Ptr->DispFunct();					//  update status-display
				}
			}
			else {										// RS232 windows update..
				if ( SerialRemoteActive && !MenuModeOn) {
					if ( NewCmdExecuted) {			// If a new command executed..
						NewCmdExecuted = FALSE;		//  unflag the information and
						Ptr->DispFunct();				//  update the status display
					}
				}
			}
		}

		// ***********************************************************
		// HANDLE DISPLAY ANIMATION									WINDOW 3
		// ***********************************************************
		if ( slicer == 3) {

			if ( UpdateEnable)
				if ( --UpdateTimer == 2) {
					UpdateSignal = TRUE;					// Signal update ready
					UpdateTimer = UpdateFrequency;	// Reset update timer

					Ptr->DispFunct();						// Update selected display
				}
		}

		// ***********************************************************
		// HANDLE READING THE A/D CONVERTERS						WINDOW 4
		// ***********************************************************
		if ( slicer == 4) {

			if ( !Wr_Front_IIC( ADC_addr, 0x44))			// Auto increment
				GotoErrorStatus( TempADCErrorType + IICErrorCode);
			else {
				Volt12Meas = Rd_Front_IIC( ADC_addr);		// Read 12 volt A/D

				feed_dog;

				if ( !IICErrorCode)
					TempMeas = Rd_Front_IIC( ADC_addr);		// Read temperature A/D

				feed_dog;

				if ( !IICErrorCode)
					Volt5Meas = Rd_Front_IIC( ADC_addr);	// Read +5V A/D

				feed_dog;
	
				if ( !IICErrorCode)
					VoltN5Meas = Rd_Front_IIC( ADC_addr);	// Read -5V A/D
				
				if ( IICErrorCode)
					GotoErrorStatus( VoltageADCErrorType + IICErrorCode);
				else {
					if ( Send_Contrast( LCDContrast))		// Update contrast
						GotoErrorStatus( LCD_ADCErrorType + IICErrorCode);
				}
			}
      }

		// ***********************************************************
		// HANDLE POWER-SUPPLY MONITORING							WINDOW 5
		// ***********************************************************
		if ( slicer == 5) {

//			if ( VoltCalib) {							// If voltage has been calibrated.
  if ( 1) {
				// Only the -5V and the 12V will be examined as the +5V is
				//  handled by the watch dog

															// if -5 volt is out of range..
//				if (( VoltN5Meas < VoltN5Min) || ( VoltN5Meas > VoltN5Max))
					if ( 1)
					GotoErrorStatus( SystemErrorType + PowerN5Failure);
				else {
					if ( ErrorStatus == ( SystemErrorType + PowerN5Failure))
						ErrorStatus = 0;

						if ( !MessageWindowOn && !MenuModeOn)
							Ptr->DispFunct();
				}
															// if 12 volt is out of range..
				if (( Volt12Meas < Volt12Min) || ( Volt12Meas > Volt12Max))
					GotoErrorStatus( SystemErrorType + Power12Failure);
				else {
					if ( ErrorStatus == ( SystemErrorType + Power12Failure))
						ErrorStatus = 0;

						if ( !MessageWindowOn && !MenuModeOn)
							Ptr->DispFunct();
				}
			}
		}

		// ***********************************************************
		// HANDLE TEMPERATURE CONTROL/MONITORING					WINDOW 6
		// ***********************************************************
		if ( slicer == 6) {

			temp = TempMeas;		// Set blower speed from NTC resistor temp

			if ( temp == 0)
				temp = 255;

			if ( temp == oldtemp)
				tempcnt = 25;
			else
				if (( --tempcnt == 0) || ( oldtemp > temp+1)) {
					tempcnt = 25;
					oldtemp = temp;
																// MANAGE TEMPERATURE WARNINGS
					if ( temp > hottemp+2) {			// If colder than HOT..
						if ( tempwarn != 0) {			//
							tempwarn = 0;					//  warning off
//							warntemp();						// TBD TBD
						}
					}
					else
						if ( temp < panictemp) {		// If warmer than TOOHOT..
							shotdown = 1;					//  shut down
							if ( tempwarn != 2) {		//  FAILURE to frontplate
								tempwarn = 2;
								GotoErrorStatus( SystemErrorType + TemperatureFailure);
							}
						}
					else
						if ( temp < hottemp)	{			// If warmer than HOT..
							if ( tempwarn != 1) {		//  WARNING to frontplate
								tempwarn = 1;
								GotoErrorStatus( SystemErrorType + TemperatureWarning);
							}
						}

					if ( temp > panictemp+10)
				      if ( shotdown) {
							shotdown=0;						// NOT TOOHOT, CANCEL SHOTDOWN
							// klardat= 0;					// normal start without data reset
							// restart();
						}
																// SET BLOWER SPEED
					if ( temp> grense) {
						temp = 0;							// cold, blower off
						if ( ud1buf & 16)
							fan_off;
						grense = templimit-2;
					}
					else {
						grense = templimit;
						if ( !( ud1buf & 16))
							fan_on;							// blower on
					}
				}
		}

		// ***********************************************************
		// HANDLE LEVEL-DETECTORS										WINDOW 7
		// ***********************************************************
		if ( slicer == 7) {

			LevelStatus = IIC1_Read( lev1det_addr);	// 8 input
			if ( IIC1ErrorCode == 0)
				LevelStatus += ( IIC1_Read( lev2det_addr) << 8);
																	// 1 input (LSB)
																	// 1 output (MSB)

			if ( IIC1ErrorCode)								// If IIC Circuit error ..
				GotoErrorStatus( LevelDetectorErrorType + IIC1ErrorCode);
			else {
				if ( LevelStatus^0x1FF)
					GotoErrorStatus( SystemErrorType + LevelDetectorError);
				else {
					if ( ErrorStatus == ( SystemErrorType + LevelDetectorError)) {
						ErrorStatus = 0;

						if ( !MessageWindowOn && !MenuModeOn)
							Ptr->DispFunct();
					}
				}
			}
		}

		// ***********************************************************
		// HANDLE SPG GENLOCKED/UNLOCKED UPDATE					WINDOW 8
		// ***********************************************************
		if ( slicer == 8) {

			if ( ActiveGenlockNo != Internal) {

				j = ( UC) RecInt( sync_addr, "GS", 0xFF, &ErrorCode);	// Send request

				if ( ErrorCode)
					DisplayErrorLine( OSCErrorType + ErrorCode, 0);
				else
					syncstatus = j;

				if (( syncstatus & 0x01) ^ !Unlocked_LED) {
					Unlocked_LED = !Unlocked_LED;

					Update_LEDs();

					if ( !MessageWindowOn && !MenuModeOn)
						Ptr->DispFunct();
				}
			}
			else {
				Unlocked_LED = OFF;
				Update_LEDs();
			}
		}

		// ***********************************************************
		// HANDLE PARALLEL REMOTE INTERFACE, IF PRESENT			WINDOW 9
		// ***********************************************************
		if ( slicer == 9) {

			if ( ParallelRemotePresent) {

				// 8574    Remote Connector
				// 0   ->  pin 1 (LSB)		Preset no
				// 1   ->  pin 2
				// 2   ->  pin 3 (MSB)
				// 3   ->  pin 4				0: Genlock active 	1: Preset active
				// 4   ->  pin 6				0: External genlock	1: Internal genlock
				// 7   ->  pin 9				0: Remote enable		1: Remote disable

				i = IIC1_Read( ttl_addr);

				if ( i != ParallelRemoteStatus) {
					ParallelRemoteStatus = i;

					if ( ParallelRemoteStatus & 0x80)
						ParallelRemoteActive = OFF;
					else
						ParallelRemoteActive = ON;

					if ( ParallelRemoteActive) {

						if ( MenuModeOn) {
							if ( SelectModeOn) {		// If in selection mode..
								Ptr->EscapeFct();		//  be sure to terminate NICELY!!
								Ptr->DispFunct();
							}

							UpToStatus();			// Update ptr to status-display
							Ptr->DispFunct();		// Display status-display
						}

						if ( ParallelRemoteStatus & 0x08) {		// Preset active

							ActivePresetNo = (UC) ( ParallelRemoteStatus & 0x07);

							ConfigurePreset( ActivePresetNo++);

							StatusNdx = StatusPresetItem;
						}
						else {											// Genlock active
							if ( ParallelRemoteStatus & 0x10)
								ActiveGenlockNo = Internal;
							else
								ActiveGenlockNo = ExternalGenlockNo;

							GenlockUnitDrv( ActiveGenlockNo, GenlockConfig[ActiveGenlockNo].System);

							StatusNdx = StatusGenlockItem;
						}

						PrevPtr = Ptr;
						Ptr = &status_menu[StatusNdx];

						if ( !MessageWindowOn)
							Ptr->DispFunct();
					}
				}
				i = 0xFF;							// Set Genlock & warning output

				if ( Warning_LED)
					i &= 0xBF;

				if ( Unlocked_LED)
					i &= 0xDF;

				IIC1_Write( ttl_addr, i);
			}
		}
	}
}