; @(#)smodl.src	1.3 7/22/97
INCLUDE	'HEAD'

		NAME _SMODL

DEFINE	_sp	"R7"	; stack pointer
DEFINE	_a	"R1"	; operand 1 high word
DEFINE	_b	"R0"	; operand 1 low  word
DEFINE	_x	"R3"	; operand 2 high word
DEFINE	_y	"R2"	; operand 2 low  word
DEFINE	_aa	"_a"	; result high word
DEFINE	_bb	"_b"	; reslut low word
DEFINE	_tx	"_x"	; temporary storage x
DEFINE	_ty	"_y"	; temporary storage y

IF	MODEL_LARGE || MODEL_MEDIUM
	EXTRN	HCODE(__UMODL)
ELSE
	EXTRN	CODE(__UMODL)
ENDIF

CODE_SEG_DEF
		RSEG	LIBRT_PR
;
		PUBLIC	__SMODL
;************************************************************************
;*									*
;*		SMODL							*
;*									*
;*	this routine provides an 32 bit by 32 bit signed modulo		*
;*	at entry:	R0D		the dividend (a:b)		*
;*			R2D		the divisor (x:y)		*
;*									*
;*	at exit:	R0D		the 32 bit remainder		*
;*									*
;*	destroys:	R0D,R2D						*
;*									*
;*	modulo algorithm: a:b = a:b mod x:y = a:b - ( a:b / x:y ) * x:y	*
;*									*
;************************************************************************
__SMODL:				; signed modulo long
	SUB.W	_sp,#02H		; increment user stack pointer
	MOV.W	[_sp],#00H		; set result sign on user stack to zero
	OR.W	_a,_a			; if( most significant bit dividend NOT set )
	BPL	OP1P			; then dividend is positive
					; else negate dividend
	CPL.W	_b			; neg b
	CPL.W	_a			; neg a
	ADD.W	_b,#01H			;
	ADDC.W	_a,#00H			;
	PUSH.W	_a			; push a on user stack
	MOV.W	_a,[_sp+02H]		; get result sign from user stack to a
	CPL.W	_a			; invert result sign
	MOV.W	[_sp+02H],_a		; move result sign back to user stack
	POP.W	_a			; pop a from user stack
OP1P:	OR.W	_x,_x			; if( most significant bit divisor NOT set )
	BPL	OP2P			; then divisor is positive
					; else negate divisor
	CPL.W	_y			; neg y
	CPL.W	_x			; neg x
	ADD.W	_y,#01H			;
	ADDC.W	_x,#00H			;
OP2P:	GCALL	__UMODL			; call common unsigned modulo long
					; a is result high word
					; b is result low word
					; y and x are free now
	POP.W	_x			; pop result sign from user stack
	OR.W	_x,_x			; if( result sign bit not set  )
	BEQ	POS			; then result is positive
					; else negate result
	CPL.W	_bb			; neg result low word
	CPL.W	_aa			; neg result high word
	ADD.W	_b,#01H			;
	ADDC.W	_a,#00H			;
POS:	RET				; and return

	END
