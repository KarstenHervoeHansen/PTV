/*---------------------------------------------------------------*/
/*               Welcome to the XVWXA tutorial!                 */
/* Remember: After each command is displayed, hit a carriage     */
/* return to execute the command and advance the tutorial, or    */
/* hit 'q' followed by a carriage return to quit the tutorial.   */
/*---------------------------------------------------------------*/
;/* here are your options --> */
/*---------------------------------------------------------------*/
/* Let's get started right away by establishing a viewing        */
/* position in the Source window at the first executable         */
/* statement in the function 'main().'                           */
/*---------------------------------------------------------------*/
e main
/*---------------------------------------------------------------*/
/* Note that XVW has identified line 47 as our current viewing   */
/* position in the Source window above.  We can set an execution */
/* breakpoint at the current line by using the 'b' command.      */
/*---------------------------------------------------------------*/
b
/*---------------------------------------------------------------*/
/* Line 47 now shows a 'B' indicating that there is a breakpoint */
/* set at that line.  Now we will reset the target system and    */
/* run the program from the beginning using the 'R' command.     */
/* First download the executable code.				 */
/*---------------------------------------------------------------*/
dn; R
/*---------------------------------------------------------------*/
/* We have executed the startup code which calls main() and have */
/* stopped at the breakpoint we set.  Now let's take a closer    */
/* look at some of XVW's windows.  'w d' activates the Data      */
/* window which can be used to display monitored expressions.    */
/*---------------------------------------------------------------*/
w d
/*---------------------------------------------------------------*/
/* Note that the name of the active window is highlighted.  The  */
/* 'w r' command takes us to the Register window which shows the */
/* values of the registers.                                      */
/*---------------------------------------------------------------*/
w r
/*---------------------------------------------------------------*/
/* 'w k' activates the Stack window which shows the functions    */
/* on the stack and their parameters.                            */
/*---------------------------------------------------------------*/
w k
/*---------------------------------------------------------------*/
/* 'w c' activates the Composite window which shows monitored    */
/* data, the registers and the stack all at the same time.       */
/*---------------------------------------------------------------*/
w c
/*---------------------------------------------------------------*/
/* From a Composite subwindow, you can use the 'z' command to    */
/* 'zoom' to the wide format of that window...                   */
/*---------------------------------------------------------------*/
z
/*---------------------------------------------------------------*/
/* ... and zoom back to the Composite window.                    */
/*---------------------------------------------------------------*/
z
/*---------------------------------------------------------------*/
/* Use the 'w a' command to change the Source window to the      */
/* Assembly window: You'll get a more detailed look on the code. */
/*---------------------------------------------------------------*/
w a
/*---------------------------------------------------------------*/
/* Using the 'w n' (window next) command is another way to move  */
/* from one window to the next.                                  */
/*---------------------------------------------------------------*/
w n
/*---------------------------------------------------------------*/
/* (You can also activate each Composite subwindow directly with */
/* the 'w cd' (Composite Data), 'w cr' (Composite Register) and  */
/* 'w ck' (Composite Stack) commands.  You can scroll up in an   */
/* active window with '-' or the 'cursor up' key.                */
/*---------------------------------------------------------------*/
-
-
-
-
-
/*---------------------------------------------------------------*/
/* ... and scroll down with '+' or the 'cursor down' key.        */
/*---------------------------------------------------------------*/
+
+
+
+
+
w n
/*---------------------------------------------------------------*/
/* 'w s' will activate the Source window.                        */
/*---------------------------------------------------------------*/
w s
/*---------------------------------------------------------------*/
/* You can change the foreground and background colors of        */
/* windows with the 'co' command.  Here we will make color #4    */
/* (red) be the color of the background of the stack window:     */
/*---------------------------------------------------------------*/
4 co b k
/*---------------------------------------------------------------*/
/* And now we will change it back to magenta (color #5):         */
/* (Please read more in the XVW manual about using function keys */
/* to change colors.)                                            */
/*---------------------------------------------------------------*/
5 co b k
/*---------------------------------------------------------------*/
/* You can change the heights of the windows with the 'WW'       */
/* command.  The syntax is <top-height> WW <middle-height> where */
/* <top-height> and <middle-height> are the heights in lines of  */
/* the top and middle windows, respectively.  For example, you   */
/* could eliminate the top window entirely by typing:            */
/*---------------------------------------------------------------*/
0 WW 15
/*---------------------------------------------------------------*/
/* Let's get back to the original window heights:                */
/*---------------------------------------------------------------*/
5 WW 10
/*---------------------------------------------------------------*/
/* In this program, the routines mygetchar() and myputs() call   */
/* the routines _simi() and _simo() to perform simulated I/O. We */
/* can use the following 'sio' commands to tell XVW to read      */
/* simulated input from the screen for stream 0...               */
/*---------------------------------------------------------------*/
0 sio i screen
/*---------------------------------------------------------------*/
/* ...and to write simulated output to the screen for stream 1.  */
/*---------------------------------------------------------------*/
1 sio o screen
/*---------------------------------------------------------------*/
/* (Please read more about simulated I/O in the User's Manual.)  */
/*---------------------------------------------------------------*/
;
/*---------------------------------------------------------------*/
/* In the Source window, XVW always points to the next statement */
/* to be executed.  To single step through execution by one C    */
/* statement we can use the 's' command.                         */
/*---------------------------------------------------------------*/
s
/*---------------------------------------------------------------*/
/* We can check that the statement executed correctly.  To       */
/* display the value of the variable 'initval' we simply type    */
/* its name:                                                     */
/*---------------------------------------------------------------*/
initval
;
/*---------------------------------------------------------------*/
/* (If you want to display a variable whose name is the same as  */
/* an XVW command, you simply type 'name/n' instead of 'name'.)  */
/*---------------------------------------------------------------*/
;
/*---------------------------------------------------------------*/
/* Here is how the structure 'recordvar' is displayed.  Notice   */
/* that character arrays are displayed as addresses and that     */
/* enumeration types values are displayed as you would hope.     */
/*---------------------------------------------------------------*/
recordvar
;
/*---------------------------------------------------------------*/
/* We can use the '/x' format to display a value in hex.         */
/* (See the manual for a complete list of available formats.)    */
/*---------------------------------------------------------------*/
initval/x
;
/*---------------------------------------------------------------*/
/* The character '.' can be used in expressions as shorthand for */
/* the value of the last expression evaluated:                   */
/*---------------------------------------------------------------*/
. * 7 + 1
;
/*---------------------------------------------------------------*/
/* If you type a double-quoted string as an XVW command, XVW     */
/* will echo the string.  You can use strings to display useful  */
/* messages without using printf().                              */
/*---------------------------------------------------------------*/
"hello, world\n"
/*---------------------------------------------------------------*/
/* It's easy to change the value of a variable:  Just type the   */
/* assignment as you would write it in C:                        */
/*---------------------------------------------------------------*/
sum = 23
;
/*---------------------------------------------------------------*/
/* You can even assign entire structures to one another if they  */
/* are of the same type:                                         */
/*---------------------------------------------------------------*/
statrec = recordvar
;
/*---------------------------------------------------------------*/
/* The value of a register can be used in expressions by         */
/* prefixing its name with a '$' (dollar sign):                  */
/*---------------------------------------------------------------*/
4 * $CS + sum
;
/*---------------------------------------------------------------*/
/* You can create new variables, with names beginning with a     */
/* dollar sign, just by referring to them.  You can use these    */
/* 'special variables' in any C expressions.                     */
/*---------------------------------------------------------------*/
$mynewvar = 250
;
/*---------------------------------------------------------------*/
/* Now we will single step through 24 more statements:           */
/* The 's' command will step into functions rather than treating */
/* function calls as one statement.                              */
/*---------------------------------------------------------------*/
27 s
/*---------------------------------------------------------------*/
/* We are now inside the recursive function 'factorial.' Let's   */
/* look at the expanded version of the Stack window.             */
/*---------------------------------------------------------------*/
w k
/*---------------------------------------------------------------*/
/* The numbers at the left in the Stack window are stack depth   */
/* values.  The current function is always at stack level 0.     */
/* Look what happens if we try to display a variable that is out */
/* of scope:                                                     */
/*---------------------------------------------------------------*/
sum
;
/*---------------------------------------------------------------*/
/* But, because 'sum' is local to main(), and main() is on the   */
/* stack, we can display 'sum' by qualifying its name with its   */
/* function name...                                              */
/*---------------------------------------------------------------*/
main#sum
;
/*---------------------------------------------------------------*/
/* ...or like this, using its stack level:                       */
/*---------------------------------------------------------------*/
2#sum
;
/*---------------------------------------------------------------*/
/* Suppose we want to continue executing until we return to      */
/* main().  First, we can set an 'up-level' breakpoint in        */
/* main(), using its stack level (2) with the bU command:        */
/*---------------------------------------------------------------*/
2 bU
/*---------------------------------------------------------------*/
/* Then we continue, using the 'C' command:                      */
/*---------------------------------------------------------------*/
C
/*---------------------------------------------------------------*/
/* If we use 'S' instead of 's' a function call is treated as    */
/* a single statement for single stepping.                       */
/*---------------------------------------------------------------*/
3 S
/*---------------------------------------------------------------*/
/* Let's continue, setting a temporary breakpoint at line 74:    */
/*---------------------------------------------------------------*/
C 74
/*---------------------------------------------------------------*/
/* Our program has executed some simulated output and has        */
/* activated the Simulated I/O window.  The program is supposed  */
/* to print 'pass' here, but it shows 'fail.' There must be a    */
/* bug in the program.  What is the value of 'sum'?              */
/*---------------------------------------------------------------*/
sum
;
/*---------------------------------------------------------------*/
/* That's wrong.  Let's go back to the Composite window.         */
/*---------------------------------------------------------------*/
w c
/*---------------------------------------------------------------*/
/* If we monitor the variables 'sum' and 'initval' using the 'm' */
/* command, we can watch their values change each time execution */
/* stops, either by hitting a breakpoint or single stepping.     */
/*---------------------------------------------------------------*/
m sum/d
m initval/d
/*---------------------------------------------------------------*/
/* Now we'll run from the beginning again:                       */
/*---------------------------------------------------------------*/
R
/*---------------------------------------------------------------*/
/* We will continue past the breakpoint we set earlier and stop  */
/* at line 63:                                                   */
/*---------------------------------------------------------------*/
C 63
/*---------------------------------------------------------------*/
/* Look in the Data window at the values of 'sum' and            */
/* 'initval.'  They are not correct. Let's start execution again */
/* and single step:                                              */
/*---------------------------------------------------------------*/
R; s
/*---------------------------------------------------------------*/
/* We can check if the variable 'initval' is written to:         */
/*---------------------------------------------------------------*/
60 b {Q; if (initval == 17) {C} {}}
/*---------------------------------------------------------------*/
/* Now we will continue execution:                               */
/*---------------------------------------------------------------*/
C
;
/*---------------------------------------------------------------*/
/* Perhaps the assignment to table[loopvar] wrote into initval.  */
/* What is the value of loopvar?                                 */
/*---------------------------------------------------------------*/
loopvar
;
/*---------------------------------------------------------------*/
/* How is table declared?  The '/t' format shows us the type of  */
/* any variable or expression.                                   */
/*---------------------------------------------------------------*/
table/t
;
/*---------------------------------------------------------------*/
/* The array table has only elements 0-7. The assignment to      */
/* table[8] wrote into initval!  We can confirm that the address */
/* of table[8] is the address of initval by evaluating this      */
/* boolean expression:                                           */
/*---------------------------------------------------------------*/
&table[8] == &initval
;
/*---------------------------------------------------------------*/
/* The upper limit of the for loop should really be '< 8'        */
/* instead of '<= 8.'  We can patch this problem by putting a    */
/* breakpoint at line 68 which has a command list.  When line 68 */
/* is hit, the commands in the list will be executed.  The       */
/* commands may be XVW commands and/or C expressions.            */
;
/* The breakpoint will test whether 'loopvar' is greater than or */
/* equal to 8.  If it is, the commands 'g 72' (change executing  */
/* position to line 72) and 'C' (continue) will be executed;     */
/* otherwise, just 'C' (continue) will be executed.              */
;
/* The 'Q' command suppresses the default echoing of the source  */
/* line when the breakpoint is hit.                              */
/*---------------------------------------------------------------*/
59 b {Q; if (loopvar >= 8) {g 63; C} {C}}
/*---------------------------------------------------------------*/
/* Now that we think we've found the source of the bug we can    */
/* delete the previous breakpoint. To display a pop-up window    */
/* which shows our breakpoints, use the 'w b' command...         */
/*---------------------------------------------------------------*/
w b
/*---------------------------------------------------------------*/
/* ... and then delete breakpoint number 3.                      */
/*---------------------------------------------------------------*/
3 d
/*---------------------------------------------------------------*/
/* We can remove 'initval' from the Data window by using         */
/* its expression id number (at the left in the Data window)     */
/* and the 'm d' (monitor delete) command:                       */
/*---------------------------------------------------------------*/
1 m d
/*---------------------------------------------------------------*/
/* Now let's run the program again from the beginning:           */
/*---------------------------------------------------------------*/
R
/*---------------------------------------------------------------*/
/* We'll continue past the first breakpoint up to line 74 again. */
/* Notice how 'sum' is updated in the Data window each time      */
/* the breakpoint is hit.                                        */
/*---------------------------------------------------------------*/
C 74
/*---------------------------------------------------------------*/
/* It worked!  Now, let's continue executing the program. NOTE:  */
/* THE PROGRAM WILL SEEM TO 'HANG.'  A FEW SECONDS AFTER YOU HIT */
/* THE CARRIAGE RETURN, PLEASE INTERRUPT EXECUTION BY HITTING    */
/* CTRL-C OR BREAK.                                              */
/*---------------------------------------------------------------*/
C
/*---------------------------------------------------------------*/
/* After you interrupt program execution, XVW updates your       */
/* viewing and executing positions.  We were in an infinite      */
/* loop.  We can create a patch which skips over this loop       */
/* by setting a breakpoint at line 78 with a command list        */
/* containing the commands 'loopvar = 0' and 'C' (continue):     */
/*---------------------------------------------------------------*/
78 b {loopvar = 0; C}
/*---------------------------------------------------------------*/
/* Let's run again, continuing past the first breakpoint up to   */
/* a temporary breakpoint at line 86.                            */
/*---------------------------------------------------------------*/
w c
R; C 86;
/*---------------------------------------------------------------*/
/* Now we will step by one machine instruction at a time, using  */
/* the 'si' command, into the function addone() which was        */
/* written in assembly language source:                          */
/*---------------------------------------------------------------*/
si
/*---------------------------------------------------------------*/
/* When Special Variable $autosrc is enabled, Source window and  */ 
/* Assembly window are toggled automatically.                    */
/*---------------------------------------------------------------*/
$autosrc="on"
2 si
s
/*---------------------------------------------------------------*/
/* It's always possible to display the disassembled code for any */
/* source statement in the program.  Suppose you want to see the */
/* disassembly for the first 3 machine instructions starting at  */
/* the address corresponding to line 66 of main().  Just type:   */
/*---------------------------------------------------------------*/
main#66/3i
;
/*---------------------------------------------------------------*/
/* main#66 will evaluate to the address corresponding to line 66 */
/* in main().  The format '/3i' indicates that you want to see   */
/* the data there as 3 disassembled instructions.  If you want   */
/* those instructions to be displayed interleaved with any C     */
/* statements, use the 'I' format character instead of 'i':      */
/*---------------------------------------------------------------*/
main#66/3I
;
/*---------------------------------------------------------------*/
/* This program is supposed to compute the factorials from 0 to  */
/* 7 and put them in the array 'table.' In C, the 'value' of an  */
/* array is its address (shown here in hex):                     */
/*---------------------------------------------------------------*/
table
;
/*---------------------------------------------------------------*/
/* XVW is very flexible about displaying memory in many formats. */
/* If you want to see the contents of the array 'table'          */
/* displayed as 8 decimal values, each 4 bytes long, you type:   */
/*---------------------------------------------------------------*/
table/8d4
;
/*---------------------------------------------------------------*/
/* If, for some reason, you want to see the memory beginning at  */
/* 'table' displayed as 5 octal values, each 1 byte long,        */
/* you type:                                                     */
/*---------------------------------------------------------------*/
table/5o1
;
/*---------------------------------------------------------------*/
/* The next part of the program performs simulated input and     */
/* output.  When you see the prompt in the SIO window, XVW is    */
/* waiting for you to type either 'y' or 'n' followed by a       */
/* carriage return.                                              */
/*---------------------------------------------------------------*/
C 95
;
/*---------------------------------------------------------------*/
/*                         MACROS                                */
/* With macros you can  tell XVW to replace every occurrence of  */
/* a particular string it sees in a command line with some other */
/* string or strings.                                            */
/*---------------------------------------------------------------*/
;
/*---------------------------------------------------------------*/
/* For example, you might decide that you want to be able to     */
/* type 'run' instead of the XVW command 'R' to reset the        */
/* target system and run.  You can define a macro like this:     */
/*---------------------------------------------------------------*/
set run "R"
/*---------------------------------------------------------------*/
/* Now, if you type 'run' it will have the same effect as typing */
/* 'R'.  You can use this macro, 'run', anywhere in an XVW       */
/* command line, even in a breakpoint command list.  You can use */
/* macros to customize XVW command names to any names of your    */
/* choosing!                                                     */
/*---------------------------------------------------------------*/
run
;
/*---------------------------------------------------------------*/
/* Most programs make significant use of #define'd preprocessor  */
/* constants such as this one from our demo program:             */
/*             #define INPUT_STREAM 0                            */
/* Because 'INPUT_STREAM' is a preprocessor name and not a name  */
/* in the symbol table, most debuggers will not recognize it:    */
/*---------------------------------------------------------------*/
INPUT_STREAM
;
/*---------------------------------------------------------------*/
/* But if you create a macro with the name 'INPUT_STREAM' and    */
/* make it equivalent to '0', XVW will let you use it in         */
/* expressions:                                                  */
/*---------------------------------------------------------------*/
set INPUT_STREAM "3"
4 * INPUT_STREAM + 15
;
/*---------------------------------------------------------------*/
/* You can also create macros which take parameters. You can use */
/* $1, $2, $3, etc. in a macro definition to refer to the first, */
/* second, third, etc. parameters passed to the macro.           */
/*---------------------------------------------------------------*/
;
/*---------------------------------------------------------------*/
/* The following defines a macro called 'add' which takes three  */
/* parameters and adds them together.                            */
/*---------------------------------------------------------------*/
set add "$1 + $2 + $3"
add(55, 29, 64)
;
/*---------------------------------------------------------------*/
/* You might want to create macros which set up frequently-used  */
/* window configurations:                                        */
/*---------------------------------------------------------------*/
set w1 "0 WW 15; w s"
set w2 "w c; 12 WW 6"
set w3 "5 WW 10"
w1
w2
w3
/*---------------------------------------------------------------*/
/* You can use the 'w m' command to look at all of your macros   */
/* in a pop-up window.                                           */
/*---------------------------------------------------------------*/
w m
/*---------------------------------------------------------------*/
/* The 'echo' command will show you the macro expansion of an    */
/* XVW command line without executing it:                        */
/*---------------------------------------------------------------*/
echo add(loopvar,3,sum)
;
/*---------------------------------------------------------------*/
/* It's easy to save all of your current macros to a file: just  */
/* type 'save <filename>' as in the example below:               */
/*---------------------------------------------------------------*/
save mymacros
;
/*---------------------------------------------------------------*/
/* If you need to type a name which is also a macro and you      */
/* don't want macro expansion performed on the name, use the '!' */
/* character immediately after the name.  You need to do this if */
/* you want to eliminate a macro, using the 'unset' command:     */
/*---------------------------------------------------------------*/
unset INPUT_STREAM!
/*---------------------------------------------------------------*/
/* During this debugging session we have made a number of        */
/* temporary fixes to our program by using breakpoints.  It      */
/* would be helpful to have a list of these breakpoints saved to */
/* a file on disk.                                               */
/*---------------------------------------------------------------*/
;
/*---------------------------------------------------------------*/
/* The '>>' command will start recording the contents of the     */
/* command window -- including commands typed and their output   */
/* -- to a designated file.  We have chosen the name 'fixes.'    */
/*---------------------------------------------------------------*/
;
>>fixes
/*---------------------------------------------------------------*/
/* Now, the following 'B' command (display breakpoints in the    */
/* command window) and its output will be written to 'fixes.'    */
/*---------------------------------------------------------------*/
B
/*---------------------------------------------------------------*/
/* To close the output file, we use the command '>>c.'           */
/*---------------------------------------------------------------*/
>>c
/*---------------------------------------------------------------*/
/* At any time in XVW you can execute a shell command by         */
/* preceding it with a '!' (exclamation point).  To look at the  */
/* file 'fixes' without leaving XVW you would type:              */
/*---------------------------------------------------------------*/
!more < fixes
;
/*---------------------------------------------------------------*/
/* (If you type '!' alone as a command, you will start a new     */
/* shell.  After executing as many shell commands as you would   */
/* like, you return to XVW by typing 'exit'.)                    */
/*---------------------------------------------------------------*/
;
/*---------------------------------------------------------------*/
/* When output recording is on, you may want to save information */
/* you see displayed in the non-command windows, such as         */
/* registers, stack, breakpoints and macros.              	 */
;
/* For this purpose there are some commands which will           */
/* display this information in the command window where it can   */
/* be captured when output recording is on.                      */
;
/* You have already seen the 'B' (list breakpoints), 'l r' (list */
/* registers) and 't' (stack trace) commands which write to the  */
/* command window instead of to one of the other windows.        */
;
/* The 'set' command (with no arguments) displays all of your    */
/* macros in the command window.                                 */
/*---------------------------------------------------------------*/
set
;
/*---------------------------------------------------------------*/
/* Let's continue up to a temporary breakpoint at line 60...     */
/*---------------------------------------------------------------*/
C 60
/*---------------------------------------------------------------*/
/* If we want to save only commands (without their output) to a  */
/* file, we use the '>' command.  Let's save a sequence of       */
/* commands to the file 'cmds.'                                  */
/*---------------------------------------------------------------*/
>cmds
e main
b
R
s
/*---------------------------------------------------------------*/
/* To close a file opened with '>' we use the '>c' command:      */
/*---------------------------------------------------------------*/
>c
/*---------------------------------------------------------------*/
/* Here's what is in 'cmds.'  Note: only commands were saved:    */
/*---------------------------------------------------------------*/
!more < cmds
;
/*---------------------------------------------------------------*/
/* Command files like 'cmds' can be read in either all at once,  */
/* using the '<' command, or in 'single step' mode, using the    */
/* '<<' command.  This tutorial is actually just a command file  */
/* which you are executing in single step mode.                  */
/*---------------------------------------------------------------*/
;
/*---------------------------------------------------------------*/
/* Let's run from the beginning again:                           */
/*---------------------------------------------------------------*/
2 d;2 d;R
;
/*---------------------------------------------------------------*/
/*                       ASSERTIONS                              */
/* An assertion is a list of commands which will be executed     */
/* after every C statement.  Assertions give you a powerful way  */
/* to track down hard-to-find bugs in your program.  The syntax  */
/* for creating an assertion is 'a <cmd-list>' where <cmd-list>  */
/* is a list of commands and/or C expressions.                   */
;
/* You might want to have XVW check whether a particular         */
/* variable goes out of an acceptable range.  You can also use   */
/* assertions to generate statistics about the execution of      */
/* your program.                                                 */
;
/* It is possible to create an assertion which exits assertion   */
/* mode when some condition becomes true (such as a variable     */
/* going out of range.  The 'x' command causes an exit from      */
/* assertion mode.  Here we will use 'x' in an assertion to exit */
/* assertion mode when 'loopvar' in main() is equal to 1:        */
a if (main#loopvar == 1) {x}
/*---------------------------------------------------------------*/
/* When you run a program with assertions active, you are said   */
/* to be running in 'assertion mode.'  In this mode, breakpoints */
/* are ignored.  Let's continue running the program and          */
/* watch our assertion execute after each statement until        */
/* loopvar becomes 1:                                            */
/*---------------------------------------------------------------*/
C
;
/*---------------------------------------------------------------*/
/* You can list your assertions with the 'l a' command:          */
/*---------------------------------------------------------------*/
l a
/*---------------------------------------------------------------*/
/* To delete an assertion, give its id number and 'a d':         */
/*---------------------------------------------------------------*/
0 a d
/*---------------------------------------------------------------*/
/* (You can also temporarily suspend and re-activate any or all  */
/* assertions.  Please read more about assertions in the XVW     */
/* User's Manual.)                                               */
/*---------------------------------------------------------------*/
;
/*---------------------------------------------------------------*/
/* To get a history of the last commands you have executed, use  */
/* 'h' (history) command.                                        */
/*---------------------------------------------------------------*/
h
/*---------------------------------------------------------------*/
/* (You can re-execute a command by preceding its history number */
/* with a '#' sign.  This can save a lot of typing.)             */
/*---------------------------------------------------------------*/
;
/*---------------------------------------------------------------*/
/* Remember that on-line help is always available.  You can type */
/* 'help' which will bring up a pop-up window with one-line      */
/* descriptions of commands.  You can move up and down through   */
/* the list for the command you want and then hit a carriage     */
/* return to get a full manual page of help for a command.       */
/*---------------------------------------------------------------*/
;
/*---------------------------------------------------------------*/
/* You can also ask for help on a specific command by typing     */
/* 'help <cmd>' where <cmd> is the name of a command.            */
/*---------------------------------------------------------------*/
;
/*---------------------------------------------------------------*/
/*               This is the end of the tutorial.                */
/*                Good luck and happy debugging!                 */
/*---------------------------------------------------------------*/
/* @(#)demo.tut	1.2 */
