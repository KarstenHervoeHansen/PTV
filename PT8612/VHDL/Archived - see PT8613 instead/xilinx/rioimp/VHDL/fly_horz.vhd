-------------------------------------------------------------------------------- 
-- Copyright (c) 2004 Xilinx, Inc. 
-- All Rights Reserved 
-------------------------------------------------------------------------------- 
--   ____  ____ 
--  /   /\/   / 
-- /___/  \  /   Vendor: Xilinx 
-- \   \   \/    Author: John F. Snow, Advanced Product Division, Xilinx, Inc.
--  \   \        Filename: $RCSfile: fly_horz.vhd,rcs $
--  /   /        Date Last Modified:  $Date: 2004-12-15 16:14:48-07 $
-- /___/   /\    Date Created: March 31, 2002
-- \   \  /  \ 
--  \___\/\___\ 
-- 
--
-- Revision History: 
-- $Log: fly_horz.vhd,rcs $
-- Revision 1.0  2004-12-15 16:14:48-07  jsnow
-- Header update.
--
-------------------------------------------------------------------------------- 
--   
--   XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" 
--   AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND 
--   SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, 
--   OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, 
--   APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION 
--   THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT, 
--   AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE 
--   FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY 
--   WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE 
--   IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR 
--   REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF 
--   INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
--   FOR A PARTICULAR PURPOSE. 
--
-------------------------------------------------------------------------------- 
-- 
-- This module implements the horizontal logic for the video flywheel.
-- 
-- The module contains the horizontal counter. This counter keeps track of the
-- current horizontal position of the video. The module also generates the H 
-- signal. The H signal is asserted during the inactive portion of each scan 
-- line.
-- 
-- This module has the following inputs:
-- 
-- clk: clock input
-- 
-- rst: asynchronous reset
-- 
-- ce: clock enable
-- 
-- clr_hcnt: When this input is asserted, the horizontal counter is cleared.
-- 
-- resync_hcnt: When this input is asserted, the horizontal counter is reloaded
-- with the position of the EAV symbol. This happens during synchronous 
-- switches.
-- 
-- std: The video standard input code.
-- 
-- The module generates the following outputs:
-- 
-- hcnt: This is the value of the horizontal counter and indicates the current
-- horizontal positon of the video.
-- 
-- eav_next: Asserted the clock cycle before it is time for the flywheel to
-- generate the first word of an EAV symbol.
-- 
-- sav_next: Asserted the clock cycle before it is time for the flywheel to 
-- generate the first word of an SAV symbol.
-- 
-- h: This is the horizontal blanking bit.
-- 
-- trs_word: A 2-bit code indicating which word of the TRS symbol should be
-- generated by the flywheel.
-- 
-- fly_trs: Asserted during the first word of a flywheel generated TRS symbol.
-- 
-- fly_eav: Asserted during the XYZ word of a flywheel generated EAV symbol.
-- 
-- fly_sav: Asserted during the XYZ word of a flywheel generated SAV symbol.
--
-------------------------------------------------------------------------------- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_arith.all;
use ieee.numeric_std.all;

entity fly_horz is
    generic (
        HCNT_WIDTH: integer := 12);
    port (
        clk:          in    std_ulogic;                     -- clock input
        rst:          in    std_ulogic;                     -- async reset input
        ce:           in    std_ulogic;                     -- clock enable
        clr_hcnt:     in    std_ulogic;                     -- clears the horizontal counter
        resync_hcnt:  in    std_ulogic;                     -- resynchronizes the hcnt during sync switch
        std:          in    std_ulogic_vector(2 downto 0);  -- indicates current video standard
        hcnt:         out   std_logic_vector(HCNT_WIDTH - 1 downto 0); -- horizontal counter
        eav_next:     inout std_ulogic;                     -- asserted when next word is first word of EAV
        sav_next:     inout std_ulogic;                     -- asserted when next word is first word of SAV
        h:            inout std_ulogic;                     -- horizontal blanking indicator
        trs_word:     inout std_logic_vector(1 downto 0);   -- indicates word # of current TRS word
        fly_trs:      out   std_ulogic;                     -- asserted during first word of flywheel generated TRS
        fly_eav:      out   std_ulogic;                     -- asserted during xyz word of flywheel generated EAV
        fly_sav:      inout std_ulogic);                    -- asserted during xyz word of flywheel generated SAV
end;

architecture synth of fly_horz is

subtype hposition is std_logic_vector(HCNT_WIDTH - 1 downto 0);
subtype stdcode   is std_ulogic_vector(2 downto 0);

-------------------------------------------------------------------------------
-- Constant definitions
--

--
-- This group of constants defines the bit widths of various fields in the
-- module. 
--
constant HCNT_MSB :             integer := HCNT_WIDTH - 1;  -- MS bit # of hcnt

--
-- This group of constants defines the starting position of the EAV symbol
-- for the various supported video standards.
--
constant EAV_LOC_NTSC_422 :      hposition := std_logic_vector(TO_UNSIGNED(1440, HCNT_WIDTH));
constant EAV_LOC_NTSC_422_WIDE : hposition := std_logic_vector(TO_UNSIGNED(1920, HCNT_WIDTH));
constant EAV_LOC_NTSC_4444 :     hposition := std_logic_vector(TO_UNSIGNED(2880, HCNT_WIDTH));
constant EAV_LOC_PAL_422 :       hposition := std_logic_vector(TO_UNSIGNED(1440, HCNT_WIDTH));
constant EAV_LOC_PAL_422_WIDE :  hposition := std_logic_vector(TO_UNSIGNED(1920, HCNT_WIDTH));
constant EAV_LOC_PAL_4444 :      hposition := std_logic_vector(TO_UNSIGNED(2880, HCNT_WIDTH));

--
-- This group of constants defines the starting position of the SAV symbol
-- for the various supported video standards.
--
constant SAV_LOC_NTSC_422 :      hposition := std_logic_vector(TO_UNSIGNED(1712, HCNT_WIDTH));
constant SAV_LOC_NTSC_422_WIDE : hposition := std_logic_vector(TO_UNSIGNED(2284, HCNT_WIDTH));
constant SAV_LOC_NTSC_4444 :     hposition := std_logic_vector(TO_UNSIGNED(3428, HCNT_WIDTH));
constant SAV_LOC_PAL_422 :       hposition := std_logic_vector(TO_UNSIGNED(1724, HCNT_WIDTH));
constant SAV_LOC_PAL_422_WIDE :  hposition := std_logic_vector(TO_UNSIGNED(2300, HCNT_WIDTH));
constant SAV_LOC_PAL_4444 :      hposition := std_logic_vector(TO_UNSIGNED(3452, HCNT_WIDTH));

--
-- This group of constants defines the encoding for the video standards output
-- code.
--
constant NTSC_422:          stdcode := "000";
constant NTSC_INVALID:      stdcode := "001";
constant NTSC_422_WIDE:     stdcode := "010";
constant NTSC_4444:         stdcode := "011";
constant PAL_422:           stdcode := "100";
constant PAL_INVALID:       stdcode := "101";
constant PAL_422_WIDE:      stdcode := "110";
constant PAL_4444:          stdcode := "111";

-------------------------------------------------------------------------------
-- Signal definitions
--

-- internal signals
signal hcount :     hposition;    -- horizontal counter
signal trs_next :   std_ulogic;   -- TRS symbol starts on next count
signal trs :        std_ulogic;   -- internal version of fly_trs signal
signal fly_xyz :    std_ulogic;   -- asserted during flywheel generated XYZ word
signal eav_loc :    hposition;    -- EAV location
signal sav_loc :    hposition;    -- SAV location
signal resync_val : hposition;    -- value to load on resync_hcnt

begin
    
    --
    -- hcount: horizontal counter
    --
    -- The horizontal counter increments every clock cycle to keep track of the
    -- current horizontal position. If clr_hcnt is asserted by the FSM, hcnt is
    -- reloaded with a value of 1. A value of 1 is used because of the latency
    -- involved in detected the TRS symbol and deciding whether to clear hcnt or
    -- not. If resync_hcnt is asserted, the horizontal coutner is loaded with
    -- resync_val, a value derived from the EAV position. This happens during
    -- synchronous switches. 
    --
    process(clk,rst)
    begin
        if (rst = '1') then
            hcount <= std_logic_vector(TO_UNSIGNED(1, HCNT_WIDTH));
        elsif (clk'event and clk = '1') then
            if (ce = '1') then
                if (resync_hcnt = '1') then
                    hcount <= resync_val;
                elsif (clr_hcnt = '1') then
                    hcount <= std_logic_vector(TO_UNSIGNED(1, HCNT_WIDTH));
                elsif (fly_sav = '1') then
                    hcount <= (others => '0');
                else
                    hcount <= hcount + 1;
                end if;
            end if;
        end if;
    end process;

    --
    -- TRS word counter
    --
    -- The TRS word counter is used to count out the words of a TRS symbol. A
    -- TRS symbol for component video is four words long.
    --
    -- During the TRS symbol the trs signal is asserted. During the XYZ word of
    -- a component video signal fly_xyz is asserted and one of fly_sav or 
    -- fly_eav.
    --
    process(clk, rst)
    begin
        if (rst = '1') then
            trs_word <= (others => '0');
        elsif (clk'event and clk = '1') then
            if (ce = '1') then
                if (trs_next = '1') then
                    trs_word <= (others => '0');
                else
                    trs_word <= trs_word + 1;
                end if;
            end if;
        end if;
    end process;

    process(clk, rst)
    begin
        if (rst = '1') then
            trs <= '0';
        elsif (clk'event and clk = '1') then
            if (ce = '1') then
                if (clr_hcnt = '1' or fly_xyz = '1' or resync_hcnt = '1') then
                    trs <= '0';
                elsif (trs_next = '1') then
                    trs <= '1';
                end if;
            end if;
        end if;
    end process;

    process(clk, rst)
    begin
        if (rst = '1') then
            fly_xyz <= '0';
        elsif (clk'event and clk = '1') then
            if (ce = '1') then
                if (clr_hcnt = '1') then
                    fly_xyz <= '0';
                elsif (trs = '1' and trs_word = "10") then
                    fly_xyz <= '1';
                else
                    fly_xyz <= '0';
                end if;
            end if;
        end if;
    end process;        
            
    fly_eav <= fly_xyz and h;
    fly_sav <= fly_xyz and not h;

    --
    -- TRS location detection
    --
    -- This block of code generates the eav_next and sav_next signals. These 
    -- signals are asserted the state before the flywheel will generate the 
    -- first word of the EAV or SAV TRS symbols.
    --
    process(std)
    begin
        case std is
            when NTSC_422 =>
                eav_loc <= EAV_LOC_NTSC_422 - 1;
                sav_loc <= SAV_LOC_NTSC_422 - 1;
                resync_val <= EAV_LOC_NTSC_422 + 2;

            when NTSC_422_WIDE =>
                eav_loc <= EAV_LOC_NTSC_422_WIDE - 1;
                sav_loc <= SAV_LOC_NTSC_422_WIDE - 1;
                resync_val <= EAV_LOC_NTSC_422_WIDE + 2;

            when NTSC_4444 =>
                eav_loc <= EAV_LOC_NTSC_4444 - 1;
                sav_loc <= SAV_LOC_NTSC_4444 - 1;
                resync_val <= EAV_LOC_NTSC_4444 + 2;

            when PAL_422 =>
                eav_loc <= EAV_LOC_PAL_422 - 1;
                sav_loc <= SAV_LOC_PAL_422 - 1;
                resync_val <= EAV_LOC_PAL_422 + 2;

            when PAL_422_WIDE =>
                eav_loc <= EAV_LOC_PAL_422_WIDE - 1;
                sav_loc <= SAV_LOC_PAL_422_WIDE - 1;
                resync_val <= EAV_LOC_PAL_422_WIDE + 2;

            when PAL_4444 =>
                eav_loc <= EAV_LOC_PAL_4444 - 1;
                sav_loc <= SAV_LOC_PAL_4444 - 1;
                resync_val <= EAV_LOC_PAL_4444 + 2;

            when others =>
                eav_loc <= EAV_LOC_NTSC_422 - 1;
                sav_loc <= SAV_LOC_NTSC_422 - 1;
                resync_val <= EAV_LOC_NTSC_422 + 2;
        end case;   
    end process;

    eav_next <= '1' when hcount = eav_loc else '0';
    sav_next <= '1' when hcount = sav_loc else '0';
    trs_next <= eav_next or sav_next;

    --
    -- h
    --
    -- This logic generates the H bit for the TRS XYZ word. The H bit becomes
    -- asserted at the start of EAV and is negated at the start of SAV. Note 
    -- that the h_blank output from the flywheel module is similar to the H bit,
    -- but remains asserted until after the last word of the SAV.
    --
    process(clk, rst)
    begin
        if (rst = '1') then
            h <= '0';
        elsif (clk'event and clk = '1') then
            if (ce = '1') then
                if (eav_next = '1' or resync_hcnt = '1') then
                    h <= '1';
                elsif (sav_next = '1' or clr_hcnt = '1') then
                    h <= '0';
                end if;
            end if;
        end if;
    end process;

    --
    -- output assignments
    --
    fly_trs <= trs;
    hcnt <= hcount;

end synth;