-------------------------------------------------------------------------------- 
-- Copyright (c) 2002 Xilinx, Inc. 
-- All Rights Reserved 
-------------------------------------------------------------------------------- 
--   ____  ____ 
--  /   /\/   / 
-- /___/  \  /   Vendor: Xilinx 
-- \   \   \/    Author: John F. Snow, Advanced Product Division, Xilinx, Inc.
--  \   \        Filename: $RCSfile: vidgen.vhd,rcs $
--  /   /        Date Last Modified:  $Date: 2004-08-27 13:23:32-06 $
-- /___/   /\    Date Created: January 7, 2002 
-- \   \  /  \ 
--  \___\/\___\ 
-- 
--
-- Revision History: 
-- $Log: vidgen.vhd,rcs $
-- Revision 1.1  2004-08-27 13:23:32-06  jsnow
-- Clock enable fixes.
--
-- Revision 1.0  2004-08-27 13:21:44-06  jsnow
-- Initial version.
--
-------------------------------------------------------------------------------- 
--   
--   XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" 
--   AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND 
--   SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, 
--   OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, 
--   APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION 
--   THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT, 
--   AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE 
--   FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY 
--   WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE 
--   IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR 
--   REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF 
--   INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
--   FOR A PARTICULAR PURPOSE. 
--
-------------------------------------------------------------------------------- 
-- 
-- This digital video test pattern generator is Block SelectRAM-based and is
-- designed to work with the RAM initialization files generated by the cbgen
-- utility.
-- 
-- This module uses three different block RAMS, one for vertical state machine, 
-- one for the horizontal state machine, and one for the video component 
-- generator. Since the block RAMs are dual-port in nature, two  independent 
-- pattern generators can be built using little more logic than is required to 
-- build one pattern generator. This module provides inputs and outputs for 
-- two pattern generators called the A and B pattern generators.
-- 
-- Each pattern generator has its own clock input, clock enable input, and 
-- pattern select input. Normally, the clock enable inputs (ce_a and ce_b) would
-- be tied high, but they can be controlled if the clock inputs are some 
-- multiple of the rate at which the pattern generator is to be cycled.
-- 
-- Note that since the video component generator block RAM is used in 9-bit wide
-- mode, the actual video component values generated by the pattern generator 
-- are really only 9-bit values. The least significant bit out of the RAM is 
-- used for the two LSBs of the video value coming out of the module. This 
-- results in LS bit errors in some video values (when compared to the SMPTE 
-- standard), but does results in correct values for all TRS symbols and for the
-- RP 178 test patterns. The code will support video output paths of 10 bits or
-- less. For wider paths, the code will need to be modified -- probably to 
-- use to block RAMs for the CROM to make it wider. The constant VID_MAX is set
-- to a value of 10 to indicate that the maximum video width for this code is
-- ten bits.
-------------------------------------------------------------------------------- 

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_arith.all;
use ieee.numeric_std.all;

--
-- If using ModelSim for simulation, you can include this library. If included
-- you should remove or comment out the component declaration for the
-- RAMB16_S18_S18 and RAMB16_S9_S9 components below.
--
library UNISIM;
use UNISIM.vcomponents.all;

entity vidgen is
    generic (
        VID_WIDTH : integer := 10                                   -- width of video output
    );
    port (
        -- signals for pattern generator A
        clk_a:      in  std_ulogic;                                 -- clock input
        rst_a:      in  std_ulogic;                                 -- async reset input
        ce_a:       in  std_ulogic;                                 -- clock enable input
        pattern_a:  in  std_ulogic;                                 -- pattern select
        q_a:        out std_ulogic_vector(VID_WIDTH - 1 downto 0);  -- video output
        h_sync_a:   out std_ulogic;                                 -- h sync out
        v_sync_a:   out std_ulogic;                                 -- v sync out
        field_a:    out std_ulogic;                                 -- field out

        -- signals for pattern generator B 
        clk_b:      in  std_ulogic;                                 -- clock input
        rst_b:      in  std_ulogic;                                 -- async reset input
        ce_b:       in  std_ulogic;                                 -- clock enable input
        pattern_b:  in  std_ulogic;                                 -- pattern select
        q_b:        out std_ulogic_vector(VID_WIDTH - 1 downto 0);  -- video output
        h_sync_b:   out std_ulogic;                                 -- h sync out
        v_sync_b:   out std_ulogic;                                 -- v sync out
        field_b:    out std_ulogic                                  -- field out
);
end vidgen;

architecture synth of vidgen is

--
-- If using ModelSim for simulation, you should comment out or remove these
-- component declarations because they duplicate declarations in the UNISIM
-- library.
--
component RAMB16_S18_S18 
-- synopsys translate_off
  generic (
       WRITE_MODE_A : string := "WRITE_FIRST";
       WRITE_MODE_B : string := "WRITE_FIRST";
       INIT_A : bit_vector  := X"00000";
       SRVAL_A : bit_vector := X"00000";
       INIT_B : bit_vector  := X"00000";
       SRVAL_B : bit_vector := X"00000";
       INITP_00 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INITP_01 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INITP_02 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INITP_03 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INITP_04 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INITP_05 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INITP_06 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INITP_07 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_00 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_01 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_02 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_03 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_04 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_05 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_06 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_07 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_08 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_09 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_0A : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_0B : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_0C : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_0D : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_0E : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_0F : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_10 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_11 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_12 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_13 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_14 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_15 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_16 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_17 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_18 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_19 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_1A : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_1B : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_1C : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_1D : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_1E : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_1F : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_20 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_21 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_22 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_23 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_24 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_25 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_26 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_27 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_28 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_29 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_2A : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_2B : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_2C : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_2D : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_2E : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_2F : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_30 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_31 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_32 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_33 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_34 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_35 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_36 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_37 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_38 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_39 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_3A : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_3B : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_3C : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_3D : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_3E : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_3F : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000"
  );
-- synopsys translate_on
  port (DIA    : in STD_LOGIC_VECTOR (15 downto 0);
        DIB    : in STD_LOGIC_VECTOR (15 downto 0);
        DIPA    : in STD_LOGIC_VECTOR (1 downto 0);
        DIPB    : in STD_LOGIC_VECTOR (1 downto 0);
        ENA    : in STD_ULOGIC;
        ENB    : in STD_ULOGIC;
        WEA    : in STD_ULOGIC;
        WEB    : in STD_ULOGIC;
        SSRA   : in STD_ULOGIC;
        SSRB   : in STD_ULOGIC;
        CLKA   : in STD_ULOGIC;
        CLKB   : in STD_ULOGIC;
        ADDRA  : in STD_LOGIC_VECTOR (9 downto 0);
        ADDRB  : in STD_LOGIC_VECTOR (9 downto 0);
        DOA    : out STD_LOGIC_VECTOR (15 downto 0);
        DOB    : out STD_LOGIC_VECTOR (15 downto 0);
        DOPA    : out STD_LOGIC_VECTOR (1 downto 0);
        DOPB    : out STD_LOGIC_VECTOR (1 downto 0)
       ); 

end component;


component RAMB16_S9_S9
-- synopsys translate_off
  generic (
       WRITE_MODE_A : string := "WRITE_FIRST";
       WRITE_MODE_B : string := "WRITE_FIRST";
       INIT_A : bit_vector := X"000";
       SRVAL_A : bit_vector  := X"000";
       INIT_B : bit_vector  := X"000";
       SRVAL_B : bit_vector  := X"000";
       INITP_00 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INITP_01 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INITP_02 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INITP_03 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INITP_04 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INITP_05 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INITP_06 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INITP_07 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_00 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_01 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_02 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_03 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_04 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_05 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_06 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_07 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_08 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_09 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_0A : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_0B : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_0C : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_0D : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_0E : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_0F : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_10 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_11 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_12 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_13 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_14 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_15 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_16 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_17 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_18 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_19 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_1A : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_1B : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_1C : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_1D : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_1E : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_1F : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_20 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_21 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_22 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_23 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_24 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_25 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_26 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_27 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_28 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_29 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_2A : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_2B : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_2C : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_2D : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_2E : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_2F : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_30 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_31 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_32 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_33 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_34 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_35 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_36 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_37 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_38 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_39 : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_3A : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_3B : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_3C : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_3D : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_3E : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000";
       INIT_3F : bit_vector := X"0000000000000000000000000000000000000000000000000000000000000000"
  );
-- synopsys translate_on
  port (DIA    : in STD_LOGIC_VECTOR (7 downto 0);
        DIB    : in STD_LOGIC_VECTOR (7 downto 0);
        DIPA    : in STD_LOGIC_VECTOR (0 downto 0);
        DIPB    : in STD_LOGIC_VECTOR (0 downto 0);
        ENA    : in STD_ULOGIC;
        ENB    : in STD_ULOGIC;
        WEA    : in STD_ULOGIC;
        WEB    : in STD_ULOGIC;
        SSRA   : in STD_ULOGIC;
        SSRB   : in STD_ULOGIC;
        CLKA   : in STD_ULOGIC;
        CLKB   : in STD_ULOGIC;
        ADDRA  : in STD_LOGIC_VECTOR (10 downto 0);
        ADDRB  : in STD_LOGIC_VECTOR (10 downto 0);
        DOA    : out STD_LOGIC_VECTOR (7 downto 0);
        DOB    : out STD_LOGIC_VECTOR (7 downto 0);
        DOPA    : out STD_LOGIC_VECTOR (0 downto 0);
        DOPB    : out STD_LOGIC_VECTOR (0 downto 0)
       ); 

end component;

-------------------------------------------------------------------------------
-- Constant definitions
--

constant VID_MAX :      integer := 10;              -- Max video width the code is setup to handle
constant HRGN_WIDTH :   integer := 4;               -- Width of h_region
constant VRGN_WIDTH :   integer := 4;               -- Width of v_region
constant HROM_WIDTH :   integer := 16;              -- Width of hrom
constant HROM_P_WIDTH : integer := 2;               -- Width of hrom parity
constant VROM_WIDTH :   integer := 16;              -- Width of vrom
constant VROM_P_WIDTH : integer := 2;               -- Width of vrom parity
constant CROM_WIDTH :   integer := 8;               -- Width of crom
constant CROM_P_WIDTH : integer := 1;               -- Width of crom parity
constant CROM_ADR_WIDTH:integer := 11;              -- Width of crom address 
constant VSTATE_WIDTH : integer := 10;              -- Width of v_state
constant HSTATE_WIDTH : integer := 10;              -- Width of h_state

constant VID_MSB :      integer := VID_WIDTH - 1;   -- MS bit # of video
constant VID_MAX_MSB :  integer := VID_MAX - 1;
constant HRGN_MSB :     integer := HRGN_WIDTH - 1;  -- MS bit # of h_region
constant VRGN_MSB :     integer := VRGN_WIDTH - 1;  -- MS bit # of v_region
constant HROM_MSB :     integer := HROM_WIDTH - 1;  -- MS bit # of hrom
constant HROM_P_MSB :   integer := HROM_P_WIDTH - 1;-- MS bit # of hrom parity
constant VROM_MSB :     integer := VROM_WIDTH - 1;  -- MS bit # of vrom 
constant VROM_P_MSB :   integer := VROM_P_WIDTH - 1;-- MS bit # of vrom parity
constant CROM_MSB :     integer := CROM_WIDTH - 1;  -- MS bit # of crom
constant CROM_P_MSB :   integer := CROM_P_WIDTH - 1;-- MS bit # of crom parity
constant CROM_MSBP :    integer := CROM_WIDTH;      -- Bit position in crom where parity bit is inserted
constant CROM_ADR_MSB : integer := CROM_ADR_WIDTH - 1;-- MS bit # of crom address
constant VSTATE_MSB :   integer := VSTATE_WIDTH - 1;-- MS bit # of v_state
constant HSTATE_MSB :   integer := HSTATE_WIDTH - 1;-- MS bit # of h_state


-------------------------------------------------------------------------------
-- Signal definitions
--

-- internal signals for pattern generator A
signal samples_a :  std_logic_vector(1 downto 0);           -- horizontal sample counter
signal h_enable_a : std_ulogic;                             -- h enable outpout of h state machine
signal hen_a :      std_ulogic;                             -- clock enable for h state machine
signal v_enable_a : std_ulogic;                             -- v clock enable output of h state machine
signal ven_a :      std_ulogic;                             -- clock enable for v state machine     
signal h_state_a :  std_logic_vector(HSTATE_MSB downto 0);  -- h state machine present state
signal v_state_a :  std_logic_vector(VSTATE_MSB downto 0);  -- v state machine present state
signal h_region_a : std_logic_vector(HRGN_MSB downto 0);    -- h region value
signal v_region_a : std_logic_vector(VRGN_MSB downto 0);    -- v region value
signal h_a :        std_ulogic;                             -- h bit from h state machine
signal v_a :        std_ulogic;                             -- v bit from v state machine
signal f_a :        std_ulogic;                             -- field bit from v state machine
signal hrom_a :     std_logic_vector(HROM_MSB downto 0);    -- hrom output
signal hromp_a :    std_logic_vector(HROM_P_MSB downto 0); -- hrom parity bits
signal vrom_a :     std_logic_vector(VROM_MSB downto 0);    -- vrom output
signal vromp_a :    std_logic_vector(VROM_P_MSB downto 0);  -- vrom parity bits
signal crom_a :     std_logic_vector(CROM_MSB + CROM_P_WIDTH downto 0);-- crom output
signal crom_adr_a : std_logic_vector(CROM_ADR_MSB downto 0);-- crom address
signal q_a_temp :   std_ulogic_vector(VID_MAX_MSB downto 0);-- temporary 10-bit wide output

-- internal signals for pattern genreator B
signal samples_b :  std_logic_vector(1 downto 0);           -- horizontal sample counter
signal h_enable_b : std_ulogic;                             -- h enable output of h state machine
signal hen_b :      std_ulogic;                             -- clock enable for h state machine
signal v_enable_b : std_ulogic;                             -- v enable output of h state machine
signal ven_b :      std_ulogic;                             -- clock enable for v state machine
signal h_state_b :  std_logic_vector(HSTATE_MSB downto 0); -- h state machine present state
signal v_state_b :  std_logic_vector(VSTATE_MSB downto 0);  -- v state machine present state
signal h_region_b : std_logic_vector(HRGN_MSB downto 0);    -- h region value
signal v_region_b : std_logic_vector(VRGN_MSB downto 0);    -- v region value
signal h_b :        std_ulogic;                             -- h bit from h state machine
signal v_b :        std_ulogic;                             -- v bit from v state machine
signal f_b :        std_ulogic;                             -- field bit from v state machine
signal hrom_b :     std_logic_vector(HROM_MSB downto 0);    -- hrom output
signal hromp_b :    std_logic_vector(HROM_P_MSB downto 0);  -- hrom parity bits
signal vrom_b :     std_logic_vector(VROM_MSB downto 0);    -- vrom output
signal vromp_b :    std_logic_vector(VROM_P_MSB downto 0);  -- vrom parity bits
signal crom_b :     std_logic_vector(CROM_MSB + CROM_P_WIDTH downto 0);-- crom output
signal crom_adr_b : std_logic_vector(CROM_ADR_MSB downto 0);-- crom address
signal q_b_temp :   std_ulogic_vector(VID_MAX_MSB downto 0);-- temporary 10-bit wide output

signal hrom_zeros : std_logic_vector(HROM_MSB downto 0);    -- zeros for unused hrom write ports
signal hromp_zeros: std_logic_vector(HROM_P_MSB downto 0);  -- zeros for unused hrom parity write ports
signal vrom_zeros : std_logic_vector(VROM_MSB downto 0);    -- zeros for unused vrom write ports
signal vromp_zeros: std_logic_vector(VROM_P_MSB downto 0);  -- zeros for unused vrom parity write ports
signal crom_zeros : std_logic_vector(CROM_MSB downto 0);    -- zeros for unused crom write ports
signal cromp_zeros: std_logic_vector(CROM_P_MSB downto 0);  -- zeros for unused crom parity write ports
signal VCC :        std_ulogic;
signal GND :        std_ulogic;


-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- Insert HROM synthesis initialization file here
-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- Insert VROM synthesis initialization file here
-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-- Insert CROM synthesis initialization file here
-- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


begin
        
    VCC         <= '1';
    GND         <= '0';
    hrom_zeros  <= (others => '0');
    hromp_zeros <= (others => '0');
    vrom_zeros  <= (others => '0');
    vromp_zeros <= (others => '0');
    crom_zeros  <= (others => '0');
    cromp_zeros <= (others => '0');
            
    --
    -- Horizontal state machine
    --
    -- The horizontal state machine changes states every four samples.  During each 
    -- horizontal state, four video component values are generated in the following 
    -- pattern: Cb Y Cr Y. 
    --
    -- The horizontal state machine generates a 10-bit current state value which
    -- is wrapped around to the address inputs of the ROM. Note that for standard
    -- definition 4:3 aspect ratio video, 9 horizontal state bits are sufficient, 
    -- but using ten allows for support of 16:9 aspect ratio video.
    --
    -- The horizontal state machine also generates a 4-bit horizontal region 
    -- (h_region_x) value that indicates to the VIDROM which horizontal region is 
    -- currently active. The state machine generates a h bit that is clocked into a 
    -- flip-flop to generate the h_sync output of the module. Also generated is a 
    -- v_enable bit which enables the vertical state machine to advance to the next 
    -- vertical state.
    --

    hen_a <= ce_a and h_enable_a;
    hen_b <= ce_b and h_enable_b;

    HROM : RAMB16_S18_S18
    -- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    -- Insert generic map code from HROM simulation initialization file here
    -- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        port map (
            DOA     => hrom_a,
            DOPA    => hromp_a,
            DOB     => hrom_b,
            DOPB    => hromp_b,
            ADDRA   => h_state_a,
            CLKA    => clk_a,
            DIA     => hrom_zeros,
            DIPA    => hromp_zeros,
            ENA     => hen_a,
            SSRA    => rst_a,
            WEA     => GND,
            ADDRB   => h_state_b,
            CLKB    => clk_b,
            DIB     => hrom_zeros,
            DIPB    => hromp_zeros,
            ENB     => hen_b,
            SSRB    => rst_b,
            WEB     => GND
        );


    -- Assign the HROM output to the various signals
    h_enable_a <= samples_a(1) and samples_a(0);
    v_enable_a <= hromp_a(1);
    h_a        <= hromp_a(0);
    h_region_a <= hrom_a(HRGN_MSB + HSTATE_WIDTH downto HSTATE_WIDTH);
    h_state_a  <= hrom_a(HSTATE_MSB downto 0);

    h_enable_b <= samples_b(1) and samples_b(0);
    v_enable_b <= hromp_b(1);
    h_b        <= hromp_b(0);
    h_region_b <= hrom_b(HRGN_MSB + HSTATE_WIDTH downto HSTATE_WIDTH);
    h_state_b  <= hrom_b(HSTATE_MSB downto 0);

    -- 
    -- Vertical state machine
    --
    -- The vertical state machine changes states once per line. It advances to the
    -- next state when the v_enable signal from the horizontal state machine is
    -- asserted (and the sample counter is at 3). The advancement to the next line
    -- does not occur when the horizontal state machine is at its maximum count.
    -- Instead this happens such that the new line begins coincident with the EAV
    -- symbol.
    --
    -- The vertical state machine ROM generates a 10-bit current state value. This
    -- is sufficient to support both NTSC and PAL standard definition video. The
    -- current state is wrapped back to the address inputs of the VROM.
    --
    -- The vertical state machine generates a 4-bit vertical region value 
    -- (v_region_x) that indicates to the video component ROM which vertical region 
    -- is active. Also generated by the vertical state machine are f and v signals 
    -- that are registered by flip-flops and become the field and v_sync outputs of 
    -- the module.
    --

    ven_a       <= h_enable_a and ce_a and v_enable_a;
    ven_b       <= h_enable_b and ce_b and v_enable_b;

    VROM : RAMB16_S18_S18
    -- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    -- Insert generic map code from VROM simulation initialization file here
    -- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        port map (
            DOA     => vrom_a,
            DOPA    => vromp_a,
            DOB     => vrom_b,
            DOPB    => vromp_b,
            ADDRA   => v_state_a,
            CLKA    => clk_a,
            DIA     => vrom_zeros,
            DIPA    => vromp_zeros,
            ENA     => ven_a,
            SSRA    => rst_a,
            WEA     => GND,
            ADDRB   => v_state_b,
            CLKB    => clk_b,
            DIB     => vrom_zeros,
            DIPB    => vromp_zeros,
            ENB     => ven_b,
            SSRB    => rst_b,
            WEB     => GND
        );


    -- Assign the VROM output bits to the various signals
    f_a         <= vromp_a(1);
    v_a         <= vromp_a(0);
    v_region_a  <= vrom_a(VRGN_MSB + VSTATE_WIDTH downto VSTATE_WIDTH);
    v_state_a   <= vrom_a(VSTATE_MSB downto 0);

    f_b         <= vromp_b(1);
    v_b         <= vromp_b(0);
    v_region_b  <= vrom_b(VRGN_MSB + VSTATE_WIDTH downto VSTATE_WIDTH);
    v_state_b   <= vrom_b(VSTATE_MSB downto 0);


--
-- Video component ROM
--
-- The video component ROM generates the 9-bit video value. The LS bit out of
-- this ROM is used as the two LS bits of the 10-bit video component value
-- out of the module.
--
-- The video component ROM's address is formed from the pattern input bit that
-- selects between the two patterns stored in the ROM and the v_region and
-- h_region values from the vertical and horizontal state machines. The last two
-- address bits into the ROM come from a 2-bit sample counter.
--

    CROM : RAMB16_S9_S9
    -- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    -- Insert generic map code from CROM simulation initialization file here
    -- !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        port map (
            DOA     => crom_a(CROM_MSB downto 0),
            DOPA    => crom_a(CROM_MSB + 1 downto CROM_MSB + 1),
            DOB     => crom_b(CROM_MSB downto 0),
            DOPB    => crom_b(CROM_MSB + 1 downto CROM_MSB + 1),
            ADDRA   => crom_adr_a,
            CLKA    => clk_a,
            DIA     => crom_zeros,
            DIPA    => cromp_zeros,
            ENA     => ce_a,
            SSRA    => rst_a,
            WEA     => GND,
            ADDRB   => crom_adr_b,
            CLKB    => clk_b,
            DIB     => crom_zeros,
            DIPB    => cromp_zeros,
            ENB     => ce_b,
            SSRB    => rst_b,
            WEB     => GND
        );

    -- Create the address for the CROM. If there is no pattern input, remove it
    -- from the concatenations below.
    crom_adr_a <= (pattern_a & v_region_a & h_region_a & samples_a);
    crom_adr_b <= (pattern_b & v_region_b & h_region_b & samples_b);

    -- Replicate the LS bit of CROM to generate 10-bit video output path then
    -- scale back down to the video width output.
    q_a_temp <= (std_ulogic_vector(crom_a) & std_ulogic(crom_a(0)));
    q_a      <= q_a_temp(VID_MAX_MSB downto VID_MAX - VID_WIDTH);

    q_b_temp <= (std_ulogic_vector(crom_b) & std_ulogic(crom_b(0)));
    q_b      <= q_b_temp(VID_MAX_MSB downto VID_MAX - VID_WIDTH);

    --
    -- Sample counters A and B
    --
    -- This is a two-bit counter used as the LS two address bits into the video
    -- ROM. The sample counter is also used to generate the clock enable inputs to
    -- the horizontal and vertical state machine so that these state machines only
    -- advance on the fourth sample of a horizontal state.
    --

    process(clk_a, rst_a)
    begin
        if(rst_a = '1') then
            samples_a <= "11";
        elsif (clk_a'event and clk_a = '1') then
            if (ce_a = '1') then
	            samples_a <= samples_a + 1;
    		end if;
        end if;
    end process;

    process(clk_b, rst_b)
    begin
        if (rst_b = '1') then
            samples_b <= "11";
        elsif (clk_b'event and clk_b = '1') then
            if (ce_b = '1') then
            	samples_b <= samples_b + 1;
			end if;
        end if;     
    end process;

    --
    -- Output flip-flops
    -- 
    -- These flip-flops register the field, h_sync, and v_sync outputs of the module.
    --

    process(clk_a, rst_a)
    begin
        if (rst_a = '1') then
            h_sync_a <= '0';
            v_sync_a <= '0';
            field_a  <= '0';
        elsif (clk_a'event and clk_a = '1') then
            if (ce_a = '1') then
	            h_sync_a <= h_a;
    	        v_sync_a <= v_a;
        	    field_a  <= f_a;
			end if;
        end if;
    end process;

    process(clk_b, rst_b)
    begin
        if (rst_b = '1') then
            h_sync_b <= '0';
            v_sync_b <= '0';
            field_b  <= '0';
        elsif (clk_b'event and clk_b = '1') then
            if (ce_b = '1') then
            	h_sync_b <= h_b;
            	v_sync_b <= v_b;
            	field_b  <= f_b;
			end if;
        end if;
    end process;

end synth;