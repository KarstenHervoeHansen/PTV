-------------------------------------------------------------------------------- 
-- Copyright (c) 2005 Xilinx, Inc. 
-- All Rights Reserved 
-------------------------------------------------------------------------------- 
--   ____  ____ 
--  /   /\/   / 
-- /___/  \  /   Vendor: Xilinx 
-- \   \   \/    Author: John F. Snow, Advanced Product Division, Xilinx, Inc.
--  \   \        Filename: $RCSfile: multigen.vhd,rcs $
--  /   /        Date Last Modified:  $Date: 2005-01-18 09:59:14-07 $
-- /___/   /\    Date Created: Jan 5, 2005
-- \   \  /  \ 
--  \___\/\___\ 
-- 
--
-- Revision History: 
-- $Log: multigen.vhd,rcs $
-- Revision 1.0  2005-01-18 09:59:14-07  jsnow
-- Header update.
--
-------------------------------------------------------------------------------- 
--   
--   XILINX IS PROVIDING THIS DESIGN, CODE, OR INFORMATION "AS IS" 
--   AS A COURTESY TO YOU, SOLELY FOR USE IN DEVELOPING PROGRAMS AND 
--   SOLUTIONS FOR XILINX DEVICES.  BY PROVIDING THIS DESIGN, CODE, 
--   OR INFORMATION AS ONE POSSIBLE IMPLEMENTATION OF THIS FEATURE, 
--   APPLICATION OR STANDARD, XILINX IS MAKING NO REPRESENTATION 
--   THAT THIS IMPLEMENTATION IS FREE FROM ANY CLAIMS OF INFRINGEMENT, 
--   AND YOU ARE RESPONSIBLE FOR OBTAINING ANY RIGHTS YOU MAY REQUIRE 
--   FOR YOUR IMPLEMENTATION.  XILINX EXPRESSLY DISCLAIMS ANY 
--   WARRANTY WHATSOEVER WITH RESPECT TO THE ADEQUACY OF THE 
--   IMPLEMENTATION, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OR 
--   REPRESENTATIONS THAT THIS IMPLEMENTATION IS FREE FROM CLAIMS OF 
--   INFRINGEMENT, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
--   FOR A PARTICULAR PURPOSE. 
--
-------------------------------------------------------------------------------- 
--
-- This module generates digital video for eight different digital video 
-- formats. The video generated by this module contains TRS symbols in the 
-- proper places. Except for the TRS symbol words, all other video data is 
-- simply the values for digital component video color BLACK.
-- 
-- This module is intended to be used in a test bench for testing modules that
-- detect digital video formats.
-- 
-- The module has the following inputs:
-- 
-- clk: input clock.
-- 
-- ce: input clock enable.
-- 
-- rst: asynchronous reset input.
-- 
-- std: 3-bit input port that tells the module which video standard to generate.
-- The std value can be switched at anytime and the module will start generating
-- the new video standard within a few clock cycles. The encoding of the std
-- port is shown below:
-- 
-- 000:    NTSC 4:2:2 component video
-- 001:    NTSC composite video
-- 010:    NTSC 4:2:2 16x9 component video
-- 011:    NTSC 4:4:4:4 13.5MHz component video
-- 100:    PAL 4:2:2 component video
-- 101:    PAL composite video
-- 110:    PAL 4:2:2 16x9 component video
-- 111:    PAL 4:4:4:4 13.5MHz component video
-- 
-- s: S input flag for the TRS XYZ word of the 4444 component video formats.
-- The S flags indicates which color space is used by the video: YCbCr (S=1) or 
-- RGB (S=0).  This input signal is used to form the TRS XYZ word for the 4444
-- formats. It also affects whether RGB or YCbCr BLACK component values are used
-- for the video.
-- 
-- q: this is the 10-bit video output port.
-- 
-- field: this three-bit output port indicates which field is being generated. 
-- For component video formats, only the LSB is valid.
-- 
-- v_blank: this is the vertical blanking interval indicator.
-- 
-- h_blank: this is the horizontal blanking interval indicator. For composite 
-- video, it is asserted only during the TRS words.
--

library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_arith.all;
use ieee.numeric_std.all;

entity multigen is
    port (
        clk:        in    std_ulogic;                       -- clock input
        ce:         in    std_ulogic;                       -- clock enable
        rst:        in    std_ulogic;                       -- async reset input
        std:        in    std_ulogic_vector(2 downto 0);    -- video standard code
        s:          in    std_ulogic;                       -- color space select for 4444
        early_v:    in    std_ulogic;                       -- enables early V bit fall
        q:          out   std_ulogic_vector(9 downto 0);    -- video output
        field:      out   std_ulogic_vector(2 downto 0);    -- field bits
        v_blank:    out   std_ulogic;                       -- vertical blanking indicator
        h_blank:    out   std_ulogic;                       -- horizontal blanking indicator
        trs:        inout std_ulogic                        -- asserted during TRS symbol
    );
end ;

architecture synth of multigen is

constant HCNT_WIDTH :   integer := 12;              -- Width of hcnt
constant VCNT_WIDTH :   integer := 10;              -- Width of vcnt

subtype video     is std_ulogic_vector(9 downto 0);
subtype hposition is std_logic_vector(HCNT_WIDTH - 1 downto 0);
subtype vposition is std_logic_vector(VCNT_WIDTH - 1 downto 0);
subtype stdcode   is std_ulogic_vector(2 downto 0);
subtype fldcnt    is std_logic_vector(2 downto 0);

-------------------------------------------------------------------------------
-- Constant definitions
--

--
-- This group of constants defines the bit widths of various fields in the
-- module. 
--
constant HCNT_MSB :     integer := HCNT_WIDTH - 1;  -- MS bit # of hcnt
constant VCNT_MSB :     integer := VCNT_WIDTH - 1;  -- MS bit # of vcnt

--
-- This group of constants controls the total number of clocks per line 
-- for the various supported video standards.
--
constant H_TOTAL_NTSC_422 :       hposition := std_logic_vector(TO_UNSIGNED(1716, HCNT_WIDTH));
constant H_TOTAL_NTSC_COMPOSITE : hposition := std_logic_vector(TO_UNSIGNED(910,  HCNT_WIDTH));
constant H_TOTAL_NTSC_422_WIDE :  hposition := std_logic_vector(TO_UNSIGNED(2288, HCNT_WIDTH));
constant H_TOTAL_NTSC_4444 :      hposition := std_logic_vector(TO_UNSIGNED(3432, HCNT_WIDTH));
constant H_TOTAL_PAL_422 :        hposition := std_logic_vector(TO_UNSIGNED(1728, HCNT_WIDTH));
constant H_TOTAL_PAL_COMPOSITE :  hposition := std_logic_vector(TO_UNSIGNED(1135, HCNT_WIDTH));
constant H_TOTAL_PAL_422_WIDE :   hposition := std_logic_vector(TO_UNSIGNED(2304, HCNT_WIDTH));
constant H_TOTAL_PAL_4444 :       hposition := std_logic_vector(TO_UNSIGNED(3456, HCNT_WIDTH));
     
--
-- PAL composite video has two extra samples per field. These samples are on
-- lines 313 and 625 and are numbered 1135 and 1136. They appear immediately
-- prior to the first active picture sample. These constants control the
-- generation of these extra samples. Note that because the vcnt increments
-- before the start of active video, the line numbers for the extra lines
-- need to be one more than indicated above.
--
constant PAL_CMPST_FLD1_EXTRA :   vposition := std_logic_vector(TO_UNSIGNED(314, VCNT_WIDTH));
constant PAL_CMPST_FLD2_EXTRA :   vposition := std_logic_vector(TO_UNSIGNED(1,   VCNT_WIDTH));
constant H_TOTAL_PAL_CMPST_EXTRA: hposition := H_TOTAL_PAL_COMPOSITE + 2;

--
-- This group of constants controls the horizontal TRS locations for the
-- various standards.
--
constant EAV_NTSC_422 :           hposition := std_logic_vector(TO_UNSIGNED(1440, HCNT_WIDTH));
constant EAV_NTSC_COMPOSITE :     hposition := std_logic_vector(TO_UNSIGNED(790,  HCNT_WIDTH));
constant EAV_NTSC_422_WIDE :      hposition := std_logic_vector(TO_UNSIGNED(1920, HCNT_WIDTH));
constant EAV_NTSC_4444 :          hposition := std_logic_vector(TO_UNSIGNED(2880, HCNT_WIDTH));
constant EAV_PAL_422 :            hposition := std_logic_vector(TO_UNSIGNED(1440, HCNT_WIDTH));
constant EAV_PAL_COMPOSITE :      hposition := std_logic_vector(TO_UNSIGNED(967,  HCNT_WIDTH));
constant EAV_PAL_422_WIDE :       hposition := std_logic_vector(TO_UNSIGNED(1920, HCNT_WIDTH));
constant EAV_PAL_4444 :           hposition := std_logic_vector(TO_UNSIGNED(2880, HCNT_WIDTH));

constant SAV_NTSC_422 :           hposition := std_logic_vector(TO_UNSIGNED(1712, HCNT_WIDTH));
constant SAV_NTSC_422_WIDE :      hposition := std_logic_vector(TO_UNSIGNED(2284, HCNT_WIDTH));
constant SAV_NTSC_4444 :          hposition := std_logic_vector(TO_UNSIGNED(3428, HCNT_WIDTH));
constant SAV_PAL_422 :            hposition := std_logic_vector(TO_UNSIGNED(1724, HCNT_WIDTH));
constant SAV_PAL_422_WIDE :       hposition := std_logic_vector(TO_UNSIGNED(2300, HCNT_WIDTH));
constant SAV_PAL_4444 :           hposition := std_logic_vector(TO_UNSIGNED(3452, HCNT_WIDTH));

--
-- This group of constants controls the vertical positioning of various
-- elements of the video signal.
--
constant V_TOTAL_NTSC :           vposition := std_logic_vector(TO_UNSIGNED(525, VCNT_WIDTH));
constant FLD1_START_NTSC :        vposition := std_logic_vector(TO_UNSIGNED(4,   VCNT_WIDTH));
constant FLD1_FIRST_ACTIVE_NTSC : vposition := std_logic_vector(TO_UNSIGNED(20,  VCNT_WIDTH));
constant FLD1_LAST_ACTIVE_NTSC :  vposition := std_logic_vector(TO_UNSIGNED(263, VCNT_WIDTH));
constant FLD2_START_NTSC :        vposition := std_logic_vector(TO_UNSIGNED(266, VCNT_WIDTH));
constant FLD2_FIRST_ACTIVE_NTSC : vposition := std_logic_vector(TO_UNSIGNED(283, VCNT_WIDTH));
constant FLD2_LAST_ACTIVE_NTSC :  vposition := std_logic_vector(TO_UNSIGNED(525, VCNT_WIDTH));

constant V_TOTAL_PAL :            vposition := std_logic_vector(TO_UNSIGNED(625, VCNT_WIDTH));
constant FLD1_START_PAL :         vposition := std_logic_vector(TO_UNSIGNED(1,   VCNT_WIDTH));
constant FLD1_FIRST_ACTIVE_PAL :  vposition := std_logic_vector(TO_UNSIGNED(23,  VCNT_WIDTH));
constant FLD1_LAST_ACTIVE_PAL :   vposition := std_logic_vector(TO_UNSIGNED(310, VCNT_WIDTH));
constant FLD2_START_PAL :         vposition := std_logic_vector(TO_UNSIGNED(313, VCNT_WIDTH));
constant FLD2_FIRST_ACTIVE_PAL :  vposition := std_logic_vector(TO_UNSIGNED(336, VCNT_WIDTH));
constant FLD2_LAST_ACTIVE_PAL :   vposition := std_logic_vector(TO_UNSIGNED(623, VCNT_WIDTH));


--
-- This group of constants defines the encoding for the video standards output
-- code.
--
constant NTSC_422 :               stdcode   := "000";
constant NTSC_COMPOSITE :         stdcode   := "001";
constant NTSC_422_WIDE :          stdcode   := "010";
constant NTSC_4444 :              stdcode   := "011";
constant PAL_422 :                stdcode   := "100";
constant PAL_COMPOSITE :          stdcode   := "101";
constant PAL_422_WIDE :           stdcode   := "110";
constant PAL_4444 :               stdcode   := "111";


--
-- When the early fall of the V bit is enabled, this constant specifies
-- how many lines early the V bit falls.
--
constant EARLY_V_OFFSET :         vposition := std_logic_vector(TO_UNSIGNED(10, VCNT_WIDTH));

--
-- These constants define the BLACK color levels for the output video.
--   
constant YCBCR_4444_BLANK_Y :     video := std_ulogic_vector(TO_UNSIGNED(64,  10));
constant YCBCR_4444_BLANK_CB :    video := std_ulogic_vector(TO_UNSIGNED(512, 10));
constant YCBCR_4444_BLANK_CR :    video := std_ulogic_vector(TO_UNSIGNED(512, 10));
constant YCBCR_4444_BLANK_A :     video := std_ulogic_vector(TO_UNSIGNED(64,  10));
         
constant RGB_4444_BLANK_R :       video := std_ulogic_vector(TO_UNSIGNED(64,  10));
constant RGB_4444_BLANK_G :       video := std_ulogic_vector(TO_UNSIGNED(64,  10));
constant RGB_4444_BLANK_B :       video := std_ulogic_vector(TO_UNSIGNED(64,  10));
constant RGB_4444_BLANK_A :       video := std_ulogic_vector(TO_UNSIGNED(64,  10));

constant YCBCR_422_BLANK_Y :      video := std_ulogic_vector(TO_UNSIGNED(64,  10));
constant YCBCR_422_BLANK_C :      video := std_ulogic_vector(TO_UNSIGNED(512, 10));
    
-------------------------------------------------------------------------------
-- Signal definitions
--

signal hcnt :           hposition;    -- horizontal counter
signal vcnt :           vposition;    -- vertical counter
signal field_count :    fldcnt;       -- field counter for composite
signal f :              std_ulogic;   -- field bit for component
signal v :              std_ulogic;   -- v blank bit
signal h :              std_ulogic;   -- h blank bit
signal h_last :         hposition;    -- total h count for current standard
signal eav_loc :        hposition;    -- location of EAV
signal sav_loc :        hposition;    -- location of SAV
signal v_last :         vposition;    -- total v count for current standard
signal fld1_last :      vposition;    -- starting position of field 1
signal fld1_act_start : vposition;    -- starting position of active video fld 1
signal fld1_act_end :   vposition;    -- ending position of active video fld 1
signal fld2_last :      vposition;    -- startingposition of field 2
signal fld2_act_start : vposition;    -- starting position of active video fld 2
signal fld2_act_end :   vposition;    -- ending position of active video fld 2
signal h_reset :        hposition;    -- reset value for hcnt
signal v_reset :        vposition;    -- reset value for vcnt
signal f_reset :        std_ulogic;   -- reset value for f
signal fcount_reset :   fldcnt;       -- reset value for field count
signal int_std :        stdcode;      -- internal version of std input bits
signal new_std :        std_ulogic;   -- asserted when std != new_std
signal reload :         std_ulogic;   -- synchronous version of new_std
signal xyz :            video;        -- TRS XYZ word
signal eav_next :       std_ulogic;   -- asserted when EAV will start on next word
signal sav_next :       std_ulogic;   -- asserted when SAV will start on next word
signal trs_id :         video;        -- TRS ID word
signal trs_word :       
    std_logic_vector(2 downto 0);     -- counter for TRS words
signal trs_length :                   
    std_logic_vector(2 downto 0);     -- number of words in TRS
signal trs_id_line :    
    std_ulogic_vector(4 downto 0);    -- line number for TRS ID word

begin
    
    --
    -- Whenever the std code changes, this code assigns new values to the 
    -- various values used to reset the hcnt, vcnt, f, and field_count 
    -- registers.
    --
    process(std)
    begin
        case std is
            when NTSC_422 => 
                h_reset <= EAV_NTSC_422 - 1;
                v_reset <= V_TOTAL_NTSC;
                f_reset <= '1';
                fcount_reset <= "000";

            when NTSC_COMPOSITE => 
                h_reset <= EAV_NTSC_COMPOSITE - 1;
                v_reset <= V_TOTAL_NTSC;
                f_reset <= '1';
                fcount_reset <= "011";

            when NTSC_422_WIDE => 
                h_reset <= EAV_NTSC_422_WIDE - 1;
                v_reset <= V_TOTAL_NTSC;
                f_reset <= '1';
                fcount_reset <= "000";

            when NTSC_4444 => 
                h_reset <= EAV_NTSC_4444 - 1;
                v_reset <= V_TOTAL_NTSC;
                f_reset <= '1';
                fcount_reset <= "000";

            when PAL_422 => 
                h_reset <= EAV_PAL_422 - 1;
                v_reset <= FLD2_LAST_ACTIVE_PAL;
                f_reset <= '1';
                fcount_reset <= "000";

            when PAL_COMPOSITE => 
                h_reset <= EAV_PAL_COMPOSITE - 1;
                v_reset <= FLD2_LAST_ACTIVE_PAL;
                f_reset <= '1';
                fcount_reset <= "111";

            when PAL_422_WIDE => 
                h_reset <= EAV_PAL_422_WIDE - 1;
                v_reset <= FLD2_LAST_ACTIVE_PAL;
                f_reset <= '1';
                fcount_reset <= "000";

            when PAL_4444 => 
                h_reset <= EAV_PAL_4444 - 1;
                v_reset <= FLD2_LAST_ACTIVE_PAL;
                f_reset <= '1';
                fcount_reset <= "000";

            when others =>
                h_reset <= EAV_NTSC_422 - 1;
                v_reset <= V_TOTAL_NTSC;
                f_reset <= '1';
                fcount_reset <= "000";

        end case;
    end process;

    --
    -- int_std
    --
    -- int_std is an internal synchronous version of the std input bits that 
    -- specify which video standard to generate.
    --
    process(clk, rst)
    begin
        if (rst = '1') then
            int_std <= std;
        elsif (clk'event and clk = '1') then
            if (ce = '1' and new_std = '1') then
                int_std <= std;
            end if;
        end if;
    end process;

    --
    -- reload and new_std signals
    --
    -- new_std is asynchronously asserted when std and int_std do not match.
    -- reload is a synchronous version of new_std.
    --
    new_std <= '0' when std = int_std else '1';

    process(clk, rst)
    begin
        if (rst = '1') then
            reload <= '0';
        elsif (clk'event and clk = '1') then
            if (ce = '1') then
                reload <= new_std;
            end if;
        end if;
    end process;

    --
    -- trs_length
    --
    -- trs_length indicates the number of words in the TRS symbol for the 
    -- current video standard: 4 for the component video standars and 5 for the
    -- composite video standards.
    --
    process(int_std)
    begin
        if (int_std = NTSC_COMPOSITE or int_std = PAL_COMPOSITE) then
            trs_length <= "100";
        else
            trs_length <= "011";
        end if;
    end process;
            

    --                      
    -- hcnt
    --
    -- hcnt is the horizontal counter used to generate video. It increments
    -- every clock and resets to 0 at the end of each video line (when h_last is
    -- asserted). When reload or reset are asserted, it will load with the value
    -- of the h_reset signal.
    --
    process(clk, rst)
    begin
        if (rst = '1') then
            hcnt <= h_reset;
        elsif (clk'event and clk = '1') then
            if (ce = '1') then
                if (reload = '1') then
                    hcnt <= h_reset;
                elsif (hcnt = h_last) then
                    hcnt <= (others => '0');
                else
                    hcnt <= hcnt + 1;
                end if;
            end if;
        end if;
    end process;

    --
    -- eav_next and sav_next
    --
    -- These signals are asserted when the EAV or SAV signals will be generated
    -- on the next clock. They are generated by comparing the hcnt counter to 
    -- the values of the eav_loc and sav_loc signals. Composite video only has 
    -- one TRS symbol per lines as indicated by the eav_next signal. sav_next is
    -- never asserted during composite video.
    --
    eav_next <= '1' when hcnt = eav_loc else '0';

    process(hcnt, sav_loc, int_std)
    begin
        if (int_std = NTSC_COMPOSITE or int_std = PAL_COMPOSITE) then
            sav_next <= '0';
        elsif (hcnt = sav_loc) then
            sav_next <= '1';
        else
            sav_next <= '0';
        end if;
    end process;

    --
    -- vcnt
    --
    -- vcnt is the vertical video line counter. It increments every time the
    -- eav_next signal is asserted, marking the beginning of a new line. When
    -- the vcnt value equals v_last, the counter rolls over to a value of 1. 
    -- When the reset or reload signals are asserted, the counter loads the 
    -- v_reset value.
    --
    process(clk, rst)
    begin
        if (rst = '1') then
            vcnt <= v_reset;
        elsif (clk'event and clk = '1') then
            if (ce = '1') then
                if (reload = '1') then
                    vcnt <= v_reset;
                elsif (eav_next = '1') then
                    if (vcnt = v_last) then
                        vcnt <= (0 => '1', others => '0');
                    else
                        vcnt <= vcnt + 1;
                    end if;
                end if;
            end if;
        end if;
    end process;

    --
    -- trs_word
    --
    -- This counter keeps track of which word of the trs symbol is being output.
    -- It resets to zero when eav_next or sav_next are asserted and increments
    -- every clock cycle after that.
    --
    process(clk, rst)
    begin
        if (rst = '1') then
            trs_word <= (others => '0');
        elsif (clk'event and clk = '1') then
            if (ce = '1') then
                if (eav_next = '1' or sav_next = '1') then
                    trs_word <= (others => '0');
                else
                    trs_word <= trs_word + 1;
                end if;
            end if;
        end if;
    end process;

    --
    -- trs
    --
    -- The trs signal is asserted during the four words of a component video TRS
    -- symbol or the five words of a composite video TRS symbol.
    --
    process(clk, rst)
    begin
        if (rst = '1') then
            trs <= '0';
        elsif (clk'event and clk = '1') then
            if (ce = '1') then
                if (eav_next = '1' or sav_next = '1') then
                    trs <= '1';
                elsif (trs = '1' and trs_word = trs_length) then
                    trs <= '0';
                end if;
            end if;
        end if;
    end process;

    --
    -- field_counter
    --
    -- The field counter is used to keep track of fields for composite video. 
    -- The NTSC composite video standard has four fields, 000 to 011. The PAL
    -- composite video standard has eight fields, 000 to 111. The field count
    -- value is included in the composite video TRS ID word. The field counter
    -- increments when the eav_next is asserted and the vcnt value is at the end
    -- of a field. If reset or reload are asserted, the field counter loads with
    -- the fcount_reset value.
    --
    process(clk, rst)
    begin
        if (rst = '1') then
            field_count <= fcount_reset;
        elsif (clk'event and clk = '1') then
            if (ce = '1') then
                if (reload = '1') then
                    field_count <= fcount_reset;
                elsif (eav_next = '1') then
                    if (int_std = NTSC_COMPOSITE) then
                        if (vcnt = FLD1_LAST_ACTIVE_NTSC or vcnt = V_TOTAL_NTSC) then
                            if (field_count = "011") then
                                field_count <= "000";
                            else
                                field_count <= field_count + 1;
                            end if;
                        end if;
                    elsif (int_std = PAL_COMPOSITE) then
                        if (vcnt = FLD2_START_PAL or vcnt = V_TOTAL_PAL) then
                            field_count <= field_count + 1;
                        end if;
                    end if;
                end if;
            end if;
        end if;
    end process;

    --                                  
    -- f bit
    --
    -- The f bit is used to keep track of fields for component video. The f bit
    -- is included in the component video TRS XYZ word.
    --
    process(clk, rst)
    begin
        if (rst = '1') then
            f <= f_reset;
        elsif (clk'event and clk = '1') then
            if (ce = '1') then
                if (reload = '1') then
                    f <= f_reset;
                elsif (eav_next = '1' and vcnt = fld1_last) then
                    f <= '1';
                elsif (eav_next = '1' and vcnt = fld2_last) then
                    f <= '0';
                end if;
            end if;
        end if;
    end process;

    --
    -- h bit
    --
    -- The h bit is used to indicate the horizontal blanking interval for 
    -- component video. This bit is included in the component video TRS XYZ 
    -- word.
    --
    process(clk, rst)
    begin
        if (rst = '1') then
            h <= '0';
        elsif (clk'event and clk = '1') then
            if (ce = '1') then
                if (int_std = NTSC_COMPOSITE or int_std = PAL_COMPOSITE) then
                    h <= '0';
                else
                    if (reload = '1') then
                        h <= '0';
                    elsif (eav_next = '1') then
                        h <= '1';
                    elsif (sav_next = '1') then
                        h <= '0';
                    end if;
                end if;
            end if;
        end if;
    end process;
            
    --
    -- v bit
    --
    -- The v bit is used to indicate the vertical blanking interval. It is valid
    -- for both component and composite video, but is only included in the
    -- component video TRS XYZ word.
    --
    process(clk, rst)
    begin
        if (rst = '1') then
            v <= '0';
        elsif (clk'event and clk = '1') then
            if (ce = '1') then
                if (reload = '1') then
                    v <= '0';
                elsif (eav_next = '1') then
                    if (vcnt = fld1_act_start or vcnt = fld2_act_start) then
                        v <= '0';
                    elsif (vcnt = fld1_act_end or vcnt = fld2_act_end) then
                        v <= '1';
                    end if;
                end if;
            end if;
        end if;
    end process;

    --
    -- horizontal and vertical constant generation
    --
    -- This code generates the various horizontal and vertical constant values
    -- that are used to compare with the hcnt and vcnt to determine when lines
    -- end, when fields start and end, and when to generate TRS symbols.
    --
    process(int_std, vcnt)
    begin
        case int_std is
            when NTSC_422       => 
                h_last          <= H_TOTAL_NTSC_422 - 1;
                v_last          <= V_TOTAL_NTSC;
                eav_loc         <= EAV_NTSC_422 - 1;
                sav_loc         <= SAV_NTSC_422 - 1;
                
                if (early_v = '1') then
                    fld1_act_start  <= FLD1_FIRST_ACTIVE_NTSC - EARLY_V_OFFSET - 1;
                    fld2_act_start  <= FLD2_FIRST_ACTIVE_NTSC - EARLY_V_OFFSET - 1;
                else 
                    fld1_act_start  <= FLD1_FIRST_ACTIVE_NTSC - 1;
                    fld2_act_start  <= FLD2_FIRST_ACTIVE_NTSC - 1;
            
                end if;
                                   
                fld1_act_end    <= FLD1_LAST_ACTIVE_NTSC;
                fld2_act_end    <= FLD2_LAST_ACTIVE_NTSC;
                fld1_last       <= FLD2_START_NTSC - 1;
                fld2_last       <= FLD1_START_NTSC - 1;

            when NTSC_COMPOSITE =>
                h_last          <= H_TOTAL_NTSC_COMPOSITE - 1;
                v_last          <= V_TOTAL_NTSC;
                eav_loc         <= EAV_NTSC_COMPOSITE - 1;
                sav_loc         <= (others => '0');
                fld1_act_start  <= FLD1_FIRST_ACTIVE_NTSC - 1;
                fld1_act_end    <= FLD1_LAST_ACTIVE_NTSC;
                fld2_act_start  <= FLD2_FIRST_ACTIVE_NTSC - 1;
                fld2_act_end    <= FLD2_LAST_ACTIVE_NTSC;
                fld1_last       <= FLD2_START_NTSC - 1;
                fld2_last       <= FLD1_START_NTSC - 1;

            when NTSC_422_WIDE  =>
                h_last          <= H_TOTAL_NTSC_422_WIDE - 1;
                v_last          <= V_TOTAL_NTSC;
                eav_loc         <= EAV_NTSC_422_WIDE - 1;
                sav_loc         <= SAV_NTSC_422_WIDE - 1;
                fld1_act_start  <= FLD1_FIRST_ACTIVE_NTSC - 1;
                fld1_act_end    <= FLD1_LAST_ACTIVE_NTSC;
                fld2_act_start  <= FLD2_FIRST_ACTIVE_NTSC - 1;
                fld2_act_end    <= FLD2_LAST_ACTIVE_NTSC;
                fld1_last       <= FLD2_START_NTSC - 1;
                fld2_last       <= FLD1_START_NTSC - 1;

            when NTSC_4444      =>
                h_last          <= H_TOTAL_NTSC_4444 - 1;
                v_last          <= V_TOTAL_NTSC;
                eav_loc         <= EAV_NTSC_4444 - 1;
                sav_loc         <= SAV_NTSC_4444 - 1;
                fld1_act_start  <= FLD1_FIRST_ACTIVE_NTSC - 1;
                fld1_act_end    <= FLD1_LAST_ACTIVE_NTSC;
                fld2_act_start  <= FLD2_FIRST_ACTIVE_NTSC - 1;
                fld2_act_end    <= FLD2_LAST_ACTIVE_NTSC;
                fld1_last       <= FLD2_START_NTSC - 1;
                fld2_last       <= FLD1_START_NTSC - 1;

            when PAL_422        =>
                h_last          <= H_TOTAL_PAL_422 - 1;
                v_last          <= V_TOTAL_PAL;
                eav_loc         <= EAV_PAL_422 - 1;
                sav_loc         <= SAV_PAL_422 - 1;
                fld1_act_start  <= FLD1_FIRST_ACTIVE_PAL - 1;
                fld1_act_end    <= FLD1_LAST_ACTIVE_PAL;
                fld2_act_start  <= FLD2_FIRST_ACTIVE_PAL - 1;
                fld2_act_end    <= FLD2_LAST_ACTIVE_PAL;
                fld1_last       <= FLD2_START_PAL - 1;
                fld2_last       <= V_TOTAL_PAL;

            when PAL_COMPOSITE  =>
                if (vcnt = PAL_CMPST_FLD1_EXTRA or vcnt = PAL_CMPST_FLD2_EXTRA) then
                    h_last      <= H_TOTAL_PAL_CMPST_EXTRA - 1;
                else
                    h_last      <= H_TOTAL_PAL_COMPOSITE - 1;
                end if;

                v_last          <= V_TOTAL_PAL;
                eav_loc         <= EAV_PAL_COMPOSITE - 1;
                sav_loc         <= (others => '0');
                fld1_act_start  <= FLD1_FIRST_ACTIVE_PAL - 1;
                fld1_act_end    <= FLD1_LAST_ACTIVE_PAL;
                fld2_act_start  <= FLD2_FIRST_ACTIVE_PAL - 1;
                fld2_act_end    <= FLD2_LAST_ACTIVE_PAL;
                fld1_last       <= FLD2_START_PAL - 1;
                fld2_last       <= V_TOTAL_PAL;

            when PAL_422_WIDE   =>
                h_last          <= H_TOTAL_PAL_422_WIDE - 1;
                v_last          <= V_TOTAL_PAL;
                eav_loc         <= EAV_PAL_422_WIDE - 1;
                sav_loc         <= SAV_PAL_422_WIDE - 1;
                fld1_act_start  <= FLD1_FIRST_ACTIVE_PAL - 1;
                fld1_act_end    <= FLD1_LAST_ACTIVE_PAL;
                fld2_act_start  <= FLD2_FIRST_ACTIVE_PAL - 1;
                fld2_act_end    <= FLD2_LAST_ACTIVE_PAL;
                fld1_last       <= FLD2_START_PAL - 1;
                fld2_last       <= V_TOTAL_PAL;

            when PAL_4444       =>
                h_last          <= H_TOTAL_PAL_4444 - 1;
                v_last          <= V_TOTAL_PAL;
                eav_loc         <= EAV_PAL_4444 - 1;
                sav_loc         <= SAV_PAL_4444 - 1;
                fld1_act_start  <= FLD1_FIRST_ACTIVE_PAL - 1;
                fld1_act_end    <= FLD1_LAST_ACTIVE_PAL;
                fld2_act_start  <= FLD2_FIRST_ACTIVE_PAL - 1;
                fld2_act_end    <= FLD2_LAST_ACTIVE_PAL;
                fld1_last       <= FLD2_START_PAL - 1;
                fld2_last       <= V_TOTAL_PAL;

            when others         =>
                h_last          <= H_TOTAL_NTSC_422 - 1;
                v_last          <= V_TOTAL_NTSC;
                eav_loc         <= EAV_NTSC_422 - 1;
                sav_loc         <= SAV_NTSC_422 - 1;
                fld1_act_start  <= FLD1_FIRST_ACTIVE_NTSC - 1;
                fld1_act_end    <= FLD1_LAST_ACTIVE_NTSC;
                fld2_act_start  <= FLD2_FIRST_ACTIVE_NTSC - 1;
                fld2_act_end    <= FLD2_LAST_ACTIVE_NTSC;
                fld1_last       <= FLD2_START_PAL - 1;
                fld2_last       <= V_TOTAL_PAL;

        end case;
    end process;

    --
    -- q video output data
    --
    -- This code generates the output video values. When a TRS is being 
    -- generated, the code generates the proper TRS word values. Otherwise it 
    -- outputs a black level value appropriate for the selected video standard. 
    -- Note that 4:2:2 component video black values are used when composite 
    -- video is selected.
    --
    process(hcnt, xyz, trs_word, int_std, trs_id, trs, s)
    begin
        if (trs = '1') then
            if (trs_word = "000") then
                q <= (others => '1');
            elsif (trs_word = "001" or trs_word = "010") then
                q <= (others => '0');
            elsif (trs_word = "011") then
                q <= xyz;
            else
                q <= trs_id;
            end if;
        elsif (int_std = NTSC_4444 or int_std = PAL_4444) then
            if (s = '1') then
                case hcnt(1 downto 0) is
                    when "00" =>   q <= YCBCR_4444_BLANK_CB;
                    when "01" =>   q <= YCBCR_4444_BLANK_Y;
                    when "10" =>   q <= YCBCR_4444_BLANK_CR;
                    when others => q <= YCBCR_4444_BLANK_A;
                end case;
            else
                case hcnt(1 downto 0) is
                    when "00" =>   q <= RGB_4444_BLANK_B;
                    when "01" =>   q <= RGB_4444_BLANK_G;
                    when "10" =>   q <= RGB_4444_BLANK_R;
                    when others => q <= RGB_4444_BLANK_A;
                end case;
            end if;
        else
            if (hcnt(0) = '1') then
                q <= YCBCR_422_BLANK_Y;
            else
                q <= YCBCR_422_BLANK_C;
            end if;
        end if;
    end process;


    --
    -- xyz word
    --
    -- This code generates the TRS XYZ word for component video. The XYZ word
    -- includes the H, V, and F bits (and the S bit for the 4444 formats). It 
    -- also includes some protection bits that are formed by xor'ing the F, V, 
    -- H, and S bits in various combinations.
    --
    process(h, v, f, s, int_std)
    begin
        if (int_std = NTSC_4444 or int_std = PAL_4444) then
            xyz(9) <= '1';
            xyz(8) <= f;
            xyz(7) <= v;
            xyz(6) <= h;
            xyz(5) <= s;
            xyz(4) <= f xor v xor h;
            xyz(3) <= f xor v xor s;
            xyz(2) <= v xor h xor s;
            xyz(1) <= f xor h xor s;
            xyz(0) <= '0';
        elsif (int_std = NTSC_422 or int_std = NTSC_422_WIDE or
               int_std = PAL_422 or int_std = PAL_422_WIDE) then
            xyz(9) <= '1';
            xyz(8) <= f;
            xyz(7) <= v;
            xyz(6) <= h;
            xyz(5) <= v xor h;
            xyz(4) <= f xor h;
            xyz(3) <= f xor v;
            xyz(2) <= f xor v xor h;
            xyz(1) <= '0';
            xyz(0) <= '0';
        else
            xyz <= (others => '0');     -- XYZ is always 000 for composite video
        end if;
    end process;

    --
    -- trs_id word
    --
    -- This code generates the TRS ID word for composite video. The TRS ID word
    -- contains the three bits of the field_count and five bits the current 
    -- vertical line. For the first 30 vertical lines of a field the five-bit 
    -- line field contains the line count. After the 30th line of a field, the 
    -- line count field is all ones. A line count of all zeros indicates the 
    -- field is not used. Bit 8 of the TRS ID word is an event parity bit for 
    -- bits 7 through 0 of the TRS ID word. Bit 9 is the complement of bit 8.
    --
    process(int_std, vcnt)
    begin
        if (int_std = NTSC_COMPOSITE) then
            if (vcnt < 31) then
                trs_id_line <= std_ulogic_vector(vcnt(4 downto 0));
            elsif (vcnt > 263 and vcnt < 294) then
                trs_id_line <= std_ulogic_vector(vcnt - 263)(4 downto 0);
            else
                trs_id_line <= (others => '1');
            end if;
        elsif (int_std = PAL_COMPOSITE) then
            if (vcnt < 31) then
                trs_id_line <= std_ulogic_vector(vcnt(4 downto 0));
            elsif (vcnt > 313 and vcnt < 344) then
                trs_id_line <= std_ulogic_vector(vcnt - 313)(4 downto 0);
            else
                trs_id_line <= (others => '1');
            end if;
        else
            trs_id_line <= (others => '0');
        end if;
    end process;

    process(field_count, trs_id_line, trs_id)
    begin
        trs_id(2 downto 0) <= std_ulogic_vector(field_count);
        trs_id(7 downto 3) <= trs_id_line;
        trs_id(8) <= trs_id_line(4) xor trs_id_line(3) xor trs_id_line(2) xor
                     trs_id_line(1) xor trs_id_line(0) xor field_count(2) xor
                     field_count(1) xor field_count(0);
        trs_id(9) <= not trs_id(8);
    end process;        

    --
    -- field output
    --
    -- The field port is a 3-bit output indicating the current field. For
    -- component video, the F bit is in bit 0 and the other two bits are zeros.
    -- For composite video, field is assigned the value of field_count.
    --
    process(field_count, f, int_std)
    begin
        if (int_std = NTSC_COMPOSITE or int_std = PAL_COMPOSITE) then
            field <= std_ulogic_vector(field_count);
        else
            field <= ("00" & f);
        end if;
    end process;

    --
    -- h_blank output
    --
    -- h_blank indicates the horizontal blanking interval. For component video
    -- it is asserted from the start of the EAV symbol through the end of the 
    -- SAV symbol. It is mostly equal to the internal h signal, except that 
    -- h_blank is asserted during the SAV and h is not.
    --
    -- For composite video, h is asserted only during the TRS symbol.
    --   
    h_blank <= trs or h;

                    
    --
    -- v_blank output
    --
    -- The v_blank signal indicates the vertical blanking interval.
    --
    v_blank <= v;
             
end synth;